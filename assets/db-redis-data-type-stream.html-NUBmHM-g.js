const e=JSON.parse('{"key":"v-efe11898","path":"/db/nosql-redis/db-redis-data-type-stream.html","title":"Redis入门 - 数据类型：Stream详解","lang":"zh-CN","frontmatter":{"date":"2022-06-13T00:00:00.000Z","category":["NoSQL Redis"],"tag":["NoSQL Redis"],"description":"Redis入门 - 数据类型：Stream详解 Redis5.0 中还增加了一个数据类型Stream，它借鉴了Kafka的设计，是一个新的强大的支持多播的可持久化的消息队列。 为什么会设计Stream Redis5.0 中还增加了一个数据结构Stream，从字面上看是流类型，但其实从功能上看，应该是Redis对消息队列（MQ，Message Queue）的完善实现。 用过Redis做消息队列的都了解，基于Reids的消息队列实现有很多种，例如：","head":[["meta",{"property":"og:url","content":"http://www.gavin-james.com/db/nosql-redis/db-redis-data-type-stream.html"}],["meta",{"property":"og:site_name","content":"Gavin James"}],["meta",{"property":"og:title","content":"Redis入门 - 数据类型：Stream详解"}],["meta",{"property":"og:description","content":"Redis入门 - 数据类型：Stream详解 Redis5.0 中还增加了一个数据类型Stream，它借鉴了Kafka的设计，是一个新的强大的支持多播的可持久化的消息队列。 为什么会设计Stream Redis5.0 中还增加了一个数据结构Stream，从字面上看是流类型，但其实从功能上看，应该是Redis对消息队列（MQ，Message Queue）的完善实现。 用过Redis做消息队列的都了解，基于Reids的消息队列实现有很多种，例如："}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-26T08:34:19.000Z"}],["meta",{"property":"article:author","content":"gavin-james"}],["meta",{"property":"article:tag","content":"NoSQL Redis"}],["meta",{"property":"article:published_time","content":"2022-06-13T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-26T08:34:19.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis入门 - 数据类型：Stream详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-06-13T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-26T08:34:19.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gavin-james\\",\\"url\\":\\"http://www.gavin-james.xyz\\"}]}"]]},"headers":[{"level":2,"title":"为什么会设计Stream","slug":"为什么会设计stream","link":"#为什么会设计stream","children":[]},{"level":2,"title":"Stream详解","slug":"stream详解","link":"#stream详解","children":[{"level":3,"title":"Stream的结构","slug":"stream的结构","link":"#stream的结构","children":[]},{"level":3,"title":"增删改查","slug":"增删改查","link":"#增删改查","children":[]},{"level":3,"title":"独立消费","slug":"独立消费","link":"#独立消费","children":[]},{"level":3,"title":"消费组消费","slug":"消费组消费","link":"#消费组消费","children":[]},{"level":3,"title":"信息监控","slug":"信息监控","link":"#信息监控","children":[]}]},{"level":2,"title":"更深入理解","slug":"更深入理解","link":"#更深入理解","children":[{"level":3,"title":"Stream用在什么样场景","slug":"stream用在什么样场景","link":"#stream用在什么样场景","children":[]},{"level":3,"title":"消息ID的设计是否考虑了时间回拨的问题？","slug":"消息id的设计是否考虑了时间回拨的问题","link":"#消息id的设计是否考虑了时间回拨的问题","children":[]},{"level":3,"title":"消费者崩溃带来的会不会消息丢失问题?","slug":"消费者崩溃带来的会不会消息丢失问题","link":"#消费者崩溃带来的会不会消息丢失问题","children":[]},{"level":3,"title":"消费者彻底宕机后如何转移给其它消费者处理？","slug":"消费者彻底宕机后如何转移给其它消费者处理","link":"#消费者彻底宕机后如何转移给其它消费者处理","children":[]},{"level":3,"title":"坏消息问题，Dead Letter，死信问题","slug":"坏消息问题-dead-letter-死信问题","link":"#坏消息问题-dead-letter-死信问题","children":[]}]},{"level":2,"title":"参考文章","slug":"参考文章","link":"#参考文章","children":[]}],"git":{"createdTime":1690160698000,"updatedTime":1703579659000,"contributors":[{"name":"gavin-james","email":"meaganlindesy1258@gmail.com","commits":2}]},"readingTime":{"minutes":16.84,"words":5052},"filePathRelative":"db/nosql-redis/db-redis-data-type-stream.md","localizedDate":"2022年6月13日","excerpt":"<h1> Redis入门 - 数据类型：Stream详解</h1>\\n<blockquote>\\n<p>Redis5.0 中还增加了一个数据类型Stream，它借鉴了Kafka的设计，是一个新的强大的支持多播的可持久化的消息队列。</p>\\n</blockquote>\\n<h2> 为什么会设计Stream</h2>\\n<blockquote>\\n<p>Redis5.0 中还增加了一个数据结构Stream，从字面上看是流类型，但其实从功能上看，应该是Redis对消息队列（MQ，Message Queue）的完善实现。</p>\\n</blockquote>\\n<p>用过Redis做消息队列的都了解，基于Reids的消息队列实现有很多种，例如：</p>","copyright":{"author":"gavin-james","license":"https://github.com/gavin-james/gavin-james.github.io/LICENSE"},"autoDesc":true}');export{e as data};
