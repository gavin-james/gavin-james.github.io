const e=JSON.parse('{"key":"v-7a75b5c4","path":"/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html","title":"JUC锁: 锁核心类AQS详解","lang":"zh-CN","frontmatter":{"date":"2022-03-02T00:00:00.000Z","category":["Java 多线程"],"tag":["Java 多线程"],"description":"JUC锁: 锁核心类AQS详解 AbstractQueuedSynchronizer抽象类是核心，需要重点掌握。它提供了一个基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架。 带着BAT大厂的面试问题去理解 提示 请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。 什么是AQS? 为什么它是核心? AQS的核心思想是什么? 它是怎么实现的? 底层数据结构等 AQS有哪些核心的方法? AQS定义什么样的资源获取方式? AQS定义了两种资源获取方式：独占(只有一个线程能访问执行，又根据是否按队列的顺序分为公平锁和非公平锁，如ReentrantLock) 和共享(多个线程可同时访问执行，如Semaphore、CountDownLatch、 CyclicBarrier )。ReentrantReadWriteLock可以看成是组合式，允许多个线程同时对某一资源进行读。 AQS底层使用了什么样的设计模式? 模板 AQS的应用示例?","head":[["meta",{"property":"og:url","content":"http://www.gavin-james.com/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html"}],["meta",{"property":"og:site_name","content":"Gavin James"}],["meta",{"property":"og:title","content":"JUC锁: 锁核心类AQS详解"}],["meta",{"property":"og:description","content":"JUC锁: 锁核心类AQS详解 AbstractQueuedSynchronizer抽象类是核心，需要重点掌握。它提供了一个基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架。 带着BAT大厂的面试问题去理解 提示 请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。 什么是AQS? 为什么它是核心? AQS的核心思想是什么? 它是怎么实现的? 底层数据结构等 AQS有哪些核心的方法? AQS定义什么样的资源获取方式? AQS定义了两种资源获取方式：独占(只有一个线程能访问执行，又根据是否按队列的顺序分为公平锁和非公平锁，如ReentrantLock) 和共享(多个线程可同时访问执行，如Semaphore、CountDownLatch、 CyclicBarrier )。ReentrantReadWriteLock可以看成是组合式，允许多个线程同时对某一资源进行读。 AQS底层使用了什么样的设计模式? 模板 AQS的应用示例?"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-25T08:42:25.000Z"}],["meta",{"property":"article:author","content":"gavin-james"}],["meta",{"property":"article:tag","content":"Java 多线程"}],["meta",{"property":"article:published_time","content":"2022-03-02T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-25T08:42:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JUC锁: 锁核心类AQS详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-03-02T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-25T08:42:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gavin-james\\",\\"url\\":\\"http://www.gavin-james.xyz\\"}]}"]]},"headers":[{"level":2,"title":"带着BAT大厂的面试问题去理解","slug":"带着bat大厂的面试问题去理解","link":"#带着bat大厂的面试问题去理解","children":[]},{"level":2,"title":"AbstractQueuedSynchronizer简介","slug":"abstractqueuedsynchronizer简介","link":"#abstractqueuedsynchronizer简介","children":[{"level":3,"title":"AQS 核心思想","slug":"aqs-核心思想","link":"#aqs-核心思想","children":[]},{"level":3,"title":"AQS 对资源的共享方式","slug":"aqs-对资源的共享方式","link":"#aqs-对资源的共享方式","children":[]},{"level":3,"title":"AQS底层使用了模板方法模式","slug":"aqs底层使用了模板方法模式","link":"#aqs底层使用了模板方法模式","children":[]}]},{"level":2,"title":"AbstractQueuedSynchronizer数据结构","slug":"abstractqueuedsynchronizer数据结构","link":"#abstractqueuedsynchronizer数据结构","children":[]},{"level":2,"title":"AbstractQueuedSynchronizer源码分析","slug":"abstractqueuedsynchronizer源码分析","link":"#abstractqueuedsynchronizer源码分析","children":[{"level":3,"title":"类的继承关系","slug":"类的继承关系","link":"#类的继承关系","children":[]},{"level":3,"title":"类的内部类 - Node类","slug":"类的内部类-node类","link":"#类的内部类-node类","children":[]},{"level":3,"title":"类的内部类 - ConditionObject类","slug":"类的内部类-conditionobject类","link":"#类的内部类-conditionobject类","children":[]},{"level":3,"title":"类的属性","slug":"类的属性","link":"#类的属性","children":[]},{"level":3,"title":"类的构造方法","slug":"类的构造方法","link":"#类的构造方法","children":[]},{"level":3,"title":"类的核心方法 - acquire方法","slug":"类的核心方法-acquire方法","link":"#类的核心方法-acquire方法","children":[]},{"level":3,"title":"类的核心方法 - release方法","slug":"类的核心方法-release方法","link":"#类的核心方法-release方法","children":[]}]},{"level":2,"title":"AbstractQueuedSynchronizer示例详解一","slug":"abstractqueuedsynchronizer示例详解一","link":"#abstractqueuedsynchronizer示例详解一","children":[]},{"level":2,"title":"AbstractQueuedSynchronizer示例详解二","slug":"abstractqueuedsynchronizer示例详解二","link":"#abstractqueuedsynchronizer示例详解二","children":[]},{"level":2,"title":"AbstractQueuedSynchronizer总结","slug":"abstractqueuedsynchronizer总结","link":"#abstractqueuedsynchronizer总结","children":[]},{"level":2,"title":"参考文章","slug":"参考文章","link":"#参考文章","children":[]}],"git":{"createdTime":1687917370000,"updatedTime":1703493745000,"contributors":[{"name":"gavin-james","email":"meaganlindesy1258@gmail.com","commits":2}]},"readingTime":{"minutes":34.25,"words":10274},"filePathRelative":"java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.md","localizedDate":"2022年3月2日","excerpt":"<h1> JUC锁: 锁核心类AQS详解</h1>\\n<blockquote>\\n<p>AbstractQueuedSynchronizer抽象类是核心，需要重点掌握。它提供了一个基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架。</p>\\n</blockquote>\\n<h2> 带着BAT大厂的面试问题去理解</h2>\\n<blockquote>\\n<p>提示</p>\\n<p>请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。</p>\\n</blockquote>\\n<ul>\\n<li>什么是AQS? 为什么它是核心?</li>\\n<li>AQS的核心思想是什么? 它是怎么实现的? 底层数据结构等</li>\\n<li>AQS有哪些核心的方法?</li>\\n<li>AQS定义什么样的资源获取方式? AQS定义了两种资源获取方式：<code>独占</code>(只有一个线程能访问执行，又根据是否按队列的顺序分为<code>公平锁</code>和<code>非公平锁</code>，如<code>ReentrantLock</code>) 和<code>共享</code>(多个线程可同时访问执行，如<code>Semaphore</code>、<code>CountDownLatch</code>、 <code>CyclicBarrier</code> )。<code>ReentrantReadWriteLock</code>可以看成是组合式，允许多个线程同时对某一资源进行读。</li>\\n<li>AQS底层使用了什么样的设计模式? 模板</li>\\n<li>AQS的应用示例?</li>\\n</ul>","copyright":{"author":"gavin-james","license":"https://github.com/gavin-james/gavin-james.github.io/LICENSE"},"autoDesc":true}');export{e as data};
