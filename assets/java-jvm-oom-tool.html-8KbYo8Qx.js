import{_ as g}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as o,o as l,c as r,a,b as i,d as e,f as n}from"./app-pgelmVnX.js";const p={},s=a("h1",{id:"调试排错-java-问题排查之jvm可视化工具",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#调试排错-java-问题排查之jvm可视化工具","aria-hidden":"true"},"#"),i(" 调试排错 - Java 问题排查之JVM可视化工具")],-1),m=a("blockquote",null,[a("p",null,"本文主要梳理常见的JVM可视化的分析工具，主要包括JConsole, Visual VM, Vusial GC, JProfile 和 MAT等。")],-1),c=a("h2",{id:"jconsole",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#jconsole","aria-hidden":"true"},"#"),i(" JConsole")],-1),d={href:"https://docs.oracle.com/javase/8/docs/technotes/guides/management/jconsole.html",target:"_blank",rel:"noopener noreferrer"},f=n(`<ul><li><strong>找到jconsole工具</strong></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>pdai@MacBook-Pro bin % <span class="token function">ls</span>
jaotc		jcmd		jinfo		jshell		rmid
jar		jconsole<span class="token punctuation">(</span>这里<span class="token punctuation">)</span>	jjs		jstack		rmiregistry
jarsigner	jdb		jlink		jstat		serialver
<span class="token function">java</span>		jdeprscan	jmap		jstatd		unpack200
javac		jdeps		jmod		keytool
javadoc		jhsdb		jps		pack200
javap		jimage		jrunscript	rmic
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>打开jconsole</strong></li></ul><p>选择</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-tool-0.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-tool-2.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li><strong>查看概述、内存、线程、类、VM概要、MBean</strong></li></ul><p>概述</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-tool-1.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>内存</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-tool-3.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>线程</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-tool-4.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>类</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-tool-5.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>VM概要</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-tool-6.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>MBean</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-tool-6.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="visual-vm" tabindex="-1"><a class="header-anchor" href="#visual-vm" aria-hidden="true">#</a> Visual VM</h2><blockquote><p>VisualVM 是一款免费的，集成了多个 JDK 命令行工具的可视化工具，它能为您提供强大的分析能力，对 Java 应用程序做性能分析和调优。这些功能包括生成和分析海量数据、跟踪内存泄漏、监控垃圾回收器、执行内存和 CPU 分析，同时它还支持在 MBeans 上进行浏览和操作。</p></blockquote><p>Overview</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-visualvm-2.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Monitor</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-visualvm-1.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>线程</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-visualvm-3.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Sampler</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-visualvm-4.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="visual-gc" tabindex="-1"><a class="header-anchor" href="#visual-gc" aria-hidden="true">#</a> Visual GC</h2>`,30),v={href:"https://www.oracle.com/java/technologies/visual-garbage-collection-monitoring-tool.html",target:"_blank",rel:"noopener noreferrer"},j=n('<p>比如我在IDEA中使用visual GC 插件来看GC状况。</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-tool-10.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="jprofile" tabindex="-1"><a class="header-anchor" href="#jprofile" aria-hidden="true">#</a> JProfile</h2><blockquote><p>Profiler 是一个商业的主要用于检查和跟踪系统（限于Java开发的）的性能的工具。JProfiler可以通过时时的监控系统的内存使用情况，随时监视垃圾回收，线程运行状况等手段，从而很好的监视JVM运行情况及其性能。</p></blockquote><p>JProfiler 是一个全功能的Java剖析工具（profiler），专用于分析J2SE和J2EE应用程序。它把CPU、执行绪和内存的剖析组合在一个强大的应用中。 JProfiler可提供许多IDE整合和应用服务器整合用途。JProfiler直觉式的GUI让你可以找到效能瓶颈、抓出内存漏失(memory leaks)、并解决执行绪的问题。它让你得以对heap walker作资源回收器的root analysis，可以轻易找出内存漏失；heap快照（snapshot）模式让未被参照（reference）的对象、稍微被参照的对象、或在终结（finalization）队列的对象都会被移除；整合精灵以便剖析浏览器的Java外挂功能。</p><h3 id="核心组件" tabindex="-1"><a class="header-anchor" href="#核心组件" aria-hidden="true">#</a> 核心组件</h3><p>JProfiler 包含用于采集目标 JVM 分析数据的 JProfiler agent、用于可视化分析数据的 JProfiler UI、提供各种功能的命令行工具，它们之间的关系如下图所示。</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-jprofile-18.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li><strong>JProfiler agent</strong></li></ul>',9),u=a("code",null,"-agentpath:<path to native library>",-1),h={href:"http://lovestblog.cn/blog/2014/06/18/jvm-attach/",target:"_blank",rel:"noopener noreferrer"},w=n('<ul><li><strong>JProfiler UI</strong></li></ul><p>JProfiler UI 是一个可独立部署的组件，它通过 socket 和 agent 建立连接。这意味着不论目标 JVM 运行在本地还是远端，JProfiler UI 和 agent 间的通信机制都是一样的。</p><p>JProfiler UI 的主要功能是展示通过 agent 采集上来的分析数据，此外还可以通过它控制 agent 的采集行为，将快照保存至磁盘，展示保存的快照。</p><ul><li><strong>命令行工具</strong></li></ul><p>JProfiler 提供了一系列命令行工具以实现不同的功能。</p><ol><li>jpcontroller - 用于控制 agent 的采集行为。它通过 agent 注册的 JProfiler MBean 向 agent 传递命令。</li><li>jpenable - 用于将 agent 加载到一个正在运行的 JVM 上。</li><li>jpdump - 用于获取正在运行的 JVM 的堆快照。</li><li>jpexport &amp; jpcompare - 用于从保存的快照中提取数据并创建 HTML 报告。</li></ol><h3 id="运行测试" tabindex="-1"><a class="header-anchor" href="#运行测试" aria-hidden="true">#</a> 运行测试</h3><p><strong>我们运行一个SpringBoot测试工程，选择attach到JVM</strong></p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-jprofile-1.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>选择指定的进程</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-jprofile-2.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>设置数据采集模式</strong></p><p>JProfier 提供两种数据采集模式 Sampling 和 Instrumentation。</p><ul><li>Sampling - 适合于不要求数据完全精确的场景。优点是对系统性能的影响较小，缺点是某些特性不支持（如方法级别的统计信息）。</li><li>Instrumentation - 完整功能模式，统计信息也是精确的。缺点是如果需要分析的类比较多，对应用性能影响较大。为了降低影响，往往需要和 Filter 一起使用。</li></ul><p>由于我们需要获取方法级别的统计信息，这里选择了 Instrumentation 模式。</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-jprofile-3.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>概览</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-jprofile-4.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>内存</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-jprofile-5.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>实时内存分布（类对象）</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-jprofile-6.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>dump 堆内存</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-jprofile-7.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>dump完会直接打开显示</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-jprofile-8.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>线程存储</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-jprofile-9.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>导出HTML报告</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-jprofile-10.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>CPU 调用树</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-jprofile-14.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>线程历史</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-jprofile-15.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>JEE &amp; 探针</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-jprofile-16.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>MBeans</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-jprofile-17.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="eclipse-memory-analyzer-mat" tabindex="-1"><a class="header-anchor" href="#eclipse-memory-analyzer-mat" aria-hidden="true">#</a> Eclipse Memory Analyzer (MAT)</h2><blockquote><p>MAT 是一种快速且功能丰富的 Java 堆分析器，可帮助你发现内存泄漏并减少内存消耗。 MAT在的堆内存分析问题使用极为广泛，需要重点掌握。</p></blockquote>',40),b={href:"https://www.eclipse.org/mat/",target:"_blank",rel:"noopener noreferrer"},x={href:"http://help.eclipse.org/latest/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html",target:"_blank",rel:"noopener noreferrer"},_=n('<ul><li><strong>Overview</strong></li></ul><p>包含内存分布，以及潜在的问题推测</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-mat-2.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li><strong>Histogram</strong></li></ul><p>可以列出内存中的对象，对象的个数以及大小。</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-mat-3.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>',6),J={href:"http://help.eclipse.org/latest/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html",target:"_blank",rel:"noopener noreferrer"},y=n('<ol><li>Shallow Heap ：一个对象内存的消耗大小，不包含对其他对象的引用</li><li>Retained Heap ：是shallow Heap的总和，也就是该对象被GC之后所能回收到内存的总和</li></ol><ul><li><strong>Dominator Tree</strong></li></ul><p>可以列出那个线程，以及线程下面的那些对象占用的空间。</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-mat-4.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li><strong>Top consumers</strong></li></ul><p>通过图形列出最大的object。</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-mat-5.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li><strong>Leak Suspects</strong></li></ul><p>自动分析潜在可能的泄漏。</p><figure><img src="https://www.pdai.tech/images/java/jvm/java-jvm-mat-6.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>',10);function z(k,M){const t=o("ExternalLinkIcon");return l(),r("div",null,[s,m,c,a("blockquote",null,[a("p",null,[i("Jconsole （Java Monitoring and Management Console），JDK自带的基于JMX的可视化监视、管理工具。 官方文档可以参考"),a("a",d,[i("这里在新窗口打开"),e(t)])])]),f,a("blockquote",null,[a("p",null,[i("visual gc 是 visualvm 中的图形化查看 gc 状况的插件。官方文档可以参考"),a("a",v,[i("这里在新窗口打开"),e(t)])])]),j,a("p",null,[i("JProfiler agent 是一个本地库，它可以在 JVM 启动时通过参数"),u,i("进行加载或者在程序运行时通过"),a("a",h,[i("JVM Attach 机制在新窗口打开"),e(t)]),i("进行加载。Agent 被成功加载后，会设置 JVMTI 环境，监听虚拟机产生的事件，如类加载、线程创建等。例如，当它监听到类加载事件后，会给这些类注入用于执行度量操作的字节码。")]),w,a("p",null,[i("可以在"),a("a",b,[i("这里在新窗口打开"),e(t)]),i("下载， 官方文档可以看"),a("a",x,[i("这里在新窗口打开"),e(t)])]),_,a("p",null,[i("具体需要重点理解如下两个概念，可参考"),a("a",J,[i("官网文档在新窗口打开"),e(t)]),i("的解释")]),y])}const I=g(p,[["render",z],["__file","java-jvm-oom-tool.html.vue"]]);export{I as default};
