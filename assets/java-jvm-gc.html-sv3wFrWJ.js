const e=JSON.parse('{"key":"v-134b39c8","path":"/java/jvm/java-jvm-gc.html","title":"GC - Java 垃圾回收基础知识","lang":"zh-CN","frontmatter":{"date":"2022-05-02T00:00:00.000Z","category":["Java JVM"],"tag":["Java JVM"],"description":"GC - Java 垃圾回收基础知识 垃圾收集主要是针对堆和方法区进行；程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。 判断一个对象是否可被回收 1. 引用计数算法 给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。","head":[["meta",{"property":"og:url","content":"http://www.gavin-james.com/java/jvm/java-jvm-gc.html"}],["meta",{"property":"og:site_name","content":"Gavin James"}],["meta",{"property":"og:title","content":"GC - Java 垃圾回收基础知识"}],["meta",{"property":"og:description","content":"GC - Java 垃圾回收基础知识 垃圾收集主要是针对堆和方法区进行；程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。 判断一个对象是否可被回收 1. 引用计数算法 给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-25T08:42:25.000Z"}],["meta",{"property":"article:author","content":"gavin-james"}],["meta",{"property":"article:tag","content":"Java JVM"}],["meta",{"property":"article:published_time","content":"2022-05-02T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-25T08:42:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"GC - Java 垃圾回收基础知识\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-05-02T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-25T08:42:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gavin-james\\",\\"url\\":\\"http://www.gavin-james.xyz\\"}]}"]]},"headers":[{"level":2,"title":"判断一个对象是否可被回收","slug":"判断一个对象是否可被回收","link":"#判断一个对象是否可被回收","children":[{"level":3,"title":"1. 引用计数算法","slug":"_1-引用计数算法","link":"#_1-引用计数算法","children":[]},{"level":3,"title":"2. 可达性分析算法","slug":"_2-可达性分析算法","link":"#_2-可达性分析算法","children":[]},{"level":3,"title":"3. 方法区的回收","slug":"_3-方法区的回收","link":"#_3-方法区的回收","children":[]},{"level":3,"title":"4. finalize()","slug":"_4-finalize","link":"#_4-finalize","children":[]}]},{"level":2,"title":"引用类型","slug":"引用类型","link":"#引用类型","children":[{"level":3,"title":"1. 强引用","slug":"_1-强引用","link":"#_1-强引用","children":[]},{"level":3,"title":"2. 软引用","slug":"_2-软引用","link":"#_2-软引用","children":[]},{"level":3,"title":"3. 弱引用","slug":"_3-弱引用","link":"#_3-弱引用","children":[]},{"level":3,"title":"4. 虚引用","slug":"_4-虚引用","link":"#_4-虚引用","children":[]}]},{"level":2,"title":"垃圾回收算法","slug":"垃圾回收算法","link":"#垃圾回收算法","children":[{"level":3,"title":"1. 标记 - 清除","slug":"_1-标记-清除","link":"#_1-标记-清除","children":[]},{"level":3,"title":"2. 标记 - 整理","slug":"_2-标记-整理","link":"#_2-标记-整理","children":[]},{"level":3,"title":"3. 复制","slug":"_3-复制","link":"#_3-复制","children":[]},{"level":3,"title":"4. 分代收集","slug":"_4-分代收集","link":"#_4-分代收集","children":[]}]},{"level":2,"title":"垃圾收集器","slug":"垃圾收集器","link":"#垃圾收集器","children":[{"level":3,"title":"1. Serial 收集器","slug":"_1-serial-收集器","link":"#_1-serial-收集器","children":[]},{"level":3,"title":"2. ParNew 收集器","slug":"_2-parnew-收集器","link":"#_2-parnew-收集器","children":[]},{"level":3,"title":"3. Parallel Scavenge 收集器","slug":"_3-parallel-scavenge-收集器","link":"#_3-parallel-scavenge-收集器","children":[]},{"level":3,"title":"4. Serial Old 收集器","slug":"_4-serial-old-收集器","link":"#_4-serial-old-收集器","children":[]},{"level":3,"title":"5. Parallel Old 收集器","slug":"_5-parallel-old-收集器","link":"#_5-parallel-old-收集器","children":[]},{"level":3,"title":"6. CMS 收集器","slug":"_6-cms-收集器","link":"#_6-cms-收集器","children":[]},{"level":3,"title":"7. G1 收集器","slug":"_7-g1-收集器","link":"#_7-g1-收集器","children":[]}]},{"level":2,"title":"内存分配与回收策略","slug":"内存分配与回收策略","link":"#内存分配与回收策略","children":[{"level":3,"title":"Minor GC、Major GC、Full GC","slug":"minor-gc、major-gc、full-gc","link":"#minor-gc、major-gc、full-gc","children":[]},{"level":3,"title":"内存分配策略","slug":"内存分配策略","link":"#内存分配策略","children":[]},{"level":3,"title":"Full GC 的触发条件","slug":"full-gc-的触发条件","link":"#full-gc-的触发条件","children":[]}]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1687917370000,"updatedTime":1703493745000,"contributors":[{"name":"gavin-james","email":"meaganlindesy1258@gmail.com","commits":2}]},"readingTime":{"minutes":17.21,"words":5163},"filePathRelative":"java/jvm/java-jvm-gc.md","localizedDate":"2022年5月2日","excerpt":"<h1> GC - Java 垃圾回收基础知识</h1>\\n<blockquote>\\n<p>垃圾收集主要是针对堆和方法区进行；程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。</p>\\n</blockquote>\\n<h2> 判断一个对象是否可被回收</h2>\\n<h3> 1. 引用计数算法</h3>\\n<p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p>\\n<p>两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。</p>","copyright":{"author":"gavin-james","license":"https://github.com/gavin-james/gavin-james.github.io/LICENSE"},"autoDesc":true}');export{e as data};
