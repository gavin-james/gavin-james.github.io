import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as p,o,c,a as n,b as a,d as l,f as s}from"./app-Kb1srcrM.js";const i={},r=s(`<h1 id="java-8-类型注解" tabindex="-1"><a class="header-anchor" href="#java-8-类型注解" aria-hidden="true">#</a> Java 8 - 类型注解</h1><blockquote><p>理解Java 8 类型注解需理解几个问题:</p><ul><li>注解在JDK哪个版本中出现的，可以在哪些地方用注解?</li><li>什么是类型注解?</li><li>类型注解的作用是什么?</li><li>为什么会出现类型注解(JSR308)?</li></ul></blockquote><h2 id="什么是类型注解" tabindex="-1"><a class="header-anchor" href="#什么是类型注解" aria-hidden="true">#</a> 什么是类型注解</h2><blockquote><p>注解大家都知道，从java5开始加入这一特性，发展到现在已然是遍地开花，在很多框架中得到了广泛的使用，用来简化程序中的配置。那充满争议的类型注解究竟是什么? 复杂还是便捷?</p></blockquote><ol><li>在java 8之前，注解只能是在声明的地方所使用，比如类，方法，属性；</li><li>java 8里面，注解可以应用在任何地方，比如:</li></ol><p>创建类实例</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">new</span> <span class="token annotation punctuation">@Interned</span> <span class="token class-name">MyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>类型映射</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>myString <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> <span class="token class-name">String</span><span class="token punctuation">)</span> str<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>implements 语句中</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">UnmodifiableList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token annotation punctuation">@Readonly</span> <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token annotation punctuation">@Readonly</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> … <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>throw exception声明</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">monitorTemperature</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token annotation punctuation">@Critical</span> <span class="token class-name">TemperatureException</span> <span class="token punctuation">{</span> … <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>需要注意的是，<strong>类型注解只是语法而不是语义，并不会影响java的编译时间，加载时间，以及运行时间，也就是说，编译成class文件的时候并不包含类型注解</strong>。</p><h2 id="类型注解的作用" tabindex="-1"><a class="header-anchor" href="#类型注解的作用" aria-hidden="true">#</a> 类型注解的作用</h2><p>先看看下面代码</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;One&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i<span class="token operator">=</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">console</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码编译是通过的，但运行是会分别报UnsupportedOperationException； NumberFormatException；NullPointerException异常，这些都是runtime error；</p><p>类型注解被用来支持在Java的程序中做强类型检查。配合插件式的check framework，可以在编译的时候检测出runtime error，以提高代码质量。这就是类型注解的作用了。</p>`,19),u={href:"http://types.cs.washington.edu/checker-framework/%E3%80%82",target:"_blank",rel:"noopener noreferrer"},d=s(`<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">checkers<span class="token punctuation">.</span>nullness<span class="token punctuation">.</span>quals<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GetStarted</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">sample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@NonNull</span> <span class="token class-name">Object</span> ref <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用javac编译上面的类</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>javac <span class="token parameter variable">-processor</span> checkers.nullness.NullnessChecker GetStarted.java
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>编译是通过，但如果修改成</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@NonNull</span> <span class="token class-name">Object</span> ref <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再次编译，则出现</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>GetStarted.java:5: incompatible types.
found   <span class="token builtin class-name">:</span> @Nullable <span class="token operator">&lt;</span>nulltype<span class="token operator">&gt;</span>
required: @NonNull Object
        @NonNull Object ref <span class="token operator">=</span> null<span class="token punctuation">;</span>
                              ^
<span class="token number">1</span> error
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="类型注解向下兼容的解决方案" tabindex="-1"><a class="header-anchor" href="#类型注解向下兼容的解决方案" aria-hidden="true">#</a> 类型注解向下兼容的解决方案</h2><p>如果你不想使用类型注解检测出来错误，则不需要processor，直接javac GetStarted.java是可以编译通过的，这是在java 8 with Type Annotation Support版本里面可以，但java 5,6,7版本都不行，因为javac编译器不知道@NonNull是什么东西，但check framework 有个向下兼容的解决方案，就是将类型注解nonnull用/**/注释起来，比如上面例子修改为</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">checkers<span class="token punctuation">.</span>nullness<span class="token punctuation">.</span>quals<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GetStarted</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">sample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/*@NonNull*/</span> <span class="token class-name">Object</span> ref <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样javac编译器就会忽略掉注释块，但用check framework里面的javac编译器同样能够检测出nonnull错误。 通过类型注解+check framework我们可以看到，现在runtime error可以在编译时候就能找到。</p><h2 id="关于jsr-308" tabindex="-1"><a class="header-anchor" href="#关于jsr-308" aria-hidden="true">#</a> 关于JSR 308</h2><p>JSR 308想要解决在Java 1.5注解中出现的两个问题:</p><ul><li>在句法上对注解的限制: 只能把注解写在声明的地方</li><li>类型系统在语义上的限制: 类型系统还做不到预防所有的bug</li></ul><p>JSR 308 通过如下方法解决上述两个问题:</p><ul><li>对Java语言的句法进行扩充，允许注解出现在更多的位置上。包括: 方法接收器(method receivers，译注: 例public int size() @Readonly { … })，泛型参数，数组，类型转换，类型测试，对象创建，类型参数绑定，类继承和throws子句。其实就是类型注解，现在是java 8的一个特性</li><li>通过引入可插拔的类型系统(pluggable type systems)能够创建功能更强大的注解处理器。类型检查器对带有类型限定注解的源码进行分析，一旦发现不匹配等错误之处就会产生警告信息。其实就是check framework</li></ul><p>对JSR308，有人反对，觉得更复杂更静态了，比如</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@NotEmpty</span> <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token annotation punctuation">@NonNull</span> <span class="token class-name">String</span><span class="token operator">&gt;</span> strings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token annotation punctuation">@NonNull</span> <span class="token class-name">String</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>换成动态语言为</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">var</span> strings <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;one&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;two&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>有人赞成，说到底，代码才是“最根本”的文档。代码中包含的注解清楚表明了代码编写者的意图。当没有及时更新或者有遗漏的时候，恰恰是注解中包含的意图信息，最容易在其他文档中被丢失。而且将运行时的错误转到编译阶段，不但可以加速开发进程，还可以节省测试时检查bug的时间。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>并不是人人都喜欢这个特性，特别是动态语言比较流行的今天，所幸，java 8并不强求大家使用这个特性，反对的人可以不使用这一特性，而对代码质量有些要求比较高的人或公司可以采用JSR 308，毕竟代码才是“最基本”的文档，这句话我是赞同的。虽然代码会增多，但可以使你的代码更具有表达意义。对这个特性有何看法，大家各抒己见。。。。</p>`,23);function k(v,m){const e=p("ExternalLinkIcon");return o(),c("div",null,[r,n("p",null,[a("check framework是第三方工具，配合Java的类型注解效果就是1+1>2。它可以嵌入到javac编译器里面，可以配合ant和maven使用, 地址是"),n("a",u,[a("http://types.cs.washington.edu/checker-framework/。"),l(e)]),a(" check framework可以找到类型注解出现的地方并检查，举个简单的例子:")]),d])}const g=t(i,[["render",k],["__file","java8-type-anno.html.vue"]]);export{g as default};
