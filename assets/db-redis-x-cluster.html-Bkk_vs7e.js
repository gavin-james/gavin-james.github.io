const e=JSON.parse('{"key":"v-49dcf7ee","path":"/db/nosql-redis/db-redis-x-cluster.html","title":"Redis进阶 - 高可拓展：分片技术（Redis Cluster）详解","lang":"zh-CN","frontmatter":{"date":"2022-06-23T00:00:00.000Z","category":["NoSQL Redis"],"tag":["NoSQL Redis"],"description":"Redis进阶 - 高可拓展：分片技术（Redis Cluster）详解 前面两篇文章，主从复制和哨兵机制保障了高可用，就读写分离而言虽然slave节点扩展了主从的读并发能力，但是写能力和存储能力是无法进行扩展，就只能是master节点能够承载的上限。如果面对海量数据那么必然需要构建master（主节点分片)之间的集群，同时必然需要吸收高可用（主从复制和哨兵机制）能力，即每个master分片节点还需要有slave节点，这是分布式系统中典型的纵向扩展（集群的分片技术）的体现；所以在Redis 3.0版本中对应的设计就是Redis Cluster。","head":[["meta",{"property":"og:url","content":"http://www.gavin-james.com/db/nosql-redis/db-redis-x-cluster.html"}],["meta",{"property":"og:site_name","content":"Gavin James"}],["meta",{"property":"og:title","content":"Redis进阶 - 高可拓展：分片技术（Redis Cluster）详解"}],["meta",{"property":"og:description","content":"Redis进阶 - 高可拓展：分片技术（Redis Cluster）详解 前面两篇文章，主从复制和哨兵机制保障了高可用，就读写分离而言虽然slave节点扩展了主从的读并发能力，但是写能力和存储能力是无法进行扩展，就只能是master节点能够承载的上限。如果面对海量数据那么必然需要构建master（主节点分片)之间的集群，同时必然需要吸收高可用（主从复制和哨兵机制）能力，即每个master分片节点还需要有slave节点，这是分布式系统中典型的纵向扩展（集群的分片技术）的体现；所以在Redis 3.0版本中对应的设计就是Redis Cluster。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-26T08:34:19.000Z"}],["meta",{"property":"article:author","content":"gavin-james"}],["meta",{"property":"article:tag","content":"NoSQL Redis"}],["meta",{"property":"article:published_time","content":"2022-06-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-26T08:34:19.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis进阶 - 高可拓展：分片技术（Redis Cluster）详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-06-23T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-26T08:34:19.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gavin-james\\",\\"url\\":\\"http://www.gavin-james.xyz\\"}]}"]]},"headers":[{"level":2,"title":"Redis 集群的设计目标","slug":"redis-集群的设计目标","link":"#redis-集群的设计目标","children":[{"level":3,"title":"Redis Cluster goals","slug":"redis-cluster-goals","link":"#redis-cluster-goals","children":[]},{"level":3,"title":"Clients and Servers roles in the Redis Cluster protocol","slug":"clients-and-servers-roles-in-the-redis-cluster-protocol","link":"#clients-and-servers-roles-in-the-redis-cluster-protocol","children":[]},{"level":3,"title":"Write safety","slug":"write-safety","link":"#write-safety","children":[]},{"level":3,"title":"可用性(Availability)","slug":"可用性-availability","link":"#可用性-availability","children":[]},{"level":3,"title":"性能(Performance)","slug":"性能-performance","link":"#性能-performance","children":[]},{"level":3,"title":"避免合并(merge)操作","slug":"避免合并-merge-操作","link":"#避免合并-merge-操作","children":[]}]},{"level":2,"title":"主要模块介绍","slug":"主要模块介绍","link":"#主要模块介绍","children":[{"level":3,"title":"哈希槽(Hash Slot)","slug":"哈希槽-hash-slot","link":"#哈希槽-hash-slot","children":[]},{"level":3,"title":"Keys hash tags","slug":"keys-hash-tags","link":"#keys-hash-tags","children":[]},{"level":3,"title":"Cluster nodes属性","slug":"cluster-nodes属性","link":"#cluster-nodes属性","children":[]},{"level":3,"title":"Cluster总线","slug":"cluster总线","link":"#cluster总线","children":[]},{"level":3,"title":"集群拓扑","slug":"集群拓扑","link":"#集群拓扑","children":[]},{"level":3,"title":"节点握手","slug":"节点握手","link":"#节点握手","children":[]}]},{"level":2,"title":"请求重定向","slug":"请求重定向","link":"#请求重定向","children":[{"level":3,"title":"Moved 重定向","slug":"moved-重定向","link":"#moved-重定向","children":[]},{"level":3,"title":"ASK 重定向","slug":"ask-重定向","link":"#ask-重定向","children":[]},{"level":3,"title":"smart客户端","slug":"smart客户端","link":"#smart客户端","children":[]}]},{"level":2,"title":"状态检测及维护","slug":"状态检测及维护","link":"#状态检测及维护","children":[{"level":3,"title":"Gossip协议","slug":"gossip协议","link":"#gossip协议","children":[]},{"level":3,"title":"通讯状态和维护","slug":"通讯状态和维护","link":"#通讯状态和维护","children":[]}]},{"level":2,"title":"故障恢复（Failover）","slug":"故障恢复-failover","link":"#故障恢复-failover","children":[]},{"level":2,"title":"扩容&缩容","slug":"扩容-缩容","link":"#扩容-缩容","children":[{"level":3,"title":"扩容","slug":"扩容","link":"#扩容","children":[]},{"level":3,"title":"缩容","slug":"缩容","link":"#缩容","children":[]}]},{"level":2,"title":"更深入理解","slug":"更深入理解","link":"#更深入理解","children":[{"level":3,"title":"为什么Redis Cluster的Hash Slot 是16384？","slug":"为什么redis-cluster的hash-slot-是16384","link":"#为什么redis-cluster的hash-slot-是16384","children":[]},{"level":3,"title":"为什么Redis Cluster中不建议使用发布订阅呢？","slug":"为什么redis-cluster中不建议使用发布订阅呢","link":"#为什么redis-cluster中不建议使用发布订阅呢","children":[]}]},{"level":2,"title":"其它常见方案","slug":"其它常见方案","link":"#其它常见方案","children":[{"level":3,"title":"Redis Sentinel 集群 + Keepalived/Haproxy","slug":"redis-sentinel-集群-keepalived-haproxy","link":"#redis-sentinel-集群-keepalived-haproxy","children":[]},{"level":3,"title":"Twemproxy","slug":"twemproxy","link":"#twemproxy","children":[]},{"level":3,"title":"Codis","slug":"codis","link":"#codis","children":[]}]},{"level":2,"title":"参考文章","slug":"参考文章","link":"#参考文章","children":[]}],"git":{"createdTime":1690160698000,"updatedTime":1703579659000,"contributors":[{"name":"gavin-james","email":"meaganlindesy1258@gmail.com","commits":2}]},"readingTime":{"minutes":29.26,"words":8779},"filePathRelative":"db/nosql-redis/db-redis-x-cluster.md","localizedDate":"2022年6月23日","excerpt":"<h1> Redis进阶 - 高可拓展：分片技术（Redis Cluster）详解</h1>\\n<blockquote>\\n<p>前面两篇文章，<a href=\\"\\">主从复制</a>和<a href=\\"\\">哨兵机制</a>保障了高可用，就读写分离而言虽然slave节点扩展了主从的读并发能力，但是<strong>写能力</strong>和<strong>存储能力</strong>是无法进行扩展，就只能是master节点能够承载的上限。如果面对海量数据那么必然需要构建master（主节点分片)之间的集群，同时必然需要吸收高可用（主从复制和哨兵机制）能力，即每个master分片节点还需要有slave节点，这是分布式系统中典型的纵向扩展（集群的分片技术）的体现；所以在Redis 3.0版本中对应的设计就是Redis Cluster。</p>\\n</blockquote>","copyright":{"author":"gavin-james","license":"https://github.com/gavin-james/gavin-james.github.io/LICENSE"},"autoDesc":true}');export{e as data};
