const e=JSON.parse('{"key":"v-b49ab68c","path":"/java/thread/java-thread-x-juc-executor-ScheduledThreadPoolExecutor.html","title":"JUC线程池: ScheduledThreadPoolExecutor详解","lang":"zh-CN","frontmatter":{"date":"2022-03-11T00:00:00.000Z","category":["Java 多线程"],"tag":["Java 多线程"],"description":"JUC线程池: ScheduledThreadPoolExecutor详解 在很多业务场景中，我们可能需要周期性的运行某项任务来获取结果，比如周期数据统计，定时发送数据等。在并发包出现之前，Java 早在1.3就提供了 Timer 类(只需要了解，目前已渐渐被 ScheduledThreadPoolExecutor 代替)来适应这些业务场景。随着业务量的不断增大，我们可能需要多个工作线程运行任务来尽可能的增加产品性能，或者是需要更高的灵活性来控制和监控这些周期业务。这些都是 ScheduledThreadPoolExecutor 诞生的必然性。","head":[["meta",{"property":"og:url","content":"http://www.gavin-james.com/java/thread/java-thread-x-juc-executor-ScheduledThreadPoolExecutor.html"}],["meta",{"property":"og:site_name","content":"Gavin James"}],["meta",{"property":"og:title","content":"JUC线程池: ScheduledThreadPoolExecutor详解"}],["meta",{"property":"og:description","content":"JUC线程池: ScheduledThreadPoolExecutor详解 在很多业务场景中，我们可能需要周期性的运行某项任务来获取结果，比如周期数据统计，定时发送数据等。在并发包出现之前，Java 早在1.3就提供了 Timer 类(只需要了解，目前已渐渐被 ScheduledThreadPoolExecutor 代替)来适应这些业务场景。随着业务量的不断增大，我们可能需要多个工作线程运行任务来尽可能的增加产品性能，或者是需要更高的灵活性来控制和监控这些周期业务。这些都是 ScheduledThreadPoolExecutor 诞生的必然性。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-25T08:42:25.000Z"}],["meta",{"property":"article:author","content":"gavin-james"}],["meta",{"property":"article:tag","content":"Java 多线程"}],["meta",{"property":"article:published_time","content":"2022-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-25T08:42:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JUC线程池: ScheduledThreadPoolExecutor详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-25T08:42:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gavin-james\\",\\"url\\":\\"http://www.gavin-james.xyz\\"}]}"]]},"headers":[{"level":2,"title":"带着BAT大厂的面试问题去理解ScheduledThreadPoolExecutor","slug":"带着bat大厂的面试问题去理解scheduledthreadpoolexecutor","link":"#带着bat大厂的面试问题去理解scheduledthreadpoolexecutor","children":[]},{"level":2,"title":"ScheduledThreadPoolExecutor简介","slug":"scheduledthreadpoolexecutor简介","link":"#scheduledthreadpoolexecutor简介","children":[]},{"level":2,"title":"ScheduledThreadPoolExecutor数据结构","slug":"scheduledthreadpoolexecutor数据结构","link":"#scheduledthreadpoolexecutor数据结构","children":[]},{"level":2,"title":"ScheduledThreadPoolExecutor源码解析","slug":"scheduledthreadpoolexecutor源码解析","link":"#scheduledthreadpoolexecutor源码解析","children":[{"level":3,"title":"内部类ScheduledFutureTask","slug":"内部类scheduledfuturetask","link":"#内部类scheduledfuturetask","children":[]},{"level":3,"title":"核心属性","slug":"核心属性","link":"#核心属性","children":[]},{"level":3,"title":"构造函数","slug":"构造函数","link":"#构造函数","children":[]},{"level":3,"title":"核心方法:Schedule","slug":"核心方法-schedule","link":"#核心方法-schedule","children":[]},{"level":3,"title":"核心方法:scheduleAtFixedRate 和 scheduleWithFixedDelay","slug":"核心方法-scheduleatfixedrate-和-schedulewithfixeddelay","link":"#核心方法-scheduleatfixedrate-和-schedulewithfixeddelay","children":[]},{"level":3,"title":"核心方法:shutdown()","slug":"核心方法-shutdown","link":"#核心方法-shutdown","children":[]}]},{"level":2,"title":"再深入理解","slug":"再深入理解","link":"#再深入理解","children":[]},{"level":2,"title":"参考文章","slug":"参考文章","link":"#参考文章","children":[]}],"git":{"createdTime":1687917370000,"updatedTime":1703493745000,"contributors":[{"name":"gavin-james","email":"meaganlindesy1258@gmail.com","commits":2}]},"readingTime":{"minutes":10.97,"words":3291},"filePathRelative":"java/thread/java-thread-x-juc-executor-ScheduledThreadPoolExecutor.md","localizedDate":"2022年3月11日","excerpt":"<h1> JUC线程池: ScheduledThreadPoolExecutor详解</h1>\\n<blockquote>\\n<p>在很多业务场景中，我们可能需要周期性的运行某项任务来获取结果，比如周期数据统计，定时发送数据等。在并发包出现之前，Java 早在1.3就提供了 Timer 类(只需要了解，目前已渐渐被 ScheduledThreadPoolExecutor 代替)来适应这些业务场景。随着业务量的不断增大，我们可能需要多个工作线程运行任务来尽可能的增加产品性能，或者是需要更高的灵活性来控制和监控这些周期业务。这些都是 ScheduledThreadPoolExecutor 诞生的必然性。</p>\\n</blockquote>","copyright":{"author":"gavin-james","license":"https://github.com/gavin-james/gavin-james.github.io/LICENSE"},"autoDesc":true}');export{e as data};
