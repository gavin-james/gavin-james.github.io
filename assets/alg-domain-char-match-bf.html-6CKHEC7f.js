import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as i,o,c as l,a,b as s,d as e,f as c}from"./app-5g2Grfu7.js";const r={},p=c(`<h1 id="字符串匹配-模式预处理-朴素算法-naive-暴力破解" tabindex="-1"><a class="header-anchor" href="#字符串匹配-模式预处理-朴素算法-naive-暴力破解" aria-hidden="true">#</a> 字符串匹配 - 模式预处理：朴素算法（Naive)(暴力破解)</h1><blockquote><p>朴素的字符串匹配算法又称为<strong>暴力匹配算法</strong>（Brute Force Algorithm），最为简单的字符串匹配算法。</p></blockquote><h2 id="算法简介" tabindex="-1"><a class="header-anchor" href="#算法简介" aria-hidden="true">#</a> 算法简介</h2><blockquote><p>朴素的字符串匹配算法又称为暴力匹配算法（Brute Force Algorithm），它的主要特点是：</p></blockquote><ul><li>没有预处理阶段；</li><li>滑动窗口总是后移 1 位；</li><li>对模式中的字符的比较顺序不限定，可以从前到后，也可以从后到前；</li><li>匹配阶段需要 O((n - m + 1)m) 的时间复杂度；</li><li>需要 2n 次的字符比较；</li></ul><p>很显然，朴素的字符串匹配算法 NAIVE-STRING-MATCHER 是最原始的算法，它通过使用循环来检查是否在范围 n-m+1 中存在满足条件 P[1..m] = T [s + 1..s + m] 的有效位移 s。</p><p>伪代码如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>NAIVE-STRING-MATCHER<span class="token punctuation">(</span>T, P<span class="token punctuation">)</span>
  n ← length<span class="token punctuation">[</span>T<span class="token punctuation">]</span>
  m ← length<span class="token punctuation">[</span>P<span class="token punctuation">]</span>
  <span class="token keyword">for</span> s ← <span class="token number">0</span> to n - m
    <span class="token keyword">do</span> <span class="token keyword">if</span> P<span class="token punctuation">[</span><span class="token number">1</span> <span class="token punctuation">..</span> m<span class="token punctuation">]</span> <span class="token operator">=</span> T<span class="token punctuation">[</span>s + <span class="token number">1</span> <span class="token punctuation">..</span> s + m<span class="token punctuation">]</span>
      <span class="token keyword">then</span> print <span class="token string">&quot;Pattern occurs with shift&quot;</span> s
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://www.pdai.tech/images/alg/alg-domain-char-bf-2.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>如上图中，对于模式 P = aab 和文本 T = acaabc，将模式 P 沿着 T 从左到右滑动，逐个比较字符以判断模式 P 在文本 T 中是否存在。</p><p>可以看出，NAIVE-STRING-MATCHER 没有对模式 P 进行预处理，所以预处理的时间为 0。而匹配的时间在最坏情况下为 Θ((n-m+1)m)，如果 m = [n/2]，则为 Θ(n2)。</p><h2 id="图例分析" tabindex="-1"><a class="header-anchor" href="#图例分析" aria-hidden="true">#</a> 图例分析</h2><p>假设有两个字符串：</p><ul><li>M=&quot;abcdefabcdx&quot;;</li><li>T=&quot;abcdx&quot;;</li></ul><p>想要找到T串在M串中的位置，要怎么找呢？</p><figure><img src="https://www.pdai.tech/images/alg/alg-domain-char-bf-1.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>也就是说，从主串M的第一个字符开始分别与子串从开头进行比较，当发现不匹配时，主串回到这一轮开始的下一个字符，子串从头开始比较。直到子串所有的字符都匹配，返回所在主串中的下标。</p><h2 id="算法复杂度" tabindex="-1"><a class="header-anchor" href="#算法复杂度" aria-hidden="true">#</a> 算法复杂度</h2><p>假设S的长度是m，T的长度是n，暂不考虑pos，从字符串S的开头开始比较。</p><ul><li>最好的情况是第一次就匹配了，需要比较的次数是n.</li><li>最坏的情况下，就是上面举的这种例子，需要把整个字符串都比较完，从下面的代码中就体现为把两层循环都跑了一遍。这时候，比较的次数就是t*(s-t+1).</li></ul><p>所以这个算法的(最坏)时间复杂度就是o(t(s-t+1))，近似为o(n2).</p><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章" aria-hidden="true">#</a> 参考文章</h2>`,22),d={href:"https://www.cnblogs.com/gaochundong/p/string_matching.html#kmp_string_matching_algorithm",target:"_blank",rel:"noopener noreferrer"},u={href:"https://blog.csdn.net/u013301192/article/details/48507695",target:"_blank",rel:"noopener noreferrer"};function h(m,g){const n=i("ExternalLinkIcon");return o(),l("div",null,[p,a("ul",null,[a("li",null,[a("a",d,[s("https://www.cnblogs.com/gaochundong/p/string_matching.html#kmp_string_matching_algorithm"),e(n)])]),a("li",null,[a("a",u,[s("https://blog.csdn.net/u013301192/article/details/48507695"),e(n)])])])])}const f=t(r,[["render",h],["__file","alg-domain-char-match-bf.html.vue"]]);export{f as default};
