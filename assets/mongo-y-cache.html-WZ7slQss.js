const e=JSON.parse('{"key":"v-53709252","path":"/db/nosql-mongo/mongo-y-cache.html","title":"Mongo进阶 - WT引擎：缓存机制","lang":"zh-CN","frontmatter":{"date":"2022-07-15T00:00:00.000Z","category":["NoSQL MongoDB"],"tag":["NoSQL MongoDB"],"description":"Mongo进阶 - WT引擎：缓存机制 WT 在设计 LRU Cache 时采用分段扫描标记和 hazard pointer 的淘汰机制，在 WT 内部称这种机制叫 eviction Cache 或者 WT Cache，其设计目标是充分利用现代计算机超大内存容量来提高事务读写并发。 为什么会需要理解eviction cache 从mongoDB 3.0版本引入WiredTiger存储引擎(以下称为WT)以来，一直有同学反应在高速写入数据时WT引擎会间歇性写挂起，有时候写延迟达到了几十秒，这确实是个严重的问题。引起这类问题的关键在于WT的LRU cache的设计模型，WT在设计LRU cache时采用分段扫描标记和hazardpointer的淘汰机制，在WT内部称这种机制叫eviction cache或者WT cache，其设计目标是充分利用现代计算机超大内存容量来提高事务读写并发。在高速不间断写时内存操作是非常快的，但是内存中的数据最终必须写入到磁盘上，将页数据（page）由内存中写入磁盘上是需要写入时间，必定会和应用程序的高速不间断写产生竞争，这在任何数据库存储引擎都是无法避免的，只是由于WT利用大内存和写无锁的特性，让这种不平衡现象更加显著。下图是一位网名叫chszs同学对mongoDB 3.0和3.2版本测试高速写遇到的hang现象.","head":[["meta",{"property":"og:url","content":"http://www.gavin-james.com/db/nosql-mongo/mongo-y-cache.html"}],["meta",{"property":"og:site_name","content":"Gavin James"}],["meta",{"property":"og:title","content":"Mongo进阶 - WT引擎：缓存机制"}],["meta",{"property":"og:description","content":"Mongo进阶 - WT引擎：缓存机制 WT 在设计 LRU Cache 时采用分段扫描标记和 hazard pointer 的淘汰机制，在 WT 内部称这种机制叫 eviction Cache 或者 WT Cache，其设计目标是充分利用现代计算机超大内存容量来提高事务读写并发。 为什么会需要理解eviction cache 从mongoDB 3.0版本引入WiredTiger存储引擎(以下称为WT)以来，一直有同学反应在高速写入数据时WT引擎会间歇性写挂起，有时候写延迟达到了几十秒，这确实是个严重的问题。引起这类问题的关键在于WT的LRU cache的设计模型，WT在设计LRU cache时采用分段扫描标记和hazardpointer的淘汰机制，在WT内部称这种机制叫eviction cache或者WT cache，其设计目标是充分利用现代计算机超大内存容量来提高事务读写并发。在高速不间断写时内存操作是非常快的，但是内存中的数据最终必须写入到磁盘上，将页数据（page）由内存中写入磁盘上是需要写入时间，必定会和应用程序的高速不间断写产生竞争，这在任何数据库存储引擎都是无法避免的，只是由于WT利用大内存和写无锁的特性，让这种不平衡现象更加显著。下图是一位网名叫chszs同学对mongoDB 3.0和3.2版本测试高速写遇到的hang现象."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-26T08:34:19.000Z"}],["meta",{"property":"article:author","content":"gavin-james"}],["meta",{"property":"article:tag","content":"NoSQL MongoDB"}],["meta",{"property":"article:published_time","content":"2022-07-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-26T08:34:19.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Mongo进阶 - WT引擎：缓存机制\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-07-15T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-26T08:34:19.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gavin-james\\",\\"url\\":\\"http://www.gavin-james.xyz\\"}]}"]]},"headers":[{"level":2,"title":"为什么会需要理解eviction cache","slug":"为什么会需要理解eviction-cache","link":"#为什么会需要理解eviction-cache","children":[]},{"level":2,"title":"eviction cache原理","slug":"eviction-cache原理","link":"#eviction-cache原理","children":[{"level":3,"title":"eviction线程模型","slug":"eviction线程模型","link":"#eviction线程模型","children":[]},{"level":3,"title":"hazard pointer","slug":"hazard-pointer","link":"#hazard-pointer","children":[]}]},{"level":2,"title":"eviction cache管理的内存","slug":"eviction-cache管理的内存","link":"#eviction-cache管理的内存","children":[{"level":3,"title":"evict pass策略","slug":"evict-pass策略","link":"#evict-pass策略","children":[]},{"level":3,"title":"evict page过程","slug":"evict-page过程","link":"#evict-page过程","children":[]}]},{"level":2,"title":"eviction cache与checkpoint之间的事","slug":"eviction-cache与checkpoint之间的事","link":"#eviction-cache与checkpoint之间的事","children":[{"level":3,"title":"btree的checkpoint","slug":"btree的checkpoint","link":"#btree的checkpoint","children":[]},{"level":3,"title":"写挂起","slug":"写挂起","link":"#写挂起","children":[]}]},{"level":2,"title":"内存和磁盘I/O的权衡","slug":"内存和磁盘i-o的权衡","link":"#内存和磁盘i-o的权衡","children":[]},{"level":2,"title":"后记","slug":"后记","link":"#后记","children":[]},{"level":2,"title":"参考文章","slug":"参考文章","link":"#参考文章","children":[]}],"git":{"createdTime":1690160698000,"updatedTime":1703579659000,"contributors":[{"name":"gavin-james","email":"meaganlindesy1258@gmail.com","commits":2}]},"readingTime":{"minutes":20.43,"words":6129},"filePathRelative":"db/nosql-mongo/mongo-y-cache.md","localizedDate":"2022年7月15日","excerpt":"<h1> Mongo进阶 - WT引擎：缓存机制</h1>\\n<blockquote>\\n<p>WT 在设计 LRU Cache 时采用分段扫描标记和 hazard pointer 的淘汰机制，在 WT 内部称这种机制叫 eviction Cache 或者 WT Cache，其设计目标是充分利用现代计算机超大内存容量来提高事务读写并发。</p>\\n</blockquote>\\n<h2> 为什么会需要理解eviction cache</h2>\\n<p>从mongoDB 3.0版本引入WiredTiger存储引擎(以下称为WT)以来，一直有同学反应在高速写入数据时WT引擎会间歇性写挂起，有时候写延迟达到了几十秒，这确实是个严重的问题。引起这类问题的关键在于WT的LRU cache的设计模型，WT在设计LRU cache时采用分段扫描标记和hazardpointer的淘汰机制，在WT内部称这种机制叫eviction cache或者WT cache，其设计目标是充分利用现代计算机超大内存容量来提高事务读写并发。在高速不间断写时内存操作是非常快的，但是内存中的数据最终必须写入到磁盘上，将页数据（page）由内存中写入磁盘上是需要写入时间，必定会和应用程序的高速不间断写产生竞争，这在任何数据库存储引擎都是无法避免的，只是由于WT利用大内存和写无锁的特性，让这种不平衡现象更加显著。下图是一位网名叫chszs同学对mongoDB 3.0和3.2版本测试高速写遇到的hang现象.</p>","copyright":{"author":"gavin-james","license":"https://github.com/gavin-james/gavin-james.github.io/LICENSE"},"autoDesc":true}');export{e as data};
