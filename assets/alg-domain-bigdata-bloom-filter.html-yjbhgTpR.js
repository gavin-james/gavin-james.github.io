const e=JSON.parse('{"key":"v-6d52f585","path":"/develop/algorithms-structures/alg-domain/alg-domain-bigdata-bloom-filter.html","title":"大数据处理 - Bitmap & Bloom Filter","lang":"zh-CN","frontmatter":{"date":"2019-07-28T00:00:00.000Z","category":["算法和数据结构"],"tag":["领域算法"],"description":"大数据处理 - Bitmap &amp; Bloom Filter 布隆过滤器有着广泛的应用，对于大量数据的“存不存在”的问题在空间上有明显优势，但是在判断存不存在是有一定的错误率(false positive)，也就是说，有可能把不属于这个集合的元素误认为属于这个集合(False Positive)，但不会把属于这个集合的元素误认为不属于这个集合(False Negative)。 布隆过滤器由来 布隆在1970年提出了布隆过滤器(Bloom Filter)，是一个很长的二进制向量(可以想象成一个序列)和一系列随机映射函数(hash function)。可用于判断一个元素是否在一个集合中，查询效率很高(1-N，最优能逼近于1)。通常应用在一些需要快速判断某个元素是否属于集合，但是并不严格要求100%正确的场合。","head":[["meta",{"property":"og:url","content":"http://www.gavin-james.com/develop/algorithms-structures/alg-domain/alg-domain-bigdata-bloom-filter.html"}],["meta",{"property":"og:site_name","content":"Gavin James"}],["meta",{"property":"og:title","content":"大数据处理 - Bitmap & Bloom Filter"}],["meta",{"property":"og:description","content":"大数据处理 - Bitmap &amp; Bloom Filter 布隆过滤器有着广泛的应用，对于大量数据的“存不存在”的问题在空间上有明显优势，但是在判断存不存在是有一定的错误率(false positive)，也就是说，有可能把不属于这个集合的元素误认为属于这个集合(False Positive)，但不会把属于这个集合的元素误认为不属于这个集合(False Negative)。 布隆过滤器由来 布隆在1970年提出了布隆过滤器(Bloom Filter)，是一个很长的二进制向量(可以想象成一个序列)和一系列随机映射函数(hash function)。可用于判断一个元素是否在一个集合中，查询效率很高(1-N，最优能逼近于1)。通常应用在一些需要快速判断某个元素是否属于集合，但是并不严格要求100%正确的场合。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-27T08:55:11.000Z"}],["meta",{"property":"article:author","content":"gavin-james"}],["meta",{"property":"article:tag","content":"领域算法"}],["meta",{"property":"article:published_time","content":"2019-07-28T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-27T08:55:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"大数据处理 - Bitmap & Bloom Filter\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2019-07-28T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-27T08:55:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gavin-james\\",\\"url\\":\\"http://www.gavin-james.xyz\\"}]}"]]},"headers":[{"level":2,"title":"布隆过滤器由来","slug":"布隆过滤器由来","link":"#布隆过滤器由来","children":[{"level":3,"title":"特点","slug":"特点","link":"#特点","children":[]},{"level":3,"title":"几个专业术语","slug":"几个专业术语","link":"#几个专业术语","children":[]}]},{"level":2,"title":"布隆过滤器应用场景","slug":"布隆过滤器应用场景","link":"#布隆过滤器应用场景","children":[]},{"level":2,"title":"布隆过滤器实现","slug":"布隆过滤器实现","link":"#布隆过滤器实现","children":[{"level":3,"title":"以BitSet 实现方式为例","slug":"以bitset-实现方式为例","link":"#以bitset-实现方式为例","children":[]},{"level":3,"title":"以BitSet 实现代码","slug":"以bitset-实现代码","link":"#以bitset-实现代码","children":[]}]},{"level":2,"title":"误报率 - False Positive Rate","slug":"误报率-false-positive-rate","link":"#误报率-false-positive-rate","children":[{"level":3,"title":"误报率的产生","slug":"误报率的产生","link":"#误报率的产生","children":[]},{"level":3,"title":"误报率的计算","slug":"误报率的计算","link":"#误报率的计算","children":[]},{"level":3,"title":"减少误报率: 最优的哈希函数个数","slug":"减少误报率-最优的哈希函数个数","link":"#减少误报率-最优的哈希函数个数","children":[]},{"level":3,"title":"减少误报率: 位数组的大小","slug":"减少误报率-位数组的大小","link":"#减少误报率-位数组的大小","children":[]}]},{"level":2,"title":"拓展: Counting Bloom Filter","slug":"拓展-counting-bloom-filter","link":"#拓展-counting-bloom-filter","children":[]},{"level":2,"title":"拓展: 其它","slug":"拓展-其它","link":"#拓展-其它","children":[{"level":3,"title":"Data synchronization","slug":"data-synchronization","link":"#data-synchronization","children":[]},{"level":3,"title":"Bloomier filters","slug":"bloomier-filters","link":"#bloomier-filters","children":[]},{"level":3,"title":"Compact approximators","slug":"compact-approximators","link":"#compact-approximators","children":[]},{"level":3,"title":"Stable Bloom filters","slug":"stable-bloom-filters","link":"#stable-bloom-filters","children":[]},{"level":3,"title":"Scalable Bloom filters","slug":"scalable-bloom-filters","link":"#scalable-bloom-filters","children":[]},{"level":3,"title":"Attenuated Bloom filters","slug":"attenuated-bloom-filters","link":"#attenuated-bloom-filters","children":[]}]},{"level":2,"title":"相关题目","slug":"相关题目","link":"#相关题目","children":[{"level":3,"title":"给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢?","slug":"给你a-b两个文件-各存放50亿条url-每条url占用64字节-内存限制是4g-让你找出a-b文件共同的url。如果是三个乃至n个文件呢","link":"#给你a-b两个文件-各存放50亿条url-每条url占用64字节-内存限制是4g-让你找出a-b文件共同的url。如果是三个乃至n个文件呢","children":[]},{"level":3,"title":"给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url?","slug":"给定a、b两个文件-各存放50亿个url-每个url各占64字节-内存限制是4g-让你找出a、b文件共同的url","link":"#给定a、b两个文件-各存放50亿个url-每个url各占64字节-内存限制是4g-让你找出a、b文件共同的url","children":[]},{"level":3,"title":"在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。","slug":"在2-5亿个整数中找出不重复的整数-注-内存不足以容纳这2-5亿个整数。","link":"#在2-5亿个整数中找出不重复的整数-注-内存不足以容纳这2-5亿个整数。","children":[]},{"level":3,"title":"给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中?","slug":"给40亿个不重复的unsigned-int的整数-没排过序的-然后再给一个数-如何快速判断这个数是否在那40亿个数当中","link":"#给40亿个不重复的unsigned-int的整数-没排过序的-然后再给一个数-如何快速判断这个数是否在那40亿个数当中","children":[]}]},{"level":2,"title":"参考文章","slug":"参考文章","link":"#参考文章","children":[]}],"git":{"createdTime":1703667311000,"updatedTime":1703667311000,"contributors":[{"name":"gavin-james","email":"meaganlindesy1258@gmail.com","commits":1}]},"readingTime":{"minutes":15.58,"words":4675},"filePathRelative":"develop/algorithms-structures/alg-domain/alg-domain-bigdata-bloom-filter.md","localizedDate":"2019年7月28日","excerpt":"<h1> 大数据处理 - Bitmap &amp; Bloom Filter</h1>\\n<blockquote>\\n<p>布隆过滤器有着广泛的应用，对于大量数据的“存不存在”的问题在空间上有明显优势，但是在判断存不存在是有一定的错误率(false positive)，也就是说，有可能把不属于这个集合的元素误认为属于这个集合(False Positive)，但不会把属于这个集合的元素误认为不属于这个集合(False Negative)。</p>\\n</blockquote>\\n<h2> 布隆过滤器由来</h2>\\n<p>布隆在1970年提出了布隆过滤器(Bloom Filter)，是一个很长的二进制向量(可以想象成一个序列)和一系列随机映射函数(hash function)。可用于判断一个元素是否在一个集合中，查询效率很高(1-N，最优能逼近于1)。通常应用在一些需要快速判断某个元素是否属于集合，但是并不严格要求100%正确的场合。</p>","copyright":{"author":"gavin-james","license":"https://github.com/gavin-james/gavin-james.github.io/LICENSE"},"autoDesc":true}');export{e as data};
