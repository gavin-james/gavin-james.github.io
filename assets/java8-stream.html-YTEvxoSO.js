const e=JSON.parse('{"key":"v-c32bfbf8","path":"/java/javaup/java8-stream.html","title":"Java 8 - 函数编程(lambda表达式)","lang":"zh-CN","frontmatter":{"date":"2022-04-02T00:00:00.000Z","category":["Java 新特性"],"tag":["Java 新特性"],"description":"Java 8 - 函数编程(lambda表达式) 我们关心的是如何写出好代码，而不是符合函数编程风格的代码。 简介 在Java世界里面，面向对象还是主流思想，对于习惯了面向对象编程的开发者来说，抽象的概念并不陌生。面向对象编程是对数据进行抽象，而函数式编程是对行为进行抽象。现实世界中，数据和行为并存，程序也是如此，因此这两种编程方式我们都得学。 这种新的抽象方式还有其他好处。很多人不总是在编写性能优先的代码，对于这些人来说，函数式编程带来的好处尤为明显。程序员能编写出更容易阅读的代码——这种代码更多地表达了业务逻辑，而不是从机制上如何实现。易读的代码也易于维护、更可靠、更不容易出错。","head":[["meta",{"property":"og:url","content":"http://www.gavin-james.com/java/javaup/java8-stream.html"}],["meta",{"property":"og:site_name","content":"Gavin James"}],["meta",{"property":"og:title","content":"Java 8 - 函数编程(lambda表达式)"}],["meta",{"property":"og:description","content":"Java 8 - 函数编程(lambda表达式) 我们关心的是如何写出好代码，而不是符合函数编程风格的代码。 简介 在Java世界里面，面向对象还是主流思想，对于习惯了面向对象编程的开发者来说，抽象的概念并不陌生。面向对象编程是对数据进行抽象，而函数式编程是对行为进行抽象。现实世界中，数据和行为并存，程序也是如此，因此这两种编程方式我们都得学。 这种新的抽象方式还有其他好处。很多人不总是在编写性能优先的代码，对于这些人来说，函数式编程带来的好处尤为明显。程序员能编写出更容易阅读的代码——这种代码更多地表达了业务逻辑，而不是从机制上如何实现。易读的代码也易于维护、更可靠、更不容易出错。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-25T08:42:25.000Z"}],["meta",{"property":"article:author","content":"gavin-james"}],["meta",{"property":"article:tag","content":"Java 新特性"}],["meta",{"property":"article:published_time","content":"2022-04-02T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-25T08:42:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 8 - 函数编程(lambda表达式)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-04-02T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-25T08:42:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gavin-james\\",\\"url\\":\\"http://www.gavin-james.xyz\\"}]}"]]},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"lambda表达式","slug":"lambda表达式","link":"#lambda表达式","children":[]},{"level":2,"title":"分类","slug":"分类","link":"#分类","children":[{"level":3,"title":"惰性求值方法","slug":"惰性求值方法","link":"#惰性求值方法","children":[]},{"level":3,"title":"及早求值方法","slug":"及早求值方法","link":"#及早求值方法","children":[]}]},{"level":2,"title":"stream & parallelStream","slug":"stream-parallelstream","link":"#stream-parallelstream","children":[{"level":3,"title":"stream & parallelStream","slug":"stream-parallelstream-1","link":"#stream-parallelstream-1","children":[]},{"level":3,"title":"parallelStream原理:","slug":"parallelstream原理","link":"#parallelstream原理","children":[]},{"level":3,"title":"stream与parallelStream性能测试对比","slug":"stream与parallelstream性能测试对比","link":"#stream与parallelstream性能测试对比","children":[]},{"level":3,"title":"Stream中常用方法如下:","slug":"stream中常用方法如下","link":"#stream中常用方法如下","children":[]}]},{"level":2,"title":"常用例子","slug":"常用例子","link":"#常用例子","children":[{"level":3,"title":"匿名类简写","slug":"匿名类简写","link":"#匿名类简写","children":[]},{"level":3,"title":"forEach","slug":"foreach","link":"#foreach","children":[]},{"level":3,"title":"方法引用","slug":"方法引用","link":"#方法引用","children":[]},{"level":3,"title":"Filter & Predicate","slug":"filter-predicate","link":"#filter-predicate","children":[]},{"level":3,"title":"Map&Reduce","slug":"map-reduce","link":"#map-reduce","children":[]},{"level":3,"title":"Collectors","slug":"collectors","link":"#collectors","children":[]},{"level":3,"title":"flatMap","slug":"flatmap","link":"#flatmap","children":[]},{"level":3,"title":"distinct","slug":"distinct","link":"#distinct","children":[]},{"level":3,"title":"count","slug":"count","link":"#count","children":[]},{"level":3,"title":"Match","slug":"match","link":"#match","children":[]},{"level":3,"title":"min,max,summaryStatistics","slug":"min-max-summarystatistics","link":"#min-max-summarystatistics","children":[]},{"level":3,"title":"peek","slug":"peek","link":"#peek","children":[]}]},{"level":2,"title":"FunctionalInterface","slug":"functionalinterface","link":"#functionalinterface","children":[{"level":3,"title":"理解注解 @FunctionInterface","slug":"理解注解-functioninterface","link":"#理解注解-functioninterface","children":[]},{"level":3,"title":"自定义函数接口","slug":"自定义函数接口","link":"#自定义函数接口","children":[]},{"level":3,"title":"内置四大函数接口","slug":"内置四大函数接口","link":"#内置四大函数接口","children":[]}]},{"level":2,"title":"一些例子","slug":"一些例子","link":"#一些例子","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1687917370000,"updatedTime":1703493745000,"contributors":[{"name":"gavin-james","email":"meaganlindesy1258@gmail.com","commits":2}]},"readingTime":{"minutes":15.53,"words":4658},"filePathRelative":"java/javaup/java8-stream.md","localizedDate":"2022年4月2日","excerpt":"<h1> Java 8 - 函数编程(lambda表达式)</h1>\\n<blockquote>\\n<p>我们关心的是如何写出好代码，而不是符合函数编程风格的代码。</p>\\n</blockquote>\\n<h2> 简介</h2>\\n<blockquote>\\n<p>在Java世界里面，面向对象还是主流思想，对于习惯了面向对象编程的开发者来说，抽象的概念并不陌生。面向对象编程是对数据进行抽象，而函数式编程是对行为进行抽象。现实世界中，数据和行为并存，程序也是如此，因此这两种编程方式我们都得学。</p>\\n</blockquote>\\n<blockquote>\\n<p>这种新的抽象方式还有其他好处。很多人不总是在编写性能优先的代码，对于这些人来说，函数式编程带来的好处尤为明显。程序员能编写出更容易阅读的代码——这种代码更多地表达了业务逻辑，而不是从机制上如何实现。易读的代码也易于维护、更可靠、更不容易出错。</p>\\n</blockquote>","copyright":{"author":"gavin-james","license":"https://github.com/gavin-james/gavin-james.github.io/LICENSE"},"autoDesc":true}');export{e as data};
