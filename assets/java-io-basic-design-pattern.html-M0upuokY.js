const e=JSON.parse('{"key":"v-dd6781f0","path":"/java/io/java-io-basic-design-pattern.html","title":"Java IO - 设计模式(装饰者模式)","lang":"zh-CN","frontmatter":{"date":"2022-03-21T00:00:00.000Z","category":["Java IO/NIO/AIO"],"tag":["Java IO/NIO/AIO"],"description":"Java IO - 设计模式(装饰者模式) Java I/O 使用了装饰者模式来实现。 装饰者模式 请参考装饰者模式详解 装饰者(Decorator)和具体组件(ConcreteComponent)都继承自组件(Component)，具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。","head":[["meta",{"property":"og:url","content":"http://www.gavin-james.com/java/io/java-io-basic-design-pattern.html"}],["meta",{"property":"og:site_name","content":"Gavin James"}],["meta",{"property":"og:title","content":"Java IO - 设计模式(装饰者模式)"}],["meta",{"property":"og:description","content":"Java IO - 设计模式(装饰者模式) Java I/O 使用了装饰者模式来实现。 装饰者模式 请参考装饰者模式详解 装饰者(Decorator)和具体组件(ConcreteComponent)都继承自组件(Component)，具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-25T08:42:25.000Z"}],["meta",{"property":"article:author","content":"gavin-james"}],["meta",{"property":"article:tag","content":"Java IO/NIO/AIO"}],["meta",{"property":"article:published_time","content":"2022-03-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-25T08:42:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java IO - 设计模式(装饰者模式)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-03-21T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-25T08:42:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gavin-james\\",\\"url\\":\\"http://www.gavin-james.xyz\\"}]}"]]},"headers":[{"level":2,"title":"装饰者模式","slug":"装饰者模式","link":"#装饰者模式","children":[]},{"level":2,"title":"IO 装饰者模式","slug":"io-装饰者模式","link":"#io-装饰者模式","children":[]}],"git":{"createdTime":1687917370000,"updatedTime":1703493745000,"contributors":[{"name":"gavin-james","email":"meaganlindesy1258@gmail.com","commits":2}]},"readingTime":{"minutes":1.34,"words":402},"filePathRelative":"java/io/java-io-basic-design-pattern.md","localizedDate":"2022年3月21日","excerpt":"<h1> Java IO - 设计模式(装饰者模式)</h1>\\n<blockquote>\\n<p>Java I/O 使用了装饰者模式来实现。</p>\\n</blockquote>\\n<h2> 装饰者模式</h2>\\n<p>请参考<a href=\\"\\">装饰者模式详解</a></p>\\n<p>装饰者(Decorator)和具体组件(ConcreteComponent)都继承自组件(Component)，具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。</p>","copyright":{"author":"gavin-james","license":"https://github.com/gavin-james/gavin-james.github.io/LICENSE"},"autoDesc":true}');export{e as data};
