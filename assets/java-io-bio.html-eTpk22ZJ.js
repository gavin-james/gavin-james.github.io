const e=JSON.parse('{"key":"v-4d1780c2","path":"/java/io/java-io-bio.html","title":"Java IO - BIO 详解","lang":"zh-CN","frontmatter":{"date":"2022-03-26T00:00:00.000Z","category":["Java IO/NIO/AIO"],"tag":["Java IO/NIO/AIO"],"description":"Java IO - BIO 详解 BIO就是: blocking IO。最容易理解、最容易实现的IO工作方式，应用程序向操作系统请求网络IO操作，这时应用程序会一直等待；另一方面，操作系统收到请求后，也会等待，直到网络上有数据传到监听端口；操作系统在收集数据后，会把数据发送给应用程序；最后应用程序受到数据，并解除等待状态。 几个重要概念 阻塞IO 和 非阻塞IO 这两个概念是程序级别的。主要描述的是程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题: 前者等待；后者继续执行(并且使用线程一直轮询，直到有IO资源准备好了)","head":[["meta",{"property":"og:url","content":"http://www.gavin-james.com/java/io/java-io-bio.html"}],["meta",{"property":"og:site_name","content":"Gavin James"}],["meta",{"property":"og:title","content":"Java IO - BIO 详解"}],["meta",{"property":"og:description","content":"Java IO - BIO 详解 BIO就是: blocking IO。最容易理解、最容易实现的IO工作方式，应用程序向操作系统请求网络IO操作，这时应用程序会一直等待；另一方面，操作系统收到请求后，也会等待，直到网络上有数据传到监听端口；操作系统在收集数据后，会把数据发送给应用程序；最后应用程序受到数据，并解除等待状态。 几个重要概念 阻塞IO 和 非阻塞IO 这两个概念是程序级别的。主要描述的是程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题: 前者等待；后者继续执行(并且使用线程一直轮询，直到有IO资源准备好了)"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-25T08:42:25.000Z"}],["meta",{"property":"article:author","content":"gavin-james"}],["meta",{"property":"article:tag","content":"Java IO/NIO/AIO"}],["meta",{"property":"article:published_time","content":"2022-03-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-25T08:42:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java IO - BIO 详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-03-26T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-25T08:42:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gavin-james\\",\\"url\\":\\"http://www.gavin-james.xyz\\"}]}"]]},"headers":[{"level":2,"title":"几个重要概念","slug":"几个重要概念","link":"#几个重要概念","children":[]},{"level":2,"title":"传统的BIO通信方式简介","slug":"传统的bio通信方式简介","link":"#传统的bio通信方式简介","children":[{"level":3,"title":"传统的BIO的问题","slug":"传统的bio的问题","link":"#传统的bio的问题","children":[]},{"level":3,"title":"多线程方式 - 伪异步方式","slug":"多线程方式-伪异步方式","link":"#多线程方式-伪异步方式","children":[]}]},{"level":2,"title":"BIO通信方式深入分析","slug":"bio通信方式深入分析","link":"#bio通信方式深入分析","children":[{"level":3,"title":"模拟20个客户端并发请求，服务器端使用单线程:","slug":"模拟20个客户端并发请求-服务器端使用单线程","link":"#模拟20个客户端并发请求-服务器端使用单线程","children":[]},{"level":3,"title":"多线程来优化服务器端","slug":"多线程来优化服务器端","link":"#多线程来优化服务器端","children":[]},{"level":3,"title":"看看服务器端的执行效果","slug":"看看服务器端的执行效果","link":"#看看服务器端的执行效果","children":[]},{"level":3,"title":"问题根源","slug":"问题根源","link":"#问题根源","children":[]}]},{"level":2,"title":"参考文章","slug":"参考文章","link":"#参考文章","children":[]}],"git":{"createdTime":1687917370000,"updatedTime":1703493745000,"contributors":[{"name":"gavin-james","email":"meaganlindesy1258@gmail.com","commits":2}]},"readingTime":{"minutes":9.88,"words":2963},"filePathRelative":"java/io/java-io-bio.md","localizedDate":"2022年3月26日","excerpt":"<h1> Java IO - BIO 详解</h1>\\n<blockquote>\\n<p>BIO就是: blocking IO。最容易理解、最容易实现的IO工作方式，应用程序向操作系统请求网络IO操作，这时应用程序会一直等待；另一方面，操作系统收到请求后，也会等待，直到网络上有数据传到监听端口；操作系统在收集数据后，会把数据发送给应用程序；最后应用程序受到数据，并解除等待状态。</p>\\n</blockquote>\\n<h2> 几个重要概念</h2>\\n<ul>\\n<li><code>阻塞IO</code> 和 <code>非阻塞IO</code></li>\\n</ul>\\n<p>这两个概念是<code>程序级别</code>的。主要描述的是程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题: 前者等待；后者继续执行(并且使用线程一直轮询，直到有IO资源准备好了)</p>","copyright":{"author":"gavin-james","license":"https://github.com/gavin-james/gavin-james.github.io/LICENSE"},"autoDesc":true}');export{e as data};
