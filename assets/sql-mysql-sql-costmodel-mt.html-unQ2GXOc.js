const e=JSON.parse(`{"key":"v-af64b6d8","path":"/db/sql-mysql/sql-mysql-sql-costmodel-mt.html","title":"大厂实践 - 美团: 基于代价的慢查询优化建议","lang":"zh-CN","frontmatter":{"date":"2022-06-07T00:00:00.000Z","category":["SQL MySQL"],"tag":["SQL MySQL"],"description":"大厂实践 - 美团: 基于代价的慢查询优化建议 前文我们介绍了优化慢查询最直接有效的方法就是选用一个查询效率高的索引。关于高效率的索引推荐，主要在日常工作中，基于经验规则的推荐随处可见，对于简单的SQL，如select * from sync_test1 where name like 'Bobby%'，直接添加索引IX(name) 就可以取得不错的效果；但对于稍微复杂点的SQL，如select * from sync_test1 where name like 'Bobby%' and dt &gt; '2021-07-06'，到底选择IX(name)、IX(dt)、IX(dt,name) 还是IX(name,dt)，该方法也无法给出准确的回答。更别说像多表Join、子查询这样复杂的场景了。所以采用基于代价的推荐来解决该问题会更加普适，因为基于代价的方法使用了和数据库优化器相同的方式，去量化评估所有的可能性，选出的是执行SQL耗费代价最小的索引。","head":[["meta",{"property":"og:url","content":"http://www.gavin-james.com/db/sql-mysql/sql-mysql-sql-costmodel-mt.html"}],["meta",{"property":"og:site_name","content":"Gavin James"}],["meta",{"property":"og:title","content":"大厂实践 - 美团: 基于代价的慢查询优化建议"}],["meta",{"property":"og:description","content":"大厂实践 - 美团: 基于代价的慢查询优化建议 前文我们介绍了优化慢查询最直接有效的方法就是选用一个查询效率高的索引。关于高效率的索引推荐，主要在日常工作中，基于经验规则的推荐随处可见，对于简单的SQL，如select * from sync_test1 where name like 'Bobby%'，直接添加索引IX(name) 就可以取得不错的效果；但对于稍微复杂点的SQL，如select * from sync_test1 where name like 'Bobby%' and dt &gt; '2021-07-06'，到底选择IX(name)、IX(dt)、IX(dt,name) 还是IX(name,dt)，该方法也无法给出准确的回答。更别说像多表Join、子查询这样复杂的场景了。所以采用基于代价的推荐来解决该问题会更加普适，因为基于代价的方法使用了和数据库优化器相同的方式，去量化评估所有的可能性，选出的是执行SQL耗费代价最小的索引。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-26T08:34:19.000Z"}],["meta",{"property":"article:author","content":"gavin-james"}],["meta",{"property":"article:tag","content":"SQL MySQL"}],["meta",{"property":"article:published_time","content":"2022-06-07T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-26T08:34:19.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"大厂实践 - 美团: 基于代价的慢查询优化建议\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-06-07T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-26T08:34:19.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"gavin-james\\",\\"url\\":\\"http://www.gavin-james.xyz\\"}]}"]]},"headers":[{"level":2,"title":"1 背景","slug":"_1-背景","link":"#_1-背景","children":[]},{"level":2,"title":"2 基于代价的优化器介绍","slug":"_2-基于代价的优化器介绍","link":"#_2-基于代价的优化器介绍","children":[{"level":3,"title":"2.1 SQL执行与优化器","slug":"_2-1-sql执行与优化器","link":"#_2-1-sql执行与优化器","children":[]},{"level":3,"title":"2.2 代价模型介绍","slug":"_2-2-代价模型介绍","link":"#_2-2-代价模型介绍","children":[]},{"level":3,"title":"2.3 基于代价的索引选择","slug":"_2-3-基于代价的索引选择","link":"#_2-3-基于代价的索引选择","children":[]},{"level":3,"title":"2.4 基于代价的索引推荐思路","slug":"_2-4-基于代价的索引推荐思路","link":"#_2-4-基于代价的索引推荐思路","children":[]}]},{"level":2,"title":"3 索引推荐实现","slug":"_3-索引推荐实现","link":"#_3-索引推荐实现","children":[{"level":3,"title":"3.1 前置校验","slug":"_3-1-前置校验","link":"#_3-1-前置校验","children":[]},{"level":3,"title":"3.2 提取关键列名","slug":"_3-2-提取关键列名","link":"#_3-2-提取关键列名","children":[]},{"level":3,"title":"3.3 生成候选索引","slug":"_3-3-生成候选索引","link":"#_3-3-生成候选索引","children":[]},{"level":3,"title":"3.4 数据采集","slug":"_3-4-数据采集","link":"#_3-4-数据采集","children":[]},{"level":3,"title":"3.5 统计数据计算","slug":"_3-5-统计数据计算","link":"#_3-5-统计数据计算","children":[]},{"level":3,"title":"3.6 候选索引代价评估","slug":"_3-6-候选索引代价评估","link":"#_3-6-候选索引代价评估","children":[]}]},{"level":2,"title":"4 推荐质量保证","slug":"_4-推荐质量保证","link":"#_4-推荐质量保证","children":[{"level":3,"title":"4.1 有效性验证","slug":"_4-1-有效性验证","link":"#_4-1-有效性验证","children":[]},{"level":3,"title":"4.2 效果追踪","slug":"_4-2-效果追踪","link":"#_4-2-效果追踪","children":[]},{"level":3,"title":"4.3 仿真环境","slug":"_4-3-仿真环境","link":"#_4-3-仿真环境","children":[]},{"level":3,"title":"4.4 测试案例库","slug":"_4-4-测试案例库","link":"#_4-4-测试案例库","children":[]}]},{"level":2,"title":"5 慢查询治理运营","slug":"_5-慢查询治理运营","link":"#_5-慢查询治理运营","children":[{"level":3,"title":"5.1 过去-历史慢查询","slug":"_5-1-过去-历史慢查询","link":"#_5-1-过去-历史慢查询","children":[]},{"level":3,"title":"5.2 现在-新增慢查询","slug":"_5-2-现在-新增慢查询","link":"#_5-2-现在-新增慢查询","children":[]},{"level":3,"title":"5.3 未来-潜在慢查询","slug":"_5-3-未来-潜在慢查询","link":"#_5-3-未来-潜在慢查询","children":[]}]},{"level":2,"title":"6 项目运行情况","slug":"_6-项目运行情况","link":"#_6-项目运行情况","children":[]},{"level":2,"title":"7 未来规划","slug":"_7-未来规划","link":"#_7-未来规划","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]},{"level":2,"title":"本文作者","slug":"本文作者","link":"#本文作者","children":[]},{"level":2,"title":"文章来源","slug":"文章来源","link":"#文章来源","children":[]}],"git":{"createdTime":1690160698000,"updatedTime":1703579659000,"contributors":[{"name":"gavin-james","email":"meaganlindesy1258@gmail.com","commits":2}]},"readingTime":{"minutes":22.01,"words":6602},"filePathRelative":"db/sql-mysql/sql-mysql-sql-costmodel-mt.md","localizedDate":"2022年6月7日","excerpt":"<h1> 大厂实践 - 美团: 基于代价的慢查询优化建议</h1>\\n<blockquote>\\n<p>前文我们介绍了优化慢查询最直接有效的方法就是选用一个查询效率高的索引。关于高效率的索引推荐，主要在日常工作中，基于经验规则的推荐随处可见，对于简单的SQL，如<code>select * from sync_test1 where name like 'Bobby%'</code>，直接添加索引IX(name) 就可以取得不错的效果；但对于稍微复杂点的SQL，如<code>select * from sync_test1 where name like 'Bobby%' and dt &gt; '2021-07-06'</code>，到底选择IX(name)、IX(dt)、IX(dt,name) 还是IX(name,dt)，该方法也无法给出准确的回答。更别说像多表Join、子查询这样复杂的场景了。所以采用基于代价的推荐来解决该问题会更加普适，因为基于代价的方法使用了和数据库优化器相同的方式，去量化评估所有的可能性，选出的是执行SQL耗费代价最小的索引。</p>\\n</blockquote>","copyright":{"author":"gavin-james","license":"https://github.com/gavin-james/gavin-james.github.io/LICENSE"},"autoDesc":true}`);export{e as data};
