export const pagesRoutes = [
  ["v-8daa1a0e","/",{"y":"h","t":"主页","i":"home"},["/index.html","/README.md"]],
  ["v-79fdd481","/home.html",{"y":"h","t":"项目主页","i":"home"},["/home","/home.md"]],
  ["v-0e503981","/slide.html",{"e":"<!-- markdownlint-disable MD024 MD033 -->\n","y":"s","t":"幻灯片页","i":"slides"},["/slide","/slide.md"]],
  ["v-74bc627b","/about/",{"e":"<h1> 数据库</h1>\n","y":"a","t":"数据库"},["/about/index.html","/about/README.md"]],
  ["v-2e25198a","/database/",{"e":"<h1> 数据库</h1>\n","y":"a","t":"数据库"},["/database/index.html","/database/README.md"]],
  ["v-2d0a870d","/en/",{"y":"h","t":"博客主页","i":"home"},["/en/index.html","/en/README.md"]],
  ["v-7c2196ed","/en/home.html",{"y":"h","t":"项目主页","i":"home"},["/en/home","/en/home.md"]],
  ["v-50a4c495","/en/slide.html",{"e":"<!-- markdownlint-disable MD024 MD033 -->\n","y":"s","t":"幻灯片页","i":"slides"},["/en/slide","/en/slide.md"]],
  ["v-7e25fb5f","/front/",{"y":"a","t":""},["/front/index.html","/front/README.md"]],
  ["v-7d72c4ac","/framework/",{"y":"a","t":""},["/framework/index.html","/framework/README.md"]],
  ["v-2250a72e","/me/study.html",{"e":"<h2> 自我提升九大招</h2>\n<ol>\n<li>\n<p>早睡半小时，早起10分钟</p>\n<p>许多人晚睡的原因，其实都是在刷手机。从今天开始，不把手机带上床，早睡半小时，第二天就会精神饱满。把第二天的闹钟往前调10分钟，早起10分钟做些你想做的事，读书、锻炼、做早餐，都会给你带来意想不到的提升。</p>\n</li>\n<li>\n<p>坚持运动</p>\n<p>运动是治愈一切的良药。那些长期坚持运动的人，都在不同程度地变好看、变自律、变优秀、变健康。开始运动吧，从多散步十分钟或者每天做10个俯卧撑开始，循序渐进，踏踏实实地完成运动任务，你一定会越来越好。</p>\n</li>\n<li>\n<p>欣赏别人的优点，警醒自己的缺点</p>\n<p>老话说，取他人之长，补己之短。学会用欣赏的眼光看他人，汲取他人身上的闪光点。当你看到别人的缺点时，也要警醒自己身上是否有和他相似的缺点。要记得，我们所做的所有事都是为了提升自我，而不是贬低他人。</p>\n</li>\n<li>\n<p>坚持读书</p>\n<p>阅读是自我提升最便捷的方式。如果你经常迷茫、时常焦虑，尝试静下心来读书吧，由内而外，让书籍的知识慢慢渗透，久而久之，看问题的角度变广了，做事情的方法更灵活了，你会爱上自己的改变。</p>\n</li>\n<li>\n<p>在失败中总结经验</p>\n<p>人生就是起起伏伏，想要成功，必会经历失败。不要因为一次、两次失败就郁郁寡欢，相比成功而言，失败反而能给我们更多启发和教训。在失败中总结经验，不断调整自己的思维和行为，前方的路才会越走越顺。</p>\n</li>\n<li>\n<p>注意仪容仪表，干净清爽最重要</p>\n<p>每个人都是先从外表认识他人的，你的内在再丰富，邋遢的外表也会让人望而却步。可以不精致，但不能不干净。每天都要认真清洁自己，穿合适的衣服，干净清爽的形象会为你加分许多。</p>\n</li>\n<li>\n<p>练习专注力</p>\n<p>练习在一段时间内专注于一件事，会让你做事更有效率。开始时，不妨先试着定下10-15分钟的闹钟，在这段时间里专注于一件事，慢慢提升专注力。</p>\n</li>\n<li>\n<p>遇到困难，想办法解决而不是抱怨</p>\n<p>遇到困难时，不要只想着抱怨。越是艰难，越是要勇于攀爬，因为每一步不好走的路，都是上坡路。当你开始着手想办法的时候，就会发现，很多事没你想象的那么难。再难的事，也总有解决办法。最难的，是你不敢踏出第一步的心。</p>\n</li>\n<li>\n<p>每晚复盘、反思</p>\n<p>睡前15分钟，回忆一下当天发生的事、见过的人，反思自己的行为是否妥当，是否有浪费时间，是否相对昨天有所进步。不断地复盘自己，像医生一样，先检查出自己身上的缺点、弱点，再一个个拔除治疗。复盘会成为你自我提升路上最好的帮手。</p>\n</li>\n</ol>","y":"a","t":""},["/me/study","/me/study.md"]],
  ["v-fffb8e28","/guide/",{"c":["使用指南"],"e":"<h2> 目录</h2>\n<ul>\n<li>\n<p><a href=\"/guide/markdown.html\" target=\"blank\">Markdown 展示</a></p>\n</li>\n<li>\n<p><a href=\"/guide/page.html\" target=\"blank\">页面展示</a></p>\n</li>\n<li>\n<p><a href=\"/guide/disable.html\" target=\"blank\">禁用展示</a></p>\n</li>\n<li>\n<p><a href=\"/guide/encrypt.html\" target=\"blank\">加密展示</a></p>\n</li>\n</ul>","y":"a","t":"主要功能与配置演示","i":"creative"},["/guide/index.html","/guide/README.md"]],
  ["v-4c863446","/guide/disable.html",{"c":["使用指南"],"g":["禁用"],"e":"<p>你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。</p>\n","y":"a","t":"布局与功能禁用","i":"config","O":3},["/guide/disable","/guide/disable.md"]],
  ["v-bf720700","/guide/encrypt.html",{"c":["使用指南"],"g":["文章加密"],"n":true,"y":"a","t":"密码加密的文章","i":"lock"},["/guide/encrypt","/guide/encrypt.md"]],
  ["v-0978b044","/guide/markdown.html",{"c":["使用指南"],"g":["Markdown"],"e":"<p>VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。</p>\n<p>你应该创建和编写 Markdown 文件，以便 VuePress 可以根据文件结构将它们转换为不同的页面。</p>\n","y":"a","t":"Markdown 展示","i":"markdown","O":2},["/guide/markdown","/guide/markdown.md"]],
  ["v-4eaf9f84","/guide/page.html",{"a":"Ms.Hope","d":1577836800000,"l":"2020年1月1日","c":["使用指南"],"g":["页面配置","使用指南"],"u":true,"e":"<p><code>more</code> 注释之前的内容被视为文章摘要。</p>\n","y":"a","t":"页面配置","i":"page","O":1},["/guide/page","/guide/page.md"]],
  ["v-ef7dd9f0","/resource/",{"d":1549152000000,"l":"2019年2月3日","c":["资源导航"],"g":["资源导航"],"e":"<h1> 资源导航</h1>\n<h2> 常用搜索</h2>\n","y":"a","t":"资源导航"},["/resource/index.html","/resource/README.md"]],
  ["v-14f73021","/more/",{"y":"a","t":""},["/more/index.html","/more/README.md"]],
  ["v-1559ca3e","/tool/",{"y":"h","t":"主页","i":"home"},["/tool/index.html","/tool/README.md"]],
  ["v-acebc5a4","/tool/mermaid.html",{"e":"<h1> 流程图</h1>\n<h3> 默认节点</h3>\n<blockquote>\n<p>注意 id 是框中显示的内容。</p>\n</blockquote>\n<h3> 文本框节点</h3>\n<p>也可以在不同于 id 的框中设置文本。 如果多次这样做，它将是为将使用的节点找到的最后一个文本。 此外，如果您稍后为节点定义边，则可以省略文本定义。 渲染框时将使用先前定义的那个。</p>\n<h2> 图形</h2>\n<p>This statement declares the direction of the Flowchart.</p>\n<p>This declares the flowchart is oriented from top to bottom (<code>TD</code> or <code>TB</code>).</p>","y":"a","t":"流程图"},["/tool/mermaid","/tool/mermaid.md"]],
  ["v-30c465ed","/tool/zuosi.html",{"e":"<p>今天给大家分享一波 Java 中的代码作死小技巧，熟练掌握这些小技巧后，保证能让你写出同事看不懂的代码~</p>\n<p>至于为啥要写出同事看不懂的代码，我发现好处还是挺多的，简单举几个例子：</p>\n<ul>\n<li>同事无法轻易修改你的代码，避免团队协作不当引入 bug</li>\n<li>塑造个人能力的不可替代性，规避被辞退的风险</li>\n<li>代码 review 时，帮助同事治疗好多年的低血压</li>\n</ul>\n<figure><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/zpom4BeZSicZeTVUxgBubfoibv2iaNJ9WVGWUfL1YLpd2wjiaZc31YwzaG1WYJvYEfmZBjPuQvZAXrCMYIfqoKYOfQ/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\" tabindex=\"0\" loading=\"lazy\"><figcaption>图片</figcaption></figure>","y":"a","t":""},["/tool/zuosi","/tool/zuosi.md"]],
  ["v-38bdd5fc","/java/basic/java-advanced-spi.html",{"d":1644451200000,"l":"2022年2月10日","c":["Java 基础"],"g":["Java 基础"],"e":"<h1> SPI机制详解</h1>\n<blockquote>\n<p>SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用。@pdai</p>\n</blockquote>\n<p>SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 <strong>解耦</strong>。</p>","y":"a","t":"SPI机制详解"},["/java/basic/java-advanced-spi","/java/basic/java-advanced-spi.md"]],
  ["v-3c09b854","/java/basic/java-basic-lan-basic.html",{"d":1643932800000,"l":"2022年2月4日","c":["Java 基础"],"g":["Java 基础"],"e":"<h1> 知识点</h1>\n<blockquote>\n<p>本文主要对Java基础知识点进行总结。 @pdai</p>\n</blockquote>\n<h2> 数据类型</h2>\n<h3> 包装类型</h3>\n<p>八个基本类型:</p>\n<ul>\n<li>boolean/1</li>\n<li>byte/8</li>\n<li>char/16</li>\n<li>short/16</li>\n<li>int/32</li>\n<li>float/32</li>\n<li>long/64</li>\n<li>double/64</li>\n</ul>\n<p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>","y":"a","t":"知识点"},["/java/basic/java-basic-lan-basic","/java/basic/java-basic-lan-basic.md"]],
  ["v-d23382d2","/java/basic/java-basic-lan-sum.html",{"d":1644019200000,"l":"2022年2月5日","c":["Java 基础"],"g":["Java 基础"],"e":"<h1> 图谱 &amp; Q/A</h1>\n<blockquote>\n<p>本文主要对Java基础知识体系小结，同时结合一些Q&amp;A进行理解。 @pdai</p>\n</blockquote>\n<h2> 参考文档</h2>\n<ul>\n<li>Thinking in Java (Java 编程思想) Gitbook中文文档 <a href=\"https://java.quanke.name/\" target=\"_blank\" rel=\"noopener noreferrer\">https://java.quanke.name/</a></li>\n<li>Thinking in Java (Java 编程思想) Github <a href=\"https://github.com/quanke/think-in-java\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/quanke/think-in-java</a></li>\n<li>Thinking in Java (Java 编程思想) Gitbook2 <a href=\"https://www.gitbook.com/book/wizardforcel/thinking-in-java/details\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.gitbook.com/book/wizardforcel/thinking-in-java/details</a></li>\n</ul>","y":"a","t":"图谱 & Q/A"},["/java/basic/java-basic-lan-sum","/java/basic/java-basic-lan-sum.md"]],
  ["v-29e9d384","/java/basic/java-basic-oop.html",{"d":1643846400000,"l":"2022年2月3日","c":["Java 基础"],"g":["Java 基础"],"e":"<h1> 面向对象</h1>\n<blockquote>\n<p>本文主要介绍Java OOP 面向对象基础和相关类图。@pdai</p>\n</blockquote>\n<h2> 三大特性</h2>\n<h3> 封装</h3>\n<p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p>\n<p>优点:</p>\n<ul>\n<li>减少耦合: 可以独立地开发、测试、优化、使用、理解和修改</li>\n<li>减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li>\n<li>有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能</li>\n<li>提高软件的可重用性</li>\n<li>降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的</li>\n</ul>","y":"a","t":"面向对象"},["/java/basic/java-basic-oop","/java/basic/java-basic-oop.md"]],
  ["v-291e8560","/java/basic/java-basic-x-annotation.html",{"d":1644192000000,"l":"2022年2月7日","c":["Java 基础"],"g":["Java 基础"],"e":"<h1> 注解机制详解</h1>\n<blockquote>\n<p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它是框架学习和设计者必须掌握的基础。@pdai</p>\n</blockquote>\n<h2> 注解基础</h2>\n<p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面：</p>\n<ul>\n<li>生成文档，通过代码里标识的元数据生成javadoc文档。</li>\n<li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li>\n<li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li>\n<li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li>\n</ul>","y":"a","t":"注解机制详解"},["/java/basic/java-basic-x-annotation","/java/basic/java-basic-x-annotation.md"]],
  ["v-63ce1cd4","/java/basic/java-basic-x-exception.html",{"d":1644278400000,"l":"2022年2月8日","c":["Java 基础"],"g":["Java 基础"],"e":"<h1> 异常机制详解</h1>\n<blockquote>\n<p>Java异常是Java提供的一种识别及响应错误的一致性机制，java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。本文综合多篇文章后，总结了Java 异常的相关知识，希望可以提升你对Java中异常的认知效率。@pdai</p>\n</blockquote>\n<h2> 异常的层次结构</h2>\n<p>异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。</p>","y":"a","t":"异常机制详解"},["/java/basic/java-basic-x-exception","/java/basic/java-basic-x-exception.md"]],
  ["v-189f4acc","/java/basic/java-basic-x-generic.html",{"d":1644105600000,"l":"2022年2月6日","c":["Java 基础"],"g":["Java 基础"],"e":"<h1> 泛型机制详解</h1>\n<blockquote>\n<p>Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“<strong>伪泛型</strong>”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“<strong>类型擦除</strong>”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。本文综合多篇文章后，总结了Java 泛型的相关知识，希望可以提升你对Java中泛型的认知效率。@pdai</p>\n</blockquote>\n<h2> 为什么会引入泛型</h2>","y":"a","t":"泛型机制详解"},["/java/basic/java-basic-x-generic","/java/basic/java-basic-x-generic.md"]],
  ["v-58387c38","/java/basic/java-basic-x-reflection.html",{"d":1644364800000,"l":"2022年2月9日","c":["Java 基础"],"g":["Java 基础"],"e":"<h1> 反射机制详解</h1>\n<blockquote>\n<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。Java反射机制在框架设计中极为广泛，需要深入理解。本文综合多篇文章后，总结了Java 反射的相关知识，希望可以提升你对Java中反射的认知效率。@pdai</p>\n</blockquote>\n<h2> 反射基础</h2>\n<p>RTTI（Run-Time Type Identification）运行时类型识别。在《Thinking in Java》一书第十四章中有提到，其作用是在运行时识别一个对象的类型和类的信息。主要有两种方式：一种是“传统的”RTTI，它假定我们在编译时已经知道了所有的类型；另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。</p>","y":"a","t":"反射机制详解"},["/java/basic/java-basic-x-reflection","/java/basic/java-basic-x-reflection.md"]],
  ["v-44ff8903","/java/collection/java-collection-ArrayList.html",{"e":"<h1> Collection - ArrayList 源码解析</h1>\n","y":"a","t":"Collection - ArrayList 源码解析"},["/java/collection/java-collection-ArrayList","/java/collection/java-collection-ArrayList.md"]],
  ["v-f973debe","/java/collection/java-collection-LinkedList.html",{"e":"<h1> Collection - LinkedList源码解析</h1>\n","y":"a","t":"Collection - LinkedList源码解析"},["/java/collection/java-collection-LinkedList","/java/collection/java-collection-LinkedList.md"]],
  ["v-07c1af0d","/java/collection/java-collection-PriorityQueue.html",{"e":"<h1> Collection - PriorityQueue源码解析</h1>\n","y":"a","t":"Collection - PriorityQueue源码解析"},["/java/collection/java-collection-PriorityQueue","/java/collection/java-collection-PriorityQueue.md"]],
  ["v-c7a49100","/java/collection/java-collection-Queue_Stack.html",{"e":"<h1> Collection - Stack &amp; Queue 源码解析</h1>\n","y":"a","t":"Collection - Stack & Queue 源码解析"},["/java/collection/java-collection-Queue_Stack","/java/collection/java-collection-Queue&Stack.html","/java/collection/java-collection-Queue&Stack.md"]],
  ["v-f1a93e4e","/java/collection/java-collection-all.html",{"e":"<h1> Collection 类关系图</h1>\n","y":"a","t":"Collection 类关系图"},["/java/collection/java-collection-all","/java/collection/java-collection-all.md"]],
  ["v-77c7f0b5","/java/collection/java-map-HashMap_HashSet.html",{"e":"<h1> Map - HashSet &amp; HashMap 源码解析</h1>\n","y":"a","t":"Map - HashSet & HashMap 源码解析"},["/java/collection/java-map-HashMap_HashSet","/java/collection/java-map-HashMap&HashSet.html","/java/collection/java-map-HashMap&HashSet.md"]],
  ["v-d718a9b2","/java/collection/java-map-LinkedHashMap_LinkedHashSet.html",{"e":"<h1> Map - LinkedHashSet&amp;Map源码解析</h1>\n","y":"a","t":"Map - LinkedHashSet&Map源码解析"},["/java/collection/java-map-LinkedHashMap_LinkedHashSet","/java/collection/java-map-LinkedHashMap&LinkedHashSet.html","/java/collection/java-map-LinkedHashMap&LinkedHashSet.md"]],
  ["v-7068a5d5","/java/collection/java-map-TreeMap_TreeSet.html",{"e":"<h1> Map - TreeSet &amp; TreeMap 源码解析</h1>\n","y":"a","t":"Map - TreeSet & TreeMap 源码解析"},["/java/collection/java-map-TreeMap_TreeSet","/java/collection/java-map-TreeMap&TreeSet.html","/java/collection/java-map-TreeMap&TreeSet.md"]],
  ["v-e6e1587c","/java/collection/java-map-WeakHashMap.html",{"e":"<h1> Map - WeakHashMap源码解析</h1>\n","y":"a","t":"Map - WeakHashMap源码解析"},["/java/collection/java-map-WeakHashMap","/java/collection/java-map-WeakHashMap.md"]],
  ["v-3593583a","/java/io/java-io-aio.html",{"e":"<h1> Java AIO - 异步IO详解</h1>\n","y":"a","t":"Java AIO - 异步IO详解"},["/java/io/java-io-aio","/java/io/java-io-aio.md"]],
  ["v-0f81c6ab","/java/io/java-io-basic-category.html",{"e":"<h1> Java IO - 分类(传输，操作)</h1>\n","y":"a","t":"Java IO - 分类(传输，操作)"},["/java/io/java-io-basic-category","/java/io/java-io-basic-category.md"]],
  ["v-91590982","/java/io/java-io-basic-code-inputstream.html",{"e":"<h1> Java IO - 源码: InputStream</h1>\n","y":"a","t":"Java IO - 源码: InputStream"},["/java/io/java-io-basic-code-inputstream","/java/io/java-io-basic-code-inputstream.md"]],
  ["v-c2e41070","/java/io/java-io-basic-code-outputstream.html",{"e":"<h1> Java IO - 源码: OutputStream</h1>\n","y":"a","t":"Java IO - 源码: OutputStream"},["/java/io/java-io-basic-code-outputstream","/java/io/java-io-basic-code-outputstream.md"]],
  ["v-dd6781f0","/java/io/java-io-basic-design-pattern.html",{"e":"<h1> Java IO - 设计模式(装饰者模式)</h1>\n","y":"a","t":"Java IO - 设计模式(装饰者模式)"},["/java/io/java-io-basic-design-pattern","/java/io/java-io-basic-design-pattern.md"]],
  ["v-1c8d45c8","/java/io/java-io-basic-usage.html",{"e":"<h1> Java IO - 常见类使用</h1>\n","y":"a","t":"Java IO - 常见类使用"},["/java/io/java-io-basic-usage","/java/io/java-io-basic-usage.md"]],
  ["v-4d1780c2","/java/io/java-io-bio.html",{"e":"<h1> Java IO - BIO 详解</h1>\n","y":"a","t":"Java IO - BIO 详解"},["/java/io/java-io-bio","/java/io/java-io-bio.md"]],
  ["v-47bd7701","/java/io/java-io-model.html",{"e":"<h1> IO 模型 - Unix IO 模型</h1>\n","y":"a","t":"IO 模型 - Unix IO 模型"},["/java/io/java-io-model","/java/io/java-io-model.md"]],
  ["v-6eb505c1","/java/io/java-io-nio-netty.html",{"e":"<h1> Java N(A)IO - 框架: Netty</h1>\n","y":"a","t":"Java N(A)IO - 框架: Netty"},["/java/io/java-io-nio-netty","/java/io/java-io-nio-netty.md"]],
  ["v-74aca148","/java/io/java-io-nio-select-epoll.html",{"e":"<h1> Java NIO - IO多路复用详解</h1>\n","y":"a","t":"Java NIO - IO多路复用详解"},["/java/io/java-io-nio-select-epoll","/java/io/java-io-nio-select-epoll.md"]],
  ["v-ad7d3fdc","/java/io/java-io-nio-zerocopy.html",{"e":"<h1> Java NIO - 零拷贝实现</h1>\n","y":"a","t":"Java NIO - 零拷贝实现"},["/java/io/java-io-nio-zerocopy","/java/io/java-io-nio-zerocopy.md"]],
  ["v-2ba59b36","/java/io/java-io-nio.html",{"e":"<h1> Java NIO - 基础详解</h1>\n","y":"a","t":"Java NIO - 基础详解"},["/java/io/java-io-nio","/java/io/java-io-nio.md"]],
  ["v-b17b64a2","/java/io/java-io-overview.html",{"e":"<h1> ♥Java IO知识体系详解♥</h1>\n","y":"a","t":"♥Java IO知识体系详解♥"},["/java/io/java-io-overview","/java/io/java-io-overview.md"]],
  ["v-56bca9f0","/java/javaup/java-8-up-overview.html",{"e":"<h1> ♥Java8+特性知识体系详解♥</h1>\n","y":"a","t":"♥Java8+特性知识体系详解♥"},["/java/javaup/java-8-up-overview","/java/javaup/java-8-up-overview.md"]],
  ["v-e9fdae4c","/java/javaup/java10.html",{"e":"<h1> Java 10 新特性概述</h1>\n","y":"a","t":"Java 10 新特性概述"},["/java/javaup/java10","/java/javaup/java10.md"]],
  ["v-e693fd0e","/java/javaup/java11.html",{"e":"<h1> Java 11 新特性概述</h1>\n","y":"a","t":"Java 11 新特性概述"},["/java/javaup/java11","/java/javaup/java11.md"]],
  ["v-13927007","/java/javaup/java12-17.html",{"e":"<h1> Java 11 升Java 17 重要特性必读</h1>\n","y":"a","t":"Java 11 升Java 17 重要特性必读"},["/java/javaup/java12-17","/java/javaup/java12-17.md"]],
  ["v-e32a4bd0","/java/javaup/java12.html",{"e":"<h1> Java 12 新特性概述</h1>\n","y":"a","t":"Java 12 新特性概述"},["/java/javaup/java12","/java/javaup/java12.md"]],
  ["v-dfc09a92","/java/javaup/java13.html",{"e":"<h1> Java 13 新特性概述</h1>\n","y":"a","t":"Java 13 新特性概述"},["/java/javaup/java13","/java/javaup/java13.md"]],
  ["v-dc56e954","/java/javaup/java14.html",{"e":"<h1> Java 14 新特性概述</h1>\n","y":"a","t":"Java 14 新特性概述"},["/java/javaup/java14","/java/javaup/java14.md"]],
  ["v-d8ed3816","/java/javaup/java15.html",{"e":"<h1> Java 15 新特性概述</h1>\n","y":"a","t":"Java 15 新特性概述"},["/java/javaup/java15","/java/javaup/java15.md"]],
  ["v-d58386d8","/java/javaup/java16.html",{"e":"<h1> Java 16 新特性概述</h1>\n","y":"a","t":"Java 16 新特性概述"},["/java/javaup/java16","/java/javaup/java16.md"]],
  ["v-d219d59a","/java/javaup/java17.html",{"e":"<h1> Java 17 新特性概述</h1>\n","y":"a","t":"Java 17 新特性概述"},["/java/javaup/java17","/java/javaup/java17.md"]],
  ["v-0c4bedb4","/java/javaup/java8-anno-repeat.html",{"e":"<h1> Java 8 - 重复注解</h1>\n","y":"a","t":"Java 8 - 重复注解"},["/java/javaup/java8-anno-repeat","/java/javaup/java8-anno-repeat.md"]],
  ["v-cb1c4026","/java/javaup/java8-default.html",{"e":"<h1> Java 8 - 默认方法</h1>\n","y":"a","t":"Java 8 - 默认方法"},["/java/javaup/java8-default","/java/javaup/java8-default.md"]],
  ["v-0dbdd390","/java/javaup/java8-javafx.html",{"e":"<h1> Java 8 - JavaFx 2.0</h1>\n","y":"a","t":"Java 8 - JavaFx 2.0"},["/java/javaup/java8-javafx","/java/javaup/java8-javafx.md"]],
  ["v-59da0611","/java/javaup/java8-jre.html",{"e":"<h1> Java 8 - JRE精简</h1>\n","y":"a","t":"Java 8 - JRE精简"},["/java/javaup/java8-jre","/java/javaup/java8-jre.md"]],
  ["v-d4064cb0","/java/javaup/java8-localdatetime.html",{"e":"<h1> Java 8 - LocalDate/LocalDateTime</h1>\n","y":"a","t":"Java 8 - LocalDate/LocalDateTime"},["/java/javaup/java8-localdatetime","/java/javaup/java8-localdatetime.md"]],
  ["v-42fc1938","/java/javaup/java8-optional.html",{"e":"<h1> Java 8 - Optional类深度解析</h1>\n","y":"a","t":"Java 8 - Optional类深度解析"},["/java/javaup/java8-optional","/java/javaup/java8-optional.md"]],
  ["v-0db1e401","/java/javaup/java8-others.html",{"e":"<h1> Java 8 - 其它更新: 字符串，base64,...</h1>\n","y":"a","t":"Java 8 - 其它更新: 字符串，base64,..."},["/java/javaup/java8-others","/java/javaup/java8-others.md"]],
  ["v-3292fb2e","/java/javaup/java8-permgen.html",{"e":"<h1> Java 8 - 移除Permgen</h1>\n","y":"a","t":"Java 8 - 移除Permgen"},["/java/javaup/java8-permgen","/java/javaup/java8-permgen.md"]],
  ["v-462b5b61","/java/javaup/java8-stampedlock.html",{"e":"<h1> Java 8 - StampedLock</h1>\n","y":"a","t":"Java 8 - StampedLock"},["/java/javaup/java8-stampedlock","/java/javaup/java8-stampedlock.md"]],
  ["v-c32bfbf8","/java/javaup/java8-stream.html",{"e":"<h1> Java 8 - 函数编程(lambda表达式)</h1>\n","y":"a","t":"Java 8 - 函数编程(lambda表达式)"},["/java/javaup/java8-stream","/java/javaup/java8-stream.md"]],
  ["v-364af0e6","/java/javaup/java8-type-anno.html",{"e":"<h1> Java 8 - 类型注解</h1>\n","y":"a","t":"Java 8 - 类型注解"},["/java/javaup/java8-type-anno","/java/javaup/java8-type-anno.md"]],
  ["v-23c3b54a","/java/javaup/java8-type.html",{"e":"<h1> Java 8 - 类型推断优化</h1>\n","y":"a","t":"Java 8 - 类型推断优化"},["/java/javaup/java8-type","/java/javaup/java8-type.md"]],
  ["v-b5dd4e3e","/java/javaup/java8.html",{"e":"<h1> ♥Java8特性知识体系详解♥</h1>\n","y":"a","t":"♥Java8特性知识体系详解♥"},["/java/javaup/java8","/java/javaup/java8.md"]],
  ["v-76d5ebe5","/java/javaup/java9-11.html",{"e":"<h1> Java 8 升Java 11 重要特性必读</h1>\n","y":"a","t":"Java 8 升Java 11 重要特性必读"},["/java/javaup/java9-11","/java/javaup/java9-11.md"]],
  ["v-b2739d00","/java/javaup/java9.html",{"e":"<h1> Java 9 新特性概述</h1>\n","y":"a","t":"Java 9 新特性概述"},["/java/javaup/java9","/java/javaup/java9.md"]],
  ["v-5253f255","/java/others/awesome-java.html",{"e":"<h1> Java资源大全中文版</h1>\n<p>Awesome 系列虽然挺全，但基本只对收录的资源做了极为简要的介绍，如果有更详细的中文介绍，对相应开发者的帮助会更大。这也是我们发起这个开源项目的初衷。</p>\n<h2> 古董级工具</h2>\n<p><em>这些工具伴随着Java一起出现，在各自辉煌之后还在一直使用。</em></p>\n<ul>\n<li><a href=\"http://www.importnew.com/apache-ant/\" target=\"_blank\" rel=\"noopener noreferrer\">Apache Ant</a>：基于XML的构建管理工具。<a href=\"http://ant.apache.org/\" target=\"_blank\" rel=\"noopener noreferrer\">官网</a></li>\n<li><a href=\"http://www.importnew.com/cglib/\" target=\"_blank\" rel=\"noopener noreferrer\">cglib</a>：字节码生成库。<a href=\"https://github.com/cglib/cglib\" target=\"_blank\" rel=\"noopener noreferrer\">官网</a></li>\n<li><a href=\"http://www.importnew.com/glassfish/\" target=\"_blank\" rel=\"noopener noreferrer\">GlassFish</a>：应用服务器，由Oracle赞助支持的Java EE参考实现。<a href=\"https://glassfish.java.net/\" target=\"_blank\" rel=\"noopener noreferrer\">官网</a></li>\n<li><a href=\"http://www.importnew.com/hudson/\" target=\"_blank\" rel=\"noopener noreferrer\">Hudson</a>：持续集成服务器，目前仍在活跃开发。<a href=\"http://hudson-ci.org/\" target=\"_blank\" rel=\"noopener noreferrer\">官网</a></li>\n<li><a href=\"http://www.importnew.com/javaserver-faces/\" target=\"_blank\" rel=\"noopener noreferrer\">JavaServer Faces</a>：Mojarra是JSF标准的一个开源实现，由Oracle开发。<a href=\"https://javaserverfaces.java.net/\" target=\"_blank\" rel=\"noopener noreferrer\">官网</a></li>\n<li><a href=\"http://www.importnew.com/javaserver-pages/\" target=\"_blank\" rel=\"noopener noreferrer\">JavaServer Pages</a>：支持自定义标签库的网站通用模板库。<a href=\"https://jsp.java.net/\" target=\"_blank\" rel=\"noopener noreferrer\">官网</a></li>\n<li><a href=\"http://www.importnew.com/liquibase/\" target=\"_blank\" rel=\"noopener noreferrer\">Liquibase</a>：与具体数据库独立的追踪、管理和应用数据库Scheme变化的工具。<a href=\"http://www.liquibase.org/\" target=\"_blank\" rel=\"noopener noreferrer\">官网</a></li>\n</ul>","y":"a","t":"Java资源大全中文版"},["/java/others/awesome-java","/java/others/awesome-java.md"]],
  ["v-a489f7dc","/java/others/better-java.html",{"e":"<h1> Better Java</h1>\n<p>Java 虽作为最流行的编程语言之一，但是似乎并没有什么人很享受用它。好吧，Java 确实是这样的一门编程语言，从最近发布不久的 Java 8 开始，为了更好的使用 Java，我决定收集一些库，实践和工具等相关资料。“更好” 是主观的，所以推荐使用我所说的建议的某些部分，而不是一下子全部按照这些建议来做。请尽情添加其他意见并提交 PR。</p>\n<h2> Style</h2>\n<p>Java 传统的代码风格是被用来编写非常复杂的企业级 JavaBean。新的代码风格看起来会更加整洁，更加正确，并且更加简单。</p>\n<h3> Structs</h3>","y":"a","t":"Better Java"},["/java/others/better-java","/java/others/better-java.md"]],
  ["v-7ec73772","/tool/docker/01.html",{"e":"<p>docker</p>\n","y":"a","t":""},["/tool/docker/01","/tool/docker/01.md"]],
  ["v-2720156a","/java/spring/01.html",{"y":"a","t":""},["/java/spring/01","/java/spring/01.md"]],
  ["v-4014464e","/java/thread/java-thread-x-juc-AtomicInteger.html",{"e":"<h1> JUC原子类: CAS, Unsafe和原子类详解</h1>\n","y":"a","t":"JUC原子类: CAS, Unsafe和原子类详解"},["/java/thread/java-thread-x-juc-AtomicInteger","/java/thread/java-thread-x-juc-AtomicInteger.md"]],
  ["v-55712db9","/java/thread/java-thread-x-juc-collection-BlockingQueue.html",{"e":"<h1> JUC集合: BlockingQueue详解</h1>\n","y":"a","t":"JUC集合: BlockingQueue详解"},["/java/thread/java-thread-x-juc-collection-BlockingQueue","/java/thread/java-thread-x-juc-collection-BlockingQueue.md"]],
  ["v-0e60e6be","/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.html",{"e":"<h1> JUC集合: ConcurrentHashMap详解</h1>\n","y":"a","t":"JUC集合: ConcurrentHashMap详解"},["/java/thread/java-thread-x-juc-collection-ConcurrentHashMap","/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.md"]],
  ["v-37193a74","/java/thread/java-thread-x-juc-collection-ConcurrentLinkedQueue.html",{"e":"<h1> JUC集合: ConcurrentLinkedQueue详解</h1>\n","y":"a","t":"JUC集合: ConcurrentLinkedQueue详解"},["/java/thread/java-thread-x-juc-collection-ConcurrentLinkedQueue","/java/thread/java-thread-x-juc-collection-ConcurrentLinkedQueue.md"]],
  ["v-616b765e","/java/thread/java-thread-x-juc-collection-CopyOnWriteArrayList.html",{"e":"<h1> JUC集合: CopyOnWriteArrayList详解</h1>\n","y":"a","t":"JUC集合: CopyOnWriteArrayList详解"},["/java/thread/java-thread-x-juc-collection-CopyOnWriteArrayList","/java/thread/java-thread-x-juc-collection-CopyOnWriteArrayList.md"]],
  ["v-6a09898a","/java/thread/java-thread-x-juc-executor-ForkJoinPool.html",{"e":"<h1> JUC线程池: Fork/Join框架详解</h1>\n","y":"a","t":"JUC线程池: Fork/Join框架详解"},["/java/thread/java-thread-x-juc-executor-ForkJoinPool","/java/thread/java-thread-x-juc-executor-ForkJoinPool.md"]],
  ["v-4289cd2a","/java/thread/java-thread-x-juc-executor-FutureTask.html",{"e":"<h1> JUC线程池: FutureTask详解</h1>\n","y":"a","t":"JUC线程池: FutureTask详解"},["/java/thread/java-thread-x-juc-executor-FutureTask","/java/thread/java-thread-x-juc-executor-FutureTask.md"]],
  ["v-b49ab68c","/java/thread/java-thread-x-juc-executor-ScheduledThreadPoolExecutor.html",{"e":"<h1> JUC线程池: ScheduledThreadPoolExecutor详解</h1>\n","y":"a","t":"JUC线程池: ScheduledThreadPoolExecutor详解"},["/java/thread/java-thread-x-juc-executor-ScheduledThreadPoolExecutor","/java/thread/java-thread-x-juc-executor-ScheduledThreadPoolExecutor.md"]],
  ["v-3344b079","/java/thread/java-thread-x-juc-executor-ThreadPoolExecutor.html",{"e":"<h1> JUC线程池: ThreadPoolExecutor详解</h1>\n","y":"a","t":"JUC线程池: ThreadPoolExecutor详解"},["/java/thread/java-thread-x-juc-executor-ThreadPoolExecutor","/java/thread/java-thread-x-juc-executor-ThreadPoolExecutor.md"]],
  ["v-29327e8d","/java/thread/java-thread-x-juc-overview.html",{"e":"<h1> JUC - 类汇总和学习指南</h1>\n","y":"a","t":"JUC - 类汇总和学习指南"},["/java/thread/java-thread-x-juc-overview","/java/thread/java-thread-x-juc-overview.md"]],
  ["v-5852c0a4","/java/thread/java-thread-x-juc-tool-countdownlatch.html",{"e":"<h1> JUC工具类: CountDownLatch详解</h1>\n","y":"a","t":"JUC工具类: CountDownLatch详解"},["/java/thread/java-thread-x-juc-tool-countdownlatch","/java/thread/java-thread-x-juc-tool-countdownlatch.md"]],
  ["v-6d0d4f46","/java/thread/java-thread-x-juc-tool-cyclicbarrier.html",{"e":"<h1> JUC工具类: CyclicBarrier详解</h1>\n","y":"a","t":"JUC工具类: CyclicBarrier详解"},["/java/thread/java-thread-x-juc-tool-cyclicbarrier","/java/thread/java-thread-x-juc-tool-cyclicbarrier.md"]],
  ["v-5bebca2c","/java/thread/java-thread-x-juc-tool-exchanger.html",{"e":"<h1> JUC工具类: Exchanger详解</h1>\n","y":"a","t":"JUC工具类: Exchanger详解"},["/java/thread/java-thread-x-juc-tool-exchanger","/java/thread/java-thread-x-juc-tool-exchanger.md"]],
  ["v-99933d00","/java/thread/java-thread-x-juc-tool-phaser.html",{"e":"<h1> JUC工具类: Phaser详解</h1>\n","y":"a","t":"JUC工具类: Phaser详解"},["/java/thread/java-thread-x-juc-tool-phaser","/java/thread/java-thread-x-juc-tool-phaser.md"]],
  ["v-277d5092","/java/thread/java-thread-x-juc-tool-semaphore.html",{"e":"<h1> JUC工具类: Semaphore详解</h1>\n","y":"a","t":"JUC工具类: Semaphore详解"},["/java/thread/java-thread-x-juc-tool-semaphore","/java/thread/java-thread-x-juc-tool-semaphore.md"]],
  ["v-0d37dc6f","/java/thread/java-thread-x-key-final.html",{"e":"<h1> 关键字: final详解</h1>\n","y":"a","t":"关键字: final详解"},["/java/thread/java-thread-x-key-final","/java/thread/java-thread-x-key-final.md"]],
  ["v-0cb2d779","/java/thread/java-thread-x-key-synchronized.html",{"e":"<h1> 关键字: synchronized详解</h1>\n","y":"a","t":"关键字: synchronized详解"},["/java/thread/java-thread-x-key-synchronized","/java/thread/java-thread-x-key-synchronized.md"]],
  ["v-6dbf2df1","/java/thread/java-thread-x-key-volatile.html",{"e":"<h1> 关键字: volatile详解</h1>\n","y":"a","t":"关键字: volatile详解"},["/java/thread/java-thread-x-key-volatile","/java/thread/java-thread-x-key-volatile.md"]],
  ["v-7a75b5c4","/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html",{"e":"<h1> JUC锁: 锁核心类AQS详解</h1>\n","y":"a","t":"JUC锁: 锁核心类AQS详解"},["/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer","/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.md"]],
  ["v-5e3906d9","/java/thread/java-thread-x-lock-LockSupport.html",{"e":"<h1> JUC锁: LockSupport详解</h1>\n","y":"a","t":"JUC锁: LockSupport详解"},["/java/thread/java-thread-x-lock-LockSupport","/java/thread/java-thread-x-lock-LockSupport.md"]],
  ["v-5f3a45a5","/java/thread/java-thread-x-lock-ReentrantLock.html",{"e":"<h1> JUC锁: ReentrantLock详解</h1>\n","y":"a","t":"JUC锁: ReentrantLock详解"},["/java/thread/java-thread-x-lock-ReentrantLock","/java/thread/java-thread-x-lock-ReentrantLock.md"]],
  ["v-680a9b6e","/java/thread/java-thread-x-lock-ReentrantReadWriteLock.html",{"e":"<h1> JUC锁: ReentrantReadWriteLock详解</h1>\n","y":"a","t":"JUC锁: ReentrantReadWriteLock详解"},["/java/thread/java-thread-x-lock-ReentrantReadWriteLock","/java/thread/java-thread-x-lock-ReentrantReadWriteLock.md"]],
  ["v-15b7a148","/java/thread/java-thread-x-lock-all.html",{"e":"<h1> Java并发 - Java中所有的锁</h1>\n","y":"a","t":"Java并发 - Java中所有的锁"},["/java/thread/java-thread-x-lock-all","/java/thread/java-thread-x-lock-all.md"]],
  ["v-1549f7bc","/java/thread/java-thread-x-overview.html",{"e":"<h1> ♥Java并发知识体系详解♥</h1>\n","y":"a","t":"♥Java并发知识体系详解♥"},["/java/thread/java-thread-x-overview","/java/thread/java-thread-x-overview.md"]],
  ["v-53ba6f7e","/java/thread/java-thread-x-theorty.html",{"e":"<h1> Java 并发 - 理论基础</h1>\n","y":"a","t":"Java 并发 - 理论基础"},["/java/thread/java-thread-x-theorty","/java/thread/java-thread-x-theorty.md"]],
  ["v-9ba68da0","/java/thread/java-thread-x-thread-basic.html",{"e":"<h1> Java 并发 - 线程基础</h1>\n","y":"a","t":"Java 并发 - 线程基础"},["/java/thread/java-thread-x-thread-basic","/java/thread/java-thread-x-thread-basic.md"]],
  ["v-b7b80514","/java/thread/java-thread-x-threadlocal.html",{"e":"<h1> Java 并发 - ThreadLocal详解</h1>\n","y":"a","t":"Java 并发 - ThreadLocal详解"},["/java/thread/java-thread-x-threadlocal","/java/thread/java-thread-x-threadlocal.md"]],
  ["v-45b69bc4","/develop/algorithms-structures/algorithms.html",{"y":"a","t":"算法"},["/develop/algorithms-structures/algorithms","/develop/algorithms-structures/algorithms.md"]],
  ["v-55057c70","/develop/algorithms-structures/structures.html",{"y":"a","t":"数据结构"},["/develop/algorithms-structures/structures","/develop/algorithms-structures/structures.md"]],
  ["v-9fc6e360","/develop/design/adapter.html",{"d":1571356800000,"l":"2019年10月18日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 基本介绍</h2>\n<p>在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。</p>\n<p>在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。</p>\n<p><strong>适配器模式</strong>（Adapter Pattern）将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器（Wrapper）。</p>","y":"a","t":"结构型适配器模式"},["/develop/design/adapter","/develop/design/adapter.md"]],
  ["v-23dca26c","/develop/design/bridge.html",{"d":1571529600000,"l":"2019年10月20日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 桥接模式基本介绍</h2>\n<p>在现实生活中，某些类具有两个或多个维度的变化，如图形既可按形状分，又可按颜色分。如何设计类似于 Photoshop 这样的软件，能画不同形状和不同颜色的图形呢？如果用继承方式，m 种形状和 n 种颜色的图形就有 m×n 种，不但对应的子类很多，而且扩展困难。</p>\n<p>当然，这样的例子还有很多，如不同颜色和字体的文字、不同品牌和功率的汽车、不同性别和职业的男女、支持不同平台和不同文件格式的媒体播放器等。如果用桥接模式就能很好地解决这些问题。</p>\n<p><strong>桥接模式</strong>（Bridge Pattern）是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变，是一种结构型设计模式。</p>","y":"a","t":"结构型桥接模式"},["/develop/design/bridge","/develop/design/bridge.md"]],
  ["v-6e251184","/develop/design/builder.html",{"d":1571184000000,"l":"2019年10月16日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 建造者模式基本介绍</h2>\n<p>在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。例如，计算机是由 CPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等部件组装而成的，采购员不可能自己去组装计算机，而是将计算机的配置要求告诉计算机销售公司，计算机销售公司安排技术人员去组装计算机，然后再交给要买计算机的采购员。</p>\n<p>生活中这样的例子很多，如游戏中的不同角色，其性别、个性、能力、脸型、体型、服装、发型等特性都有所差异；还有汽车中的方向盘、发动机、车架、轮胎等部件也多种多样；每封电子邮件的发件人、收件人、主题、内容、附件等内容也各不相同。</p>","y":"a","t":"创建型建造者模式"},["/develop/design/builder","/develop/design/builder.md"]],
  ["v-2b152058","/develop/design/command.html",{"d":1572825600000,"l":"2019年11月4日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 命令模式基本介绍</h2>\n<p>在软件开发系统中，「方法的请求者」与「方法的实现者」之间经常存在紧密的耦合关系，这不利于软件功能的扩展与维护。例如，想对方法进行「撤销、重做、记录」等处理都很不方便，因此「如何将方法的请求者与实现者解耦？」变得很重要，命令模式就能很好地解决这个问题。</p>\n<p><strong>命令模式</strong>（Command Pattern）：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计。</p>\n<p>命名模式使得 <strong>请求发送者与请求接收者消除彼此之间的耦合</strong>，让对象之间的调用关系更加灵活，实现解耦。</p>","y":"a","t":"行为型命令模式"},["/develop/design/command","/develop/design/command.md"]],
  ["v-cf7f7ed0","/develop/design/composite.html",{"d":1571875200000,"l":"2019年10月24日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 组合模式基本介绍</h2>\n<p>在现实生活中，存在很多「部分-整体」的关系，例如，大学中的部门与学院、总公司中的部门与分公司、学习用品中的书与书包、生活用品中的衣服与衣柜、以及厨房中的锅碗瓢盆等。在软件开发中也是这样，例如，文件系统中的文件与文件夹、窗体程序中的简单控件与容器控件等。对这些简单对象与复合对象的处理，如果用组合模式来实现会很方便。</p>\n<p><strong>组合模式</strong>（Composite Pattern），又叫 <strong>部分整体模式</strong>，它创建了对象组的树形结构，将对象组合成树状结构以表示「整体-部分」的层次关系，属于结构型模式。</p>","y":"a","t":"结构型组合模式"},["/develop/design/composite","/develop/design/composite.md"]],
  ["v-3b93eb64","/develop/design/decorator.html",{"d":1571702400000,"l":"2019年10月22日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 装饰器模式的定义与特点</h2>\n<p>上班族大多都有睡懒觉的习惯，每天早上上班时间都很紧张，于是很多人为了多睡一会，就会用方便的方式解决早餐问题。有些人早餐可能会吃煎饼，煎饼中可以加鸡蛋，也可以加香肠，但是不管怎么「加码」，都还是一个煎饼。在现实生活中，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等，都是装饰器模式。</p>\n<p>在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以釆用装饰器模式来实现。</p>\n<p><strong>装饰器模式</strong>（Decorator Pattern）的定义：指 <strong>在不改变现有对象结构的情况下，动态地给该对象增加一些职责</strong>（即增加其额外功能）的模式，它属于对象结构型模式，也体现了开闭原则（OCP）。</p>","y":"a","t":"结构型装饰者模式"},["/develop/design/decorator","/develop/design/decorator.md"]],
  ["v-2014e344","/develop/design/end.html",{"d":1574640000000,"l":"2019年11月25日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 总结</h2>\n<p>23 种设计模式表格总结：</p>\n<h3> 创建型设计模式</h3>\n<p>简单来说就是用来创建对象的</p>\n<table>\n<thead>\n<tr>\n<th>设计模式</th>\n<th>分类</th>\n<th>简述</th>\n<th>一句话归纳</th>\n<th>目的</th>\n<th>生活案例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>工厂模式（Factory Pattern）</td>\n<td>不同条件下创建不同实例</td>\n<td>工厂生产物品</td>\n<td>产品标准化，生产更高效</td>\n<td>封装创建细节</td>\n<td>实体工厂</td>\n</tr>\n<tr>\n<td>单例模式（Singleton Pattern）</td>\n<td>保证一个类仅有一个实例，并且提供一个全局访问点</td>\n<td>世上只有一个我</td>\n<td>保证独一无二</td>\n<td>CEO</td>\n<td></td>\n</tr>\n<tr>\n<td>原型模式（Prototype Pattern）</td>\n<td>通过拷贝原型创建新的对象</td>\n<td>拔一根猴毛，吹出千万个</td>\n<td>高效创建对象</td>\n<td>克隆</td>\n<td></td>\n</tr>\n<tr>\n<td>建造者模式（Builder Pattern）</td>\n<td>用来创建复杂的复合对象</td>\n<td>高配中配和低配，想选哪配就哪配</td>\n<td>开放个性配置步骤</td>\n<td>选配</td>\n<td></td>\n</tr>\n</tbody>\n</table>","y":"a","t":"设计模式总结"},["/develop/design/end","/develop/design/end.md"]],
  ["v-8e59b74e","/develop/design/facade.html",{"d":1572048000000,"l":"2019年10月26日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 外观模式基本介绍</h2>\n<p>现实生活中，常常存在办事较复杂的例子，如办房产证或注册一家公司，有时要同多个部门联系，这时要是有一个综合部门能解决一切手续问题就好了。</p>\n<p>软件设计也是这样，当一个系统的功能越来越强，子系统会越来越多，客户对系统的访问也变得越来越复杂。这时如果系统内部发生改变，客户端也要跟着改变，这违背了「开闭原则」，也违背了「迪米特法则」，所以有必要为多个子系统提供一个统一的接口，从而降低系统的耦合度，这就是外观模式的目标。</p>\n<p><strong>外观模式</strong>（Facade Pattern），也叫 <strong>过程模式</strong>、<strong>门面模式</strong>，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>","y":"a","t":"结构型外观模式"},["/develop/design/facade","/develop/design/facade.md"]],
  ["v-05c85d75","/develop/design/factory.html",{"d":1570838400000,"l":"2019年10月12日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 工厂模式概述</h2>\n<blockquote>\n<p>工厂模式很重要，后面的很多架构设计，都是工厂模式联合着其它设计模式使用。</p>\n</blockquote>\n<p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在 GOF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，在今天的讲解中，我们沿用第一种分类方法。</p>\n<p>在这三种细分的工厂模式中，简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。</p>","y":"a","t":"创建型工厂模式"},["/develop/design/factory","/develop/design/factory.md"]],
  ["v-5a65fcf4","/develop/design/flyweight.html",{"d":1572220800000,"l":"2019年10月28日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 享元模式基本介绍</h2>\n<p>在面向对象程序设计过程中，有时会面临要创建大量相同或相似对象实例的问题。创建那么多的对象将会耗费很多的系统资源，它是系统性能提高的一个瓶颈。</p>\n<p>例如，围棋和五子棋中的黑白棋子，图像中的坐标点或颜色，局域网中的路由器、交换机和集线器，教室里的桌子和凳子等。这些对象有很多相似的地方，如果能把它们相同的部分提取出来共享，则能节省大量的系统资源，这就是享元模式的产生背景。</p>\n<p><strong>享元模式</strong>（Flyweight Pattern） 也叫 <strong>蝇量模式</strong>: 运用共享技术有效地支持大量细粒度的对象。</p>","y":"a","t":"结构型享元模式"},["/develop/design/flyweight","/develop/design/flyweight.md"]],
  ["v-26071b05","/develop/design/interpreter.html",{"d":1573862400000,"l":"2019年11月16日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 解释器模式基本介绍</h2>\n<p>在编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器都可以看做是解释器。</p>\n<p><strong>解释器模式</strong>（Interpreter Pattern）：是指给定一个语言（表达式），定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子（表达式）。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。</p>\n<p>这里提到的文法和句子的概念同编译原理中的描述相同，<mark>文法</mark> 指语言的语法规则，而 <mark>句子</mark> 是语言集中的元素。例如，汉语中的句子有很多，「我是中国人」是其中的一个句子，可以用一棵语法树来直观地描述语言中的句子。</p>","y":"a","t":"行为型解释器模式"},["/develop/design/interpreter","/develop/design/interpreter.md"]],
  ["v-660b0285","/develop/design/iterator.html",{"d":1573171200000,"l":"2019年11月8日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 迭代器模式基本介绍</h2>\n<p>迭代器模式在生活中应用的比较广泛，比如：物流系统中的传送带，不管传送的是什么物品，都会被打包成一个个箱子，并且有一个统一的二维码。这样我们不需要关心箱子里是什么，在分发时只需要一个个检查发送的目的地即可。再比如，我们平时乘坐交通工具，都是统一刷卡或者刷脸进站，而不需要关心是男性还是女性、是残疾人还是正常人等信息。</p>\n<p><strong>迭代器模式</strong>（Iterator Pattern）是常用的设计模式，属于行为型模式。</p>\n<p>如果我们的集合元素是用不同的方式实现的，有数组，还有 Java 的集合类，或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。</p>","y":"a","t":"行为型迭代器模式"},["/develop/design/iterator","/develop/design/iterator.md"]],
  ["v-fd9681c0","/develop/design/mediator.html",{"d":1573516800000,"l":"2019年11月12日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 中介者模式基本介绍</h2>\n<p><strong>中介者模式</strong>（Mediator Pattern）又叫 <strong>调停模式</strong>，它是迪米特法则的典型应用。用一个 <strong>中介对象来封装一系列的对象交互</strong>。中介者使各个对象不需要显式地相互引用，从而使其 <strong>耦合松散</strong>，而且可以独立地改变它们之间的交互。</p>\n<p>中介者模式属于行为型模式，使代码易于维护。</p>\n<p>在现实生活中，常常会出现好多对象之间存在复杂的交互关系，这种交互关系常常是「网状结构」，它要求每个对象都必须知道它需要交互的对象。例如，每个人必须记住他（她）所有朋友的电话；而且，朋友中如果有人的电话修改了，他（她）必须让其他所有的朋友一起修改，这叫作「牵一发而动全身」，非常复杂。</p>","y":"a","t":"行为型中介模式"},["/develop/design/mediator","/develop/design/mediator.md"]],
  ["v-5aed6ba6","/develop/design/memento.html",{"d":1573689600000,"l":"2019年11月14日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 备忘录模式基本介绍</h2>\n<p><strong>备忘录模式</strong>（Memento Pattern）又叫 <strong>快照模式</strong>，在 <strong>不破坏封装性的前提下</strong>，捕获 <strong>一个对象的内部状态</strong>，并在该对象之外保存这个状态。这样以后就 <strong>可将该对象恢复到原先保存的状态</strong>。</p>\n<p>备忘录模式属于行为型模式。</p>\n<p>可以这里理解备忘录模式：现实生活中的备忘录是用来记录某些要去做的事情，或者是记录已经达成的共同意见的事情，以防忘记了。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作。</p>","y":"a","t":"行为型备忘录模式"},["/develop/design/memento","/develop/design/memento.md"]],
  ["v-72940dc6","/develop/design/observer.html",{"d":1573344000000,"l":"2019年11月10日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 观察者模式基本介绍</h2>\n<p>在现实世界中，许多对象并不是独立存在的，其中一个对象的行为发生改变可能会导致一个或者多个其他对象的行为也发生改变。例如，某种商品的物价上涨时会导致部分商家高兴，而消费者伤心；还有，当我们开车到交叉路口时，遇到红灯会停，遇到绿灯会行。这样的例子还有很多，例如，股票价格与股民、微信公众号与微信用户、气象局的天气预报与听众、小偷与警察等。</p>\n<p><strong>观察者模式</strong>（Observer Pattern）的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</p>","y":"a","t":"行为型观察者模式"},["/develop/design/observer","/develop/design/observer.md"]],
  ["v-7dc0f6dd","/develop/design/prototype.html",{"d":1571011200000,"l":"2019年10月14日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 原型模式基本介绍</h2>\n<p>在有些系统中，存在大量相同或相似对象的创建问题，如果用传统的构造函数来创建对象，会比较复杂且耗时耗资源，用原型模式生成对象就很高效，就像孙悟空拔下猴毛轻轻一吹就变出很多孙悟空一样简单。</p>\n<p><strong>原型模式</strong>（Prototype Pattern）是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。</p>\n<p>原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节。</p>\n<p>工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 <code>对象.clone()</code>。</p>","y":"a","t":"创建型原型模式"},["/develop/design/prototype","/develop/design/prototype.md"]],
  ["v-1902a411","/develop/design/proxy.html",{"d":1572393600000,"l":"2019年10月30日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 代理模式的基本介绍</h2>\n<p>在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。</p>\n<p>在软件设计中，使用代理模式的例子也很多，例如，要访问的远程对象比较大（如视频或大图像等），其下载要花很多时间。还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。</p>\n<p><strong>代理模式</strong>（Proxy Pattern）：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。</p>","y":"a","t":"结构型代理模式"},["/develop/design/proxy","/develop/design/proxy.md"]],
  ["v-d8e95536","/develop/design/responsibility.html",{"d":1574380800000,"l":"2019年11月22日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 职责链模式基本介绍</h2>\n<p>在现实生活中，一个事件需要经过多个对象处理是很常见的场景。例如，采购审批流程、请假流程等。公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据需要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这无疑增加了难度。</p>\n<p>在计算机软硬件中也有相关例子，如总线网中数据报传送，每台计算机根据目标地址是否同自己的地址相同来决定是否接收；还有异常处理中，处理程序根据异常的类型决定自己是否处理该异常；还有 Struts2 的拦截器、JSP 和 Servlet 的 Filter 等，所有这些都可以考虑使用职责链模式来实现。</p>","y":"a","t":"行为型职责链模式"},["/develop/design/responsibility","/develop/design/responsibility.md"]],
  ["v-72c7365c","/develop/design/seven-principles.html",{"d":1570147200000,"l":"2019年10月4日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 设计模式七大原则</h2>\n<p>设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础（即：设计模式为什么 这样设计的依据）。</p>\n<p>设计模式常用的七大原则有：</p>\n<ul>\n<li>单一职责原则</li>\n<li>接口隔离原则</li>\n<li>依赖倒转（倒置）原则</li>\n<li>里氏替换原则</li>\n<li>开闭原则</li>\n<li>迪米特法则</li>\n<li>合成复用原则</li>\n</ul>\n<h2> 单一职责原则（SRP）</h2>\n<h3> 基本介绍</h3>\n<p><strong>单一职责原则</strong>（Single Responsibility Principle，SRP）又称单一功能原则，由罗伯特·C.马丁（Robert C. Martin）于《敏捷软件开发：原则、模式和实践》一书中提出的。这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）。</p>","y":"a","t":"七大原则"},["/develop/design/seven-principles","/develop/design/seven-principles.md"]],
  ["v-60256d6b","/develop/design/single.html",{"d":1570665600000,"l":"2019年10月10日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 单例设计模式介绍</h2>\n<p>在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。</p>\n<p>所谓类的 <strong>单例设计模式</strong>，就是 <strong>采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法（静态方法）。</p>\n<p>比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。</p>","y":"a","t":"创建型单例模式"},["/develop/design/single","/develop/design/single.md"]],
  ["v-7a5d87ce","/develop/design/state.html",{"d":1574035200000,"l":"2019年11月18日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 状态模式基本介绍</h2>\n<p>在软件开发过程中，应用程序中的部分对象可能会根据不同的情况做出不同的行为，我们把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态。当有状态的对象与外部事件产生互动时，其内部状态就会发生改变，从而使其行为也发生改变。如人都有高兴和伤心的时候，不同的情绪有不同的行为，当然外界也会影响其情绪变化。</p>\n<p>对这种有状态的对象编程，传统的解决方案是：将这些所有可能发生的情况全都考虑到，然后使用 if-else 或 switch-case 语句来做状态判断，再进行不同情况的处理。但是显然这种做法对复杂的状态判断存在天然弊端，条件判断语句会过于臃肿，可读性差，且不具备扩展性，维护难度也大。且增加新的状态时要添加新的 if-else 语句，这违背了「开闭原则」，不利于程序的扩展。</p>","y":"a","t":"行为型状态模式"},["/develop/design/state","/develop/design/state.md"]],
  ["v-5d8882a0","/develop/design/strategy.html",{"d":1574208000000,"l":"2019年11月20日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 策略模式基本介绍</h2>\n<p>在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，出行旅游可以乘坐飞机、乘坐火车、骑自行车或自己开私家车等，超市促销可以釆用打折、送商品、送积分等方法。</p>\n<p>在软件开发中也常常遇到类似的情况，当实现某一个功能存在多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能，如数据排序策略有冒泡排序、选择排序、插入排序、二叉树排序等。</p>\n<p>如果使用多重条件转移语句实现（即硬编码），不但使条件语句变得很复杂，而且增加、删除或更换算法要修改原代码，不易维护，违背开闭原则。如果采用策略模式就能很好解决该问题。</p>","y":"a","t":"行为型策略模式"},["/develop/design/strategy","/develop/design/strategy.md"]],
  ["v-4b4aaf4e","/develop/design/summary.html",{"d":1570492800000,"l":"2019年10月8日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 掌握设计模式的层次</h2>\n<ul>\n<li>第 1 层：刚开始学编程不久，听说过什么是设计模式</li>\n<li>第 2 层：有很长时间的编程经验，自己写了很多代码，其中用到了设计模式，但是自己却不知道</li>\n<li>第 3 层：学习过了设计模式，发现自己已经在使用了，并且发现了一些新的模式挺好用的</li>\n<li>第 4 层：阅读了很多别人写的源码和框架，在其中看到别人设计模式，并且能够领会设计模式的精妙和带来的 好处</li>\n<li>第 5 层：代码写着写着，自己都没有意识到使用了设计模式，并且熟练的写了出来</li>\n</ul>\n<h2> 设计模式介绍</h2>\n<p>设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，<strong>模式不是代码</strong>，而是 <strong>某类问题的通用解决方案</strong>，设计模式（Design pattern）代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>","y":"a","t":"设计模式概述"},["/develop/design/summary","/develop/design/summary.md"]],
  ["v-4a6785aa","/develop/design/template-method.html",{"d":1572652800000,"l":"2019年11月2日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 模板方法模式基本介绍</h2>\n<p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p>\n<p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p>\n<p>这样的例子在生活中还有很多，例如，一个人每天会起床、吃饭、做事、睡觉等，其中「做事」的内容每天可能不同。我们把这些规定了流程或格式的实例定义成模板，允许使用者根据自己的需求去更新它，例如，简历模板、论文模板、Word 中模板文件等。</p>","y":"a","t":"行为型模板方法模式"},["/develop/design/template-method","/develop/design/template-method.md"]],
  ["v-32e615c6","/develop/design/thought.html",{"d":1569974400000,"l":"2019年10月2日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 基于接口而非实现编程</h2>\n<p>这个原则非常重要，是一种非常有效的提高代码质量的手段，在平时的开发中特别经常被用到。</p>\n<h3> 如何解读原则中的「接口」二字</h3>\n<p>「基于接口而非实现编程」这条原则的英文描述是：「Program to an interface, not an implementation」。我们理解这条原则的时候，千万不要一开始就与具体的编程语言挂钩，局限在编程语言的「接口」语法中（比如 Java 中的 interface 接口语法）。这条原则最早出现于 1994 年 GoF 的《设计模式》这本书，它先于很多编程语言而诞生（比如 Java 语言），是一条比较抽象、泛化的设计思想。</p>","y":"a","t":"设计思想"},["/develop/design/thought","/develop/design/thought.md"]],
  ["v-379fc8cc","/develop/design/uml-class-diagram.html",{"d":1570320000000,"l":"2019年10月6日","c":["设计模式"],"g":["设计模式"],"e":"<h2> UML 基本介绍</h2>\n<p>997 年 UML 被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是 <strong>简单、统一、图形化、能表达软件设计中的动态与静态信息</strong>。</p>\n<p>UML：Unified modeling language UML (统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果。</p>\n<p>UML 本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他 们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等，如右图：</p>","y":"a","t":"UML类图"},["/develop/design/uml-class-diagram","/develop/design/uml-class-diagram.md"]],
  ["v-6a6fd891","/develop/design/visitor.html",{"d":1572998400000,"l":"2019年11月6日","c":["设计模式"],"g":["设计模式"],"e":"<h2> 访问者模式基本介绍</h2>\n<p>在现实生活中，有些集合对象存在多种不同的元素，且每种元素也存在多种不同的访问者和处理方式。例如，公园中存在多个景点，也存在多个游客，不同的游客对同一个景点的评价可能不同；医院医生开的处方单中包含多种药元素，査看它的划价员和药房工作人员对它的处理方式也不同，划价员根据处方单上面的药品名和数量进行划价，药房工作人员根据处方单的内容进行抓药。</p>\n<p>这样的例子还有很多，例如，电影或电视剧中的人物角色，不同的观众对他们的评价也不同；还有顾客在商场购物时放在「购物车」中的商品，顾客主要关心所选商品的性价比，而收银员关心的是商品的价格和数量。</p>\n","y":"a","t":"行为型访问者模式"},["/develop/design/visitor","/develop/design/visitor.md"]],
  ["v-72edcc3e","/develop/quality-assurance/code-style-alibaba.html",{"d":1643846400000,"l":"2022年2月3日","c":["代码规范"],"g":["代码规范"],"e":"<h1> 阿里巴巴 Java 开发手册</h1>\n<h2> 前言</h2>\n<p>《Java开发手册》是阿里巴巴和开课吧技术团队的集体智慧结晶和经验总结，经历了多次大规模一线实战的检验及不断完善，公开到业界后，众多社区开发者踊跃参与打磨完善，系统化地整理成册，当前的最新版本是黄山版。现代软件行业的高速发展对开发者的综合素质要求越来越高，因为不仅是编程知识点，其它维度的知识点也会影响到软件的最终交付质量。比如：五花八门的错误码会人为地增加排查问题的难度；数据库的表结构和索引设计缺陷带来的系统架构缺陷或性能风险；工程结构混乱导致后续项目维护艰难；没有鉴权的漏洞代码容易被黑客攻击等。所以本手册以Java开发者为中心视角，划分为编程规约、异常日志、单元测试、安全规约、MySQL数据库、工程结构、设计规约七个维度，再根据内容特征，细分成若干二级子目录。此外，依据约束力强弱及故障敏感性，规约依次分为<span style=\"color: red;\">【强制】</span>、<span style=\"color: #FEB409;\">【推荐】</span>、<span style=\"color: #64822E;\">【参考】</span>三大类。在延伸的信息中，“说明”对规约做了适当扩展和解释；“<span style=\"color: #64822E;\">正例</span>”提倡什么样的编码和实现方式；“<span style=\"color: red;\">反例</span>”说明需要提防的雷区，以及真实的错误案例。</p>","y":"a","t":"阿里巴巴 Java 开发手册"},["/develop/quality-assurance/code-style-alibaba","/develop/quality-assurance/code-style-alibaba.md"]],
  ["v-56af3e42","/develop/quality-assurance/code-style-google.html",{"d":1643932800000,"l":"2022年2月4日","c":["代码规范"],"g":["代码规范"],"e":"<h1> Google Java 编程风格指南</h1>\n<blockquote>\n<p>转载并翻译自 <a href=\"https://google.github.io/styleguide/javaguide.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://google.github.io/styleguide/javaguide.html</a>。个人英语水平有限，应以原文档为标准。<!--more--></p>\n</blockquote>\n<h2> 简介</h2>\n<p>本文档是 Google Java 语言编程规范的 <strong>完整</strong> 定义。一个 Java 源文件当且仅当遵守本规范时，才可被描述为 Google 风格。</p>","y":"a","t":"Google Java 编程风格指南"},["/develop/quality-assurance/code-style-google","/develop/quality-assurance/code-style-google.md"]],
  ["v-7c15438d","/develop/quality-assurance/code-style-name.html",{"d":1549843200000,"l":"2019年2月11日","e":"<h1> 统一命名规范详解</h1>\n","y":"a","t":"统一命名规范详解"},["/develop/quality-assurance/code-style-name","/develop/quality-assurance/code-style-name.md"]],
  ["v-1d64c9ca","/develop/quality-assurance/code-style-static.html",{"d":1549929600000,"l":"2019年2月12日","e":"<h1> 静态样式检查详解</h1>\n","y":"a","t":"静态样式检查详解"},["/develop/quality-assurance/code-style-static","/develop/quality-assurance/code-style-static.md"]],
  ["v-2c847d26","/develop/quality-assurance/code-style.html",{"d":1549756800000,"l":"2019年2月10日","e":"<h1> 统一代码格式化详解</h1>\n","y":"a","t":"统一代码格式化详解"},["/develop/quality-assurance/code-style","/develop/quality-assurance/code-style.md"]],
  ["v-ba136d28","/develop/quality-assurance/quality-control-sonarlint.html",{"d":1550016000000,"l":"2019年2月13日","e":"<h1> Sonarlint插件详解</h1>\n","y":"a","t":"Sonarlint插件详解"},["/develop/quality-assurance/quality-control-sonarlint","/develop/quality-assurance/quality-control-sonarlint.md"]],
  ["v-51157dd4","/develop/quality-assurance/unit-test-junit-idea.html",{"d":1549584000000,"l":"2019年2月8日","e":"<h1> IDEA下单元测试详解</h1>\n","y":"a","t":"IDEA下单元测试详解"},["/develop/quality-assurance/unit-test-junit-idea","/develop/quality-assurance/unit-test-junit-idea.md"]],
  ["v-ea902450","/develop/quality-assurance/unit-test-junit.html",{"d":1549324800000,"l":"2019年2月5日","e":"<h1> JUnit4 详解</h1>\n<blockquote>\n<p>JUint是Java编程语言的单元测试框架，用于编写和运行可重复的自动化测试。本文主要针对Junit4要点进行梳理总结。</p>\n</blockquote>\n<h2> 什么是JUnit？</h2>\n<p>JUint是Java编程语言的单元测试框架，用于编写和运行可重复的自动化测试。</p>\n<h2> JUnit特点？</h2>\n<p>JUnit 是一个开放的资源框架，用于编写和运行测试。</p>\n<ul>\n<li>提供注解来识别测试方法。</li>\n<li>提供断言来测试预期结果。</li>\n<li>JUnit 测试允许你编写代码更快，并能提高质量。</li>\n<li>JUnit 优雅简洁。没那么复杂，花费时间较少。</li>\n<li>JUnit测试可以自动运行并且检查自身结果并提供即时反馈。所以也没有必要人工梳理测试结果的报告。</li>\n<li>JUnit测试可以被组织为测试套件，包含测试用例，甚至其他的测试套件。</li>\n<li>JUnit在一个条中显示进度。如果运行良好则是绿色；如果运行失败，则变成红色。</li>\n</ul>","y":"a","t":"JUnit4 详解"},["/develop/quality-assurance/unit-test-junit","/develop/quality-assurance/unit-test-junit.md"]],
  ["v-55fde6b6","/develop/quality-assurance/unit-test-junit5.html",{"d":1549411200000,"l":"2019年2月6日","e":"<h1> Junit5 详解</h1>\n","y":"a","t":"Junit5 详解"},["/develop/quality-assurance/unit-test-junit5","/develop/quality-assurance/unit-test-junit5.md"]],
  ["v-07ea442c","/develop/quality-assurance/unit-test-mockito.html",{"d":1549497600000,"l":"2019年2月7日","e":"<h1> Mockito 详解</h1>\n","y":"a","t":"Mockito 详解"},["/develop/quality-assurance/unit-test-mockito","/develop/quality-assurance/unit-test-mockito.md"]],
  ["v-0995ea93","/develop/quality-assurance/unit-test-springboot2.html",{"d":1549670400000,"l":"2019年2月9日","e":"<h1> SpringBoot2+H2+Mockito实战</h1>\n","y":"a","t":"SpringBoot2+H2+Mockito实战"},["/develop/quality-assurance/unit-test-springboot2","/develop/quality-assurance/unit-test-springboot2.md"]],
  ["v-595dbbce","/develop/quality-assurance/unit-test.html",{"d":1549238400000,"l":"2019年2月4日","e":"<h1> 浅谈单元测试</h1>\n<blockquote>\n<p>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。这是基础，所以围绕着单元测试，我从网上搜集和总结了相关的概念，以助你完善体系。</p>\n</blockquote>\n<h2> 什么是单元测试？</h2>\n<blockquote>\n<p>来自百度百科。</p>\n</blockquote>\n<p>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。</p>","y":"a","t":"浅谈单元测试"},["/develop/quality-assurance/unit-test","/develop/quality-assurance/unit-test.md"]],
  ["v-3706649a","/404.html",{"y":"p","t":""},["/404"]],
  ["v-2d0aa3fe","/me/",{"y":"p","t":"Me"},["/me/index.html"]],
  ["v-ffb97496","/java/basic/",{"y":"p","t":"Basic"},["/java/basic/index.html"]],
  ["v-14c69af4","/java/",{"y":"p","t":"Java"},["/java/index.html"]],
  ["v-16722c46","/java/collection/",{"y":"p","t":"Collection"},["/java/collection/index.html"]],
  ["v-9828af56","/java/io/",{"y":"p","t":"Io"},["/java/io/index.html"]],
  ["v-2b9e3a1e","/java/javaup/",{"y":"p","t":"Javaup"},["/java/javaup/index.html"]],
  ["v-53c5f3b8","/java/others/",{"y":"p","t":"Others"},["/java/others/index.html"]],
  ["v-27762a11","/tool/docker/",{"y":"p","t":"Docker"},["/tool/docker/index.html"]],
  ["v-211a2a4e","/java/spring/",{"y":"p","t":"Spring"},["/java/spring/index.html"]],
  ["v-48579df1","/java/thread/",{"y":"p","t":"Thread"},["/java/thread/index.html"]],
  ["v-5bb56591","/develop/algorithms-structures/",{"y":"p","t":"Algorithms Structures"},["/develop/algorithms-structures/index.html"]],
  ["v-1891b76b","/develop/",{"y":"p","t":"Develop"},["/develop/index.html"]],
  ["v-114ea066","/develop/design/",{"y":"p","t":"Design"},["/develop/design/index.html"]],
  ["v-e867e24a","/develop/quality-assurance/",{"y":"p","t":"Quality Assurance"},["/develop/quality-assurance/index.html"]],
  ["v-5bc93818","/category/",{"y":"p","t":"分类","I":0},["/category/index.html"]],
  ["v-744d024e","/tag/",{"y":"p","t":"标签","I":0},["/tag/index.html"]],
  ["v-e52c881c","/article/",{"y":"p","t":"文章","I":0},["/article/index.html"]],
  ["v-154dc4c4","/star/",{"y":"p","t":"收藏","I":0},["/star/index.html"]],
  ["v-01560935","/timeline/",{"y":"p","t":"时间轴","I":0},["/timeline/index.html"]],
  ["v-03d57386","/category/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",{"y":"p","t":"使用指南 分类","I":0},["/category/使用指南/","/category/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/index.html"]],
  ["v-83e1f92e","/tag/%E7%A6%81%E7%94%A8/",{"y":"p","t":"禁用 标签","I":0},["/tag/禁用/","/tag/%E7%A6%81%E7%94%A8/index.html"]],
  ["v-506407f4","/en/article/",{"y":"p","t":"Articles","I":0},["/en/article/index.html"]],
  ["v-37a8c5a0","/en/star/",{"y":"p","t":"Star","I":0},["/en/star/index.html"]],
  ["v-0379cba1","/en/timeline/",{"y":"p","t":"Timeline","I":0},["/en/timeline/index.html"]],
  ["v-ad1708ba","/category/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/",{"y":"p","t":"资源导航 分类","I":0},["/category/资源导航/","/category/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/index.html"]],
  ["v-1e447d61","/tag/%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86/",{"y":"p","t":"文章加密 标签","I":0},["/tag/文章加密/","/tag/%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86/index.html"]],
  ["v-7189e1c4","/category/java-%E5%9F%BA%E7%A1%80/",{"y":"p","t":"Java 基础 分类","I":0},["/category/java-基础/","/category/java-%E5%9F%BA%E7%A1%80/index.html"]],
  ["v-484552dc","/tag/markdown/",{"y":"p","t":"Markdown 标签","I":0},["/tag/markdown/index.html"]],
  ["v-41590e77","/category/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",{"y":"p","t":"设计模式 分类","I":0},["/category/设计模式/","/category/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html"]],
  ["v-a378ad66","/tag/%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE/",{"y":"p","t":"页面配置 标签","I":0},["/tag/页面配置/","/tag/%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE/index.html"]],
  ["v-791f1092","/category/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/",{"y":"p","t":"代码规范 分类","I":0},["/category/代码规范/","/category/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/index.html"]],
  ["v-7b167472","/tag/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",{"y":"p","t":"使用指南 标签","I":0},["/tag/使用指南/","/tag/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/index.html"]],
  ["v-5decfa84","/en/category/",{"y":"p","t":"Category","I":0},["/en/category/index.html"]],
  ["v-6dd3fb2d","/tag/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/",{"y":"p","t":"资源导航 标签","I":0},["/tag/资源导航/","/tag/%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA/index.html"]],
  ["v-20002c0c","/tag/java-%E5%9F%BA%E7%A1%80/",{"y":"p","t":"Java 基础 标签","I":0},["/tag/java-基础/","/tag/java-%E5%9F%BA%E7%A1%80/index.html"]],
  ["v-05b88e01","/tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",{"y":"p","t":"设计模式 标签","I":0},["/tag/设计模式/","/tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html"]],
  ["v-3d7e901c","/tag/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/",{"y":"p","t":"代码规范 标签","I":0},["/tag/代码规范/","/tag/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/index.html"]],
  ["v-075c6c62","/en/tag/",{"y":"p","t":"Tag","I":0},["/en/tag/index.html"]],
  ["v-2c8cebb5","/java/jvm/java-jvm-agent-usage.html",{"y":"a","t":"调试排错 - Java动态调试技术原理"},["/java/jvm/java-jvm-agent-usage","/java/jvm/java-jvm-agent-usage.md"]],
  ["v-526554b6","/java/jvm/java-jvm-agent-arthas.html",{"y":"a","t":"调试排错 - Java 问题排查之应用在线调试Arthas"},["/java/jvm/java-jvm-agent-arthas","/java/jvm/java-jvm-agent-arthas.md"]],
  ["v-0620a7ea","/java/jvm/java-jvm-class-enhancer.html",{"y":"a","t":"JVM 基础 - 字节码的增强技术"},["/java/jvm/java-jvm-class-enhancer","/java/jvm/java-jvm-class-enhancer.md"]],
  ["v-d2220394","/java/jvm/java-jvm-class.html",{"y":"a","t":"JVM 基础 - 类字节码详解"},["/java/jvm/java-jvm-class","/java/jvm/java-jvm-class.md"]],
  ["v-2e496290","/java/jvm/java-jvm-classload.html",{"y":"a","t":"JVM 基础 - Java 类加载机制"},["/java/jvm/java-jvm-classload","/java/jvm/java-jvm-classload.md"]],
  ["v-1ce727c4","/java/jvm/java-jvm-cms-gc.html",{"y":"a","t":"GC - Java 垃圾回收器之CMS GC问题分析与解决"},["/java/jvm/java-jvm-cms-gc","/java/jvm/java-jvm-cms-gc.md"]],
  ["v-18eedada","/java/jvm/java-jvm-debug-idea.html",{"y":"a","t":"调试排错 - Java 问题排查之使用IDEA本地调试和远程调试"},["/java/jvm/java-jvm-debug-idea","/java/jvm/java-jvm-debug-idea.md"]],
  ["v-5ebaefb4","/java/jvm/java-jvm-debug-tools-linux.html",{"y":"a","t":"调试排错 - Java 问题排查之Linux命令"},["/java/jvm/java-jvm-debug-tools-linux","/java/jvm/java-jvm-debug-tools-linux.md"]],
  ["v-3f7ab1cc","/java/jvm/java-jvm-debug-tools-list.html",{"y":"a","t":"调试排错 - Java 问题排查之工具单"},["/java/jvm/java-jvm-debug-tools-list","/java/jvm/java-jvm-debug-tools-list.md"]],
  ["v-134b39c8","/java/jvm/java-jvm-gc.html",{"y":"a","t":"GC - Java 垃圾回收基础知识"},["/java/jvm/java-jvm-gc","/java/jvm/java-jvm-gc.md"]],
  ["v-070878a4","/java/jvm/java-jvm-jmm.html",{"y":"a","t":"JVM 基础 - Java 内存模型详解"},["/java/jvm/java-jvm-jmm","/java/jvm/java-jvm-jmm.md"]],
  ["v-ccc0a742","/java/jvm/java-jvm-gc-zgc.html",{"y":"a","t":"GC - Java 垃圾回收器之ZGC详解"},["/java/jvm/java-jvm-gc-zgc","/java/jvm/java-jvm-gc-zgc.md"]],
  ["v-2c851e53","/java/jvm/java-jvm-gc-g1.html",{"y":"a","t":"GC - Java 垃圾回收器之G1详解"},["/java/jvm/java-jvm-gc-g1","/java/jvm/java-jvm-gc-g1.md"]],
  ["v-d1b45d9a","/java/jvm/java-jvm-oom-offheap.html",{"y":"a","t":"调试排错 - Java 内存分析之堆外内存"},["/java/jvm/java-jvm-oom-offheap","/java/jvm/java-jvm-oom-offheap.md"]],
  ["v-175b530c","/java/jvm/java-jvm-oom-tool.html",{"y":"a","t":"调试排错 - Java 问题排查之JVM可视化工具"},["/java/jvm/java-jvm-oom-tool","/java/jvm/java-jvm-oom-tool.md"]],
  ["v-7980977e","/java/jvm/java-jvm-param.html",{"y":"a","t":"调试排错 - JVM 调优参数"},["/java/jvm/java-jvm-param","/java/jvm/java-jvm-param.md"]],
  ["v-05ae10ef","/java/jvm/java-jvm-struct.html",{"y":"a","t":"JVM 基础 - JVM 内存结构"},["/java/jvm/java-jvm-struct","/java/jvm/java-jvm-struct.md"]],
  ["v-783acf81","/java/jvm/java-jvm-oom.html",{"y":"a","t":"调试排错 - Java 内存分析之堆内存和MetaSpace内存"},["/java/jvm/java-jvm-oom","/java/jvm/java-jvm-oom.md"]],
  ["v-64225912","/java/jvm/java-jvm-thread-dump.html",{"y":"a","t":"调试排错 - Java 线程分析之线程Dump分析"},["/java/jvm/java-jvm-thread-dump","/java/jvm/java-jvm-thread-dump.md"]],
  ["v-c35eedb8","/java/jvm/java-jvm-x-introduce.html",{"y":"a","t":"JVM 基础 - Java 内存模型引入"},["/java/jvm/java-jvm-x-introduce","/java/jvm/java-jvm-x-introduce.md"]],
  ["v-16edf7b6","/java/jvm/java-jvm-x-overview.html",{"y":"a","t":"♥JVM相关知识体系详解♥"},["/java/jvm/java-jvm-x-overview","/java/jvm/java-jvm-x-overview.md"]],
]
