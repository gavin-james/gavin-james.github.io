export const data = JSON.parse("{\"key\":\"v-25c8fdb4\",\"path\":\"/develop/design/establish.html\",\"title\":\"创建型\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"创建型\",\"summary\":\"单例设计模式介绍 在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。 所谓类的 单例设计模式，就是 采取一定的方法保证在整个的软件系统中，对某个类只能存在\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"http://www.gavin-james.com/develop/design/establish.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"Gavin blog\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"创建型\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"og:locale:alternate\",\"content\":\"en-US\"}]]},\"excerpt\":\"\",\"headers\":[{\"level\":2,\"title\":\"单例设计模式介绍\",\"slug\":\"单例设计模式介绍\",\"children\":[]},{\"level\":2,\"title\":\"单例设计模式八种方式\",\"slug\":\"单例设计模式八种方式\",\"children\":[{\"level\":3,\"title\":\"饿汉式（静态常量）\",\"slug\":\"饿汉式-静态常量\",\"children\":[]},{\"level\":3,\"title\":\"饿汉式（静态代码块）\",\"slug\":\"饿汉式-静态代码块\",\"children\":[]},{\"level\":3,\"title\":\"懒汉式（线程不安全）\",\"slug\":\"懒汉式-线程不安全\",\"children\":[]},{\"level\":3,\"title\":\"懒汉式（线程安全，同步方法）\",\"slug\":\"懒汉式-线程安全-同步方法\",\"children\":[]},{\"level\":3,\"title\":\"懒汉式（线程安全，同步代码块）\",\"slug\":\"懒汉式-线程安全-同步代码块\",\"children\":[]},{\"level\":3,\"title\":\"双重检查\",\"slug\":\"双重检查\",\"children\":[]},{\"level\":3,\"title\":\"静态内部类\",\"slug\":\"静态内部类\",\"children\":[]},{\"level\":3,\"title\":\"枚举\",\"slug\":\"枚举\",\"children\":[]}]},{\"level\":2,\"title\":\"单例模式JDK应用\",\"slug\":\"单例模式jdk应用\",\"children\":[]},{\"level\":2,\"title\":\"单例模式注意事项和细节说明\",\"slug\":\"单例模式注意事项和细节说明\",\"children\":[]},{\"level\":2,\"title\":\"单例模式的应用场景\",\"slug\":\"单例模式的应用场景\",\"children\":[]},{\"level\":2,\"title\":\"单例存在哪些问题\",\"slug\":\"单例存在哪些问题\",\"children\":[{\"level\":3,\"title\":\"单例对 OOP 特性的支持不友好\",\"slug\":\"单例对-oop-特性的支持不友好\",\"children\":[]},{\"level\":3,\"title\":\"单例会隐藏类之间的依赖关系\",\"slug\":\"单例会隐藏类之间的依赖关系\",\"children\":[]},{\"level\":3,\"title\":\"单例对代码的扩展性不友好\",\"slug\":\"单例对代码的扩展性不友好\",\"children\":[]},{\"level\":3,\"title\":\"单例对代码的可测试性不友好\",\"slug\":\"单例对代码的可测试性不友好\",\"children\":[]},{\"level\":3,\"title\":\"单例不支持有参数的构造函数\",\"slug\":\"单例不支持有参数的构造函数\",\"children\":[]}]},{\"level\":2,\"title\":\"有何替代解决方案\",\"slug\":\"有何替代解决方案\",\"children\":[]},{\"level\":2,\"title\":\"如何理解单例模式中的唯一性\",\"slug\":\"如何理解单例模式中的唯一性\",\"children\":[]},{\"level\":2,\"title\":\"如何实现线程唯一的单例\",\"slug\":\"如何实现线程唯一的单例\",\"children\":[]},{\"level\":2,\"title\":\"如何实现集群环境下的单例？\",\"slug\":\"如何实现集群环境下的单例\",\"children\":[]},{\"level\":2,\"title\":\"如何实现一个多例模式？\",\"slug\":\"如何实现一个多例模式\",\"children\":[]},{\"level\":2,\"title\":\"工厂模式概述\",\"slug\":\"工厂模式概述\",\"children\":[]},{\"level\":2,\"title\":\"简单工厂（Simple Factory）\",\"slug\":\"简单工厂-simple-factory\",\"children\":[{\"level\":3,\"title\":\"简单工厂模式基本介绍\",\"slug\":\"简单工厂模式基本介绍\",\"children\":[]},{\"level\":3,\"title\":\"传统方式完成披萨案例\",\"slug\":\"传统方式完成披萨案例\",\"children\":[]},{\"level\":3,\"title\":\"简单工厂模式完成案例\",\"slug\":\"简单工厂模式完成案例\",\"children\":[]}]},{\"level\":2,\"title\":\"工厂方法（Factory Method）\",\"slug\":\"工厂方法-factory-method\",\"children\":[{\"level\":3,\"title\":\"工厂方法模式介绍\",\"slug\":\"工厂方法模式介绍\",\"children\":[]},{\"level\":3,\"title\":\"工厂方法模式完成案例\",\"slug\":\"工厂方法模式完成案例\",\"children\":[]},{\"level\":3,\"title\":\"什么时候该用工厂方法模式，而非简单工厂模式呢？\",\"slug\":\"什么时候该用工厂方法模式-而非简单工厂模式呢\",\"children\":[]}]},{\"level\":2,\"title\":\"抽象工厂（Abstract Factory）\",\"slug\":\"抽象工厂-abstract-factory\",\"children\":[{\"level\":3,\"title\":\"基本介绍\",\"slug\":\"基本介绍\",\"children\":[]},{\"level\":3,\"title\":\"抽象工厂模式应用实例\",\"slug\":\"抽象工厂模式应用实例\",\"children\":[]}]},{\"level\":2,\"title\":\"工厂模式在 JDK-Calendar 应用的源码分析\",\"slug\":\"工厂模式在-jdk-calendar-应用的源码分析\",\"children\":[]},{\"level\":2,\"title\":\"工厂模式小结\",\"slug\":\"工厂模式小结\",\"children\":[]},{\"level\":2,\"title\":\"如何设计实现一个Dependency Injection框架\",\"slug\":\"如何设计实现一个dependency-injection框架\",\"children\":[{\"level\":3,\"title\":\"工厂模式和 DI 容器有何区别\",\"slug\":\"工厂模式和-di-容器有何区别\",\"children\":[]},{\"level\":3,\"title\":\"DI 容器的核心功能有哪些\",\"slug\":\"di-容器的核心功能有哪些\",\"children\":[]}]},{\"level\":2,\"title\":\"如何实现一个简单的 DI 容器？\",\"slug\":\"如何实现一个简单的-di-容器\",\"children\":[{\"level\":3,\"title\":\"最小原型设计\",\"slug\":\"最小原型设计\",\"children\":[]},{\"level\":3,\"title\":\"提供执行入口\",\"slug\":\"提供执行入口\",\"children\":[]},{\"level\":3,\"title\":\"配置文件解析\",\"slug\":\"配置文件解析\",\"children\":[]},{\"level\":3,\"title\":\"核心工厂类设计\",\"slug\":\"核心工厂类设计\",\"children\":[]}]},{\"level\":2,\"title\":\"原型模式基本介绍\",\"slug\":\"原型模式基本介绍\",\"children\":[]},{\"level\":2,\"title\":\"原型模式原理结构图\",\"slug\":\"原型模式原理结构图\",\"children\":[]},{\"level\":2,\"title\":\"克隆羊案例\",\"slug\":\"克隆羊案例\",\"children\":[]},{\"level\":2,\"title\":\"传统方式解决克隆羊实例\",\"slug\":\"传统方式解决克隆羊实例\",\"children\":[]},{\"level\":2,\"title\":\"传统的方式的优缺点\",\"slug\":\"传统的方式的优缺点\",\"children\":[]},{\"level\":2,\"title\":\"原型模式解决克隆羊实例\",\"slug\":\"原型模式解决克隆羊实例\",\"children\":[]},{\"level\":2,\"title\":\"Spring 框架的原型模式\",\"slug\":\"spring-框架的原型模式\",\"children\":[]},{\"level\":2,\"title\":\"深入讨论：浅拷贝和深拷贝\",\"slug\":\"深入讨论-浅拷贝和深拷贝\",\"children\":[]},{\"level\":2,\"title\":\"原型模式的注意事项和细节\",\"slug\":\"原型模式的注意事项和细节\",\"children\":[]}],\"readingTime\":{\"minutes\":61.1,\"words\":18329},\"copyright\":\"著作权归Gavin所有\\n基于https://github.com/Small-market/Small-market.github.io/LICENSE协议\\n原文链接：http://www.gavin-james.com/develop/design/establish.html\",\"filePathRelative\":\"develop/design/establish.md\"}")

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
