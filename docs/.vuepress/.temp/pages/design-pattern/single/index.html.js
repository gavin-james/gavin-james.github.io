export const data = JSON.parse("{\"key\":\"v-829cb4dc\",\"path\":\"/design-pattern/single/\",\"title\":\"设计模式 -  创建型单例模式\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"设计模式 -  创建型单例模式\",\"date\":\"2022-02-26T23:32:00.000Z\",\"permalink\":\"/design-pattern/single/\",\"categories\":[\"设计模式\"],\"tags\":[\"设计模式\"],\"author\":{\"name\":\"Gavin\",\"link\":\"https://github.com/Small-market\"},\"summary\":\"[[TOC]] 单例设计模式介绍 在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。 所谓类的 单例设计模式，就是 采取一定的方法保证在整个的软件系统中，\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"http://www.gavin-james.com/design-pattern/single/\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"Gavin blog\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"设计模式 -  创建型单例模式\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"og:locale:alternate\",\"content\":\"en-US\"}],[\"meta\",{\"property\":\"article:author\",\"content\":\"Gavin\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"设计模式\"}],[\"meta\",{\"property\":\"article:published_time\",\"content\":\"2022-02-26T23:32:00.000Z\"}]]},\"excerpt\":\"\",\"headers\":[{\"level\":2,\"title\":\"单例设计模式介绍\",\"slug\":\"单例设计模式介绍\",\"children\":[]},{\"level\":2,\"title\":\"单例设计模式八种方式\",\"slug\":\"单例设计模式八种方式\",\"children\":[{\"level\":3,\"title\":\"饿汉式（静态常量）\",\"slug\":\"饿汉式-静态常量\",\"children\":[]},{\"level\":3,\"title\":\"饿汉式（静态代码块）\",\"slug\":\"饿汉式-静态代码块\",\"children\":[]},{\"level\":3,\"title\":\"懒汉式（线程不安全）\",\"slug\":\"懒汉式-线程不安全\",\"children\":[]},{\"level\":3,\"title\":\"懒汉式（线程安全，同步方法）\",\"slug\":\"懒汉式-线程安全-同步方法\",\"children\":[]},{\"level\":3,\"title\":\"懒汉式（线程安全，同步代码块）\",\"slug\":\"懒汉式-线程安全-同步代码块\",\"children\":[]},{\"level\":3,\"title\":\"双重检查\",\"slug\":\"双重检查\",\"children\":[]},{\"level\":3,\"title\":\"静态内部类\",\"slug\":\"静态内部类\",\"children\":[]},{\"level\":3,\"title\":\"枚举\",\"slug\":\"枚举\",\"children\":[]}]},{\"level\":2,\"title\":\"单例模式JDK应用\",\"slug\":\"单例模式jdk应用\",\"children\":[]},{\"level\":2,\"title\":\"单例模式注意事项和细节说明\",\"slug\":\"单例模式注意事项和细节说明\",\"children\":[]},{\"level\":2,\"title\":\"单例模式的应用场景\",\"slug\":\"单例模式的应用场景\",\"children\":[]},{\"level\":2,\"title\":\"单例存在哪些问题\",\"slug\":\"单例存在哪些问题\",\"children\":[{\"level\":3,\"title\":\"单例对 OOP 特性的支持不友好\",\"slug\":\"单例对-oop-特性的支持不友好\",\"children\":[]},{\"level\":3,\"title\":\"单例会隐藏类之间的依赖关系\",\"slug\":\"单例会隐藏类之间的依赖关系\",\"children\":[]},{\"level\":3,\"title\":\"单例对代码的扩展性不友好\",\"slug\":\"单例对代码的扩展性不友好\",\"children\":[]},{\"level\":3,\"title\":\"单例对代码的可测试性不友好\",\"slug\":\"单例对代码的可测试性不友好\",\"children\":[]},{\"level\":3,\"title\":\"单例不支持有参数的构造函数\",\"slug\":\"单例不支持有参数的构造函数\",\"children\":[]}]},{\"level\":2,\"title\":\"有何替代解决方案\",\"slug\":\"有何替代解决方案\",\"children\":[]},{\"level\":2,\"title\":\"如何理解单例模式中的唯一性\",\"slug\":\"如何理解单例模式中的唯一性\",\"children\":[]},{\"level\":2,\"title\":\"如何实现线程唯一的单例\",\"slug\":\"如何实现线程唯一的单例\",\"children\":[]},{\"level\":2,\"title\":\"如何实现集群环境下的单例？\",\"slug\":\"如何实现集群环境下的单例\",\"children\":[]},{\"level\":2,\"title\":\"如何实现一个多例模式？\",\"slug\":\"如何实现一个多例模式\",\"children\":[]}],\"readingTime\":{\"minutes\":26.65,\"words\":7995},\"copyright\":\"著作权归Gavin所有\\n基于https://github.com/Small-market/Small-market.github.io/LICENSE协议\\n原文链接：http://www.gavin-james.com/design-pattern/single/\",\"filePathRelative\":\"develop/design/09.设计模式 - 创建型单例模式.md\",\"localizedDate\":\"2022年2月27日\"}")

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
