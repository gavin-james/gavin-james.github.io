const nt="ENTRIES",T="KEYS",V="VALUES",F="";class D{constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case V:return this.value();case T:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const h=u*i;t:for(const c of e.keys())if(c===F){const a=o[h-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let l=0;l<c.length;++l,++a){const p=c[l],f=i*a,g=f-i;let d=o[f];const m=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let _=m;_<y;++_){const b=p!==t[_],z=o[g+_]+ +b,A=o[g+_+1]+1,w=o[f+_]+1,L=o[f+_+1]=Math.min(z,A,w);L<d&&(d=L)}if(d>s)continue t}W(e.get(c),t,s,n,o,a,i,r+c)}};class C{constructor(t=new Map,s=""){this._size=void 0,this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=I(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=O(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=O(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,T)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,V)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},O=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return O(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const h=e.get(u);if(r===u.length)e=h;else{const c=new Map;c.set(u.slice(r),h),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=I(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=I(e);n.set(o+t,s),n.delete(o)},I=e=>e[e.length-1],it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",P="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},q=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,lt=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),q(n.terms,u)}}return e},[P]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);q(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d:h}=u;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(i+1)/(e+i*(1-r+r*n/o)))},dt=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},ft={k:1.2,b:.7,d:.5},gt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},H={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:ft},mt={combineWith:P,prefix:(e,t,s)=>t===s.length-1},pt={batchSize:1e3,batchWait:10},J={minDirtFactor:.1,minDirtCount:20},Ft={...pt,...J};class _t{constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?Ft:t.autoVacuum;this._options={...gt,...t,autoVacuum:s,searchOptions:{...H,...t.searchOptions||{}},autoSuggestOptions:{...mt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=J,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const yt=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},U=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},At=(e,t,s,n)=>{if(!e._index.has(n)){U(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?U(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(ht[s])||new Map},B=(e,t,s,n,o,u,i,r,h=new Map)=>{if(o==null)return h;for(const c of Object.keys(u)){const a=u[c],l=e._fieldIds[c],p=o.get(l);if(p==null)continue;let f=p.size;const g=e._avgFieldLength[l];for(const d of p.keys()){if(!e._documentIds.has(d)){At(e,l,d,s),f-=1;continue}const m=i?i(e._documentIds.get(d),s,e._storedFields.get(d)):1;if(!m)continue;const y=p.get(d),_=e._fieldLength.get(d)[l],b=at(y,f,e._documentCount,_,g,r),z=n*a*m*b,A=h.get(d);if(A){A.score+=z,ct(A.terms,t);const w=N(A.match,s);w?w.push(c):A.match[s]=[c]}else h.set(d,{score:z,terms:[t],match:{[s]:[c]}})}}return h},Ct=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((d,m)=>({...d,[m]:N(n.boost,m)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:h}=n,{fuzzy:c,prefix:a}={...H.weights,...i},l=e._index.get(t.term),p=B(e,t.term,t.term,1,l,o,u,h);let f,g;if(t.prefix&&(f=e._index.atPrefix(t.term)),t.fuzzy){const d=t.fuzzy===!0?.2:t.fuzzy,m=d<1?Math.min(r,Math.round(t.term.length*d)):d;m&&(g=e._index.fuzzyGet(t.term,m))}if(f)for(const[d,m]of f){const y=d.length-t.term.length;if(!y)continue;g==null||g.delete(d);const _=a*d.length/(d.length+.3*y);B(e,t.term,d,_,m,o,u,h,p)}if(g)for(const d of g.keys()){const[m,y]=g.get(d);if(!y)continue;const _=c*d.length/(d.length+y);B(e,t.term,d,_,m,o,u,h,p)}return p},K=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},l=t.queries.map(p=>K(e,p,a));return Y(l,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:h}=i,c=r(t).flatMap(a=>h(a)).filter(a=>!!a).map(dt(i)).map(a=>Ct(e,a,i));return Y(c,i.combineWith)},X=(e,t,s={})=>{const n=K(e,t,s),o=[];for(const[u,{score:i,terms:r,match:h}]of n){const c=r.length,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(h),match:h};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Et=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of X(e,t,s)){const r=i.join(" "),h=n.get(r);h!=null?(h.score+=u,h.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:h}]of n)o.push({suggestion:u,terms:r,score:i/h});return o.sort(G),o},zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:h,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const l=new _t(a);l._documentCount=t,l._nextId=s,l._documentIds=k(n),l._idToShortId=new Map,l._fieldIds=o,l._fieldLength=k(u),l._avgFieldLength=i,l._storedFields=k(r),l._dirtCount=h||0,l._index=new C;for(const[p,f]of l._documentIds)l._idToShortId.set(f,p);for(const[p,f]of e){const g=new Map;for(const d of Object.keys(f)){let m=f[d];c===1&&(m=m.ds),g.set(parseInt(d,10),k(m))}l._index.set(p,g)}return l},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let l="";i===0?l=c.length>20?`… ${c.slice(-20)}`:c:a?l=c.length+i>100?`${c.slice(0,100-i)}… `:c:l=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,l&&o.push(l),i+=l.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let h=s.indexOf(n,u);if(h===-1)return null;for(;h>=0;){const c=h+n.length;if(r(e.slice(u,h)),u=c,i>100)break;h=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return X(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,h=u.includes("@"),c=u.includes("#"),[a,l]=u.split(/[#@]/),{contents:p}=n[a]??={title:"",contents:[]};if(h)p.push([{type:"customField",key:a,index:l,display:i.map(f=>o.c.map(g=>j(g,f))).flat().filter(f=>f!==null)},r]);else{const f=i.map(g=>j(o.h,g)).filter(g=>g!==null);if(f.length&&p.push([{type:c?"heading":"title",key:a,...c&&{anchor:l},display:f},r]),"t"in o)for(const g of o.t){const d=i.map(m=>j(g,m)).filter(m=>m!==null);d.length&&p.push([{type:"text",key:a,...c&&{anchor:l},display:d},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=yt(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Et(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/en/\":{\"documentCount\":2,\"nextId\":2,\"documentIds\":{\"0\":\"v-7c2196ed\",\"1\":\"v-50a4c495\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,12],\"1\":[1]},\"averageFieldLength\":[1,12],\"storedFields\":{\"0\":{\"h\":\"项目主页\",\"t\":[\"这是项目主页的案例。你可以在这里放置你的主体内容。\",\"想要使用此布局，你需要在页面 front matter 中设置 home: true。\",\"配置项的相关说明详见 项目主页配置。\"]},\"1\":{\"h\":\"幻灯片页\"}},\"dirtCount\":0,\"index\":[[\"幻灯片页\",{\"0\":{\"1\":1}}],[\"配置项的相关说明详见\",{\"1\":{\"0\":1}}],[\"true\",{\"1\":{\"0\":1}}],[\"home\",{\"1\":{\"0\":1}}],[\"中设置\",{\"1\":{\"0\":1}}],[\"matter\",{\"1\":{\"0\":1}}],[\"front\",{\"1\":{\"0\":1}}],[\"你需要在页面\",{\"1\":{\"0\":1}}],[\"你可以在这里放置你的主体内容\",{\"1\":{\"0\":1}}],[\"想要使用此布局\",{\"1\":{\"0\":1}}],[\"这是项目主页的案例\",{\"1\":{\"0\":1}}],[\"项目主页配置\",{\"1\":{\"0\":1}}],[\"项目主页\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2},\"/\":{\"documentCount\":1017,\"nextId\":1017,\"documentIds\":{\"0\":\"v-79fdd481\",\"1\":\"v-0e503981\",\"2\":\"v-74bc627b\",\"3\":\"v-2e25198a\",\"4\":\"v-fffb8e28\",\"5\":\"v-fffb8e28#目录\",\"6\":\"v-4c863446\",\"7\":\"v-bf720700\",\"8\":\"v-0978b044\",\"9\":\"v-0978b044#markdown-介绍\",\"10\":\"v-0978b044#markdown-配置\",\"11\":\"v-0978b044#markdown-扩展\",\"12\":\"v-0978b044#vuepress-扩展\",\"13\":\"v-0978b044#主题扩展\",\"14\":\"v-0978b044#自定义容器\",\"15\":\"v-0978b044#代码块\",\"16\":\"v-0978b044#自定义对齐\",\"17\":\"v-0978b044#上下角标\",\"18\":\"v-0978b044#脚注\",\"19\":\"v-0978b044#标记\",\"20\":\"v-0978b044#任务列表\",\"21\":\"v-0978b044#图片增强\",\"22\":\"v-0978b044#图表\",\"23\":\"v-0978b044#echarts\",\"24\":\"v-0978b044#流程图\",\"25\":\"v-0978b044#mermaid\",\"26\":\"v-0978b044#tex-语法\",\"27\":\"v-0978b044#导入文件\",\"28\":\"v-0978b044#代码演示\",\"29\":\"v-0978b044#样式化\",\"30\":\"v-0978b044#幻灯片\",\"31\":\"v-4eaf9f84\",\"32\":\"v-4eaf9f84#页面信息\",\"33\":\"v-4eaf9f84#页面内容\",\"34\":\"v-4eaf9f84#页面结构\",\"35\":\"v-2250a72e\",\"36\":\"v-2250a72e#自我提升九大招\",\"37\":\"v-ef7dd9f0\",\"38\":\"v-ef7dd9f0#常用搜索\",\"39\":\"v-1559ca3e\",\"40\":\"v-acebc5a4\",\"41\":\"v-acebc5a4#默认节点\",\"42\":\"v-acebc5a4#文本框节点\",\"43\":\"v-acebc5a4#图形\",\"44\":\"v-acebc5a4#flowchart-orientation\",\"45\":\"v-acebc5a4#node-shapes\",\"46\":\"v-acebc5a4#a-node-with-round-edges\",\"47\":\"v-acebc5a4#a-stadium-shaped-node\",\"48\":\"v-acebc5a4#a-node-in-a-subroutine-shape\",\"49\":\"v-acebc5a4#a-node-in-a-cylindrical-shape\",\"50\":\"v-acebc5a4#a-node-in-the-form-of-a-circle\",\"51\":\"v-acebc5a4#a-node-in-an-asymmetric-shape\",\"52\":\"v-acebc5a4#a-node-rhombus\",\"53\":\"v-acebc5a4#a-hexagon-node\",\"54\":\"v-acebc5a4#parallelogram\",\"55\":\"v-acebc5a4#parallelogram-alt\",\"56\":\"v-acebc5a4#trapezoid\",\"57\":\"v-acebc5a4#trapezoid-alt\",\"58\":\"v-acebc5a4#double-circle\",\"59\":\"v-acebc5a4#links-between-nodes\",\"60\":\"v-acebc5a4#a-link-with-arrow-head\",\"61\":\"v-acebc5a4#an-open-link\",\"62\":\"v-acebc5a4#text-on-links\",\"63\":\"v-acebc5a4#a-link-with-arrow-head-and-text\",\"64\":\"v-acebc5a4#dotted-link\",\"65\":\"v-acebc5a4#dotted-link-with-text\",\"66\":\"v-acebc5a4#thick-link\",\"67\":\"v-acebc5a4#thick-link-with-text\",\"68\":\"v-acebc5a4#chaining-of-links\",\"69\":\"v-acebc5a4#new-arrow-types\",\"70\":\"v-acebc5a4#multi-directional-arrows\",\"71\":\"v-acebc5a4#minimum-length-of-a-link\",\"72\":\"v-acebc5a4#special-characters-that-break-syntax\",\"73\":\"v-acebc5a4#entity-codes-to-escape-characters\",\"74\":\"v-acebc5a4#subgraphs\",\"75\":\"v-acebc5a4#flowcharts\",\"76\":\"v-acebc5a4#direction-in-subgraphs\",\"77\":\"v-acebc5a4#interaction\",\"78\":\"v-acebc5a4#comments\",\"79\":\"v-acebc5a4#styling-and-classes\",\"80\":\"v-acebc5a4#styling-links\",\"81\":\"v-acebc5a4#styling-a-node\",\"82\":\"v-acebc5a4#classes\",\"83\":\"v-acebc5a4#css-classes\",\"84\":\"v-acebc5a4#default-class\",\"85\":\"v-acebc5a4#basic-support-for-fontawesome\",\"86\":\"v-acebc5a4#graph-declarations-with-spaces-between-vertices-and-link-and-without-semicolon\",\"87\":\"v-acebc5a4#configuration\",\"88\":\"v-30c465ed\",\"89\":\"v-30c465ed#壹、瞒天过海\",\"90\":\"v-30c465ed#贰、舍近求远\",\"91\":\"v-30c465ed#叁、颠倒黑白\",\"92\":\"v-30c465ed#肆、化整为零\",\"93\":\"v-30c465ed#伍、釜底抽薪\",\"94\":\"v-30c465ed#最后\",\"95\":\"v-28a994e2\",\"96\":\"v-28a994e2#spi机制的简单示例\",\"97\":\"v-28a994e2#spi机制的广泛应用\",\"98\":\"v-28a994e2#spi机制-jdbc-drivermanager\",\"99\":\"v-28a994e2#jdbc接口定义\",\"100\":\"v-28a994e2#mysql实现\",\"101\":\"v-28a994e2#postgresql实现\",\"102\":\"v-28a994e2#使用方法\",\"103\":\"v-28a994e2#源码实现\",\"104\":\"v-28a994e2#spi机制-common-logging\",\"105\":\"v-28a994e2#spi机制-插件体系\",\"106\":\"v-28a994e2#spi机制-spring中spi机制\",\"107\":\"v-28a994e2#spi机制深入理解\",\"108\":\"v-28a994e2#spi机制通常怎么使用\",\"109\":\"v-28a994e2#定义标准\",\"110\":\"v-28a994e2#具体厂商或者框架开发者实现\",\"111\":\"v-28a994e2#程序猿使用\",\"112\":\"v-28a994e2#使用规范\",\"113\":\"v-28a994e2#spi和api的区别是什么\",\"114\":\"v-28a994e2#spi机制实现原理\",\"115\":\"v-28a994e2#spi机制的缺陷\",\"116\":\"v-28a994e2#参考文章\",\"117\":\"v-97baa718\",\"118\":\"v-97baa718#数据类型\",\"119\":\"v-97baa718#包装类型\",\"120\":\"v-97baa718#缓存池\",\"121\":\"v-97baa718#string\",\"122\":\"v-97baa718#概览\",\"123\":\"v-97baa718#不可变的好处\",\"124\":\"v-97baa718#string-stringbuffer-and-stringbuilder\",\"125\":\"v-97baa718#string-intern\",\"126\":\"v-97baa718#运算\",\"127\":\"v-97baa718#参数传递\",\"128\":\"v-97baa718#float-与-double\",\"129\":\"v-97baa718#隐式类型转换\",\"130\":\"v-97baa718#switch\",\"131\":\"v-97baa718#继承\",\"132\":\"v-97baa718#访问权限\",\"133\":\"v-97baa718#抽象类与接口\",\"134\":\"v-97baa718#super\",\"135\":\"v-97baa718#重写与重载\",\"136\":\"v-97baa718#object-通用方法\",\"137\":\"v-97baa718#概览-1\",\"138\":\"v-97baa718#equals\",\"139\":\"v-97baa718#hashcode\",\"140\":\"v-97baa718#tostring\",\"141\":\"v-97baa718#clone\",\"142\":\"v-97baa718#关键字\",\"143\":\"v-97baa718#final\",\"144\":\"v-97baa718#static\",\"145\":\"v-97baa718#反射\",\"146\":\"v-97baa718#异常\",\"147\":\"v-97baa718#泛型\",\"148\":\"v-97baa718#注解\",\"149\":\"v-97baa718#特性\",\"150\":\"v-97baa718#java-各版本的新特性\",\"151\":\"v-97baa718#java-与-c-的区别\",\"152\":\"v-97baa718#jre-or-jdk\",\"153\":\"v-97baa718#参考资料\",\"154\":\"v-1a248a92\",\"155\":\"v-1a248a92#参考文档\",\"156\":\"v-1a248a92#知识体系\",\"157\":\"v-1a248a92#q-a\",\"158\":\"v-1a248a92#java-中应该使用什么数据类型来代表价格\",\"159\":\"v-1a248a92#怎么将-byte-转换为-string\",\"160\":\"v-1a248a92#java-中怎样将-bytes-转换为-long-类型\",\"161\":\"v-1a248a92#我们能将-int-强制转换为-byte-类型的变量吗-如果该值大于-byte-类型的范围-将会出现什么现象\",\"162\":\"v-1a248a92#存在两个类-b-继承-a-c-继承-b-我们能将-b-转换为-c-么-如-c-c-b\",\"163\":\"v-1a248a92#哪个类包含-clone-方法-是-cloneable-还是-object\",\"164\":\"v-1a248a92#java-中-操作符是线程安全的吗\",\"165\":\"v-1a248a92#a-a-b-与-a-b-的区别\",\"166\":\"v-1a248a92#我能在不进行强制转换的情况下将一个-double-值赋值给-long-类型的变量吗\",\"167\":\"v-1a248a92#_3-0-1-0-3-将会返回什么-true-还是-false\",\"168\":\"v-1a248a92#int-和-integer-哪个会占用更多的内存\",\"169\":\"v-1a248a92#为什么-java-中的-string-是不可变的-immutable\",\"170\":\"v-1a248a92#我们能在-switch-中使用-string-吗\",\"171\":\"v-1a248a92#java-中的构造器链是什么\",\"172\":\"v-1a248a92#枚举类\",\"173\":\"v-1a248a92#什么是不可变对象-immutable-object-java-中怎么创建一个不可变对象\",\"174\":\"v-1a248a92#我们能创建一个包含可变对象的不可变对象吗\",\"175\":\"v-1a248a92#有没有可能两个不相等的对象有相同的-hashcode\",\"176\":\"v-1a248a92#两个相同的对象会有不同的-hash-code-吗\",\"177\":\"v-1a248a92#我们可以在-hashcode-中使用随机数字吗\",\"178\":\"v-1a248a92#java-中-comparator-与-comparable-有什么不同\",\"179\":\"v-1a248a92#为什么在重写-equals-方法的时候需要重写-hashcode-方法\",\"180\":\"v-1a248a92#a-b-和-a-equals-b-有什么区别\",\"181\":\"v-1a248a92#a-hashcode-有什么用-与-a-equals-b-有什么关系\",\"182\":\"v-1a248a92#final、finalize-和-finally-的不同之处\",\"183\":\"v-1a248a92#java-中的编译期常量是什么-使用它又什么风险\",\"184\":\"v-1a248a92#静态内部类与顶级类有什么区别\",\"185\":\"v-1a248a92#java-中-serializable-与-externalizable-的区别\",\"186\":\"v-1a248a92#说出-jdk-1-7-中的三个新特性\",\"187\":\"v-1a248a92#说出-5-个-jdk-1-8-引入的新特性\",\"188\":\"v-1a248a92#接口是什么-为什么要使用接口而不是直接使用具体类\",\"189\":\"v-1a248a92#java-中-抽象类与接口之间有什么不同\",\"190\":\"v-1a248a92#object有哪些公用方法\",\"191\":\"v-1a248a92#equals与-的区别\",\"192\":\"v-1a248a92#string、stringbuffer与stringbuilder的区别\",\"193\":\"v-1a248a92#switch能否用string做参数\",\"194\":\"v-1a248a92#接口与抽象类\",\"195\":\"v-1a248a92#抽象类和最终类\",\"196\":\"v-1a248a92#异常\",\"197\":\"v-1a248a92#关于finally\",\"198\":\"v-1a248a92#受检查异常和运行时异常\",\"199\":\"v-1a248a92#super出现在父类的子类中。有三种存在方式\",\"200\":\"v-1a248a92#this-super-在构造方法中的区别\",\"201\":\"v-1a248a92#构造内部类和静态内部类对象\",\"202\":\"v-1a248a92#序列化\",\"203\":\"v-1a248a92#java移位运算符\",\"204\":\"v-1a248a92#形参-实参\",\"205\":\"v-1a248a92#局部变量为什么要初始化\",\"206\":\"v-1a248a92#java语言的鲁棒性\",\"207\":\"v-5514bb44\",\"208\":\"v-5514bb44#三大特性\",\"209\":\"v-5514bb44#封装\",\"210\":\"v-5514bb44#继承\",\"211\":\"v-5514bb44#多态\",\"212\":\"v-5514bb44#类图\",\"213\":\"v-5514bb44#泛化关系-generalization\",\"214\":\"v-5514bb44#实现关系-realization\",\"215\":\"v-5514bb44#聚合关系-aggregation\",\"216\":\"v-5514bb44#组合关系-composition\",\"217\":\"v-5514bb44#关联关系-association\",\"218\":\"v-5514bb44#依赖关系-dependency\",\"219\":\"v-5514bb44#参考资料\",\"220\":\"v-08ff9d40\",\"221\":\"v-08ff9d40#注解基础\",\"222\":\"v-08ff9d40#java内置注解\",\"223\":\"v-08ff9d40#内置注解-override\",\"224\":\"v-08ff9d40#内置注解-deprecated\",\"225\":\"v-08ff9d40#内置注解-suppresswarnings\",\"226\":\"v-08ff9d40#元注解\",\"227\":\"v-08ff9d40#元注解-target\",\"228\":\"v-08ff9d40#元注解-retention-retentiontarget\",\"229\":\"v-08ff9d40#元注解-documented\",\"230\":\"v-08ff9d40#元注解-inherited\",\"231\":\"v-08ff9d40#元注解-repeatable-java8\",\"232\":\"v-08ff9d40#元注解-native-java8\",\"233\":\"v-08ff9d40#注解与反射接口\",\"234\":\"v-08ff9d40#自定义注解\",\"235\":\"v-08ff9d40#深入理解注解\",\"236\":\"v-08ff9d40#java8提供了哪些新的注解\",\"237\":\"v-08ff9d40#注解支持继承吗\",\"238\":\"v-08ff9d40#注解实现的原理\",\"239\":\"v-08ff9d40#注解的应用场景\",\"240\":\"v-08ff9d40#配置化到注解化-框架的演进\",\"241\":\"v-08ff9d40#继承实现到注解实现-junit3到junit4\",\"242\":\"v-08ff9d40#自定义注解和aop-通过切面实现解耦\",\"243\":\"v-08ff9d40#参考文章\",\"244\":\"v-397a88f4\",\"245\":\"v-397a88f4#异常的层次结构\",\"246\":\"v-397a88f4#throwable\",\"247\":\"v-397a88f4#error-错误\",\"248\":\"v-397a88f4#exception-异常\",\"249\":\"v-397a88f4#可查的异常-checked-exceptions-和不可查的异常-unchecked-exceptions\",\"250\":\"v-397a88f4#异常基础\",\"251\":\"v-397a88f4#异常关键字\",\"252\":\"v-397a88f4#异常的申明-throws\",\"253\":\"v-397a88f4#异常的抛出-throw\",\"254\":\"v-397a88f4#异常的自定义\",\"255\":\"v-397a88f4#异常的捕获\",\"256\":\"v-397a88f4#try-catch\",\"257\":\"v-397a88f4#try-catch-finally\",\"258\":\"v-397a88f4#try-finally\",\"259\":\"v-397a88f4#try-with-resource\",\"260\":\"v-397a88f4#异常基础总结\",\"261\":\"v-397a88f4#常用的异常\",\"262\":\"v-397a88f4#异常实践\",\"263\":\"v-397a88f4#只针对不正常的情况才使用异常\",\"264\":\"v-397a88f4#在-finally-块中清理资源或者使用-try-with-resource-语句\",\"265\":\"v-397a88f4#尽量使用标准的异常\",\"266\":\"v-397a88f4#对异常进行文档说明\",\"267\":\"v-397a88f4#优先捕获最具体的异常\",\"268\":\"v-397a88f4#不要捕获-throwable-类\",\"269\":\"v-397a88f4#不要忽略异常\",\"270\":\"v-397a88f4#不要记录并抛出异常\",\"271\":\"v-397a88f4#包装异常时不要抛弃原始的异常\",\"272\":\"v-397a88f4#不要使用异常控制程序的流程\",\"273\":\"v-397a88f4#不要在finally块中使用return。\",\"274\":\"v-397a88f4#深入理解异常\",\"275\":\"v-397a88f4#jvm处理异常的机制\",\"276\":\"v-397a88f4#异常是否耗时-为什么会耗时\",\"277\":\"v-397a88f4#参考文章\",\"278\":\"v-de8f8228\",\"279\":\"v-de8f8228#为什么会引入泛型\",\"280\":\"v-de8f8228#泛型的基本使用\",\"281\":\"v-de8f8228#泛型类\",\"282\":\"v-de8f8228#泛型接口\",\"283\":\"v-de8f8228#泛型方法\",\"284\":\"v-de8f8228#泛型的上下限\",\"285\":\"v-de8f8228#泛型数组\",\"286\":\"v-de8f8228#深入理解泛型\",\"287\":\"v-de8f8228#如何理解java中的泛型是伪泛型-泛型中类型擦除\",\"288\":\"v-de8f8228#如何证明类型的擦除呢\",\"289\":\"v-de8f8228#如何理解类型擦除后保留的原始类型\",\"290\":\"v-de8f8228#如何理解泛型的编译期检查\",\"291\":\"v-de8f8228#如何理解泛型的多态-泛型的桥接方法\",\"292\":\"v-de8f8228#如何理解基本类型不能作为泛型类型\",\"293\":\"v-de8f8228#如何理解泛型类型不能实例化\",\"294\":\"v-de8f8228#泛型数组-能不能采用具体的泛型类型进行初始化\",\"295\":\"v-de8f8228#泛型数组-如何正确的初始化泛型数组实例\",\"296\":\"v-de8f8228#如何理解泛型类中的静态方法和静态变量\",\"297\":\"v-de8f8228#如何理解异常中使用泛型\",\"298\":\"v-de8f8228#如何获取泛型的参数类型\",\"299\":\"v-de8f8228#参考文章\",\"300\":\"v-98764c78\",\"301\":\"v-98764c78#反射基础\",\"302\":\"v-98764c78#class类\",\"303\":\"v-98764c78#类加载\",\"304\":\"v-98764c78#反射的使用\",\"305\":\"v-98764c78#class类对象的获取\",\"306\":\"v-98764c78#constructor类及其用法\",\"307\":\"v-98764c78#field类及其用法\",\"308\":\"v-98764c78#method类及其用法\",\"309\":\"v-98764c78#反射机制执行的流程\",\"310\":\"v-98764c78#反射获取类实例\",\"311\":\"v-98764c78#反射获取方法\",\"312\":\"v-98764c78#调用method-invoke-方法\",\"313\":\"v-98764c78#反射调用流程小结\",\"314\":\"v-98764c78#参考文章\",\"315\":\"v-160dd523\",\"316\":\"v-57fd6efe\",\"317\":\"v-5ae629a6\",\"318\":\"v-62d97ba0\",\"319\":\"v-b925760e\",\"320\":\"v-23afa095\",\"321\":\"v-3c1ae9f2\",\"322\":\"v-1c5055b5\",\"323\":\"v-0eec18bc\",\"324\":\"v-65047803\",\"325\":\"v-3469ce8b\",\"326\":\"v-0f25a31f\",\"327\":\"v-4100cbe8\",\"328\":\"v-05724230\",\"329\":\"v-168549e8\",\"330\":\"v-6634b63c\",\"331\":\"v-0c931321\",\"332\":\"v-591f91e1\",\"333\":\"v-50af3f3c\",\"334\":\"v-236c401c\",\"335\":\"v-a9188154\",\"336\":\"v-7d45bd8f\",\"337\":\"v-7ba4b1d0\",\"338\":\"v-44ce00ba\",\"339\":\"v-4682d959\",\"340\":\"v-4f2fe7b2\",\"341\":\"v-4837b1f8\",\"342\":\"v-49ec8a97\",\"343\":\"v-4ba16336\",\"344\":\"v-4d563bd5\",\"345\":\"v-4f0b1474\",\"346\":\"v-50bfed13\",\"347\":\"v-685369d4\",\"348\":\"v-f64727e6\",\"349\":\"v-387d7920\",\"350\":\"v-1eafa231\",\"351\":\"v-0e15cdc8\",\"352\":\"v-4168eb44\",\"353\":\"v-3895583e\",\"354\":\"v-1cfd874e\",\"355\":\"v-bb9a50fe\",\"356\":\"v-746d71e4\",\"357\":\"v-425ae8a6\",\"358\":\"v-0cbcc5ac\",\"359\":\"v-574bf5fe\",\"360\":\"v-1e676876\",\"361\":\"v-53e244c0\",\"362\":\"v-089544f6\",\"363\":\"v-eed73056\",\"364\":\"v-f015882a\",\"365\":\"v-7cce1256\",\"366\":\"v-284166b0\",\"367\":\"v-1a2ad0b8\",\"368\":\"v-38911273\",\"369\":\"v-26372774\",\"370\":\"v-7fb8820c\",\"371\":\"v-12643273\",\"372\":\"v-6fa31c3f\",\"373\":\"v-e57cccb0\",\"374\":\"v-6843d678\",\"375\":\"v-19a5655a\",\"376\":\"v-7a424aec\",\"377\":\"v-3d106ba1\",\"378\":\"v-adc26f3e\",\"379\":\"v-489cfe62\",\"380\":\"v-29f64f97\",\"381\":\"v-0b4ff578\",\"382\":\"v-5bf67796\",\"383\":\"v-28576235\",\"384\":\"v-28576235#古董级工具\",\"385\":\"v-28576235#构建工具\",\"386\":\"v-28576235#字节码操作\",\"387\":\"v-28576235#集群管理\",\"388\":\"v-28576235#代码分析\",\"389\":\"v-28576235#编译器生成工具\",\"390\":\"v-28576235#外部配置工具\",\"391\":\"v-28576235#约束满足问题求解程序\",\"392\":\"v-28576235#持续集成\",\"393\":\"v-28576235#csv解析\",\"394\":\"v-28576235#数据库\",\"395\":\"v-28576235#数据结构\",\"396\":\"v-28576235#时间日期工具库\",\"397\":\"v-28576235#依赖注入\",\"398\":\"v-28576235#开发流程增强工具\",\"399\":\"v-28576235#分布式应用\",\"400\":\"v-28576235#分布式数据库\",\"401\":\"v-28576235#发布\",\"402\":\"v-28576235#文档处理工具\",\"403\":\"v-28576235#函数式编程\",\"404\":\"v-28576235#游戏开发\",\"405\":\"v-28576235#gui\",\"406\":\"v-28576235#高性能计算\",\"407\":\"v-28576235#ide\",\"408\":\"v-28576235#图像处理\",\"409\":\"v-28576235#json\",\"410\":\"v-28576235#jvm与jdk\",\"411\":\"v-28576235#基于jvm的语言\",\"412\":\"v-28576235#日志\",\"413\":\"v-28576235#机器学习\",\"414\":\"v-28576235#消息传递\",\"415\":\"v-28576235#杂项\",\"416\":\"v-28576235#应用监控工具\",\"417\":\"v-28576235#原生开发库\",\"418\":\"v-28576235#自然语言处理\",\"419\":\"v-28576235#网络\",\"420\":\"v-28576235#orm\",\"421\":\"v-28576235#pdf\",\"422\":\"v-28576235#性能分析\",\"423\":\"v-28576235#响应式开发库\",\"424\":\"v-28576235#rest框架\",\"425\":\"v-28576235#科学计算与分析\",\"426\":\"v-28576235#搜索引擎\",\"427\":\"v-28576235#安全\",\"428\":\"v-28576235#序列化\",\"429\":\"v-28576235#应用服务器\",\"430\":\"v-28576235#模板引擎\",\"431\":\"v-28576235#测试\",\"432\":\"v-28576235#通用工具库\",\"433\":\"v-28576235#网络爬虫\",\"434\":\"v-28576235#web框架\",\"435\":\"v-28576235#业务流程管理套件\",\"436\":\"v-28576235#资源\",\"437\":\"v-28576235#社区\",\"438\":\"v-28576235#有影响力的书\",\"439\":\"v-28576235#播客\",\"440\":\"v-28576235#twitter\",\"441\":\"v-28576235#知名网站\",\"442\":\"v-28576235#英文站点\",\"443\":\"v-d8cbcf9c\",\"444\":\"v-d8cbcf9c#style\",\"445\":\"v-d8cbcf9c#structs\",\"446\":\"v-d8cbcf9c#the-builder-pattern\",\"447\":\"v-d8cbcf9c#immutable-object-generation\",\"448\":\"v-d8cbcf9c#exceptions\",\"449\":\"v-d8cbcf9c#dependency-injection\",\"450\":\"v-d8cbcf9c#avoid-nulls\",\"451\":\"v-d8cbcf9c#immutable-by-default\",\"452\":\"v-d8cbcf9c#avoid-lots-of-util-classes\",\"453\":\"v-d8cbcf9c#formatting\",\"454\":\"v-d8cbcf9c#javadoc\",\"455\":\"v-d8cbcf9c#streams\",\"456\":\"v-d8cbcf9c#deploying\",\"457\":\"v-d8cbcf9c#frameworks\",\"458\":\"v-d8cbcf9c#maven\",\"459\":\"v-d8cbcf9c#dependency-convergence\",\"460\":\"v-d8cbcf9c#continuous-integration\",\"461\":\"v-d8cbcf9c#maven-repository\",\"462\":\"v-d8cbcf9c#configuration-management\",\"463\":\"v-d8cbcf9c#libraries\",\"464\":\"v-d8cbcf9c#missing-features\",\"465\":\"v-d8cbcf9c#apache-commons\",\"466\":\"v-d8cbcf9c#guava\",\"467\":\"v-d8cbcf9c#gson\",\"468\":\"v-d8cbcf9c#java-tuples\",\"469\":\"v-d8cbcf9c#javaslang\",\"470\":\"v-d8cbcf9c#joda-time\",\"471\":\"v-d8cbcf9c#lombok\",\"472\":\"v-d8cbcf9c#play-framework\",\"473\":\"v-d8cbcf9c#slf4j\",\"474\":\"v-d8cbcf9c#jooq\",\"475\":\"v-d8cbcf9c#testing\",\"476\":\"v-d8cbcf9c#junit-4\",\"477\":\"v-d8cbcf9c#jmock\",\"478\":\"v-d8cbcf9c#assertj\",\"479\":\"v-d8cbcf9c#tools\",\"480\":\"v-d8cbcf9c#intellij-idea\",\"481\":\"v-d8cbcf9c#chronon\",\"482\":\"v-d8cbcf9c#jrebel\",\"483\":\"v-d8cbcf9c#the-checker-framework\",\"484\":\"v-d8cbcf9c#code-quality\",\"485\":\"v-d8cbcf9c#eclipse-memory-analyzer\",\"486\":\"v-d8cbcf9c#resources\",\"487\":\"v-d8cbcf9c#books\",\"488\":\"v-d8cbcf9c#podcasts\",\"489\":\"v-d8cbcf9c#videos\",\"490\":\"v-b2bcbe0e\",\"491\":\"v-3eb79599\",\"492\":\"v-c71f42c4\",\"493\":\"v-822c7b58\",\"494\":\"v-ed4d7e1e\",\"495\":\"v-433f2daa\",\"496\":\"v-01cc0d6c\",\"497\":\"v-403c3c9a\",\"498\":\"v-a91286ce\",\"499\":\"v-fdf6b326\",\"500\":\"v-14e2ecc4\",\"501\":\"v-2223283d\",\"502\":\"v-6ab88a0c\",\"503\":\"v-f776a4c0\",\"504\":\"v-09e3d0d2\",\"505\":\"v-2979c08f\",\"506\":\"v-5d6e0f59\",\"507\":\"v-74dd545e\",\"508\":\"v-3af7313e\",\"509\":\"v-a217828e\",\"510\":\"v-6e070585\",\"511\":\"v-6b3090e4\",\"512\":\"v-55f57188\",\"513\":\"v-5587c7fc\",\"514\":\"v-2966db9e\",\"515\":\"v-09fee110\",\"516\":\"v-91054cd4\",\"517\":\"v-9fc6e360\",\"518\":\"v-9fc6e360#基本介绍\",\"519\":\"v-9fc6e360#模式的结构\",\"520\":\"v-9fc6e360#工作原理\",\"521\":\"v-9fc6e360#现实生活中的适配器例子\",\"522\":\"v-9fc6e360#类适配器模式\",\"523\":\"v-9fc6e360#类适配器模式介绍\",\"524\":\"v-9fc6e360#类适配器模式应用实例\",\"525\":\"v-9fc6e360#类适配器模式注意事项和细节\",\"526\":\"v-9fc6e360#对象适配器模式\",\"527\":\"v-9fc6e360#对象适配器模式介绍\",\"528\":\"v-9fc6e360#对象适配器模式应用实例\",\"529\":\"v-9fc6e360#对象适配器模式注意事项和细节\",\"530\":\"v-9fc6e360#接口适配器模式\",\"531\":\"v-9fc6e360#接口适配器模式介绍\",\"532\":\"v-9fc6e360#接口适配器模式应用实例\",\"533\":\"v-9fc6e360#springmvc-的适配器模式剖析\",\"534\":\"v-9fc6e360#适配器模式的注意事项和细节\",\"535\":\"v-9fc6e360#适配器模式的应用场景\",\"536\":\"v-23dca26c\",\"537\":\"v-23dca26c#桥接模式基本介绍\",\"538\":\"v-23dca26c#桥接模式的结构与实现\",\"539\":\"v-23dca26c#手机操作问题\",\"540\":\"v-23dca26c#传统方案解决手机操作问题\",\"541\":\"v-23dca26c#传统方案解决手机操作问题分析\",\"542\":\"v-23dca26c#桥接模式解决手机操作问题\",\"543\":\"v-23dca26c#jdbc-的桥接模式剖析\",\"544\":\"v-23dca26c#桥接模式的注意事项和细节\",\"545\":\"v-23dca26c#桥接模式的应用场景\",\"546\":\"v-23dca26c#常见的应用场景\",\"547\":\"v-23dca26c#桥接模式模式的扩展\",\"548\":\"v-6e251184\",\"549\":\"v-6e251184#建造者模式基本介绍\",\"550\":\"v-6e251184#建造者模式的四个角色\",\"551\":\"v-6e251184#建造者模式结构图\",\"552\":\"v-6e251184#盖房案例\",\"553\":\"v-6e251184#传统方式解决盖房案例\",\"554\":\"v-6e251184#传统方式的问题分析\",\"555\":\"v-6e251184#建造者模式解决盖房案例\",\"556\":\"v-6e251184#建造者模式的-jdk-应用\",\"557\":\"v-6e251184#建造者模式的注意事项和细节\",\"558\":\"v-6e251184#建造者模式的应用场景\",\"559\":\"v-2b152058\",\"560\":\"v-2b152058#命令模式基本介绍\",\"561\":\"v-2b152058#命令模式的结构与实现\",\"562\":\"v-2b152058#命令模式解决智能生活项目\",\"563\":\"v-2b152058#jdbctemplate-的命令模式分析\",\"564\":\"v-2b152058#命令模式的注意事项和细节\",\"565\":\"v-2b152058#命令模式的应用场景\",\"566\":\"v-cf7f7ed0\",\"567\":\"v-cf7f7ed0#组合模式基本介绍\",\"568\":\"v-cf7f7ed0#组合模式结构与实现\",\"569\":\"v-cf7f7ed0#透明方式\",\"570\":\"v-cf7f7ed0#安全方式\",\"571\":\"v-cf7f7ed0#模式的实现\",\"572\":\"v-cf7f7ed0#学校院系展示需求\",\"573\":\"v-cf7f7ed0#传统方案解决学校院系展示\",\"574\":\"v-cf7f7ed0#组合模式解决学校院系展示\",\"575\":\"v-cf7f7ed0#jdk-集合的组合模式剖析\",\"576\":\"v-cf7f7ed0#组合模式的注意事项和细节\",\"577\":\"v-cf7f7ed0#组合模式的应用场景\",\"578\":\"v-3b93eb64\",\"579\":\"v-3b93eb64#装饰器模式的定义与特点\",\"580\":\"v-3b93eb64#装饰器模式的结构与实现\",\"581\":\"v-3b93eb64#星巴克咖啡订单项目\",\"582\":\"v-3b93eb64#方案-1-较差\",\"583\":\"v-3b93eb64#方案-2-较好\",\"584\":\"v-3b93eb64#装饰者模式解决订单项目\",\"585\":\"v-3b93eb64#jdk-io-的装饰者模式剖析\",\"586\":\"v-3b93eb64#装饰器模式的应用场景\",\"587\":\"v-2014e344\",\"588\":\"v-2014e344#总结\",\"589\":\"v-2014e344#创建型设计模式\",\"590\":\"v-2014e344#结构型设计模式\",\"591\":\"v-2014e344#行为型设计模式\",\"592\":\"v-8e59b74e\",\"593\":\"v-8e59b74e#外观模式基本介绍\",\"594\":\"v-8e59b74e#外观模式的结构与实现\",\"595\":\"v-8e59b74e#模式的结构\",\"596\":\"v-8e59b74e#模式的实现\",\"597\":\"v-8e59b74e#影院管理项目\",\"598\":\"v-8e59b74e#传统方式解决影院管理\",\"599\":\"v-8e59b74e#传统方式解决问题图\",\"600\":\"v-8e59b74e#传统方式解决问题分析\",\"601\":\"v-8e59b74e#外观模式解决影院管理\",\"602\":\"v-8e59b74e#mybatis-框架的外观模式剖析\",\"603\":\"v-8e59b74e#外观模式的注意事项和细节\",\"604\":\"v-8e59b74e#外观模式的应用场景\",\"605\":\"v-05c85d75\",\"606\":\"v-05c85d75#工厂模式概述\",\"607\":\"v-05c85d75#简单工厂-simple-factory\",\"608\":\"v-05c85d75#简单工厂模式基本介绍\",\"609\":\"v-05c85d75#传统方式完成披萨案例\",\"610\":\"v-05c85d75#简单工厂模式完成案例\",\"611\":\"v-05c85d75#工厂方法-factory-method\",\"612\":\"v-05c85d75#工厂方法模式介绍\",\"613\":\"v-05c85d75#工厂方法模式完成案例\",\"614\":\"v-05c85d75#什么时候该用工厂方法模式-而非简单工厂模式呢\",\"615\":\"v-05c85d75#抽象工厂-abstract-factory\",\"616\":\"v-05c85d75#基本介绍\",\"617\":\"v-05c85d75#抽象工厂模式应用实例\",\"618\":\"v-05c85d75#工厂模式在-jdk-calendar-应用的源码分析\",\"619\":\"v-05c85d75#工厂模式小结\",\"620\":\"v-05c85d75#如何设计实现一个dependency-injection框架\",\"621\":\"v-05c85d75#工厂模式和-di-容器有何区别\",\"622\":\"v-05c85d75#di-容器的核心功能有哪些\",\"623\":\"v-05c85d75#如何实现一个简单的-di-容器\",\"624\":\"v-05c85d75#最小原型设计\",\"625\":\"v-05c85d75#提供执行入口\",\"626\":\"v-05c85d75#配置文件解析\",\"627\":\"v-05c85d75#核心工厂类设计\",\"628\":\"v-5a65fcf4\",\"629\":\"v-5a65fcf4#享元模式基本介绍\",\"630\":\"v-5a65fcf4#享元模式的结构与实现\",\"631\":\"v-5a65fcf4#内部状态和外部状态\",\"632\":\"v-5a65fcf4#模式的结构\",\"633\":\"v-5a65fcf4#展示网站项目需求\",\"634\":\"v-5a65fcf4#传统方案解决网站展现项目\",\"635\":\"v-5a65fcf4#问题分析\",\"636\":\"v-5a65fcf4#享元模式解决网站展现项目\",\"637\":\"v-5a65fcf4#jdk-integer-的享元模式剖析\",\"638\":\"v-5a65fcf4#享元模式的注意事项和细节\",\"639\":\"v-5a65fcf4#享元模式的应用场景\",\"640\":\"v-26071b05\",\"641\":\"v-26071b05#解释器模式基本介绍\",\"642\":\"v-26071b05#解释器模式的结构与实现\",\"643\":\"v-26071b05#四则运算问题\",\"644\":\"v-26071b05#解释器模式来实现四则\",\"645\":\"v-26071b05#解释器模式的注意事项和细节\",\"646\":\"v-26071b05#解释器模式的应用场景\",\"647\":\"v-660b0285\",\"648\":\"v-660b0285#迭代器模式基本介绍\",\"649\":\"v-660b0285#迭代器模式的结构与实现\",\"650\":\"v-660b0285#迭代器模式应用实例\",\"651\":\"v-660b0285#jdk-arraylist-的迭代器模式剖析\",\"652\":\"v-660b0285#迭代器模式的注意事项和细节\",\"653\":\"v-660b0285#迭代器模式的应用场景\",\"654\":\"v-fd9681c0\",\"655\":\"v-fd9681c0#中介者模式基本介绍\",\"656\":\"v-fd9681c0#中介者模式的结构与实现\",\"657\":\"v-fd9681c0#智能家具项目\",\"658\":\"v-fd9681c0#传统方案解决智能家具项目\",\"659\":\"v-fd9681c0#中介者模式解决智能家庭项目\",\"660\":\"v-fd9681c0#中介者模式的注意事项和细节\",\"661\":\"v-fd9681c0#中介者模式的应用场景\",\"662\":\"v-5aed6ba6\",\"663\":\"v-5aed6ba6#备忘录模式基本介绍\",\"664\":\"v-5aed6ba6#备忘录模式的结构与实现\",\"665\":\"v-5aed6ba6#游戏角色状态恢复问题\",\"666\":\"v-5aed6ba6#传统方案解决游戏角色恢复\",\"667\":\"v-5aed6ba6#备忘录模式解决游戏角色恢复\",\"668\":\"v-5aed6ba6#备忘录模式的注意事项和细节\",\"669\":\"v-5aed6ba6#备忘录模式的应用场景\",\"670\":\"v-72940dc6\",\"671\":\"v-72940dc6#观察者模式基本介绍\",\"672\":\"v-72940dc6#观察者模式的结构与实现\",\"673\":\"v-72940dc6#天气预报项目需求\",\"674\":\"v-72940dc6#普通方案解决天气预报需求\",\"675\":\"v-72940dc6#逻辑分析\",\"676\":\"v-72940dc6#代码实现\",\"677\":\"v-72940dc6#问题分析\",\"678\":\"v-72940dc6#观察者模式解决天气预报需求\",\"679\":\"v-72940dc6#jdk-的观察者模式剖析\",\"680\":\"v-72940dc6#观察者模式的应用场景\",\"681\":\"v-7dc0f6dd\",\"682\":\"v-7dc0f6dd#原型模式基本介绍\",\"683\":\"v-7dc0f6dd#原型模式原理结构图\",\"684\":\"v-7dc0f6dd#克隆羊案例\",\"685\":\"v-7dc0f6dd#传统方式解决克隆羊实例\",\"686\":\"v-7dc0f6dd#传统的方式的优缺点\",\"687\":\"v-7dc0f6dd#原型模式解决克隆羊实例\",\"688\":\"v-7dc0f6dd#spring-框架的原型模式\",\"689\":\"v-7dc0f6dd#深入讨论-浅拷贝和深拷贝\",\"690\":\"v-7dc0f6dd#原型模式的注意事项和细节\",\"691\":\"v-1902a411\",\"692\":\"v-1902a411#代理模式的基本介绍\",\"693\":\"v-1902a411#静态代理\",\"694\":\"v-1902a411#静态代理基本介绍\",\"695\":\"v-1902a411#静态代理应用实例\",\"696\":\"v-1902a411#静态代理优缺点\",\"697\":\"v-1902a411#动态代理\",\"698\":\"v-1902a411#动态代理基本介绍\",\"699\":\"v-1902a411#jdk-中生成代理对象的-api\",\"700\":\"v-1902a411#动态代理应用实例\",\"701\":\"v-1902a411#cglib-代理\",\"702\":\"v-1902a411#cglib-代理基本介绍\",\"703\":\"v-1902a411#cglib-代理模式应用实例\",\"704\":\"v-1902a411#几种常见的代理模式介绍\",\"705\":\"v-1902a411#代理模式的应用场景\",\"706\":\"v-d8e95536\",\"707\":\"v-d8e95536#职责链模式基本介绍\",\"708\":\"v-d8e95536#职责链模式的结构与实现\",\"709\":\"v-d8e95536#学校-oa-系统的采购审批项目\",\"710\":\"v-d8e95536#职责链模式解决采购审批项目\",\"711\":\"v-d8e95536#职责链模式的注意事项和细节\",\"712\":\"v-d8e95536#职责链模式的应用场景\",\"713\":\"v-72c7365c\",\"714\":\"v-72c7365c#设计模式七大原则\",\"715\":\"v-72c7365c#单一职责原则-srp\",\"716\":\"v-72c7365c#基本介绍\",\"717\":\"v-72c7365c#单一职责原则的优点\",\"718\":\"v-72c7365c#应用实例\",\"719\":\"v-72c7365c#单一职责原则注意事项和细节\",\"720\":\"v-72c7365c#接口隔离原则-isp\",\"721\":\"v-72c7365c#基本介绍-1\",\"722\":\"v-72c7365c#接口隔离原则的优点\",\"723\":\"v-72c7365c#应用实例-1\",\"724\":\"v-72c7365c#依赖倒转原则-dip\",\"725\":\"v-72c7365c#基本介绍-2\",\"726\":\"v-72c7365c#依赖倒转原则的作用\",\"727\":\"v-72c7365c#简单应用实例\",\"728\":\"v-72c7365c#依赖关系传递的三种方式和应用案例\",\"729\":\"v-72c7365c#依赖倒转原则的注意事项和细节\",\"730\":\"v-72c7365c#里氏替换原则-lsp\",\"731\":\"v-72c7365c#oo-中的继承性的思考和说明\",\"732\":\"v-72c7365c#基本介绍-3\",\"733\":\"v-72c7365c#里氏替换原则的作用\",\"734\":\"v-72c7365c#应用实例-2\",\"735\":\"v-72c7365c#开闭原则-ocp\",\"736\":\"v-72c7365c#基本介绍-4\",\"737\":\"v-72c7365c#开闭原则的作用\",\"738\":\"v-72c7365c#应用示例\",\"739\":\"v-72c7365c#应用实例改进\",\"740\":\"v-72c7365c#迪米特法则-dp\",\"741\":\"v-72c7365c#基本介绍-5\",\"742\":\"v-72c7365c#应用实例-3\",\"743\":\"v-72c7365c#应用实例改进-1\",\"744\":\"v-72c7365c#迪米特法则注意事项和细节\",\"745\":\"v-72c7365c#合成复用原则-crp\",\"746\":\"v-72c7365c#设计原则核心思想\",\"747\":\"v-72c7365c#合成复用原则的重要性\",\"748\":\"v-72c7365c#总结\",\"749\":\"v-60256d6b\",\"750\":\"v-60256d6b#单例设计模式介绍\",\"751\":\"v-60256d6b#单例设计模式八种方式\",\"752\":\"v-60256d6b#饿汉式-静态常量\",\"753\":\"v-60256d6b#饿汉式-静态代码块\",\"754\":\"v-60256d6b#懒汉式-线程不安全\",\"755\":\"v-60256d6b#懒汉式-线程安全-同步方法\",\"756\":\"v-60256d6b#懒汉式-线程安全-同步代码块\",\"757\":\"v-60256d6b#双重检查\",\"758\":\"v-60256d6b#静态内部类\",\"759\":\"v-60256d6b#枚举\",\"760\":\"v-60256d6b#单例模式jdk应用\",\"761\":\"v-60256d6b#单例模式注意事项和细节说明\",\"762\":\"v-60256d6b#单例模式的应用场景\",\"763\":\"v-60256d6b#单例存在哪些问题\",\"764\":\"v-60256d6b#单例对-oop-特性的支持不友好\",\"765\":\"v-60256d6b#单例会隐藏类之间的依赖关系\",\"766\":\"v-60256d6b#单例对代码的扩展性不友好\",\"767\":\"v-60256d6b#单例对代码的可测试性不友好\",\"768\":\"v-60256d6b#单例不支持有参数的构造函数\",\"769\":\"v-60256d6b#有何替代解决方案\",\"770\":\"v-60256d6b#如何理解单例模式中的唯一性\",\"771\":\"v-60256d6b#如何实现线程唯一的单例\",\"772\":\"v-60256d6b#如何实现集群环境下的单例\",\"773\":\"v-60256d6b#如何实现一个多例模式\",\"774\":\"v-7a5d87ce\",\"775\":\"v-7a5d87ce#状态模式基本介绍\",\"776\":\"v-7a5d87ce#状态模式的结构与实现\",\"777\":\"v-7a5d87ce#app-抽奖活动问题\",\"778\":\"v-7a5d87ce#状态模式解决抽奖活动问题\",\"779\":\"v-7a5d87ce#状态模式在实际项目源码\",\"780\":\"v-7a5d87ce#状态模式的注意事项和细节\",\"781\":\"v-7a5d87ce#状态模式的应用场景\",\"782\":\"v-5d8882a0\",\"783\":\"v-5d8882a0#策略模式基本介绍\",\"784\":\"v-5d8882a0#策略模式的结构与实现\",\"785\":\"v-5d8882a0#鸭子项目\",\"786\":\"v-5d8882a0#传统方式解决鸭子项目\",\"787\":\"v-5d8882a0#传统方式代码实现\",\"788\":\"v-5d8882a0#传统方式问题分析和解决方案\",\"789\":\"v-5d8882a0#策略模式解决鸭子项目\",\"790\":\"v-5d8882a0#jdk-arrays-的策略模式剖析\",\"791\":\"v-5d8882a0#策略模式的注意事项和细节\",\"792\":\"v-5d8882a0#策略模式的应用场景\",\"793\":\"v-4b4aaf4e\",\"794\":\"v-4b4aaf4e#掌握设计模式的层次\",\"795\":\"v-4b4aaf4e#设计模式介绍\",\"796\":\"v-4b4aaf4e#设计模式的重要性\",\"797\":\"v-4b4aaf4e#设计模式的目的\",\"798\":\"v-4b4aaf4e#设计模式类型\",\"799\":\"v-4a6785aa\",\"800\":\"v-4a6785aa#模板方法模式基本介绍\",\"801\":\"v-4a6785aa#模板方法模式结构与实现\",\"802\":\"v-4a6785aa#模板方法模式解决豆浆制作问题\",\"803\":\"v-4a6785aa#模板方法模式的钩子方法\",\"804\":\"v-4a6785aa#模板方法模式的注意事项和细节\",\"805\":\"v-4a6785aa#模板方法模式的应用场景\",\"806\":\"v-32e615c6\",\"807\":\"v-32e615c6#基于接口而非实现编程\",\"808\":\"v-32e615c6#如何解读原则中的「接口」二字\",\"809\":\"v-32e615c6#如何将这条原则应用到实战中\",\"810\":\"v-32e615c6#是否需要为每个类定义接口\",\"811\":\"v-32e615c6#多用组合少用继承\",\"812\":\"v-32e615c6#为什么不推荐使用继承\",\"813\":\"v-32e615c6#组合相比继承有哪些优势\",\"814\":\"v-32e615c6#如何判断该用组合还是继承\",\"815\":\"v-32e615c6#通过封装、抽象、模块化、中间层等解耦代码\",\"816\":\"v-32e615c6#解耦为何如此重要\",\"817\":\"v-32e615c6#代码是否需要解耦\",\"818\":\"v-32e615c6#如何给代码解耦\",\"819\":\"v-32e615c6#代码复用\",\"820\":\"v-32e615c6#扩展性\",\"821\":\"v-379fc8cc\",\"822\":\"v-379fc8cc#uml-基本介绍\",\"823\":\"v-379fc8cc#应用场景\",\"824\":\"v-379fc8cc#基本构件\",\"825\":\"v-379fc8cc#uml-接口\",\"826\":\"v-379fc8cc#uml-类图\",\"827\":\"v-379fc8cc#类之间的关系\",\"828\":\"v-379fc8cc#类图—依赖关系-dependence\",\"829\":\"v-379fc8cc#小结\",\"830\":\"v-379fc8cc#类图—关联关系-association\",\"831\":\"v-379fc8cc#类图—聚合关系-aggregation\",\"832\":\"v-379fc8cc#类图—组合关系-composition\",\"833\":\"v-379fc8cc#类图—泛化关系-generalization\",\"834\":\"v-379fc8cc#类图—实现关系-implementation\",\"835\":\"v-379fc8cc#类与类箭头技巧\",\"836\":\"v-6a6fd891\",\"837\":\"v-6a6fd891#访问者模式基本介绍\",\"838\":\"v-6a6fd891#访问者模式的结构与实现\",\"839\":\"v-6a6fd891#访问者模式应用实例\",\"840\":\"v-6a6fd891#访问者模式的注意事项和细节\",\"841\":\"v-6a6fd891#访问者模式的应用场景\",\"842\":\"v-72edcc3e\",\"843\":\"v-72edcc3e#前言\",\"844\":\"v-72edcc3e#一、编程规约\",\"845\":\"v-72edcc3e#一-命名风格\",\"846\":\"v-72edcc3e#二-常量定义\",\"847\":\"v-72edcc3e#三-代码格式\",\"848\":\"v-72edcc3e#四-oop规约\",\"849\":\"v-72edcc3e#五-日期时间\",\"850\":\"v-72edcc3e#六-集合处理\",\"851\":\"v-72edcc3e#七-并发处理\",\"852\":\"v-72edcc3e#八-控制语句\",\"853\":\"v-72edcc3e#九-注释规约\",\"854\":\"v-72edcc3e#十-前后端规约\",\"855\":\"v-72edcc3e#十一-其他\",\"856\":\"v-72edcc3e#二、异常日志\",\"857\":\"v-72edcc3e#一-错误码\",\"858\":\"v-72edcc3e#二-异常处理\",\"859\":\"v-72edcc3e#三-日志规约\",\"860\":\"v-72edcc3e#三、单元测试\",\"861\":\"v-72edcc3e#四、安全规约\",\"862\":\"v-72edcc3e#五、mysql数据库\",\"863\":\"v-72edcc3e#一-建表规约\",\"864\":\"v-72edcc3e#二-索引规约\",\"865\":\"v-72edcc3e#三-sql语句\",\"866\":\"v-72edcc3e#四-orm映射\",\"867\":\"v-72edcc3e#六、工程结构\",\"868\":\"v-72edcc3e#一-应用分层\",\"869\":\"v-72edcc3e#二-二方库依赖\",\"870\":\"v-72edcc3e#三-服务器\",\"871\":\"v-72edcc3e#七、设计规约\",\"872\":\"v-72edcc3e#附-1-版本历史\",\"873\":\"v-72edcc3e#附-2-专有名词解释\",\"874\":\"v-72edcc3e#附-3-错误码列表\",\"875\":\"v-56af3e42\",\"876\":\"v-56af3e42#简介\",\"877\":\"v-56af3e42#术语说明\",\"878\":\"v-56af3e42#指南说明\",\"879\":\"v-56af3e42#源文件准则\",\"880\":\"v-56af3e42#文件名\",\"881\":\"v-56af3e42#文件编码-utf-8\",\"882\":\"v-56af3e42#特殊字符\",\"883\":\"v-56af3e42#空格字符\",\"884\":\"v-56af3e42#特殊转义序列\",\"885\":\"v-56af3e42#非-ascii-字符\",\"886\":\"v-56af3e42#源文件结构\",\"887\":\"v-56af3e42#license-或者-copyright-信息\",\"888\":\"v-56af3e42#package-语句\",\"889\":\"v-56af3e42#import-语句\",\"890\":\"v-56af3e42#不允许通配符\",\"891\":\"v-56af3e42#不允许换行\",\"892\":\"v-56af3e42#顺序和间隔\",\"893\":\"v-56af3e42#不允许类的静态导入\",\"894\":\"v-56af3e42#class-定义\",\"895\":\"v-56af3e42#有且仅有一个顶级类的声明\",\"896\":\"v-56af3e42#类内容顺序\",\"897\":\"v-56af3e42#方法重载-不应被分离\",\"898\":\"v-56af3e42#格式化\",\"899\":\"v-56af3e42#花括号\",\"900\":\"v-56af3e42#可选花括号的使用\",\"901\":\"v-56af3e42#非空语句块-k-r-风格\",\"902\":\"v-56af3e42#空语句块-可以简洁\",\"903\":\"v-56af3e42#块缩进-2-个空格\",\"904\":\"v-56af3e42#一条语句占一行\",\"905\":\"v-56af3e42#列限制-100\",\"906\":\"v-56af3e42#换行\",\"907\":\"v-56af3e42#在何处换行\",\"908\":\"v-56af3e42#换行缩进至少-4-个空格\",\"909\":\"v-56af3e42#空格\",\"910\":\"v-56af3e42#垂直空格\",\"911\":\"v-56af3e42#水平空格\",\"912\":\"v-56af3e42#水平对齐-从不要求\",\"913\":\"v-56af3e42#分组括号-推荐\",\"914\":\"v-56af3e42#特定结构\",\"915\":\"v-56af3e42#枚举类\",\"916\":\"v-56af3e42#变量声明\",\"917\":\"v-56af3e42#每次声明一个变量\",\"918\":\"v-56af3e42#在需要时声明\",\"919\":\"v-56af3e42#数组\",\"920\":\"v-56af3e42#数组初始化-可以写成块状结构\",\"921\":\"v-56af3e42#拒绝使用-c-语言式的声明\",\"922\":\"v-56af3e42#switch-语句\",\"923\":\"v-56af3e42#缩进\",\"924\":\"v-56af3e42#fall-through-需要注释\",\"925\":\"v-56af3e42#default-分支-需要存在\",\"926\":\"v-56af3e42#注解\",\"927\":\"v-56af3e42#用于类型的注解\",\"928\":\"v-56af3e42#用于类的注解\",\"929\":\"v-56af3e42#用于方法和构造方法的注解\",\"930\":\"v-56af3e42#用于字段的注解\",\"931\":\"v-56af3e42#用于参数和局部变量的注解\",\"932\":\"v-56af3e42#注释\",\"933\":\"v-56af3e42#注释块样式\",\"934\":\"v-56af3e42#修饰符\",\"935\":\"v-56af3e42#数字字面量\",\"936\":\"v-56af3e42#命名\",\"937\":\"v-56af3e42#适用于所有标识符的通用规则\",\"938\":\"v-56af3e42#各种类型的标识符的规则\",\"939\":\"v-56af3e42#包名\",\"940\":\"v-56af3e42#类名\",\"941\":\"v-56af3e42#方法名\",\"942\":\"v-56af3e42#常量名\",\"943\":\"v-56af3e42#非常量字段名\",\"944\":\"v-56af3e42#参数名\",\"945\":\"v-56af3e42#局部变量名\",\"946\":\"v-56af3e42#类型变量名\",\"947\":\"v-56af3e42#骆驼峰形式-定义\",\"948\":\"v-56af3e42#编程实践\",\"949\":\"v-56af3e42#override-总是使用\",\"950\":\"v-56af3e42#捕获异常-不能忽略\",\"951\":\"v-56af3e42#静态成员-限定使用类\",\"952\":\"v-56af3e42#finalizers-禁用\",\"953\":\"v-56af3e42#javadoc\",\"954\":\"v-56af3e42#格式化-1\",\"955\":\"v-56af3e42#一般形式\",\"956\":\"v-56af3e42#段落\",\"957\":\"v-56af3e42#块标签\",\"958\":\"v-56af3e42#摘要片段\",\"959\":\"v-56af3e42#在何处使用-javadoc\",\"960\":\"v-56af3e42#特殊情况-自解释的成员\",\"961\":\"v-56af3e42#特殊情况-重写\",\"962\":\"v-56af3e42#非必需的-javadoc\",\"963\":\"v-7c15438d\",\"964\":\"v-1d64c9ca\",\"965\":\"v-2c847d26\",\"966\":\"v-ba136d28\",\"967\":\"v-51157dd4\",\"968\":\"v-ea902450\",\"969\":\"v-ea902450#什么是junit\",\"970\":\"v-ea902450#junit特点\",\"971\":\"v-ea902450#官方资料\",\"972\":\"v-ea902450#常用注解\",\"973\":\"v-ea902450#编写单元测试\",\"974\":\"v-ea902450#maven包引入\",\"975\":\"v-ea902450#测试-hello-world\",\"976\":\"v-ea902450#测试-生命周期\",\"977\":\"v-ea902450#测试-禁用测试\",\"978\":\"v-ea902450#测试-断言测试\",\"979\":\"v-ea902450#测试-异常测试\",\"980\":\"v-ea902450#测试-时间测试\",\"981\":\"v-ea902450#测试-参数化测试\",\"982\":\"v-ea902450#测试-套件测试\",\"983\":\"v-ea902450#测试-测试顺序\",\"984\":\"v-ea902450#参考文章\",\"985\":\"v-55fde6b6\",\"986\":\"v-07ea442c\",\"987\":\"v-0995ea93\",\"988\":\"v-595dbbce\",\"989\":\"v-595dbbce#什么是单元测试\",\"990\":\"v-595dbbce#为什么要写单元测试\",\"991\":\"v-595dbbce#什么时候写单元测试\",\"992\":\"v-595dbbce#单元测试要写多细\",\"993\":\"v-595dbbce#有哪些单元测试相关的概念\",\"994\":\"v-595dbbce#被测系统\",\"995\":\"v-595dbbce#测试依赖组件-doc\",\"996\":\"v-595dbbce#测试替身-test-double\",\"997\":\"v-595dbbce#test-fixture\",\"998\":\"v-595dbbce#测试用例-test-case\",\"999\":\"v-595dbbce#测试套件\",\"1000\":\"v-595dbbce#参考文章\",\"1001\":\"v-7ec73772\",\"1002\":\"v-2d0aa3fe\",\"1003\":\"v-38e624d6\",\"1004\":\"v-1303aad4\",\"1005\":\"v-7ae9a406\",\"1006\":\"v-9073e716\",\"1007\":\"v-35698e3e\",\"1008\":\"v-40fc1882\",\"1009\":\"v-5d9147d8\",\"1010\":\"v-2ae57e6e\",\"1011\":\"v-5222f211\",\"1012\":\"v-5bb56591\",\"1013\":\"v-1891b76b\",\"1014\":\"v-114ea066\",\"1015\":\"v-e867e24a\",\"1016\":\"v-27762a11\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,28],\"1\":[1],\"2\":[1],\"3\":[1],\"4\":[1],\"5\":[1,5],\"6\":[1,18],\"7\":[1,7],\"8\":[2,11],\"9\":[2,8],\"10\":[2,13],\"11\":[2,11],\"12\":[2,10],\"13\":[1,18],\"14\":[1,26],\"15\":[1,1],\"16\":[1,3],\"17\":[1,3],\"18\":[1,3],\"19\":[1,3],\"20\":[1,5],\"21\":[1,2],\"22\":[1,1],\"23\":[1,1],\"24\":[1,1],\"25\":[1,1],\"26\":[2,1],\"27\":[1,1],\"28\":[1,1],\"29\":[1,3],\"30\":[1,3],\"31\":[1,3],\"32\":[1,20],\"33\":[1,17],\"34\":[1,16],\"35\":[1],\"36\":[1,106],\"37\":[1],\"38\":[1],\"39\":[1],\"40\":[1],\"41\":[1,4],\"42\":[1,10],\"43\":[1,21],\"44\":[2,17],\"45\":[2],\"46\":[5],\"47\":[4,9],\"48\":[6,9],\"49\":[6,4],\"50\":[8,9],\"51\":[6,24],\"52\":[4,9],\"53\":[3,9],\"54\":[1,9],\"55\":[2,9],\"56\":[1,4],\"57\":[2,5],\"58\":[2,9],\"59\":[3,22],\"60\":[5,5],\"61\":[3,5],\"62\":[3,13],\"63\":[7,8],\"64\":[2,5],\"65\":[4,7],\"66\":[2,6],\"67\":[4,8],\"68\":[3,86],\"69\":[3,18],\"70\":[3,19],\"71\":[5,129],\"72\":[5,23],\"73\":[5,40],\"74\":[1,31],\"75\":[1,32],\"76\":[3,36],\"77\":[1,158],\"78\":[1,51],\"79\":[3],\"80\":[2,65],\"81\":[3,38],\"82\":[1,65],\"83\":[2,45],\"84\":[2,24],\"85\":[4,55],\"86\":[10,85],\"87\":[2,39],\"88\":[1,18],\"89\":[2,70],\"90\":[2,60],\"91\":[2,80],\"92\":[2,69],\"93\":[2,89],\"94\":[1,11],\"95\":[1,40],\"96\":[1,74],\"97\":[1],\"98\":[3,17],\"99\":[1,6],\"100\":[1,19],\"101\":[1,12],\"102\":[1,24],\"103\":[1,133],\"104\":[3,395],\"105\":[2,42],\"106\":[2,73],\"107\":[1,3],\"108\":[1,6],\"109\":[1,5],\"110\":[1,14],\"111\":[1,18],\"112\":[1,3],\"113\":[1,32],\"114\":[1,256],\"115\":[1,20],\"116\":[1,45],\"117\":[1,2],\"118\":[1],\"119\":[1,24],\"120\":[1,123],\"121\":[1],\"122\":[1,32],\"123\":[1,49],\"124\":[4,19],\"125\":[3,95],\"126\":[1],\"127\":[1,51],\"128\":[3,17],\"129\":[1,30],\"130\":[1,56],\"131\":[1],\"132\":[1,71],\"133\":[1,138],\"134\":[1,37],\"135\":[1,24],\"136\":[2],\"137\":[1,29],\"138\":[2,68],\"139\":[2,71],\"140\":[2,21],\"141\":[2,94],\"142\":[1],\"143\":[1,37],\"144\":[1,96],\"145\":[1,224],\"146\":[1,28],\"147\":[1,19],\"148\":[1,11],\"149\":[1],\"150\":[2,59],\"151\":[4,48],\"152\":[3,28],\"153\":[1,16],\"154\":[3,4],\"155\":[1,20],\"156\":[1,1],\"157\":[2],\"158\":[3,6],\"159\":[5,10],\"160\":[7,3],\"161\":[9,22],\"162\":[11,5],\"163\":[8,17],\"164\":[5,11],\"165\":[7,30],\"166\":[6,11],\"167\":[9,3],\"168\":[5,9],\"169\":[7,8],\"170\":[6,14],\"171\":[3,5],\"172\":[1,3],\"173\":[6,30],\"174\":[2,8],\"175\":[3,12],\"176\":[5,7],\"177\":[4,5],\"178\":[7,9],\"179\":[6,12],\"180\":[7,22],\"181\":[8,61],\"182\":[6,25],\"183\":[4,17],\"184\":[2,11],\"185\":[7,15],\"186\":[6,42],\"187\":[8,48],\"188\":[3,21],\"189\":[4,11],\"190\":[2,12],\"191\":[1,15],\"192\":[2,18],\"193\":[1,10],\"194\":[1,27],\"195\":[1,6],\"196\":[1,12],\"197\":[1,22],\"198\":[1,39],\"199\":[2,9],\"200\":[3,14],\"201\":[1,22],\"202\":[1,2],\"203\":[1,17],\"204\":[2,22],\"205\":[1,12],\"206\":[1,13],\"207\":[1,4],\"208\":[1],\"209\":[1,79],\"210\":[1,28],\"211\":[1,51],\"212\":[1,8],\"213\":[3,17],\"214\":[3,18],\"215\":[3,15],\"216\":[3,17],\"217\":[3,24],\"218\":[3,30],\"219\":[1,44],\"220\":[1,11],\"221\":[1,46],\"222\":[1,37],\"223\":[2,20],\"224\":[2,32],\"225\":[2,121],\"226\":[1,13],\"227\":[2,53],\"228\":[3,80],\"229\":[2,25],\"230\":[2,55],\"231\":[4,4],\"232\":[4,8],\"233\":[1,64],\"234\":[1,108],\"235\":[1,3],\"236\":[2,48],\"237\":[2,19],\"238\":[2,17],\"239\":[1,3],\"240\":[2,4],\"241\":[2,81],\"242\":[2,259],\"243\":[1,31],\"244\":[1,9],\"245\":[1,19],\"246\":[1,16],\"247\":[3,29],\"248\":[3,34],\"249\":[6,25],\"250\":[1,3],\"251\":[1,27],\"252\":[3,77],\"253\":[3,51],\"254\":[1,18],\"255\":[1,6],\"256\":[2,24],\"257\":[3,71],\"258\":[2,35],\"259\":[3,65],\"260\":[1,35],\"261\":[1,60],\"262\":[1,24],\"263\":[1,36],\"264\":[7,83],\"265\":[1,57],\"266\":[1,29],\"267\":[1,39],\"268\":[3,32],\"269\":[1,32],\"270\":[1,64],\"271\":[1,37],\"272\":[1,7],\"273\":[2,22],\"274\":[1,4],\"275\":[2,215],\"276\":[3,71],\"277\":[1,32],\"278\":[1,22],\"279\":[1,66],\"280\":[1,11],\"281\":[1,67],\"282\":[1,42],\"283\":[1,61],\"284\":[1,193],\"285\":[1,69],\"286\":[1,3],\"287\":[2,71],\"288\":[2,68],\"289\":[2,110],\"290\":[2,135],\"291\":[2,177],\"292\":[2,14],\"293\":[2,36],\"294\":[3,100],\"295\":[3,50],\"296\":[2,25],\"297\":[2,66],\"298\":[2,70],\"299\":[1,53],\"300\":[1,13],\"301\":[1,35],\"302\":[1,109],\"303\":[1,13],\"304\":[1,19],\"305\":[1,191],\"306\":[1,181],\"307\":[1,175],\"308\":[1,194],\"309\":[1,59],\"310\":[1,490],\"311\":[1,162],\"312\":[3,391],\"313\":[1,23],\"314\":[1,38],\"315\":[3],\"316\":[2],\"317\":[2],\"318\":[4],\"319\":[2],\"320\":[4],\"321\":[3],\"322\":[4],\"323\":[2],\"324\":[3],\"325\":[6],\"326\":[4],\"327\":[4],\"328\":[5],\"329\":[3],\"330\":[4],\"331\":[3],\"332\":[6],\"333\":[3],\"334\":[3],\"335\":[3],\"336\":[2],\"337\":[1],\"338\":[3],\"339\":[3],\"340\":[5],\"341\":[3],\"342\":[3],\"343\":[3],\"344\":[3],\"345\":[3],\"346\":[3],\"347\":[3],\"348\":[3],\"349\":[5],\"350\":[3],\"351\":[4],\"352\":[3],\"353\":[6],\"354\":[3],\"355\":[3],\"356\":[5],\"357\":[3],\"358\":[3],\"359\":[1],\"360\":[5],\"361\":[3],\"362\":[3],\"363\":[2],\"364\":[3],\"365\":[3],\"366\":[4],\"367\":[4],\"368\":[3],\"369\":[3],\"370\":[3],\"371\":[3],\"372\":[3],\"373\":[3],\"374\":[4],\"375\":[3],\"376\":[3],\"377\":[3],\"378\":[3],\"379\":[3],\"380\":[3],\"381\":[4],\"382\":[1],\"383\":[1,7],\"384\":[1,24],\"385\":[1,21],\"386\":[1,13],\"387\":[1,15],\"388\":[1,16],\"389\":[1,8],\"390\":[1,6],\"391\":[1,12],\"392\":[1,26],\"393\":[1,6],\"394\":[1,29],\"395\":[1,14],\"396\":[1,13],\"397\":[1,12],\"398\":[1,31],\"399\":[1,23],\"400\":[1,17],\"401\":[1,33],\"402\":[1,19],\"403\":[1,27],\"404\":[1,13],\"405\":[1,7],\"406\":[1,29],\"407\":[1,26],\"408\":[1,29],\"409\":[1,21],\"410\":[1,7],\"411\":[1,23],\"412\":[1,19],\"413\":[1,26],\"414\":[1,58],\"415\":[1,23],\"416\":[1,15],\"417\":[1,6],\"418\":[1,18],\"419\":[1,48],\"420\":[1,39],\"421\":[1,22],\"422\":[1,16],\"423\":[1,17],\"424\":[1,41],\"425\":[1,9],\"426\":[1,19],\"427\":[1,43],\"428\":[1,12],\"429\":[1,23],\"430\":[1,25],\"431\":[1,72],\"432\":[1,52],\"433\":[1,16],\"434\":[1,60],\"435\":[1,8],\"436\":[1],\"437\":[1,11],\"438\":[1,16],\"439\":[1,10],\"440\":[1,88],\"441\":[1,2],\"442\":[1,42],\"443\":[2,18],\"444\":[1,7],\"445\":[1,45],\"446\":[3,45],\"447\":[3,20],\"448\":[1,17],\"449\":[2,39],\"450\":[2,64],\"451\":[3,64],\"452\":[5,31],\"453\":[1,18],\"454\":[1,11],\"455\":[1,33],\"456\":[1,5],\"457\":[1,27],\"458\":[1,60],\"459\":[2,46],\"460\":[2,23],\"461\":[2,22],\"462\":[2,22],\"463\":[1,6],\"464\":[2,5],\"465\":[2,25],\"466\":[1,72],\"467\":[1,23],\"468\":[2,20],\"469\":[1,77],\"470\":[2,15],\"471\":[1,30],\"472\":[2,50],\"473\":[1,19],\"474\":[1,48],\"475\":[1,3],\"476\":[2,17],\"477\":[1,64],\"478\":[1,30],\"479\":[1],\"480\":[2,24],\"481\":[1,17],\"482\":[1,15],\"483\":[3,14],\"484\":[2,57],\"485\":[3,53],\"486\":[1,4],\"487\":[1,7],\"488\":[1,15],\"489\":[1,14],\"490\":[3],\"491\":[2],\"492\":[2],\"493\":[2],\"494\":[2],\"495\":[3],\"496\":[2],\"497\":[2],\"498\":[2],\"499\":[2],\"500\":[2],\"501\":[2],\"502\":[2],\"503\":[2],\"504\":[2],\"505\":[2],\"506\":[2],\"507\":[2],\"508\":[2],\"509\":[2],\"510\":[2],\"511\":[2],\"512\":[2],\"513\":[1],\"514\":[3],\"515\":[3],\"516\":[3],\"517\":[1],\"518\":[1,40],\"519\":[1,17],\"520\":[1,12],\"521\":[1,7],\"522\":[1],\"523\":[1,10],\"524\":[1,81],\"525\":[1,21],\"526\":[1],\"527\":[1,28],\"528\":[1,97],\"529\":[1,12],\"530\":[1],\"531\":[1,13],\"532\":[1,78],\"533\":[2,24],\"534\":[1,26],\"535\":[1,7],\"536\":[1],\"537\":[1,52],\"538\":[1,55],\"539\":[1,9],\"540\":[1,3],\"541\":[1,14],\"542\":[1,67],\"543\":[2,16],\"544\":[1,19],\"545\":[1,45],\"546\":[1,21],\"547\":[1,12],\"548\":[1],\"549\":[1,80],\"550\":[1,22],\"551\":[1,22],\"552\":[1,10],\"553\":[1,35],\"554\":[1,19],\"555\":[1,95],\"556\":[3,27],\"557\":[1,39],\"558\":[1,24],\"559\":[1],\"560\":[1,102],\"561\":[1,64],\"562\":[1,139],\"563\":[2,34],\"564\":[1,30],\"565\":[1,25],\"566\":[1],\"567\":[1,44],\"568\":[1,31],\"569\":[1,17],\"570\":[1,10],\"571\":[1,59],\"572\":[1,8],\"573\":[1,26],\"574\":[1,100],\"575\":[2,7],\"576\":[1,21],\"577\":[1,5],\"578\":[1],\"579\":[1,46],\"580\":[1,67],\"581\":[1,25],\"582\":[4,32],\"583\":[4,33],\"584\":[1,86],\"585\":[3,36],\"586\":[1,33],\"587\":[1],\"588\":[1,3],\"589\":[1,37],\"590\":[1,58],\"591\":[1,120],\"592\":[1],\"593\":[1,58],\"594\":[1,8],\"595\":[1,15],\"596\":[1,34],\"597\":[1,20],\"598\":[1],\"599\":[1,2],\"600\":[1,31],\"601\":[1,89],\"602\":[2,10],\"603\":[1,26],\"604\":[1,8],\"605\":[1],\"606\":[1,44],\"607\":[4],\"608\":[1,71],\"609\":[1,85],\"610\":[1,69],\"611\":[4],\"612\":[1,52],\"613\":[1,113],\"614\":[3,62],\"615\":[4],\"616\":[1,61],\"617\":[1,83],\"618\":[4,123],\"619\":[1,23],\"620\":[2,30],\"621\":[3,32],\"622\":[2,148],\"623\":[4,11],\"624\":[1,65],\"625\":[1,81],\"626\":[1,65],\"627\":[1,138],\"628\":[1],\"629\":[1,50],\"630\":[1],\"631\":[1,50],\"632\":[1,107],\"633\":[1,11],\"634\":[1,3],\"635\":[1,20],\"636\":[1,88],\"637\":[3,66],\"638\":[1,32],\"639\":[1,24],\"640\":[1],\"641\":[1,49],\"642\":[1,64],\"643\":[1,30],\"644\":[1,164],\"645\":[1,10],\"646\":[1,24],\"647\":[1],\"648\":[1,46],\"649\":[1,88],\"650\":[1,140],\"651\":[3,28],\"652\":[1,27],\"653\":[1,10],\"654\":[1],\"655\":[1,91],\"656\":[1,76],\"657\":[1,16],\"658\":[1,18],\"659\":[1,126],\"660\":[1,14],\"661\":[1,5],\"662\":[1],\"663\":[1,56],\"664\":[1,57],\"665\":[1,9],\"666\":[1,15],\"667\":[1,66],\"668\":[1,10],\"669\":[1,15],\"670\":[1],\"671\":[1,39],\"672\":[1,76],\"673\":[1,11],\"674\":[1],\"675\":[1,22],\"676\":[1,67],\"677\":[1,18],\"678\":[1,133],\"679\":[2,24],\"680\":[1,20],\"681\":[1],\"682\":[1,51],\"683\":[1,17],\"684\":[1,12],\"685\":[1,49],\"686\":[1,27],\"687\":[1,73],\"688\":[2,7],\"689\":[2,152],\"690\":[1,18],\"691\":[1],\"692\":[1,57],\"693\":[1],\"694\":[1,28],\"695\":[1,68],\"696\":[1,8],\"697\":[1],\"698\":[1,14],\"699\":[3,45],\"700\":[1,103],\"701\":[2],\"702\":[2,71],\"703\":[2,106],\"704\":[1,20],\"705\":[1,33],\"706\":[1],\"707\":[1,88],\"708\":[1,75],\"709\":[3,37],\"710\":[1,97],\"711\":[1,19],\"712\":[1,7],\"713\":[1],\"714\":[1,17],\"715\":[3],\"716\":[1,60],\"717\":[1,18],\"718\":[1,68],\"719\":[1,11],\"720\":[3],\"721\":[1,46],\"722\":[1,28],\"723\":[1,71],\"724\":[3],\"725\":[1,33],\"726\":[1,5],\"727\":[1,74],\"728\":[1,70],\"729\":[1,11],\"730\":[3],\"731\":[2,22],\"732\":[1,86],\"733\":[1,11],\"734\":[1,92],\"735\":[3],\"736\":[1,54],\"737\":[1,18],\"738\":[1,71],\"739\":[1,66],\"740\":[3],\"741\":[1,152],\"742\":[1,95],\"743\":[1,87],\"744\":[1,10],\"745\":[3,39],\"746\":[1,6],\"747\":[1,30],\"748\":[1,66],\"749\":[1],\"750\":[1,70],\"751\":[1,12],\"752\":[3,78],\"753\":[3,49],\"754\":[3,53],\"755\":[4,54],\"756\":[4,40],\"757\":[1,60],\"758\":[1,61],\"759\":[1,44],\"760\":[1,22],\"761\":[1,24],\"762\":[1,34],\"763\":[1,31],\"764\":[3,64],\"765\":[1,18],\"766\":[1,49],\"767\":[1,26],\"768\":[1,85],\"769\":[1,91],\"770\":[1,66],\"771\":[1,88],\"772\":[2,86],\"773\":[2,101],\"774\":[1],\"775\":[1,83],\"776\":[1,62],\"777\":[2,15],\"778\":[1,156],\"779\":[1,155],\"780\":[1,19],\"781\":[1,6],\"782\":[1],\"783\":[1,76],\"784\":[1,63],\"785\":[1,9],\"786\":[1,4],\"787\":[1,26],\"788\":[1,50],\"789\":[1,95],\"790\":[3,93],\"791\":[1,33],\"792\":[1,20],\"793\":[1],\"794\":[1,23],\"795\":[1,33],\"796\":[1,55],\"797\":[1,80],\"798\":[1,142],\"799\":[1],\"800\":[1,71],\"801\":[1,61],\"802\":[1,18],\"803\":[1,77],\"804\":[1,22],\"805\":[1,16],\"806\":[1],\"807\":[1,4],\"808\":[3,85],\"809\":[1,220],\"810\":[1,52],\"811\":[1,12],\"812\":[1,150],\"813\":[1,89],\"814\":[1,133],\"815\":[4],\"816\":[1,58],\"817\":[1,30],\"818\":[1,141],\"819\":[1,61],\"820\":[1,49],\"821\":[1],\"822\":[2,53],\"823\":[1,46],\"824\":[1,15],\"825\":[2,20],\"826\":[2,70],\"827\":[1,15],\"828\":[4,44],\"829\":[1,6],\"830\":[4,56],\"831\":[4,45],\"832\":[4,83],\"833\":[4,38],\"834\":[4,36],\"835\":[1,81],\"836\":[1],\"837\":[1,71],\"838\":[1,91],\"839\":[1,114],\"840\":[1,20],\"841\":[1,21],\"842\":[3],\"843\":[1,98],\"844\":[2],\"845\":[3,273],\"846\":[3,109],\"847\":[3,183],\"848\":[3,356],\"849\":[3,148],\"850\":[3,390],\"851\":[3,282],\"852\":[3,242],\"853\":[3,147],\"854\":[3,236],\"855\":[3,87],\"856\":[2],\"857\":[3,120],\"858\":[3,179],\"859\":[3,216],\"860\":[2,159],\"861\":[2,101],\"862\":[2],\"863\":[3,182],\"864\":[3,159],\"865\":[3,168],\"866\":[3,104],\"867\":[2],\"868\":[3,115],\"869\":[3,161],\"870\":[3,84],\"871\":[2,218],\"872\":[3,184],\"873\":[3,116],\"874\":[3,370],\"875\":[3,11],\"876\":[1,18],\"877\":[1,40],\"878\":[1,10],\"879\":[1],\"880\":[1,8],\"881\":[3,5],\"882\":[1],\"883\":[1,9],\"884\":[1,18],\"885\":[3,56],\"886\":[1,15],\"887\":[4,3],\"888\":[2,9],\"889\":[2],\"890\":[1,4],\"891\":[1,10],\"892\":[1,21],\"893\":[1,3],\"894\":[2],\"895\":[1,2],\"896\":[1,13],\"897\":[2,13],\"898\":[1,12],\"899\":[1],\"900\":[1,15],\"901\":[4,57],\"902\":[2,41],\"903\":[3,14],\"904\":[1,2],\"905\":[2,51],\"906\":[1,17],\"907\":[1,72],\"908\":[3,17],\"909\":[1],\"910\":[1,36],\"911\":[1,86],\"912\":[2,56],\"913\":[2,9],\"914\":[1],\"915\":[1,28],\"916\":[1],\"917\":[1,13],\"918\":[1,10],\"919\":[1],\"920\":[2,13],\"921\":[3,6],\"922\":[2,16],\"923\":[1,13],\"924\":[3,34],\"925\":[3,16],\"926\":[1],\"927\":[1,17],\"928\":[1,15],\"929\":[1,14],\"930\":[1,11],\"931\":[1,5],\"932\":[1,10],\"933\":[1,28],\"934\":[1,16],\"935\":[1,14],\"936\":[1],\"937\":[1,22],\"938\":[1],\"939\":[1,14],\"940\":[1,21],\"941\":[1,17],\"942\":[1,82],\"943\":[1,11],\"944\":[1,6],\"945\":[1,9],\"946\":[1,16],\"947\":[2,86],\"948\":[1],\"949\":[3,13],\"950\":[2,47],\"951\":[2,12],\"952\":[2,19],\"953\":[1],\"954\":[1],\"955\":[1,31],\"956\":[1,21],\"957\":[1,14],\"958\":[1,40],\"959\":[2,16],\"960\":[2,28],\"961\":[2,3],\"962\":[2,17],\"963\":[1],\"964\":[1],\"965\":[1],\"966\":[1],\"967\":[1],\"968\":[2,4],\"969\":[2,3],\"970\":[2,20],\"971\":[1,5],\"972\":[1,122],\"973\":[1,3],\"974\":[1,67],\"975\":[3,35],\"976\":[2,62],\"977\":[2,22],\"978\":[2,170],\"979\":[2,121],\"980\":[2,119],\"981\":[2,144],\"982\":[2,38],\"983\":[2,30],\"984\":[1,24],\"985\":[2],\"986\":[2],\"987\":[1],\"988\":[1,9],\"989\":[2,16],\"990\":[2,31],\"991\":[2,37],\"992\":[2,15],\"993\":[2,13],\"994\":[1,12],\"995\":[3,10],\"996\":[4,93],\"997\":[2,49],\"998\":[4,17],\"999\":[1,19],\"1000\":[1,17],\"1001\":[1,1],\"1002\":[1],\"1003\":[1],\"1004\":[1],\"1005\":[1],\"1006\":[1],\"1007\":[1],\"1008\":[1],\"1009\":[1],\"1010\":[1],\"1011\":[1],\"1012\":[2],\"1013\":[1],\"1014\":[1],\"1015\":[2],\"1016\":[1]},\"averageFieldLength\":[1.814159292035399,44.05247152711251],\"storedFields\":{\"0\":{\"h\":\"项目主页\",\"t\":[\"这是项目主页的案例。你可以在这里放置你的主体内容。\",\"想要使用此布局，你需要在页面 front matter 中设置 home: true。\",\"配置项的相关说明详见 项目主页配置。\",\"\\\"@anyfork/vuepress-plugin-cursor-effects-next\\\": \\\"^0.1.0-beta.0\\\",\\n// \\\"@vuepress-denaro/vuepress-plugin-dynamic-title\\\": \\\"^1.0.2-alpha.0\\\",\"]},\"1\":{\"h\":\"幻灯片页\"},\"2\":{\"h\":\"数据库\"},\"3\":{\"h\":\"数据库\"},\"4\":{\"h\":\"主要功能与配置演示\"},\"5\":{\"h\":\"目录\",\"t\":[\"Markdown 展示\",\"页面展示\",\"禁用展示\",\"加密展示\"]},\"6\":{\"h\":\"布局与功能禁用\",\"t\":[\"你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。\",\"本页面就是一个示例，禁用了如下功能:\",\"导航栏\",\"侧边栏\",\"路径导航\",\"页面信息\",\"贡献者\",\"编辑此页链接\",\"更新时间\",\"上一篇/下一篇 链接\",\"评论\",\"页脚\",\"返回顶部按钮\"]},\"7\":{\"h\":\"密码加密的文章\",\"t\":[\"实际的文章内容。\",\"段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字。\",\"段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字。\"]},\"8\":{\"h\":\"Markdown 展示\",\"t\":[\"VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。\",\"你应该创建和编写 Markdown 文件，以便 VuePress 可以根据文件结构将它们转换为不同的页面。\"]},\"9\":{\"h\":\"Markdown 介绍\",\"t\":[\"如果你是一个新手，还不会编写 Markdown，请先阅读 Markdown 介绍 和 Markdown 演示。\"]},\"10\":{\"h\":\"Markdown 配置\",\"t\":[\"VuePress 通过 Frontmatter 为每个 Markdown 页面引入配置。\",\"相关信息\",\"Frontmatter 是 VuePress 中很重要的一个概念，如果你不了解它，你需要阅读 Frontmatter 介绍。\"]},\"11\":{\"h\":\"Markdown 扩展\",\"t\":[\"VuePress 会使用 markdown-it 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 语法扩展 。\"]},\"12\":{\"h\":\"VuePress 扩展\",\"t\":[\"为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。\",\"关于这些扩展，请阅读 VuePress 中的 Markdown 扩展。\"]},\"13\":{\"h\":\"主题扩展\",\"t\":[\"通过 vuepress-plugin-md-enhance，主题扩展了更多 Markdown 语法，提供更加丰富的写作功能。\",\"一键启用\",\"你可以设置在主题选项中设置 plugins.mdEnhance.enableAll: true 启用 md-enhance 插件的所有功能。\"]},\"14\":{\"h\":\"自定义容器\",\"t\":[\"安全的在 Markdown 中使用 {{ variable }}。\",\"自定义标题\",\"信息容器，包含 代码 与 链接。\",\"const a = 1; \",\"自定义标题\",\"提示容器\",\"自定义标题\",\"警告容器\",\"自定义标题\",\"危险容器\",\"自定义标题\",\"详情容器\",\"代码\",\"::: v-pre 安全的在 Markdown 中使用 {{ variable }}。 ::: ::: info 自定义标题 信息容器 ::: ::: tip 自定义标题 提示容器 ::: ::: warning 自定义标题 警告容器 ::: ::: danger 自定义标题 危险容器 ::: ::: details 自定义标题 详情容器 ::: \",\"查看详情\"]},\"15\":{\"h\":\"代码块\",\"t\":[\"查看详情\"]},\"16\":{\"h\":\"自定义对齐\",\"t\":[\"我是居中的\",\"我在右对齐\",\"查看详情\"]},\"17\":{\"h\":\"上下角标\",\"t\":[\"19th H2O\",\"查看详情\"]},\"18\":{\"h\":\"脚注\",\"t\":[\"此文字有脚注[1].\",\"查看详情\"]},\"19\":{\"h\":\"标记\",\"t\":[\"你可以标记 重要的内容 。\",\"查看详情\"]},\"20\":{\"h\":\"任务列表\",\"t\":[\" 计划 1\",\" 计划 2\",\"查看详情\"]},\"21\":{\"h\":\"图片增强\",\"t\":[\"支持为图片设置颜色模式和大小\",\"查看详情\"]},\"22\":{\"h\":\"图表\",\"t\":[\"查看详情\"]},\"23\":{\"h\":\"Echarts\",\"t\":[\"查看详情\"]},\"24\":{\"h\":\"流程图\",\"t\":[\"查看详情\"]},\"25\":{\"h\":\"Mermaid\",\"t\":[\"查看详情\"]},\"26\":{\"h\":\"Tex 语法\",\"t\":[\"查看详情\"]},\"27\":{\"h\":\"导入文件\",\"t\":[\"查看详情\"]},\"28\":{\"h\":\"代码演示\",\"t\":[\"查看详情\"]},\"29\":{\"h\":\"样式化\",\"t\":[\"设置它没有任何效果，请不要这样使用\",\"查看详情\"]},\"30\":{\"h\":\"幻灯片\",\"t\":[\"查看详情\",\"这是脚注内容 ↩︎\"]},\"31\":{\"h\":\"页面配置\",\"t\":[\"more 注释之前的内容被视为文章摘要。\"]},\"32\":{\"h\":\"页面信息\",\"t\":[\"你可以在 Markdown 的 Frontmatter 中设置页面信息。\",\"作者设置为 Ms.Hope。\",\"写作日期为 2020 年 1 月 1 日\",\"分类为 “使用指南”\",\"标签为 “页面配置” 和 “使用指南”\"]},\"33\":{\"h\":\"页面内容\",\"t\":[\"你可以自由在这里书写你的 Markdown。\",\"提示\",\"你可以将图片和 Markdown 文件放置在一起，但是你需要使用相对链接./ 进行引用。\",\"对于 .vuepress/public 文件夹的图片，请使用绝对链接 / 进行引用。\",\"主题包含了一个自定义徽章章可以使用:\",\"文字结尾应该有深蓝色的 徽章文字 徽章。 \"]},\"34\":{\"h\":\"页面结构\",\"t\":[\"此页面应当包含:\",\"路径导航\",\"标题和页面信息\",\"TOC (文章标题列表)\",\"贡献者、更新时间等页面元信息\",\"评论\",\"导航栏\",\"侧边栏\",\"页脚\",\"返回顶部按钮\",\"你可以通过主题选项和页面 Frontmatter 自定义它们。\"]},\"35\":{\"h\":\"\"},\"36\":{\"h\":\"自我提升九大招\",\"t\":[\"早睡半小时，早起10分钟\",\"许多人晚睡的原因，其实都是在刷手机。从今天开始，不把手机带上床，早睡半小时，第二天就会精神饱满。把第二天的闹钟往前调10分钟，早起10分钟做些你想做的事，读书、锻炼、做早餐，都会给你带来意想不到的提升。\",\"坚持运动\",\"运动是治愈一切的良药。那些长期坚持运动的人，都在不同程度地变好看、变自律、变优秀、变健康。开始运动吧，从多散步十分钟或者每天做10个俯卧撑开始，循序渐进，踏踏实实地完成运动任务，你一定会越来越好。\",\"欣赏别人的优点，警醒自己的缺点\",\"老话说，取他人之长，补己之短。学会用欣赏的眼光看他人，汲取他人身上的闪光点。当你看到别人的缺点时，也要警醒自己身上是否有和他相似的缺点。要记得，我们所做的所有事都是为了提升自我，而不是贬低他人。\",\"坚持读书\",\"阅读是自我提升最便捷的方式。如果你经常迷茫、时常焦虑，尝试静下心来读书吧，由内而外，让书籍的知识慢慢渗透，久而久之，看问题的角度变广了，做事情的方法更灵活了，你会爱上自己的改变。\",\"在失败中总结经验\",\"人生就是起起伏伏，想要成功，必会经历失败。不要因为一次、两次失败就郁郁寡欢，相比成功而言，失败反而能给我们更多启发和教训。在失败中总结经验，不断调整自己的思维和行为，前方的路才会越走越顺。\",\"注意仪容仪表，干净清爽最重要\",\"每个人都是先从外表认识他人的，你的内在再丰富，邋遢的外表也会让人望而却步。可以不精致，但不能不干净。每天都要认真清洁自己，穿合适的衣服，干净清爽的形象会为你加分许多。\",\"练习专注力\",\"练习在一段时间内专注于一件事，会让你做事更有效率。开始时，不妨先试着定下10-15分钟的闹钟，在这段时间里专注于一件事，慢慢提升专注力。\",\"遇到困难，想办法解决而不是抱怨\",\"遇到困难时，不要只想着抱怨。越是艰难，越是要勇于攀爬，因为每一步不好走的路，都是上坡路。当你开始着手想办法的时候，就会发现，很多事没你想象的那么难。再难的事，也总有解决办法。最难的，是你不敢踏出第一步的心。\",\"每晚复盘、反思\",\"睡前15分钟，回忆一下当天发生的事、见过的人，反思自己的行为是否妥当，是否有浪费时间，是否相对昨天有所进步。不断地复盘自己，像医生一样，先检查出自己身上的缺点、弱点，再一个个拔除治疗。复盘会成为你自我提升路上最好的帮手。\"]},\"37\":{\"h\":\"资源导航\"},\"38\":{\"h\":\"常用搜索\"},\"39\":{\"h\":\"主页\"},\"40\":{\"h\":\"流程图\"},\"41\":{\"h\":\"默认节点\",\"t\":[\"注意 id 是框中显示的内容。\"]},\"42\":{\"h\":\"文本框节点\",\"t\":[\"也可以在不同于 id 的框中设置文本。 如果多次这样做，它将是为将使用的节点找到的最后一个文本。 此外，如果您稍后为节点定义边，则可以省略文本定义。 渲染框时将使用先前定义的那个。\"]},\"43\":{\"h\":\"图形\",\"t\":[\"This statement declares the direction of the Flowchart.\",\"This declares the flowchart is oriented from top to bottom (TD or TB).\",\"This declares the flowchart is oriented from left to right (LR).\"]},\"44\":{\"h\":\"Flowchart Orientation\",\"t\":[\"Possible FlowChart orientations are:\",\"TB - top to bottom\",\"TD - top-down/ same as top to bottom\",\"BT - bottom to top\",\"RL - right to left\",\"LR - left to right\"]},\"45\":{\"h\":\"Node shapes\"},\"46\":{\"h\":\"A node with round edges\"},\"47\":{\"h\":\"A stadium-shaped node\",\"t\":[\"flowchart LR id1([This is the text in the box]) \",\"This is the text in the box\"]},\"48\":{\"h\":\"A node in a subroutine shape\",\"t\":[\"flowchart LR id1[[This is the text in the box]] \",\"This is the text in the box\"]},\"49\":{\"h\":\"A node in a cylindrical shape\",\"t\":[\"flowchart LR id1[(Database)] \",\"Database\"]},\"50\":{\"h\":\"A node in the form of a circle\",\"t\":[\"flowchart LR id1((This is the text in the circle)) \",\"This is the text in the circle\"]},\"51\":{\"h\":\"A node in an asymmetric shape\",\"t\":[\"flowchart LR id1>This is the text in the box] \",\"This is the text in the box\",\"Currently only the shape above is possible and not its mirror. This might change with future releases.\"]},\"52\":{\"h\":\"A node (rhombus)\",\"t\":[\"flowchart LR id1{This is the text in the box} \",\"This is the text in the box\"]},\"53\":{\"h\":\"A hexagon node\",\"t\":[\"flowchart LR id1{{This is the text in the box}} \",\"This is the text in the box\"]},\"54\":{\"h\":\"Parallelogram\",\"t\":[\"flowchart TD id1[/This is the text in the box/] \",\"This is the text in the box\"]},\"55\":{\"h\":\"Parallelogram alt\",\"t\":[\"flowchart TD id1[\\\\This is the text in the box\\\\] \",\"This is the text in the box\"]},\"56\":{\"h\":\"Trapezoid\",\"t\":[\"flowchart TD A[/Christmas\\\\] \",\"Christmas\"]},\"57\":{\"h\":\"Trapezoid alt\",\"t\":[\"flowchart TD B[\\\\Go shopping/] \",\"Go shopping\"]},\"58\":{\"h\":\"Double circle\",\"t\":[\"flowchart TD id1(((This is the text in the circle))) \",\"This is the text in the circle\"]},\"59\":{\"h\":\"Links between nodes\",\"t\":[\"Nodes can be connected with links/edges. It is possible to have different types of links or attach a text string to a link.\"]},\"60\":{\"h\":\"A link with arrow head\",\"t\":[\"flowchart LR A-->B \",\"AB\"]},\"61\":{\"h\":\"An open link\",\"t\":[\"flowchart LR A --- B \",\"AB\"]},\"62\":{\"h\":\"Text on links\",\"t\":[\"flowchart LR A-- This is the text! ---B \",\"This is the text!AB\",\"or\",\"flowchart LR A---|This is the text|B \",\"This is the textAB\"]},\"63\":{\"h\":\"A link with arrow head and text\",\"t\":[\"flowchart LR A-->|text|B \",\"textAB\",\"or\",\"flowchart LR A-- text -->B \",\"textAB\"]},\"64\":{\"h\":\"Dotted link\",\"t\":[\"flowchart LR; A-.->B; \",\"AB\"]},\"65\":{\"h\":\"Dotted link with text\",\"t\":[\"flowchart LR A-. text .-> B \",\"textAB\"]},\"66\":{\"h\":\"Thick link\",\"t\":[\"flowchart LR A ==> B \",\"AB\"]},\"67\":{\"h\":\"Thick link with text\",\"t\":[\"flowchart LR A == text ==> B \",\"textAB\"]},\"68\":{\"h\":\"Chaining of links\",\"t\":[\"It is possible declare many links in the same line as per below:\",\"flowchart LR A -- text --> B -- text2 --> C \",\"texttext2ABC\",\"It is also possible to declare multiple nodes links in the same line as per below:\",\"flowchart LR a --> b & c--> d \",\"abcd\",\"You can then describe dependencies in a very expressive way. Like the one-liner below:\",\"flowchart TB A & B--> C & D \",\"ABCD\",\"If you describe the same diagram using the the basic syntax, it will take four lines. A word of warning, one could go overboard with this making the flowchart harder to read in markdown form. The Swedish word lagom comes to mind. It means, not too much and not too little. This goes for expressive syntaxes as well.\",\"flowchart TB A --> C A --> D B --> C B --> D \"]},\"69\":{\"h\":\"New arrow types\",\"t\":[\"There are new types of arrows supported as per below:\",\"flowchart LR A --o B B --x C \",\"ABC\"]},\"70\":{\"h\":\"Multi directional arrows\",\"t\":[\"There is the possibility to use multidirectional arrows.\",\"flowchart LR A o--o B B <--> C C x--x D \",\"ABCD\"]},\"71\":{\"h\":\"Minimum length of a link\",\"t\":[\"Each node in the flowchart is ultimately assigned to a rank in the rendered graph, i.e. to a vertical or horizontal level (depending on the flowchart orientation), based on the nodes to which it is linked. By default, links can span any number of ranks, but you can ask for any link to be longer than the others by adding extra dashes in the link definition.\",\"In the following example, two extra dashes are added in the link from node B to node E, so that it spans two more ranks than regular links:\",\"flowchart TD A[Start] --> B{Is it?} B -->|Yes| C[OK] C --> D[Rethink] D --> B B ---->|No| E[End] \",\"YesNoStartIs it?OKRethinkEnd\",\"Note Links may still be made longer than the requested number of ranks by the rendering engine to accommodate other requests.\",\"When the link label is written in the middle of the link, the extra dashes must be added on the right side of the link. The following example is equivalent to the previous one:\",\"flowchart TD A[Start] --> B{Is it?} B -- Yes --> C[OK] C --> D[Rethink] D --> B B -- No ----> E[End] \",\"YesNoStartIs it?OKRethinkEnd\",\"For dotted or thick links, the characters to add are equals signs or dots, as summed up in the following table:\",\"Length\",\"1\",\"2\",\"3\",\"Normal\",\"---\",\"----\",\"-----\",\"Normal with arrow\",\"-->\",\"--->\",\"---->\",\"Thick\",\"===\",\"====\",\"=====\",\"Thick with arrow\",\"==>\",\"===>\",\"====>\",\"Dotted\",\"-.-\",\"-..-\",\"-...-\",\"Dotted with arrow\",\"-.->\",\"-..->\",\"-...->\"]},\"72\":{\"h\":\"Special characters that break syntax\",\"t\":[\"It is possible to put text within quotes in order to render more troublesome characters. As in the example below:\",\"flowchart LR id1[\\\"This is the (text) in the box\\\"] \",\"This is the (text) in the box\"]},\"73\":{\"h\":\"Entity codes to escape characters\",\"t\":[\"It is possible to escape characters using the syntax exemplified here.\",\" flowchart LR A[\\\"A double quote:#quot;\\\"] -->B[\\\"A dec char:#9829;\\\"] \",\"A double quote:\\\"A dec char:♥\",\"Numbers given are base 10, so # can be encoded as #35;. It is also supported to use HTML character names.\"]},\"74\":{\"h\":\"Subgraphs\",\"t\":[\"subgraph title graph definition end \",\"An example below:\",\"flowchart TB c1-->a2 subgraph one a1-->a2 end subgraph two b1-->b2 end subgraph three c1-->c2 end \",\"threeonec2c1twob2b1a2a1\",\"You can also set an explicit id for the subgraph.\",\"flowchart TB c1-->a2 subgraph ide1 [one] a1-->a2 end \",\"onea2a1c1\"]},\"75\":{\"h\":\"flowcharts\",\"t\":[\"With the graphtype flowchart it is also possible to set edges to and from subgraphs as in the flowchart below.\",\"flowchart TB c1-->a2 subgraph one a1-->a2 end subgraph two b1-->b2 end subgraph three c1-->c2 end one --> two three --> two two --> c2 \",\"threeonec2c1twob2b1a2a1\"]},\"76\":{\"h\":\"Direction in subgraphs\",\"t\":[\"With the graphtype flowcharts you can use the direction statement to set the direction which the subgraph will render like in this example.\",\"flowchart LR subgraph TOP direction TB subgraph B1 direction RL i1 -->f1 end subgraph B2 direction BT i2 -->f2 end end A --> TOP --> B B1 --> B2 \",\"TOPB1f1i1B2f2i2AB\"]},\"77\":{\"h\":\"Interaction\",\"t\":[\"It is possible to bind a click event to a node, the click can lead to either a javascript callback or to a link which will be opened in a new browser tab. Note: This functionality is disabled when using securityLevel='strict' and enabled when using securityLevel='loose'.\",\"click nodeId callback click nodeId call callback() \",\"nodeId is the id of the node\",\"callback is the name of a javascript function defined on the page displaying the graph, the function will be called with the nodeId as parameter.\",\"Examples of tooltip usage below:\",\"<script> var callback = function () { alert('A callback was triggered'); }; </script> \",\"The tooltip text is surrounded in double quotes. The styles of the tooltip are set by the class .mermaidTooltip.\",\"flowchart LR A-->B B-->C C-->D click A callback \\\"Tooltip for a callback\\\" click B \\\"https://www.github.com\\\" \\\"This is a tooltip for a link\\\" click A call callback() \\\"Tooltip for a callback\\\" click B href \\\"https://www.github.com\\\" \\\"This is a tooltip for a link\\\" \",\"ABCD\",\"Success The tooltip functionality and the ability to link to urls are available from version 0.5.2.\",\"Due to limitations with how Docsify handles JavaScript callback functions, an alternate working demo for the above code can be viewed at this jsfiddle.\",\"Links are opened in the same browser tab/window by default. It is possible to change this by adding a link target to the click definition (_self, _blank, _parent and _top are supported):\",\"flowchart LR A-->B B-->C C-->D D-->E click A \\\"https://www.github.com\\\" _blank click B \\\"https://www.github.com\\\" \\\"Open this in a new tab\\\" _blank click C href \\\"https://www.github.com\\\" _blank click D href \\\"https://www.github.com\\\" \\\"Open this in a new tab\\\" _blank \",\"ABCDE\",\"Beginners tip, a full example using interactive links in a html context:\",\"<body> <div class=\\\"mermaid\\\"> flowchart LR A-->B B-->C C-->D click A callback \\\"Tooltip\\\" click B \\\"https://www.github.com\\\" \\\"This is a link\\\" click C call callback() \\\"Tooltip\\\" click D href \\\"https://www.github.com\\\" \\\"This is a link\\\" </div> <script> var callback = function () { alert('A callback was triggered'); }; var config = { startOnLoad: true, flowchart: { useMaxWidth: true, htmlLabels: true, curve: 'cardinal' }, securityLevel:'loose' }; mermaid.initialize(config); </script> </body> \"]},\"78\":{\"h\":\"Comments\",\"t\":[\"Comments can be entered within a flow diagram, which will be ignored by the parser. Comments need to be on their own line, and must be prefaced with %% (double percent signs). Any text after the start of the comment to the next newline will be treated as a comment, including any flow syntax\",\"flowchart LR %% this is a comment A -- text --> B{node} A -- text --> B -- text2 --> C \"]},\"79\":{\"h\":\"Styling and classes\"},\"80\":{\"h\":\"Styling links\",\"t\":[\"It is possible to style links. For instance you might want to style a link that is going backwards in the flow. As links have no ids in the same way as nodes, some other way of deciding what style the links should be attached to is required. Instead of ids, the order number of when the link was defined in the graph is used, or use default to apply to all links. In the example below the style defined in the linkStyle statement will belong to the fourth link in the graph:\",\"linkStyle 3 stroke:#ff3,stroke-width:4px,color:red; \"]},\"81\":{\"h\":\"Styling a node\",\"t\":[\"It is possible to apply specific styles such as a thicker border or a different background color to a node.\",\"flowchart LR id1(Start)-->id2(Stop) style id1 fill:#f9f,stroke:#333,stroke-width:4px style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5 \",\"StartStop\"]},\"82\":{\"h\":\"Classes\",\"t\":[\"More convenient than defining the style every time is to define a class of styles and attach this class to the nodes that should have a different look.\",\"a class definition looks like the example below:\",\" classDef className fill:#f9f,stroke:#333,stroke-width:4px; \",\"Attachment of a class to a node is done as per below:\",\" class nodeId1 className; \",\"It is also possible to attach a class to a list of nodes in one statement:\",\" class nodeId1,nodeId2 className; \",\"A shorter form of adding a class is to attach the classname to the node using the :::operator as per below:\",\"flowchart LR A:::someclass --> B classDef someclass fill:#f96; \",\"AB\"]},\"83\":{\"h\":\"Css classes\",\"t\":[\"It is also possible to predefine classes in css styles that can be applied from the graph definition as in the example below:\",\"Example style\",\"<style> .cssClass > rect{ fill:#FF0000; stroke:#FFFF00; stroke-width:4px; } </style> \",\"Example definition\",\"flowchart LR; A-->B[AAA<span>BBB</span>] B-->D class A cssClass \",\"AAAABBBD\"]},\"84\":{\"h\":\"Default class\",\"t\":[\"If a class is named default it will be assigned to all classes without specific class definitions.\",\" classDef default fill:#f9f,stroke:#333,stroke-width:4px; \"]},\"85\":{\"h\":\"Basic support for fontawesome\",\"t\":[\"It is possible to add icons from fontawesome.\",\"The icons are accessed via the syntax fa:#icon class name#.\",\"flowchart TD B[\\\"fab:fa-twitter for peace\\\"] B-->C[fa:fa-ban forbidden] B-->D(fa:fa-spinner); B-->E(A fa:fa-camera-retro perhaps?) \",\"for peace forbiddenA perhaps?\",\"Mermaid is now only compatible with Font Awesome versions 4 and 5. Check that you are using the correct version of Font Awesome.\"]},\"86\":{\"h\":\"Graph declarations with spaces between vertices and link and without semicolon\",\"t\":[\"In graph declarations, the statements also can now end without a semicolon. After release 0.2.16, ending a graph statement with semicolon is just optional. So the below graph declaration is also valid along with the old declarations of the graph.\",\"A single space is allowed between vertices and the link. However there should not be any space between a vertex and its text and a link and its text. The old syntax of graph declaration will also work and hence this new feature is optional and is introduced to improve readability.\",\"Below is the new declaration of the graph edges which is also valid along with the old declaration of the graph edges.\",\"flowchart LR A[Hard edge] -->|Link text| B(Round edge) B --> C{Decision} C -->|One| D[Result one] C -->|Two| E[Result two] \",\"Link textOneTwoHard edgeRound edgeDecisionResult oneResult two\"]},\"87\":{\"h\":\"Configuration...\",\"t\":[\"Is it possible to adjust the width of the rendered flowchart.\",\"This is done by defining mermaid.flowchartConfig or by the CLI to use a JSON file with the configuration. How to use the CLI is described in the mermaidCLI page. mermaid.flowchartConfig can be set to a JSON string with config parameters or the corresponding object.\"]},\"88\":{\"h\":\"\",\"t\":[\"今天给大家分享一波 Java 中的代码作死小技巧，熟练掌握这些小技巧后，保证能让你写出同事看不懂的代码~\",\"至于为啥要写出同事看不懂的代码，我发现好处还是挺多的，简单举几个例子：\",\"同事无法轻易修改你的代码，避免团队协作不当引入 bug\",\"塑造个人能力的不可替代性，规避被辞退的风险\",\"代码 review 时，帮助同事治疗好多年的低血压\",\"图片\"]},\"89\":{\"h\":\"壹、瞒天过海\",\"t\":[\"我打赌你肯定想不到，有人居然会在注释里下了毒。看看下面的代码，简单到main方法中只有一行注释。\",\"public static void main(String[] args) { // \\\\u000d System.out.println(\\\"coder Hydra\\\"); } \",\"猜猜看，这段程序运行结果如何？执行后它居然会在控制台打印：\",\"coder Hydra \",\"看到这你是不是一脸懵逼，为什么注释中的代码会被执行？\",\"其实原理就在于大家熟悉的unicode编码，上面的\\\\u000d就是一个unicode转义字符，它所表示的是一个换行符。而java中的编译器，不仅会编译代码，还会解析unicode编码将它替换成对应的字符。所以说，上面的代码解析完后实际是这样的：\",\"public static void main(String[] args) { // System.out.println(\\\"coder Hydra\\\"); } \",\"这样，就能解释为什么能够执行注释中的语句了。当然，如果你觉得上面的代码不够绝，想要再绝一点，那么就可以把代码写成下面这个样子。\",\"public static void main(String[] args) { int a=1; // \\\\u000d \\\\u0061\\\\u002b\\\\u002b\\\\u003b System.out.println(a); } \",\"执行结果会打印2，同理，因为后面的unicode编码的转义后表示的是a++;。\",\"至于这么写有什么好处，当然是用在某些不想让别人看懂的地方，用来掩人耳目了，估计大家都看过下面这个笑话。\",\"图片\",\"你这么写的话客户如果懂点代码，看一下就穿帮了啊，但是你如果写成下面这样，大部分估计都以为这是一段乱码：\",\"//\\\\u000d\\\\u0054\\\\u0068\\\\u0072\\\\u0065\\\\u0061\\\\u0064\\\\u002e\\\\u0073\\\\u006c\\\\u0065\\\\u0065\\\\u0070\\\\u0028\\\\u0032\\\\u0030\\\\u0030\\\\u0030\\\\u0029\\\\u003b \",\"恕我直言，没个几十年的功力真看不出来这里执行的是sleep，简直完美。\",\"图片\"]},\"90\":{\"h\":\"贰、舍近求远\",\"t\":[\"要想写出别人看不懂的代码，很重要的一个小技巧就是把简单的东西复杂化。例如，判断一个int型数字的正负时明明可以写成这样：\",\"public void judge(int x){ if (x>0){ //... }else if (x<0){ //... } } \",\"但是我偏不，放着简单的代码不用，我就是玩，非要写成下面这样：\",\"public void judge2(int x){ if (x>>>31==0){ //... }else if (x>>>31==1){ //... } } \",\"怎么样，这么写的话是不是逼格一下子就支棱起来了！别人看到这多少得琢磨一会这块到底写了个啥玩意。\",\"其实原理也很简单，这里用到的>>>是无符号右移操作。举个简单的例子，以-3为例，移位前先转化为它的补码：\",\"11111111111111111111111111111101 \",\"无符号右移一位后变成下面的形式，这个数转化为十进制后是2147483646。\",\"01111111111111111111111111111110 \",\"所以，当一个int类型的数字在无符号右移31位后，其实在前面的31位高位全部是0，剩下的最低位是原来的符号位，因此可以用来判断数字的正负。\",\"基于这个小知识，我们还能整出不少活来。例如，放着好好的0不用，我们可以通过下面的方式定义一个0：\",\"int ZERO=Integer.MAX_VALUE>>31>>1; \",\"通过上面的知识，相信大家可以轻易理解，因为在将一个数字无符号右移32位后，二进制的所有位上全部是0，所以最终会得到0。那么问题来了，我为什么不直接用Integer.MAX_VALUE>>32，一次性右移32位呢？\",\"这是因为在对int型的数字进行移位操作时，会对操作符右边的参数进行模32的取余运算，因此如果直接写32的话，那么相当于什么都不做，得到的还是原数值。\",\"图片\"]},\"91\":{\"h\":\"叁、颠倒黑白\",\"t\":[\"古有赵高指鹿为马，今有码农颠倒真假。阻碍同事阅读你代码的有力武器之一，就是让他在遇到条件判断时失去基本判断能力，陷入云里雾里，不知道接下来要走的是哪一个分支。\",\"下面的代码，我说会打印fasle，是不是没有人会信？\",\"public class TrueTest { public static void main(String[] args) { Boolean reality = true; if(reality) { System.out.println(\\\"true\\\"); } else { System.out.println(\\\"false\\\"); } } } \",\"没错，只要大家了解布尔类型就知道这不符合逻辑，但是，经过下面的改造就可以让它变为现实。\",\"首先，在类中找个隐蔽的位置插入下面这段代码：\",\"static { try { Field trueField = Boolean.class.getDeclaredField(\\\"TRUE\\\"); trueField.setAccessible(true); Field modifiersField = Field.class.getDeclaredField(\\\"modifiers\\\"); modifiersField.setAccessible(true); modifiersField.setInt(trueField, trueField.getModifiers() & ~Modifier.FINAL); trueField.set(null, false); } catch(IllegalAccessException | NoSuchFieldException e) { e.printStackTrace(); } } \",\"然后再运行上面的程序，你就会发现神奇地打印了false。\",\"其实原理也很简单，首先通过反射拿到Boolean类中定义的TRUE这个变量：\",\"public static final Boolean TRUE = new Boolean(true); \",\"接着使用反射，去掉它的final修饰符，最后再将它的值设为false。而在之后再使用true进行定义Boolean类型的变量过程中，会进行自动装箱，调用下面的方法：\",\"public static Boolean valueOf(boolean b) { return (b ? TRUE : FALSE); } \",\"这时的b为true，而TRUE实际上是false，因此不满足第一个表达式，最终会返回false。\",\"这样一来就能解释上面的打印结果了，不过切记，这么写的时候一定要找一个代码中隐蔽的角落，不要被人发现，否则容易被打的很惨…\",\"图片\"]},\"92\":{\"h\":\"肆、化整为零\",\"t\":[\"接下来要介绍的这个技巧就有点厉害了，可以将原有的一段串行逻辑改写成判断逻辑中的不同分支，并且保证最后能够正常执行。\",\"在开始前先提一个问题，有没有一种方法，可以让if和else中的语句都能执行，就像下面的这个例子中：\",\"public static void judge(String param){ if (/*判断条件*/){ System.out.println(\\\"step one\\\"); }else { System.out.println(\\\"step two\\\"); } } \",\"如果我说只调用一次这个方法，就能同时输出if和else中的打印语句，你肯定会说不可能，因为这违背了java中判断逻辑的基本常识。\",\"没错，在限定了上面的修饰语只调用『一次』方法的条件下，谁都无法做到。但是如果在判断条件中动一点点手脚，就能够实现上面提到的功能。看一下改造后的代码：\",\"public class IfTest { public static void main(String[] args) { judge(\\\"Hydra\\\"); } public static void judge(String param){ if (param==null || new IfTest(){{ IfTest.check(null); }}.equals(\\\"Hydra\\\")){ System.out.println(\\\"step one\\\"); }else { System.out.println(\\\"step two\\\"); } } } \",\"运行后控制台打印了：\",\"step one step two \",\"惊不惊喜、意不意外？其实它能够执行的秘密就在if的判断条件中。\",\"当第一次调用judge()方法时，不满足或运算中的第一个条件，因此执行第二个条件，会执行匿名内部类内的实例化初始块代码，再次执行judge()方法，此时满足if条件，因此执行第一句打印语句。\",\"而实例化的新对象不满足后面的equals()方法中的条件，所以不满足if中的任意一个条件，因此会执行else中的语句，执行第二句打印语句。\",\"这样就实现了表面上调用一次方法，同时执行if和else中的语句块的功能。怎么样，用这种方式把一段整体的逻辑拆成两块，让你的同事迷惑去吧。\",\"图片\"]},\"93\":{\"h\":\"伍、釜底抽薪\",\"t\":[\"在程序员的世界里，不同语言之间一直存在鄙视链，例如写c的就看不起写java的，因为直接操作内存啥的看上去就很高大上不是么？那么我们今天就假装自己是一个c语言程序员，来在java中操作一把内存。\",\"具体要怎么做呢，还是要使用java中的魔法类Unsafe。看这个名字也可以明白，这玩意如果使用不当的话不是非常安全，所以获取Unsafe实例也比较麻烦，需要通过反射获取：\",\"Field unsafeField = Unsafe.class.getDeclaredField(\\\"theUnsafe\\\"); unsafeField.setAccessible(true); Unsafe unsafe =(Unsafe) unsafeField.get(null); \",\"在拿到这个对象后，我们就可以对内存为所欲为了。例如，我们在实现int a=1;这样的简单赋值时，就可以搞复杂点，像下面这样绕一个弯子：\",\"void test(){ long addr = unsafe.allocateMemory(4); unsafe.putInt(addr,1); int a=unsafe.getInt(addr); System.out.println(a); unsafe.freeMemory(addr); } \",\"首先通过allocateMemory方法申请4字节的内存空间后，然后通过putInt方法写入一个1，再从这个地址读取一个int类型长度的变量，最终实现了把1赋值给a的操作。\",\"当然了，还有很多高级一点的用法，这里简单举两个例子。\",\"void test(){ long addr = unsafe.allocateMemory(4); unsafe.setMemory(addr,4, (byte) 1); System.out.println(unsafe.getInt(addr)); unsafe.freeMemory(addr); } \",\"上面的代码中，通过setMemory方法向每个字节写入byte类型的1，最后调用getInt方法一次性读取4个字节作为一个int型变量的值。这段代码最终打印结果为16843009，对应的二进制如下：\",\"00000001 00000001 00000001 00000001 \",\"至于c语言中的内存复制，用Unsafe搞起来也是信手拈来：\",\"void test2(){ long addr = unsafe.allocateMemory(4); long addr2 = unsafe.reallocateMemory(addr, 4 * 2); unsafe.putInt(addr, 1); for (int i = 0; i < 2; i++) { unsafe.copyMemory(addr,addr2+4*i,4); } System.out.println(unsafe.getInt(addr)); System.out.println(unsafe.getLong(addr2)); unsafe.freeMemory(addr); unsafe.freeMemory(addr2); } \",\"上面的代码中，通过reallocateMemory方法重新分配了一块8字节长度的内存空间，并把addr开头的4字节内存空间分两次进复制到addr2的内存空间中，上面的代码会打印：\",\"1 4294967297 \",\"这是因为新的8字节内存空间addr2中存储的二进制数字是下面这样，转化为十进制的long类型后正好对应4294967297。\",\"100000000000000000000000000000001 \",\"Unsafe除了能直接操作内存空间外，还有线程调度、对象操作、CAS操作等实用的功能。\",\"图片\"]},\"94\":{\"h\":\"最后\",\"t\":[\"好了，没用的知识介绍环节就此结束，相信大家在掌握了这些技巧后，都能自带代码混淆光环，写出不一样的拉轰代码。\",\"最后建议大家，在项目中这样写代码的时候，搭配红花油、跌打损伤酒一起使用，可能效果更佳。\"]},\"95\":{\"h\":\"SPI机制详解\",\"t\":[\"SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用。@pdai\",\"SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 解耦。\",\"SPI整体机制图如下：\",\"img\",\"当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util.ServiceLoader。\"]},\"96\":{\"h\":\"SPI机制的简单示例\",\"t\":[\"网上找了个例子：这里在新窗口打开\",\"我们现在需要使用一个内容搜索接口，搜索的实现可能是基于文件系统的搜索，也可能是基于数据库的搜索。\",\"先定义好接口\",\"public interface Search { public List<String> searchDoc(String keyword); } \",\"文件搜索实现\",\"public class FileSearch implements Search{ @Override public List<String> searchDoc(String keyword) { System.out.println(\\\"文件搜索 \\\"+keyword); return null; } } \",\"数据库搜索实现\",\"public class DatabaseSearch implements Search{ @Override public List<String> searchDoc(String keyword) { System.out.println(\\\"数据搜索 \\\"+keyword); return null; } } \",\"resources 接下来可以在resources下新建META-INF/services/目录，然后新建接口全限定名的文件：com.cainiao.ys.spi.learn.Search，里面加上我们需要用到的实现类\",\"com.cainiao.ys.spi.learn.FileSearch \",\"测试方法\",\"public class TestCase { public static void main(String[] args) { ServiceLoader<Search> s = ServiceLoader.load(Search.class); Iterator<Search> iterator = s.iterator(); while (iterator.hasNext()) { Search search = iterator.next(); search.searchDoc(\\\"hello world\\\"); } } } \",\"可以看到输出结果：文件搜索 hello world\",\"如果在com.cainiao.ys.spi.learn.Search文件里写上两个实现类，那最后的输出结果就是两行了。\",\"这就是因为ServiceLoader.load(Search.class)在加载某接口时，会去META-INF/services下找接口的全限定名文件，再根据里面的内容加载相应的实现类。\",\"这就是spi的思想，接口的实现由provider实现，provider只用在提交的jar包里的META-INF/services下根据平台定义的接口新建文件，并添加进相应的实现类内容就好。\"]},\"97\":{\"h\":\"SPI机制的广泛应用\"},\"98\":{\"h\":\"SPI机制 - JDBC DriverManager\",\"t\":[\"在JDBC4.0之前，我们开发有连接数据库的时候，通常会用Class.forName(\\\"com.mysql.jdbc.Driver\\\")这句先加载数据库相关的驱动，然后再进行获取连接等的操作。而JDBC4.0之后不需要用Class.forName(\\\"com.mysql.jdbc.Driver\\\")来加载驱动，直接获取连接就可以了，现在这种方式就是使用了Java的SPI扩展机制来实现。\"]},\"99\":{\"h\":\"JDBC接口定义\",\"t\":[\"首先在java中定义了接口java.sql.Driver，并没有具体的实现，具体的实现都是由不同厂商来提供的。\"]},\"100\":{\"h\":\"mysql实现\",\"t\":[\"在mysql的jar包mysql-connector-java-6.0.6.jar中，可以找到META-INF/services目录，该目录下会有一个名字为java.sql.Driver的文件，文件内容是com.mysql.cj.jdbc.Driver，这里面的内容就是针对Java中定义的接口的实现。\"]},\"101\":{\"h\":\"postgresql实现\",\"t\":[\"同样在postgresql的jar包postgresql-42.0.0.jar中，也可以找到同样的配置文件，文件内容是org.postgresql.Driver，这是postgresql对Java的java.sql.Driver的实现。\"]},\"102\":{\"h\":\"使用方法\",\"t\":[\"上面说了，现在使用SPI扩展来加载具体的驱动，我们在Java中写连接数据库的代码的时候，不需要再使用Class.forName(\\\"com.mysql.jdbc.Driver\\\")来加载驱动了，而是直接使用如下代码：\",\"String url = \\\"jdbc:xxxx://xxxx:xxxx/xxxx\\\"; Connection conn = DriverManager.getConnection(url,username,password); ..... \",\"这里并没有涉及到spi的使用，接着看下面的解析。\"]},\"103\":{\"h\":\"源码实现\",\"t\":[\"上面的使用方法，就是我们普通的连接数据库的代码，并没有涉及到SPI的东西，但是有一点我们可以确定的是，我们没有写有关具体驱动的硬编码Class.forName(\\\"com.mysql.jdbc.Driver\\\")！\",\"上面的代码可以直接获取数据库连接进行操作，但是跟SPI有啥关系呢？上面代码没有了加载驱动的代码，我们怎么去确定使用哪个数据库连接的驱动呢？这里就涉及到使用Java的SPI扩展机制来查找相关驱动的东西了，关于驱动的查找其实都在DriverManager中，DriverManager是Java中的实现，用来获取数据库连接，在DriverManager中有一个静态代码块如下：\",\"static { loadInitialDrivers(); println(\\\"JDBC DriverManager initialized\\\"); } \",\"可以看到是加载实例化驱动的，接着看loadInitialDrivers方法：\",\"private static void loadInitialDrivers() { String drivers; try { drivers = AccessController.doPrivileged(new PrivilegedAction<String>() { public String run() { return System.getProperty(\\\"jdbc.drivers\\\"); } }); } catch (Exception ex) { drivers = null; } AccessController.doPrivileged(new PrivilegedAction<Void>() { public Void run() { //使用SPI的ServiceLoader来加载接口的实现 ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class); Iterator<Driver> driversIterator = loadedDrivers.iterator(); try{ while(driversIterator.hasNext()) { driversIterator.next(); } } catch(Throwable t) { // Do nothing } return null; } }); println(\\\"DriverManager.initialize: jdbc.drivers = \\\" + drivers); if (drivers == null || drivers.equals(\\\"\\\")) { return; } String[] driversList = drivers.split(\\\":\\\"); println(\\\"number of Drivers:\\\" + driversList.length); for (String aDriver : driversList) { try { println(\\\"DriverManager.Initialize: loading \\\" + aDriver); Class.forName(aDriver, true, ClassLoader.getSystemClassLoader()); } catch (Exception ex) { println(\\\"DriverManager.Initialize: load failed: \\\" + ex); } } } \",\"上面的代码主要步骤是：\",\"从系统变量中获取有关驱动的定义。\",\"使用SPI来获取驱动的实现。\",\"遍历使用SPI获取到的具体实现，实例化各个实现类。\",\"根据第一步获取到的驱动列表来实例化具体实现类。\",\"我们主要关注2,3步，这两步是SPI的用法，首先看第二步，使用SPI来获取驱动的实现，对应的代码是：\",\"ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class); \",\"这里没有去META-INF/services目录下查找配置文件，也没有加载具体实现类，做的事情就是封装了我们的接口类型和类加载器，并初始化了一个迭代器。\",\"接着看第三步，遍历使用SPI获取到的具体实现，实例化各个实现类，对应的代码如下：\",\"//获取迭代器 Iterator<Driver> driversIterator = loadedDrivers.iterator(); //遍历所有的驱动实现 while(driversIterator.hasNext()) { driversIterator.next(); } \",\"在遍历的时候，首先调用driversIterator.hasNext()方法，这里会搜索classpath下以及jar包中所有的META-INF/services目录下的java.sql.Driver文件，并找到文件中的实现类的名字，此时并没有实例化具体的实现类（ServiceLoader具体的源码实现在下面）。\",\"然后是调用driversIterator.next();方法，此时就会根据驱动名字具体实例化各个实现类了。现在驱动就被找到并实例化了。\",\"可以看下截图，我在测试项目中添加了两个jar包，mysql-connector-java-6.0.6.jar和postgresql-42.0.0.0.jar，跟踪到DriverManager中之后：\",\"img\",\"可以看到此时迭代器中有两个驱动，mysql和postgresql的都被加载了。\"]},\"104\":{\"h\":\"SPI机制 - Common-Logging\",\"t\":[\"common-logging（也称Jakarta Commons Logging，缩写 JCL）是常用的日志库门面，具体日志库相关可以看这篇。我们看下它是怎么解耦的。\",\"首先，日志实例是通过LogFactory的getLog(String)方法创建的：\",\"public static getLog(Class clazz) throws LogConfigurationException { return getFactory().getInstance(clazz); } \",\"LogFatory是一个抽象类，它负责加载具体的日志实现，分析其Factory getFactory()方法：\",\"public static org.apache.commons.logging.LogFactory getFactory() throws LogConfigurationException { // Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoaderInternal(); if (contextClassLoader == null) { // This is an odd enough situation to report about. This // output will be a nuisance on JDK1.1, as the system // classloader is null in that environment. if (isDiagnosticsEnabled()) { logDiagnostic(\\\"Context classloader is null.\\\"); } } // Return any previously registered factory for this class loader org.apache.commons.logging.LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) { return factory; } if (isDiagnosticsEnabled()) { logDiagnostic( \\\"[LOOKUP] LogFactory implementation requested for the first time for context classloader \\\" + objectId(contextClassLoader)); logHierarchy(\\\"[LOOKUP] \\\", contextClassLoader); } // Load properties file. // // If the properties file exists, then its contents are used as // \\\"attributes\\\" on the LogFactory implementation class. One particular // property may also control which LogFactory concrete subclass is // used, but only if other discovery mechanisms fail.. // // As the properties file (if it exists) will be used one way or // another in the end we may as well look for it first. // classpath根目录下寻找commons-logging.properties Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); // Determine whether we will be using the thread context class loader to // load logging classes or not by checking the loaded properties file (if any). // classpath根目录下commons-logging.properties是否配置use_tccl ClassLoader baseClassLoader = contextClassLoader; if (props != null) { String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) { // The Boolean.valueOf(useTCCLStr).booleanValue() formulation // is required for Java 1.2 compatibility. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) { // Don't use current context classloader when locating any // LogFactory or Log classes, just use the class that loaded // this abstract class. When this class is deployed in a shared // classpath of a container, it means webapps cannot deploy their // own logging implementations. It also means that it is up to the // implementation whether to load library-specific config files // from the TCCL or not. baseClassLoader = thisClassLoader; } } } // 这里真正开始决定使用哪个factory // 首先，尝试查找vm系统属性org.apache.commons.logging.LogFactory，其是否指定factory // Determine which concrete LogFactory subclass to use. // First, try a global system property if (isDiagnosticsEnabled()) { logDiagnostic(\\\"[LOOKUP] Looking for system property [\\\" + FACTORY_PROPERTY + \\\"] to define the LogFactory subclass to use...\\\"); } try { String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic(\\\"[LOOKUP] Creating an instance of LogFactory class '\\\" + factoryClass + \\\"' as specified by system property \\\" + FACTORY_PROPERTY); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); } else { if (isDiagnosticsEnabled()) { logDiagnostic(\\\"[LOOKUP] No system property [\\\" + FACTORY_PROPERTY + \\\"] defined.\\\"); } } } catch (SecurityException e) { if (isDiagnosticsEnabled()) { logDiagnostic(\\\"[LOOKUP] A security exception occurred while trying to create an\\\" + \\\" instance of the custom factory class\\\" + \\\": [\\\" + trim(e.getMessage()) + \\\"]. Trying alternative implementations...\\\"); } // ignore } catch (RuntimeException e) { // This is not consistent with the behaviour when a bad LogFactory class is // specified in a services file. // // One possible exception that can occur here is a ClassCastException when // the specified class wasn't castable to this LogFactory type. if (isDiagnosticsEnabled()) { logDiagnostic(\\\"[LOOKUP] An exception occurred while trying to create an\\\" + \\\" instance of the custom factory class\\\" + \\\": [\\\" + trim(e.getMessage()) + \\\"] as specified by a system property.\\\"); } throw e; } // 第二，尝试使用java spi服务发现机制，载META-INF/services下寻找org.apache.commons.logging.LogFactory实现 // Second, try to find a service by using the JDK1.3 class // discovery mechanism, which involves putting a file with the name // of an interface class in the META-INF/services directory, where the // contents of the file is a single line specifying a concrete class // that implements the desired interface. if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic(\\\"[LOOKUP] Looking for a resource file of name [\\\" + SERVICE_ID + \\\"] to define the LogFactory subclass to use...\\\"); } try { // META-INF/services/org.apache.commons.logging.LogFactory, SERVICE_ID final InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if (is != null) { // This code is needed by EBCDIC and other strange systems. // It's a fix for bugs reported in xerces BufferedReader rd; try { rd = new BufferedReader(new InputStreamReader(is, \\\"UTF-8\\\")); } catch (java.io.UnsupportedEncodingException e) { rd = new BufferedReader(new InputStreamReader(is)); } String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null && !\\\"\\\".equals(factoryClassName)) { if (isDiagnosticsEnabled()) { logDiagnostic(\\\"[LOOKUP] Creating an instance of LogFactory class \\\" + factoryClassName + \\\" as specified by file '\\\" + SERVICE_ID + \\\"' which was present in the path of the context classloader.\\\"); } factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader); } } else { // is == null if (isDiagnosticsEnabled()) { logDiagnostic(\\\"[LOOKUP] No resource file with name '\\\" + SERVICE_ID + \\\"' found.\\\"); } } } catch (Exception ex) { // note: if the specified LogFactory class wasn't compatible with LogFactory // for some reason, a ClassCastException will be caught here, and attempts will // continue to find a compatible class. if (isDiagnosticsEnabled()) { logDiagnostic( \\\"[LOOKUP] A security exception occurred while trying to create an\\\" + \\\" instance of the custom factory class\\\" + \\\": [\\\" + trim(ex.getMessage()) + \\\"]. Trying alternative implementations...\\\"); } // ignore } } // 第三，尝试从classpath根目录下的commons-logging.properties中查找org.apache.commons.logging.LogFactory属性指定的factory // Third try looking into the properties file read earlier (if found) if (factory == null) { if (props != null) { if (isDiagnosticsEnabled()) { logDiagnostic( \\\"[LOOKUP] Looking in properties file for entry with key '\\\" + FACTORY_PROPERTY + \\\"' to define the LogFactory subclass to use...\\\"); } String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) { if (isDiagnosticsEnabled()) { logDiagnostic( \\\"[LOOKUP] Properties file specifies LogFactory subclass '\\\" + factoryClass + \\\"'\\\"); } factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); // TODO: think about whether we need to handle exceptions from newFactory } else { if (isDiagnosticsEnabled()) { logDiagnostic(\\\"[LOOKUP] Properties file has no entry specifying LogFactory subclass.\\\"); } } } else { if (isDiagnosticsEnabled()) { logDiagnostic(\\\"[LOOKUP] No properties file available to determine\\\" + \\\" LogFactory subclass from..\\\"); } } } // 最后，使用后备factory实现，org.apache.commons.logging.impl.LogFactoryImpl // Fourth, try the fallback implementation class if (factory == null) { if (isDiagnosticsEnabled()) { logDiagnostic( \\\"[LOOKUP] Loading the default LogFactory implementation '\\\" + FACTORY_DEFAULT + \\\"' via the same classloader that loaded this LogFactory\\\" + \\\" class (ie not looking in the context classloader).\\\"); } // Note: unlike the above code which can try to load custom LogFactory // implementations via the TCCL, we don't try to load the default LogFactory // implementation via the context classloader because: // * that can cause problems (see comments in newFactory method) // * no-one should be customising the code of the default class // Yes, we do give up the ability for the child to ship a newer // version of the LogFactoryImpl class and have it used dynamically // by an old LogFactory class in the parent, but that isn't // necessarily a good idea anyway. factory = newFactory(FACTORY_DEFAULT, thisClassLoader, contextClassLoader); } if (factory != null) { /** * Always cache using context class loader. */ cacheFactory(contextClassLoader, factory); if (props != null) { Enumeration names = props.propertyNames(); while (names.hasMoreElements()) { String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); } } } return factory; } \",\"可以看出，抽象类LogFactory加载具体实现的步骤如下：\",\"从vm系统属性org.apache.commons.logging.LogFactory\",\"使用SPI服务发现机制，发现org.apache.commons.logging.LogFactory的实现\",\"查找classpath根目录commons-logging.properties的org.apache.commons.logging.LogFactory属性是否指定factory实现\",\"使用默认factory实现，org.apache.commons.logging.impl.LogFactoryImpl\",\"LogFactory的getLog()方法返回类型是org.apache.commons.logging.Log接口，提供了从trace到fatal方法。可以确定，如果日志实现提供者只要实现该接口，并且使用继承自org.apache.commons.logging.LogFactory的子类创建Log，必然可以构建一个松耦合的日志系统。\"]},\"105\":{\"h\":\"SPI机制 - 插件体系\",\"t\":[\"其实最具spi思想的应该属于插件开发，我们项目中也用到的这种思想，后面再说，这里具体说一下eclipse的插件思想。\",\"Eclipse使用OSGi作为插件系统的基础，动态添加新插件和停止现有插件，以动态的方式管理组件生命周期。\",\"一般来说，插件的文件结构必须在指定目录下包含以下三个文件：\",\"META-INF/MANIFEST.MF: 项目基本配置信息，版本、名称、启动器等\",\"build.properties: 项目的编译配置信息，包括，源代码路径、输出路径\",\"plugin.xml：插件的操作配置信息，包含弹出菜单及点击菜单后对应的操作执行类等\",\"当eclipse启动时，会遍历plugins文件夹中的目录，扫描每个插件的清单文件MANIFEST.MF，并建立一个内部模型来记录它所找到的每个插件的信息，就实现了动态添加新的插件。\",\"这也意味着是eclipse制定了一系列的规则，像是文件结构、类型、参数等。插件开发者遵循这些规则去开发自己的插件，eclipse并不需要知道插件具体是怎样开发的，只需要在启动的时候根据配置文件解析、加载到系统里就好了，是spi思想的一种体现。\"]},\"106\":{\"h\":\"SPI机制 - Spring中SPI机制\",\"t\":[\"在springboot的自动装配过程中，最终会加载META-INF/spring.factories文件，而加载的过程是由SpringFactoriesLoader加载的。从CLASSPATH下的每个Jar包中搜寻所有META-INF/spring.factories配置文件，然后将解析properties文件，找到指定名称的配置后返回。需要注意的是，其实这里不仅仅是会去ClassPath路径下查找，会扫描所有路径下的Jar包，只不过这个文件只会在Classpath下的jar包中。\",\"public static final String FACTORIES_RESOURCE_LOCATION = \\\"META-INF/spring.factories\\\"; // spring.factories文件的格式为：key=value1,value2,value3 // 从所有的jar包中找到META-INF/spring.factories文件 // 然后从文件中解析出key=factoryClass类名称的所有value值 public static List<String> loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader) { String factoryClassName = factoryClass.getName(); // 取得资源文件的URL Enumeration<URL> urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); List<String> result = new ArrayList<String>(); // 遍历所有的URL while (urls.hasMoreElements()) { URL url = urls.nextElement(); // 根据资源文件URL解析properties文件，得到对应的一组@Configuration类 Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url)); String factoryClassNames = properties.getProperty(factoryClassName); // 组装数据，并返回 result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames))); } return result; } \"]},\"107\":{\"h\":\"SPI机制深入理解\",\"t\":[\"提示\",\"接下来，我们深入理解下SPI相关内容\"]},\"108\":{\"h\":\"SPI机制通常怎么使用\",\"t\":[\"看完上面的几个例子解析，应该都能知道大概的流程了：\",\"有关组织或者公司定义标准。\",\"具体厂商或者框架开发者实现。\",\"程序猿使用。\"]},\"109\":{\"h\":\"定义标准\",\"t\":[\"定义标准，就是定义接口。比如接口java.sql.Driver\"]},\"110\":{\"h\":\"具体厂商或者框架开发者实现\",\"t\":[\"厂商或者框架开发者开发具体的实现：\",\"在META-INF/services目录下定义一个名字为接口全限定名的文件，比如java.sql.Driver文件，文件内容是具体的实现名字，比如me.cxis.sql.MyDriver。\",\"写具体的实现me.cxis.sql.MyDriver，都是对接口Driver的实现。\"]},\"111\":{\"h\":\"程序猿使用\",\"t\":[\"我们会引用具体厂商的jar包来实现我们的功能：\",\"ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class); //获取迭代器 Iterator<Driver> driversIterator = loadedDrivers.iterator(); //遍历 while(driversIterator.hasNext()) { driversIterator.next(); //可以做具体的业务逻辑 } \"]},\"112\":{\"h\":\"使用规范\",\"t\":[\"最后总结一下jdk spi需要遵循的规范\",\"img\"]},\"113\":{\"h\":\"SPI和API的区别是什么\",\"t\":[\"这里实际包含两个问题，第一个SPI和API的区别？第二个什么时候用API，什么时候用SPI？\",\"SPI - “接口”位于“调用方”所在的“包”中\",\"概念上更依赖调用方。\",\"组织上位于调用方所在的包中。\",\"实现位于独立的包中。\",\"常见的例子是：插件模式的插件。\",\"API - “接口”位于“实现方”所在的“包”中\",\"概念上更接近实现方。\",\"组织上位于实现方所在的包中。\",\"实现和接口在一个包中。\",\"参考：\",\"difference-between-spi-and-api在新窗口打开\",\"设计原则：小议 SPI 和 API在新窗口打开\",\"img\",\"img\"]},\"114\":{\"h\":\"SPI机制实现原理\",\"t\":[\"不妨看下JDK中ServiceLoader<S>方法的具体实现：\",\"//ServiceLoader实现了Iterable接口，可以遍历所有的服务实现者 public final class ServiceLoader<S> implements Iterable<S> { //查找配置文件的目录 private static final String PREFIX = \\\"META-INF/services/\\\"; //表示要被加载的服务的类或接口 private final Class<S> service; //这个ClassLoader用来定位，加载，实例化服务提供者 private final ClassLoader loader; // 访问控制上下文 private final AccessControlContext acc; // 缓存已经被实例化的服务提供者，按照实例化的顺序存储 private LinkedHashMap<String,S> providers = new LinkedHashMap<>(); // 迭代器 private LazyIterator lookupIterator; //重新加载，就相当于重新创建ServiceLoader了，用于新的服务提供者安装到正在运行的Java虚拟机中的情况。 public void reload() { //清空缓存中所有已实例化的服务提供者 providers.clear(); //新建一个迭代器，该迭代器会从头查找和实例化服务提供者 lookupIterator = new LazyIterator(service, loader); } //私有构造器 //使用指定的类加载器和服务创建服务加载器 //如果没有指定类加载器，使用系统类加载器，就是应用类加载器。 private ServiceLoader(Class<S> svc, ClassLoader cl) { service = Objects.requireNonNull(svc, \\\"Service interface cannot be null\\\"); loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl; acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null; reload(); } //解析失败处理的方法 private static void fail(Class<?> service, String msg, Throwable cause) throws ServiceConfigurationError { throw new ServiceConfigurationError(service.getName() + \\\": \\\" + msg, cause); } private static void fail(Class<?> service, String msg) throws ServiceConfigurationError { throw new ServiceConfigurationError(service.getName() + \\\": \\\" + msg); } private static void fail(Class<?> service, URL u, int line, String msg) throws ServiceConfigurationError { fail(service, u + \\\":\\\" + line + \\\": \\\" + msg); } //解析服务提供者配置文件中的一行 //首先去掉注释校验，然后保存 //返回下一行行号 //重复的配置项和已经被实例化的配置项不会被保存 private int parseLine(Class<?> service, URL u, BufferedReader r, int lc, List<String> names) throws IOException, ServiceConfigurationError { //读取一行 String ln = r.readLine(); if (ln == null) { return -1; } //#号代表注释行 int ci = ln.indexOf('#'); if (ci >= 0) ln = ln.substring(0, ci); ln = ln.trim(); int n = ln.length(); if (n != 0) { if ((ln.indexOf(' ') >= 0) || (ln.indexOf('\\\\t') >= 0)) fail(service, u, lc, \\\"Illegal configuration-file syntax\\\"); int cp = ln.codePointAt(0); if (!Character.isJavaIdentifierStart(cp)) fail(service, u, lc, \\\"Illegal provider-class name: \\\" + ln); for (int i = Character.charCount(cp); i < n; i += Character.charCount(cp)) { cp = ln.codePointAt(i); if (!Character.isJavaIdentifierPart(cp) && (cp != '.')) fail(service, u, lc, \\\"Illegal provider-class name: \\\" + ln); } if (!providers.containsKey(ln) && !names.contains(ln)) names.add(ln); } return lc + 1; } //解析配置文件，解析指定的url配置文件 //使用parseLine方法进行解析，未被实例化的服务提供者会被保存到缓存中去 private Iterator<String> parse(Class<?> service, URL u) throws ServiceConfigurationError { InputStream in = null; BufferedReader r = null; ArrayList<String> names = new ArrayList<>(); try { in = u.openStream(); r = new BufferedReader(new InputStreamReader(in, \\\"utf-8\\\")); int lc = 1; while ((lc = parseLine(service, u, r, lc, names)) >= 0); } return names.iterator(); } //服务提供者查找的迭代器 private class LazyIterator implements Iterator<S> { Class<S> service;//服务提供者接口 ClassLoader loader;//类加载器 Enumeration<URL> configs = null;//保存实现类的url Iterator<String> pending = null;//保存实现类的全名 String nextName = null;//迭代器中下一个实现类的全名 private LazyIterator(Class<S> service, ClassLoader loader) { this.service = service; this.loader = loader; } private boolean hasNextService() { if (nextName != null) { return true; } if (configs == null) { try { String fullName = PREFIX + service.getName(); if (loader == null) configs = ClassLoader.getSystemResources(fullName); else configs = loader.getResources(fullName); } } while ((pending == null) || !pending.hasNext()) { if (!configs.hasMoreElements()) { return false; } pending = parse(service, configs.nextElement()); } nextName = pending.next(); return true; } private S nextService() { if (!hasNextService()) throw new NoSuchElementException(); String cn = nextName; nextName = null; Class<?> c = null; try { c = Class.forName(cn, false, loader); } if (!service.isAssignableFrom(c)) { fail(service, \\\"Provider \\\" + cn + \\\" not a subtype\\\"); } try { S p = service.cast(c.newInstance()); providers.put(cn, p); return p; } } public boolean hasNext() { if (acc == null) { return hasNextService(); } else { PrivilegedAction<Boolean> action = new PrivilegedAction<Boolean>() { public Boolean run() { return hasNextService(); } }; return AccessController.doPrivileged(action, acc); } } public S next() { if (acc == null) { return nextService(); } else { PrivilegedAction<S> action = new PrivilegedAction<S>() { public S run() { return nextService(); } }; return AccessController.doPrivileged(action, acc); } } public void remove() { throw new UnsupportedOperationException(); } } //获取迭代器 //返回遍历服务提供者的迭代器 //以懒加载的方式加载可用的服务提供者 //懒加载的实现是：解析配置文件和实例化服务提供者的工作由迭代器本身完成 public Iterator<S> iterator() { return new Iterator<S>() { //按照实例化顺序返回已经缓存的服务提供者实例 Iterator<Map.Entry<String,S>> knownProviders = providers.entrySet().iterator(); public boolean hasNext() { if (knownProviders.hasNext()) return true; return lookupIterator.hasNext(); } public S next() { if (knownProviders.hasNext()) return knownProviders.next().getValue(); return lookupIterator.next(); } public void remove() { throw new UnsupportedOperationException(); } }; } //为指定的服务使用指定的类加载器来创建一个ServiceLoader public static <S> ServiceLoader<S> load(Class<S> service, ClassLoader loader) { return new ServiceLoader<>(service, loader); } //使用线程上下文的类加载器来创建ServiceLoader public static <S> ServiceLoader<S> load(Class<S> service) { ClassLoader cl = Thread.currentThread().getContextClassLoader(); return ServiceLoader.load(service, cl); } //使用扩展类加载器为指定的服务创建ServiceLoader //只能找到并加载已经安装到当前Java虚拟机中的服务提供者，应用程序类路径中的服务提供者将被忽略 public static <S> ServiceLoader<S> loadInstalled(Class<S> service) { ClassLoader cl = ClassLoader.getSystemClassLoader(); ClassLoader prev = null; while (cl != null) { prev = cl; cl = cl.getParent(); } return ServiceLoader.load(service, prev); } public String toString() { return \\\"java.util.ServiceLoader[\\\" + service.getName() + \\\"]\\\"; } } \",\"首先，ServiceLoader实现了Iterable接口，所以它有迭代器的属性，这里主要都是实现了迭代器的hasNext和next方法。这里主要都是调用的lookupIterator的相应hasNext和next方法，lookupIterator是懒加载迭代器。\",\"其次，LazyIterator中的hasNext方法，静态变量PREFIX就是”META-INF/services/”目录，这也就是为什么需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件。\",\"最后，通过反射方法Class.forName()加载类对象，并用newInstance方法将类实例化，并把实例化后的类缓存到providers对象中，(LinkedHashMap<String,S>类型）然后返回实例对象。\",\"所以我们可以看到ServiceLoader不是实例化以后，就去读取配置文件中的具体实现，并进行实例化。而是等到使用迭代器去遍历的时候，才会加载对应的配置文件去解析，调用hasNext方法的时候会去加载配置文件进行解析，调用next方法的时候进行实例化并缓存。\",\"所有的配置文件只会加载一次，服务提供者也只会被实例化一次，重新加载配置文件可使用reload方法。\"]},\"115\":{\"h\":\"SPI机制的缺陷\",\"t\":[\"通过上面的解析，可以发现，我们使用SPI机制的缺陷：\",\"不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。\",\"获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。\",\"多个并发多线程使用 ServiceLoader 类的实例是不安全的。\"]},\"116\":{\"h\":\"参考文章\",\"t\":[\"https://cxis.me/2017/04/17/Java中SPI机制深入及源码解析/\",\"https://stackoverflow.com/questions/2954372/difference-between-spi-and-api?answertab=votes#tab-top\",\"https://zhuanlan.zhihu.com/p/28909673\",\"http://blog.itpub.net/69912579/viewspace-2656555/\",\"https://www.cnblogs.com/happyframework/archive/2013/09/17/3325560.html\",\"https://blog.csdn.net/sakurainluojia/article/details/53534949\",\"https://www.jianshu.com/p/0d196ad23915\"]},\"117\":{\"h\":\"知识点\",\"t\":[\"本文主要对Java基础知识点进行总结。 @pdai\"]},\"118\":{\"h\":\"数据类型\"},\"119\":{\"h\":\"包装类型\",\"t\":[\"八个基本类型:\",\"boolean/1\",\"byte/8\",\"char/16\",\"short/16\",\"int/32\",\"float/32\",\"long/64\",\"double/64\",\"基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。\",\"Integer x = 2; // 装箱 int y = x; // 拆箱 \"]},\"120\":{\"h\":\"缓存池\",\"t\":[\"new Integer(123) 与 Integer.valueOf(123) 的区别在于:\",\"new Integer(123) 每次都会新建一个对象\",\"Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。\",\"Integer x = new Integer(123); Integer y = new Integer(123); System.out.println(x == y); // false Integer z = Integer.valueOf(123); Integer k = Integer.valueOf(123); System.out.println(z == k); // true \",\"valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。\",\"public static Integer valueOf(int i) { if (i >= IntegerCache.low && i <= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } \",\"在 Java 8 中，Integer 缓存池的大小默认为 -128~127。\",\"static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\\\"java.lang.Integer.IntegerCache.high\\\"); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k < cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high >= 127; } \",\"编译器会在缓冲池范围内的基本类型自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。\",\"Integer m = 123; Integer n = 123; System.out.println(m == n); // true \",\"基本类型对应的缓冲池如下:\",\"boolean values true and false\",\"all byte values\",\"short values between -128 and 127\",\"int values between -128 and 127\",\"char in the range \\\\u0000 to \\\\u007F\",\"在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。\",\"如果在缓冲池之外：\",\"Integer m = 323; Integer n = 323; System.out.println(m == n); // false \"]},\"121\":{\"h\":\"String\"},\"122\":{\"h\":\"概览\",\"t\":[\"String 被声明为 final，因此它不可被继承。\",\"内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。\",\"public final class String implements java.io.Serializable, Comparable<String>, CharSequence { /** The value is used for character storage. */ private final char value[]; \"]},\"123\":{\"h\":\"不可变的好处\",\"t\":[\"1. 可以缓存 hash 值\",\"因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。\",\"2. String Pool 的需要\",\"如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。\",\"img\",\"3. 安全性\",\"String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。\",\"4. 线程安全\",\"String 不可变性天生具备线程安全，可以在多个线程中安全地使用。\",\"Program Creek : Why String is immutable in Java?在新窗口打开\"]},\"124\":{\"h\":\"String, StringBuffer and StringBuilder\",\"t\":[\"1. 可变性\",\"String 不可变\",\"StringBuffer 和 StringBuilder 可变\",\"2. 线程安全\",\"String 不可变，因此是线程安全的\",\"StringBuilder 不是线程安全的\",\"StringBuffer 是线程安全的，内部使用 synchronized 进行同步\",\"StackOverflow : String, StringBuffer, and StringBuilder在新窗口打开\"]},\"125\":{\"h\":\"String.intern()\",\"t\":[\"使用 String.intern() 可以保证相同内容的字符串变量引用同一的内存对象。\",\"下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用。intern() 首先把 s1 引用的对象放到 String Pool(字符串常量池)中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。\",\"String s1 = new String(\\\"aaa\\\"); String s2 = new String(\\\"aaa\\\"); System.out.println(s1 == s2); // false String s3 = s1.intern(); System.out.println(s1.intern() == s3); // true \",\"如果是采用 \\\"bbb\\\" 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。\",\"String s4 = \\\"bbb\\\"; String s5 = \\\"bbb\\\"; System.out.println(s4 == s5); // true \",\"HotSpot中字符串常量池保存哪里？永久代？方法区还是堆区？\",\"运行时常量池（Runtime Constant Pool）是虚拟机规范中是方法区的一部分，在加载类和结构到虚拟机后，就会创建对应的运行时常量池；而字符串常量池是这个过程中常量字符串的存放位置。所以从这个角度，字符串常量池属于虚拟机规范中的方法区，它是一个逻辑上的概念；而堆区，永久代以及元空间是实际的存放位置。\",\"不同的虚拟机对虚拟机的规范（比如方法区）是不一样的，只有 HotSpot 才有永久代的概念。\",\"HotSpot也是发展的，由于一些问题在新窗口打开的存在，HotSpot考虑逐渐去永久代，对于不同版本的JDK，实际的存储位置是有差异的，具体看如下表格：\",\"JDK版本\",\"是否有永久代，字符串常量池放在哪里？\",\"方法区逻辑上规范，由哪些实际的部分实现的？\",\"jdk1.6及之前\",\"有永久代，运行时常量池（包括字符串常量池），静态变量存放在永久代上\",\"这个时期方法区在HotSpot中是由永久代来实现的，以至于这个时期说方法区就是指永久代\",\"jdk1.7\",\"有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中；\",\"这个时期方法区在HotSpot中由永久代（类型信息、字段、方法、常量）和堆（字符串常量池、静态变量）共同实现\",\"jdk1.8及之后\",\"取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中\",\"这个时期方法区在HotSpot中由本地内存的元空间（类型信息、字段、方法、常量）和堆（字符串常量池、静态变量）共同实现\"]},\"126\":{\"h\":\"运算\"},\"127\":{\"h\":\"参数传递\",\"t\":[\"Java 的参数是以值传递的形式传入方法中，而不是引用传递。\",\"以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中改变指针引用的对象，那么这两个指针此时指向的是完全不同的对象，一方改变其所指向对象的内容对另一方没有影响。\",\"public class Dog { String name; Dog(String name) { this.name = name; } String getName() { return this.name; } void setName(String name) { this.name = name; } String getObjectAddress() { return super.toString(); } } public class PassByValueExample { public static void main(String[] args) { Dog dog = new Dog(\\\"A\\\"); System.out.println(dog.getObjectAddress()); // Dog@4554617c func(dog); System.out.println(dog.getObjectAddress()); // Dog@4554617c System.out.println(dog.getName()); // A } private static void func(Dog dog) { System.out.println(dog.getObjectAddress()); // Dog@4554617c dog = new Dog(\\\"B\\\"); System.out.println(dog.getObjectAddress()); // Dog@74a14482 System.out.println(dog.getName()); // B } } \",\"但是如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。\",\"class PassByValueExample { public static void main(String[] args) { Dog dog = new Dog(\\\"A\\\"); func(dog); System.out.println(dog.getName()); // B } private static void func(Dog dog) { dog.setName(\\\"B\\\"); } } \",\"StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?在新窗口打开\"]},\"128\":{\"h\":\"float 与 double\",\"t\":[\"1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。Java 不能隐式执行向下转型，因为这会使得精度降低。\",\"// float f = 1.1; \",\"1.1f 字面量才是 float 类型。\",\"float f = 1.1f; \"]},\"129\":{\"h\":\"隐式类型转换\",\"t\":[\"因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。\",\"short s1 = 1; // s1 = s1 + 1; \",\"但是使用 += 运算符可以执行隐式类型转换。\",\"s1 += 1; \",\"上面的语句相当于将 s1 + 1 的计算结果进行了向下转型:\",\"s1 = (short) (s1 + 1); \",\"StackOverflow : Why don't Java's +=, -=, *=, /= compound assignment operators require casting?在新窗口打开\"]},\"130\":{\"h\":\"switch\",\"t\":[\"从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。\",\"String s = \\\"a\\\"; switch (s) { case \\\"a\\\": System.out.println(\\\"aaa\\\"); break; case \\\"b\\\": System.out.println(\\\"bbb\\\"); break; } \",\"switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。\",\"// long x = 111; // switch (x) { // Incompatible types. Found: 'long', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum' // case 111: // System.out.println(111); // break; // case 222: // System.out.println(222); // break; // } \",\"StackOverflow : Why can't your switch statement data type be long, Java?在新窗口打开\"]},\"131\":{\"h\":\"继承\"},\"132\":{\"h\":\"访问权限\",\"t\":[\"Java 中有三个访问权限修饰符: private、protected 以及 public，如果不加访问修饰符，表示包级可见。\",\"可以对类或类中的成员(字段以及方法)加上访问修饰符。\",\"类可见表示其它类可以用这个类创建实例对象。\",\"成员可见表示其它类可以用这个类的实例对象访问到该成员；\",\"protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。\",\"设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。\",\"如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。\",\"字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 共有字段，如果在某个时刻，我们想要使用 int 去存储 id 字段，那么就需要去修改所有的客户端代码。\",\"public class AccessExample { public String id; } \",\"可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。\",\"public class AccessExample { private int id; public String getId() { return id + \\\"\\\"; } public void setId(String id) { this.id = Integer.valueOf(id); } } \",\"但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。\",\"public class AccessWithInnerClassExample { private class InnerClass { int x; } private InnerClass innerClass; public AccessWithInnerClassExample() { innerClass = new InnerClass(); } public int getValue() { return innerClass.x; // 直接访问 } } \"]},\"133\":{\"h\":\"抽象类与接口\",\"t\":[\"1. 抽象类\",\"抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。\",\"抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。\",\"public abstract class AbstractClassExample { protected int x; private int y; public abstract void func1(); public void func2() { System.out.println(\\\"func2\\\"); } } public class AbstractExtendClassExample extends AbstractClassExample { @Override public void func1() { System.out.println(\\\"func1\\\"); } } // AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiated AbstractClassExample ac2 = new AbstractExtendClassExample(); ac2.func1(); \",\"2. 接口\",\"接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。\",\"从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。\",\"接口的成员(字段 + 方法)默认都是 public 的，并且不允许定义为 private 或者 protected。\",\"接口的字段默认都是 static 和 final 的。\",\"public interface InterfaceExample { void func1(); default void func2(){ System.out.println(\\\"func2\\\"); } int x = 123; // int y; // Variable 'y' might not have been initialized public int z = 0; // Modifier 'public' is redundant for interface fields // private int k = 0; // Modifier 'private' not allowed here // protected int l = 0; // Modifier 'protected' not allowed here // private void fun3(); // Modifier 'private' not allowed here } public class InterfaceImplementExample implements InterfaceExample { @Override public void func1() { System.out.println(\\\"func1\\\"); } } // InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiated InterfaceExample ie2 = new InterfaceImplementExample(); ie2.func1(); System.out.println(InterfaceExample.x); \",\"3. 比较\",\"从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。\",\"从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。\",\"接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。\",\"接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。\",\"4. 使用选择\",\"使用接口:\",\"需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；\",\"需要使用多重继承。\",\"使用抽象类:\",\"需要在几个相关的类中共享代码。\",\"需要能控制继承来的成员的访问权限，而不是都为 public。\",\"需要继承非静态和非常量字段。\",\"在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。\",\"深入理解 abstract class 和 interface在新窗口打开\",\"When to Use Abstract Class and Interface在新窗口打开\"]},\"134\":{\"h\":\"super\",\"t\":[\"访问父类的构造函数: 可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。\",\"访问父类的成员: 如果子类重写了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。\",\"public class SuperExample { protected int x; protected int y; public SuperExample(int x, int y) { this.x = x; this.y = y; } public void func() { System.out.println(\\\"SuperExample.func()\\\"); } } public class SuperExtendExample extends SuperExample { private int z; public SuperExtendExample(int x, int y, int z) { super(x, y); this.z = z; } @Override public void func() { super.func(); System.out.println(\\\"SuperExtendExample.func()\\\"); } } SuperExample e = new SuperExtendExample(1, 2, 3); e.func(); SuperExample.func() SuperExtendExample.func() \",\"Using the Keyword super在新窗口打开\"]},\"135\":{\"h\":\"重写与重载\",\"t\":[\"1. 重写(Override)\",\"存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。\",\"为了满足里式替换原则，重写有以下两个限制:\",\"子类方法的访问权限必须大于等于父类方法；\",\"子类方法的返回类型必须是父类方法返回类型或为其子类型。\",\"使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。\",\"2. 重载(Overload)\",\"存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。\",\"应该注意的是，返回值不同，其它都相同不算是重载。\"]},\"136\":{\"h\":\"Object 通用方法\"},\"137\":{\"h\":\"概览\",\"t\":[\"public final native Class<?> getClass() public native int hashCode() public boolean equals(Object obj) protected native Object clone() throws CloneNotSupportedException public String toString() public final native void notify() public final native void notifyAll() public final native void wait(long timeout) throws InterruptedException public final void wait(long timeout, int nanos) throws InterruptedException public final void wait() throws InterruptedException protected void finalize() throws Throwable {} \"]},\"138\":{\"h\":\"equals()\",\"t\":[\"1. 等价关系\",\"(一)自反性\",\"x.equals(x); // true \",\"(二)对称性\",\"x.equals(y) == y.equals(x); // true \",\"(三)传递性\",\"if (x.equals(y) && y.equals(z)) x.equals(z); // true; \",\"(四)一致性\",\"多次调用 equals() 方法结果不变\",\"x.equals(y) == x.equals(y); // true \",\"(五)与 null 的比较\",\"对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false\",\"x.equals(null); // false; \",\"2. equals() 与 ==\",\"对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。\",\"对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。\",\"Integer x = new Integer(1); Integer y = new Integer(1); System.out.println(x.equals(y)); // true System.out.println(x == y); // false \",\"3. 实现\",\"检查是否为同一个对象的引用，如果是直接返回 true；\",\"检查是否是同一个类型，如果不是，直接返回 false；\",\"将 Object 对象进行转型；\",\"判断每个关键域是否相等。\",\"public class EqualExample { private int x; private int y; private int z; public EqualExample(int x, int y, int z) { this.x = x; this.y = y; this.z = z; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; EqualExample that = (EqualExample) o; if (x != that.x) return false; if (y != that.y) return false; return z == that.z; } } \"]},\"139\":{\"h\":\"hashCode()\",\"t\":[\"hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。\",\"在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。\",\"下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。\",\"EqualExample e1 = new EqualExample(1, 1, 1); EqualExample e2 = new EqualExample(1, 1, 1); System.out.println(e1.equals(e2)); // true HashSet<EqualExample> set = new HashSet<>(); set.add(e1); set.add(e2); System.out.println(set.size()); // 2 \",\"理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。\",\"一个数与 31 相乘可以转换成移位和减法: 31*x == (x<<5)-x，编译器会自动进行这个优化。\",\"@Override public int hashCode() { int result = 17; result = 31 * result + x; result = 31 * result + y; result = 31 * result + z; return result; } \"]},\"140\":{\"h\":\"toString()\",\"t\":[\"默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。\",\"public class ToStringExample { private int number; public ToStringExample(int number) { this.number = number; } } ToStringExample example = new ToStringExample(123); System.out.println(example.toString()); ToStringExample@4554617c \"]},\"141\":{\"h\":\"clone()\",\"t\":[\"1. cloneable\",\"clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。\",\"public class CloneExample { private int a; private int b; } CloneExample e1 = new CloneExample(); // CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object' \",\"重写 clone() 得到以下实现:\",\"public class CloneExample { private int a; private int b; @Override protected CloneExample clone() throws CloneNotSupportedException { return (CloneExample)super.clone(); } } CloneExample e1 = new CloneExample(); try { CloneExample e2 = e1.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } java.lang.CloneNotSupportedException: CloneExample \",\"以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。\",\"应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。\",\"public class CloneExample implements Cloneable { private int a; private int b; @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } \",\"2. 浅拷贝\",\"拷贝对象和原始对象的引用类型引用同一个对象。\",\"public class ShallowCloneExample implements Cloneable { private int[] arr; public ShallowCloneExample() { arr = new int[10]; for (int i = 0; i < arr.length; i++) { arr[i] = i; } } public void set(int index, int value) { arr[index] = value; } public int get(int index) { return arr[index]; } @Override protected ShallowCloneExample clone() throws CloneNotSupportedException { return (ShallowCloneExample) super.clone(); } } ShallowCloneExample e1 = new ShallowCloneExample(); ShallowCloneExample e2 = null; try { e2 = e1.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } e1.set(2, 222); System.out.println(e2.get(2)); // 222 \",\"3. 深拷贝\",\"拷贝对象和原始对象的引用类型引用不同对象。\",\"public class DeepCloneExample implements Cloneable { private int[] arr; public DeepCloneExample() { arr = new int[10]; for (int i = 0; i < arr.length; i++) { arr[i] = i; } } public void set(int index, int value) { arr[index] = value; } public int get(int index) { return arr[index]; } @Override protected DeepCloneExample clone() throws CloneNotSupportedException { DeepCloneExample result = (DeepCloneExample) super.clone(); result.arr = new int[arr.length]; for (int i = 0; i < arr.length; i++) { result.arr[i] = arr[i]; } return result; } } DeepCloneExample e1 = new DeepCloneExample(); DeepCloneExample e2 = null; try { e2 = e1.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } e1.set(2, 222); System.out.println(e2.get(2)); // 2 \",\"4. clone() 的替代方案\",\"使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。\",\"public class CloneConstructorExample { private int[] arr; public CloneConstructorExample() { arr = new int[10]; for (int i = 0; i < arr.length; i++) { arr[i] = i; } } public CloneConstructorExample(CloneConstructorExample original) { arr = new int[original.arr.length]; for (int i = 0; i < original.arr.length; i++) { arr[i] = original.arr[i]; } } public void set(int index, int value) { arr[index] = value; } public int get(int index) { return arr[index]; } } CloneConstructorExample e1 = new CloneConstructorExample(); CloneConstructorExample e2 = new CloneConstructorExample(e1); e1.set(2, 222); System.out.println(e2.get(2)); // 2 \"]},\"142\":{\"h\":\"关键字\"},\"143\":{\"h\":\"final\",\"t\":[\"1. 数据\",\"声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。\",\"对于基本类型，final 使数值不变；\",\"对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。\",\"final int x = 1; // x = 2; // cannot assign value to final variable 'x' final A y = new A(); y.a = 1; \",\"2. 方法\",\"声明方法不能被子类重写。\",\"private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。\",\"3. 类\",\"声明类不允许被继承。\"]},\"144\":{\"h\":\"static\",\"t\":[\"1. 静态变量\",\"静态变量: 又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份。\",\"实例变量: 每创建一个实例就会产生一个实例变量，它与该实例同生共死。\",\"public class A { private int x; // 实例变量 private static int y; // 静态变量 public static void main(String[] args) { // int x = A.x; // Non-static field 'x' cannot be referenced from a static context A a = new A(); int x = a.x; int y = A.y; } } \",\"2. 静态方法\",\"静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法(abstract)。\",\"public abstract class A { public static void func1(){ } // public abstract static void func2(); // Illegal combination of modifiers: 'abstract' and 'static' } \",\"只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。\",\"public class A { private static int x; private int y; public static void func1(){ int a = x; // int b = y; // Non-static field 'y' cannot be referenced from a static context // int b = this.y; // 'A.this' cannot be referenced from a static context } } \",\"3. 静态语句块\",\"静态语句块在类初始化时运行一次。\",\"public class A { static { System.out.println(\\\"123\\\"); } public static void main(String[] args) { A a1 = new A(); A a2 = new A(); } } 123 \",\"4. 静态内部类\",\"非静态内部类依赖于外部类的实例，而静态内部类不需要。\",\"public class OuterClass { class InnerClass { } static class StaticInnerClass { } public static void main(String[] args) { // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass(); } } \",\"静态内部类不能访问外部类的非静态的变量和方法。\",\"5. 静态导包\",\"在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。\",\"import static com.xxx.ClassName.* \",\"6. 初始化顺序\",\"静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。\",\"public static String staticField = \\\"静态变量\\\"; static { System.out.println(\\\"静态语句块\\\"); } public String field = \\\"实例变量\\\"; { System.out.println(\\\"普通语句块\\\"); } \",\"最后才是构造函数的初始化。\",\"public InitialOrderTest() { System.out.println(\\\"构造函数\\\"); } \",\"存在继承的情况下，初始化顺序为:\",\"父类(静态变量、静态语句块)\",\"子类(静态变量、静态语句块)\",\"父类(实例变量、普通语句块)\",\"父类(构造函数)\",\"子类(实例变量、普通语句块)\",\"子类(构造函数)\"]},\"145\":{\"h\":\"反射\",\"t\":[\"每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。\",\"类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 Class.forName(\\\"com.mysql.jdbc.Driver\\\") 这种方式来控制类的加载，该方法会返回一个 Class 对象。\",\"反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。\",\"Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类:\",\"Field : 可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；\",\"Method : 可以使用 invoke() 方法调用与 Method 对象关联的方法；\",\"Constructor : 可以用 Constructor 创建新的对象。\",\"Advantages of Using Reflection:\",\"Extensibility Features : An application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names.\",\"Class Browsers and Visual Development Environments : A class browser needs to be able to enumerate the members of classes. Visual development environments can benefit from making use of type information available in reflection to aid the developer in writing correct code.\",\"Debuggers and Test Tools : Debuggers need to be able to examine private members on classes. Test harnesses can make use of reflection to systematically call a discoverable set APIs defined on a class, to insure a high level of code coverage in a test suite.\",\"Drawbacks of Reflection:\",\"Reflection is powerful, but should not be used indiscriminately. If it is possible to perform an operation without using reflection, then it is preferable to avoid using it. The following concerns should be kept in mind when accessing code via reflection.\",\"Performance Overhead : Because reflection involves types that are dynamically resolved, certain Java virtual machine optimizations can not be performed. Consequently, reflective operations have slower performance than their non-reflective counterparts, and should be avoided in sections of code which are called frequently in performance-sensitive applications.\",\"Security Restrictions : Reflection requires a runtime permission which may not be present when running under a security manager. This is in an important consideration for code which has to run in a restricted security context, such as in an Applet.\",\"Exposure of Internals :Since reflection allows code to perform operations that would be illegal in non-reflective code, such as accessing private fields and methods, the use of reflection can result in unexpected side-effects, which may render code dysfunctional and may destroy portability. Reflective code breaks abstractions and therefore may change behavior with upgrades of the platform.\",\"相关文章：Java 基础 - 反射机制详解\"]},\"146\":{\"h\":\"异常\",\"t\":[\"Throwable 可以用来表示任何可以作为异常抛出的类，分为两种: Error 和 Exception。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种:\",\"受检异常 : 需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；\",\"非受检异常 : 是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。\",\"img\",\"相关文章：Java 基础 - 异常机制详解\"]},\"147\":{\"h\":\"泛型\",\"t\":[\"public class Box<T> { // T stands for \\\"Type\\\" private T t; public void set(T t) { this.t = t; } public T get() { return t; } } \",\"相关文章：Java 基础 - 泛型机制详解\"]},\"148\":{\"h\":\"注解\",\"t\":[\"Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。\",\"相关文章：Java 基础 - 注解机制详解\"]},\"149\":{\"h\":\"特性\"},\"150\":{\"h\":\"Java 各版本的新特性\",\"t\":[\"New highlights in Java SE 8\",\"Lambda Expressions\",\"Pipelines and Streams\",\"Date and Time API\",\"Default Methods\",\"Type Annotations\",\"Nashhorn JavaScript Engine\",\"Concurrent Accumulators\",\"Parallel operations\",\"PermGen Error Removed\",\"New highlights in Java SE 7\",\"Strings in Switch Statement\",\"Type Inference for Generic Instance Creation\",\"Multiple Exception Handling\",\"Support for Dynamic Languages\",\"Try with Resources\",\"Java nio Package\",\"Binary Literals, Underscore in literals\",\"Diamond Syntax\",\"Difference between Java 1.8 and Java 1.7?在新窗口打开\",\"Java 8 特性在新窗口打开\"]},\"151\":{\"h\":\"Java 与 C++ 的区别\",\"t\":[\"Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。\",\"Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。\",\"Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。\",\"Java 支持自动垃圾回收，而 C++ 需要手动回收。\",\"Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。\",\"Java 不支持操作符重载，虽然可以对两个 String 对象支持加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。\",\"Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。\",\"Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。\",\"What are the main differences between Java and C++?在新窗口打开\"]},\"152\":{\"h\":\"JRE or JDK\",\"t\":[\"JRE is the JVM program, Java application need to run on JRE.\",\"JDK is a superset of JRE, JRE + tools for developing java programs. e.g, it provides the compiler \\\"javac\\\"\"]},\"153\":{\"h\":\"参考资料\",\"t\":[\"Eckel B. Java 编程思想[M]. 机械工业出版社, 2002.\",\"Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.\"]},\"154\":{\"h\":\"图谱 & Q/A\",\"t\":[\"本文主要对Java基础知识体系小结，同时结合一些Q&A进行理解。 @pdai\"]},\"155\":{\"h\":\"参考文档\",\"t\":[\"Thinking in Java (Java 编程思想) Gitbook中文文档 https://java.quanke.name/\",\"Thinking in Java (Java 编程思想) Github https://github.com/quanke/think-in-java\",\"Thinking in Java (Java 编程思想) Gitbook2 https://www.gitbook.com/book/wizardforcel/thinking-in-java/details\"]},\"156\":{\"h\":\"知识体系\",\"t\":[\"img\"]},\"157\":{\"h\":\"Q&A\"},\"158\":{\"h\":\"Java 中应该使用什么数据类型来代表价格?\",\"t\":[\"如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。\"]},\"159\":{\"h\":\"怎么将 byte 转换为 String?\",\"t\":[\"可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。\"]},\"160\":{\"h\":\"Java 中怎样将 bytes 转换为 long 类型?\",\"t\":[\"String接收bytes的构造器转成String，再Long.parseLong\"]},\"161\":{\"h\":\"我们能将 int 强制转换为 byte 类型的变量吗? 如果该值大于 byte 类型的范围，将会出现什么现象?\",\"t\":[\"是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 127。\"]},\"162\":{\"h\":\"存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么? 如 C = (C) B；\",\"t\":[\"可以，向下转型。但是不建议使用，容易出现类型转型异常.\"]},\"163\":{\"h\":\"哪个类包含 clone 方法? 是 Cloneable 还是 Object?\",\"t\":[\"java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。\"]},\"164\":{\"h\":\"Java 中 ++ 操作符是线程安全的吗?\",\"t\":[\"不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。还会存在竞态条件(读取-修改-写入)。\"]},\"165\":{\"h\":\"a = a + b 与 a += b 的区别\",\"t\":[\"+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。\",\"byte a = 127; byte b = 127; b = a + b; // error : cannot convert from int to byte b += a; // ok \",\"(因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错)\"]},\"166\":{\"h\":\"我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗?\",\"t\":[\"不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。\"]},\"167\":{\"h\":\"3*0.1 == 0.3 将会返回什么? true 还是 false?\",\"t\":[\"false，因为有些浮点数不能完全精确的表示出来。\"]},\"168\":{\"h\":\"int 和 Integer 哪个会占用更多的内存?\",\"t\":[\"Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。\"]},\"169\":{\"h\":\"为什么 Java 中的 String 是不可变的(Immutable)?\",\"t\":[\"Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。更详细的内容参见答案。\"]},\"170\":{\"h\":\"我们能在 Switch 中使用 String 吗?\",\"t\":[\"从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。\"]},\"171\":{\"h\":\"Java 中的构造器链是什么?\",\"t\":[\"当你从一个构造器中调用另一个构造器，就是Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。\"]},\"172\":{\"h\":\"枚举类\",\"t\":[\"JDK1.5出现 每个枚举值都需要调用一次构造函数\"]},\"173\":{\"h\":\"什么是不可变对象(immutable object)? Java 中怎么创建一个不可变对象?\",\"t\":[\"不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。\",\"如何在Java中写出Immutable的类?\",\"要写出这样的类，需要遵循以下几个原则:\",\"1)immutable对象的状态在创建之后就不能发生改变，任何对它的改变都应该产生一个新的对象。\",\"2)Immutable类的所有的属性都应该是final的。\",\"3)对象必须被正确的创建，比如: 对象引用在对象创建过程中不能泄露(leak)。\",\"4)对象应该是final的，以此来限制子类继承父类，以避免子类改变了父类的immutable特性。\",\"5)如果类中包含mutable类对象，那么返回给客户端的时候，返回该对象的一个拷贝，而不是该对象本身(该条可以归为第一条中的一个特例)\"]},\"174\":{\"h\":\"我们能创建一个包含可变对象的不可变对象吗?\",\"t\":[\"是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。\"]},\"175\":{\"h\":\"有没有可能两个不相等的对象有相同的 hashcode?\",\"t\":[\"有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。\"]},\"176\":{\"h\":\"两个相同的对象会有不同的 hash code 吗?\",\"t\":[\"不能，根据 hash code 的规定，这是不可能的。\"]},\"177\":{\"h\":\"我们可以在 hashcode() 中使用随机数字吗?\",\"t\":[\"不行，因为对象的 hashcode 值必须是相同的。\"]},\"178\":{\"h\":\"Java 中，Comparator 与 Comparable 有什么不同?\",\"t\":[\"Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。\"]},\"179\":{\"h\":\"为什么在重写 equals 方法的时候需要重写 hashCode 方法?\",\"t\":[\"因为有强制的规范指定需要同时重写 hashcode 与 equals 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。\"]},\"180\":{\"h\":\"“a==b”和”a.equals(b)”有什么区别?\",\"t\":[\"如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。\"]},\"181\":{\"h\":\"a.hashCode() 有什么用? 与 a.equals(b) 有什么关系?\",\"t\":[\"简介: hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equals() 方法来判断相等的对象，必须具有相同的 hash code。\",\"1、hashcode的作用\",\"List和Set，如何保证Set不重复呢? 通过迭代使用equals方法来判断，数据量小还可以接受，数据量大怎么解决? 引入hashcode，实际上hashcode扮演的角色就是寻址，大大减少查询匹配次数。\",\"2、hashcode重要吗\",\"对于数组、List集合就是一个累赘。而对于hashmap, hashset, hashtable就异常重要了。\",\"3、equals方法遵循的原则\",\"对称性 若x.equals(y)true，则y.equals(x)true\",\"自反性 x.equals(x)必须true\",\"传递性 若x.equals(y)true,y.equals(z)true,则x.equals(z)必为true\",\"一致性 只要x,y内容不变，无论调用多少次结果不变\",\"其他 x.equals(null) 永远false，x.equals(和x数据类型不同)始终false\"]},\"182\":{\"h\":\"final、finalize 和 finally 的不同之处?\",\"t\":[\"final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。\",\"Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的，但是什么时候调用 finalize 没有保证。\",\"finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。\"]},\"183\":{\"h\":\"Java 中的编译期常量是什么? 使用它又什么风险?\",\"t\":[\"变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。\"]},\"184\":{\"h\":\"静态内部类与顶级类有什么区别?\",\"t\":[\"一个公共的顶级类的源文件名称与类名相同，而嵌套静态类没有这个要求。一个嵌套类位于顶级类内部，需要使用顶级类的名称来引用嵌套静态类，如 HashMap.Entry 是一个嵌套静态类，HashMap 是一个顶级类，Entry是一个嵌套静态类。\"]},\"185\":{\"h\":\"Java 中，Serializable 与 Externalizable 的区别?\",\"t\":[\"Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。\"]},\"186\":{\"h\":\"说出 JDK 1.7 中的三个新特性?\",\"t\":[\"虽然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符(<>)用于泛型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码。另一个值得一提的特性是改善异常处理，如允许在同一个 catch 块中捕获多个异常。\"]},\"187\":{\"h\":\"说出 5 个 JDK 1.8 引入的新特性?\",\"t\":[\"Java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性: Lambda 表达式，允许像对象一样传递匿名函数 Stream API，充分利用现代多核 CPU，可以写出很简洁的代码 Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用 扩展方法，现在，接口中可以有静态、默认方法。 重复注解，现在你可以将相同的注解在同一类型上使用多次。\",\"下述包含 Java 面试过程中关于 SOLID 的设计原则，OOP 基础，如类，对象，接口，继承，多态，封装，抽象以及更高级的一些概念，如组合、聚合及关联。也包含了 GOF 设计模式的问题。\"]},\"188\":{\"h\":\"接口是什么? 为什么要使用接口而不是直接使用具体类?\",\"t\":[\"接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许普通方法，以此来保证抽象，但是 Java 8 中你可以在接口声明静态方法和默认普通方法。\"]},\"189\":{\"h\":\"Java 中，抽象类与接口之间有什么不同?\",\"t\":[\"Java 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制 参见第六条。\"]},\"190\":{\"h\":\"Object有哪些公用方法?\",\"t\":[\"clone equals hashcode wait notify notifyall finalize toString getClass 除了clone和finalize其他均为公共方法。\",\"11个方法，wait被重载了两次\"]},\"191\":{\"h\":\"equals与==的区别\",\"t\":[\"区别1. ==是一个运算符 equals是Object类的方法\",\"区别2. 比较时的区别\",\"用于基本类型的变量比较时: ==用于比较值是否相等，equals不能直接用于基本数据类型的比较，需要转换为其对应的包装类型。\",\"用于引用类型的比较时。==和equals都是比较栈内存中的地址是否相等 。相等为true 否则为false。但是通常会重写equals方法去实现对象内容的比较。\"]},\"192\":{\"h\":\"String、StringBuffer与StringBuilder的区别\",\"t\":[\"第一点: 可变和适用范围。String对象是不可变的，而StringBuffer和StringBuilder是可变字符序列。每次对String的操作相当于生成一个新的String对象，而对StringBuffer和StringBuilder的操作是对对象本身的操作，而不会生成新的对象，所以对于频繁改变内容的字符串避免使用String，因为频繁的生成对象将会对系统性能产生影响。\",\"第二点: 线程安全。String由于有final修饰，是immutable的，安全性是简单而纯粹的。StringBuilder和StringBuffer的区别在于StringBuilder不保证同步，也就是说如果需要线程安全需要使用StringBuffer，不需要同步的StringBuilder效率更高。\"]},\"193\":{\"h\":\"switch能否用String做参数\",\"t\":[\"Java1.7开始支持，但实际这是一颗Java语法糖。除此之外，byte，short，int，枚举均可用于switch，而boolean和浮点型不可以。\"]},\"194\":{\"h\":\"接口与抽象类\",\"t\":[\"一个子类只能继承一个抽象类, 但能实现多个接口\",\"抽象类可以有构造方法, 接口没有构造方法\",\"抽象类可以有普通成员变量, 接口没有普通成员变量\",\"抽象类和接口都可有静态成员变量, 抽象类中静态成员变量访问类型任意，接口只能public static final(默认)\",\"抽象类可以没有抽象方法, 抽象类可以有普通方法；接口在JDK8之前都是抽象方法，在JDK8可以有default方法，在JDK9中允许有私有普通方法\",\"抽象类可以有静态方法；接口在JDK8之前不能有静态方法，在JDK8中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用）\",\"抽象类中的方法可以是public、protected; 接口方法在JDK8之前只有public abstract，在JDK8可以有default方法，在JDK9中允许有private方法\"]},\"195\":{\"h\":\"抽象类和最终类\",\"t\":[\"抽象类可以没有抽象方法, 最终类可以没有最终方法\",\"最终类不能被继承, 最终方法不能被重写(可以重载)\"]},\"196\":{\"h\":\"异常\",\"t\":[\"相关的关键字 throw、throws、try...catch、finally\",\"throws 用在方法签名上, 以便抛出的异常可以被调用者处理\",\"throw 方法内部通过throw抛出异常\",\"try 用于检测包住的语句块, 若有异常, catch子句捕获并执行catch块\"]},\"197\":{\"h\":\"关于finally\",\"t\":[\"finally不管有没有异常都要处理\",\"当try和catch中有return时，finally仍然会执行，finally比return先执行\",\"不管有木有异常抛出, finally在return返回前执行\",\"finally是在return后面的表达式运算后执行的(此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值)，所以函数返回值是在finally执行前确定的\",\"注意: finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值\",\"finally不执行的几种情况: 程序提前终止如调用了System.exit, 病毒，断电\"]},\"198\":{\"h\":\"受检查异常和运行时异常\",\"t\":[\"受检查的异常(checked exceptions),其必须被try...catch语句块所捕获, 或者在方法签名里通过throws子句声明。受检查的异常必须在编译时被捕捉处理,命名为Checked Exception是因为Java编译器要进行检查, Java虚拟机也要进行检查, 以确保这个规则得到遵守。\",\"常见的checked exception: ClassNotFoundException IOException FileNotFoundException EOFException\",\"运行时异常(runtime exceptions), 需要程序员自己分析代码决定是否捕获和处理,比如空指针,被0除...\",\"常见的runtime exception: NullPointerException ArithmeticException ClassCastException IllegalArgumentException IllegalStateException IndexOutOfBoundsException NoSuchElementException\",\"Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕获。\"]},\"199\":{\"h\":\"super出现在父类的子类中。有三种存在方式\",\"t\":[\"super.xxx(xxx为变量名或对象名)意思是获取父类中xxx的变量或引用\",\"super.xxx(); (xxx为方法名)意思是直接访问并调用父类中的方法\",\"super() 调用父类构造\",\"注: super只能指代其直接父类\"]},\"200\":{\"h\":\"this() & super()在构造方法中的区别\",\"t\":[\"调用super()必须写在子类构造方法的第一行, 否则编译不通过\",\"super从子类调用父类构造, this在同一类中调用其他构造均需要放在第一行\",\"尽管可以用this调用一个构造器, 却不能调用2个\",\"this和super不能出现在同一个构造器中, 否则编译不通过\",\"this()、super()都指的对象,不可以在static环境中使用\",\"本质this指向本对象的指针。super是一个关键字\"]},\"201\":{\"h\":\"构造内部类和静态内部类对象\",\"t\":[\"public class Enclosingone { public class Insideone {} public static class Insideone{} } public class Test { public static void main(String[] args) { // 构造内部类对象需要外部类的引用 Enclosingone.Insideone obj1 = new Enclosingone().new Insideone(); // 构造静态内部类的对象 Enclosingone.Insideone obj2 = new Enclosingone.Insideone(); } } \",\"静态内部类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。非静态内部类能够访问外部类的静态和非静态成员。静态内部类不能访问外部类的非静态成员，只能访问外部类的静态成员。\"]},\"202\":{\"h\":\"序列化\",\"t\":[\"声明为static和transient类型的数据不能被序列化， 反序列化需要一个无参构造函数\"]},\"203\":{\"h\":\"Java移位运算符\",\"t\":[\"java中有三种移位运算符\",\"<< :左移运算符,x << 1,相当于x乘以2(不溢出的情况下),低位补0\",\">> :带符号右移,x >> 1,相当于x除以2,正数高位补0,负数高位补1\",\">>> :无符号右移,忽略符号位,空位都以0补齐\"]},\"204\":{\"h\":\"形参&实参\",\"t\":[\"形式参数可被视为local variable.形参和局部变量一样都不能离开方法。只有在方法中使用，不会在方法外可见。 形式参数只能用final修饰符，其它任何修饰符都会引起编译器错误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。不过一般情况下，一个方法的形参不用final修饰。只有在特殊情况下，那就是: 方法内部类。一个方法内的内部类如果使用了这个方法的参数或者局部变量的话，这个参数或局部变量应该是final。 形参的值在调用时根据调用者更改，实参则用自身的值更改形参的值(指针、引用皆在此列)，也就是说真正被传递的是实参。\"]},\"205\":{\"h\":\"局部变量为什么要初始化\",\"t\":[\"局部变量是指类方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值。\"]},\"206\":{\"h\":\"Java语言的鲁棒性\",\"t\":[\"Java在编译和运行程序时，都要对可能出现的问题进行检查，以消除错误的产生。它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生的错误。通过集成的面向对象的例外处理机制，在编译时，Java揭示出可能出现但未被处理的异常，帮助程序员正确地进行选择以防止系统的崩溃。另外，Java在编译时还可捕获类型声明中的许多常见错误，防止动态运行时不匹配问题的出现。\"]},\"207\":{\"h\":\"面向对象\",\"t\":[\"本文主要介绍Java OOP 面向对象基础和相关类图。@pdai\"]},\"208\":{\"h\":\"三大特性\"},\"209\":{\"h\":\"封装\",\"t\":[\"利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。\",\"优点:\",\"减少耦合: 可以独立地开发、测试、优化、使用、理解和修改\",\"减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块\",\"有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能\",\"提高软件的可重用性\",\"降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的\",\"以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。\",\"注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。\",\"public class Person { private String name; private int gender; private int age; public String getName() { return name; } public String getGender() { return gender == 0 ? \\\"man\\\" : \\\"woman\\\"; } public void work() { if (18 <= age && age <= 50) { System.out.println(name + \\\" is working very hard!\\\"); } else { System.out.println(name + \\\" can't work any more!\\\"); } } } \"]},\"210\":{\"h\":\"继承\",\"t\":[\"继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。\",\"继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。\",\"Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型 。\",\"Animal animal = new Cat(); \"]},\"211\":{\"h\":\"多态\",\"t\":[\"多态分为编译时多态和运行时多态:\",\"编译时多态主要指方法的重载\",\"运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定\",\"运行时多态有三个条件:\",\"继承\",\"覆盖(重写)\",\"向上转型\",\"下面的代码中，乐器类(Instrument)有两个子类: Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。\",\"public class Instrument { public void play() { System.out.println(\\\"Instrument is playing...\\\"); } } public class Wind extends Instrument { public void play() { System.out.println(\\\"Wind is playing...\\\"); } } public class Percussion extends Instrument { public void play() { System.out.println(\\\"Percussion is playing...\\\"); } } public class Music { public static void main(String[] args) { List<Instrument> instruments = new ArrayList<>(); instruments.add(new Wind()); instruments.add(new Percussion()); for(Instrument instrument : instruments) { instrument.play(); } } } \"]},\"212\":{\"h\":\"类图\",\"t\":[\"以下类图使用 PlantUML在新窗口打开 绘制，更多语法及使用请参考: http://plantuml.com/ 。\"]},\"213\":{\"h\":\"泛化关系 (Generalization)\",\"t\":[\"用来描述继承关系，在 Java 中使用 extends 关键字。\",\"img\",\"@startuml title Generalization class Vehical class Car class Truck Vehical <|-- Car Vehical <|-- Truck @enduml \"]},\"214\":{\"h\":\"实现关系 (Realization)\",\"t\":[\"用来实现一个接口，在 Java 中使用 implements 关键字。\",\"img\",\"@startuml title Realization interface MoveBehavior class Fly class Run MoveBehavior <|.. Fly MoveBehavior <|.. Run @enduml \"]},\"215\":{\"h\":\"聚合关系 (Aggregation)\",\"t\":[\"表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。\",\"img\",\"@startuml title Aggregation class Computer class Keyboard class Mouse class Screen Computer o-- Keyboard Computer o-- Mouse Computer o-- Screen @enduml \"]},\"216\":{\"h\":\"组合关系 (Composition)\",\"t\":[\"和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。\",\"img\",\"@startuml title Composition class Company class DepartmentA class DepartmentB Company *-- DepartmentA Company *-- DepartmentB @enduml \"]},\"217\":{\"h\":\"关联关系 (Association)\",\"t\":[\"表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。\",\"img\",\"@startuml title Association class School class Student School \\\"1\\\" - \\\"n\\\" Student @enduml \"]},\"218\":{\"h\":\"依赖关系 (Dependency)\",\"t\":[\"和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式:\",\"A 类是 B 类中的(某中方法的)局部变量；\",\"A 类是 B 类方法当中的一个参数；\",\"A 类向 B 类发送消息，从而影响 B 类发生变化；\",\"img\",\"@startuml title Dependency class Vehicle { move(MoveBehavior) } interface MoveBehavior { move() } note \\\"MoveBehavior.move()\\\" as N Vehicle ..> MoveBehavior Vehicle .. N @enduml \"]},\"219\":{\"h\":\"参考资料\",\"t\":[\"Java 编程思想\",\"敏捷软件开发: 原则、模式与实践\",\"面向对象设计的 SOLID 原则在新窗口打开\",\"看懂 UML 类图和时序图在新窗口打开\",\"UML 系列——时序图(顺序图)sequence diagram在新窗口打开\",\"面向对象编程三大特性 ------ 封装、继承、多态在新窗口打开\",\"javaoop基础知识总结 https://blog.csdn.net/weixin_38173324/article/details/70037927\",\"Java实现OOP(面向对象编程) https://www.cnblogs.com/AlanLee/p/6475334.html\",\"Java 抽象类与oop三大特征 http://www.cnblogs.com/wujing-hubei/p/6012105.html\"]},\"220\":{\"h\":\"注解机制详解\",\"t\":[\"注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它是框架学习和设计者必须掌握的基础。@pdai\"]},\"221\":{\"h\":\"注解基础\",\"t\":[\"注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面：\",\"生成文档，通过代码里标识的元数据生成javadoc文档。\",\"编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。\",\"编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。\",\"运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。\",\"这么来说是比较抽象的，我们具体看下注解的常见分类：\",\"Java自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。\",\"元注解，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented，@Retention用于标明注解被保留的阶段，@Target用于标明注解使用的范围，@Inherited用于标明注解可继承，@Documented用于标明是否生成javadoc文档。\",\"自定义注解，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。\",\"接下来我们通过这个分类角度来理解注解。\"]},\"222\":{\"h\":\"Java内置注解\",\"t\":[\"我们从最为常见的Java内置的注解开始说起，先看下下面的代码：\",\"class A{ public void test() { } } class B extends A{ /** * 重载父类的test方法 */ @Override public void test() { } /** * 被弃用的方法 */ @Deprecated public void oldMethod() { } /** * 忽略告警 * * @return */ @SuppressWarnings(\\\"rawtypes\\\") public List processList() { List list = new ArrayList(); return list; } } \",\"Java 1.5开始自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings：\",\"@Override：表示当前的方法定义将覆盖父类中的方法\",\"@Deprecated：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告\",\"@SuppressWarnings：表示关闭编译器警告信息\",\"我们再具体看下这几个内置注解，同时通过这几个内置注解中的元注解的定义来引出元注解。\"]},\"223\":{\"h\":\"内置注解 - @Override\",\"t\":[\"我们先来看一下这个注解类型的定义：\",\"@Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } \",\"从它的定义我们可以看到，这个注解可以被用来修饰方法，并且它只在编译时有效，在编译后的class文件中便不再存在。这个注解的作用我们大家都不陌生，那就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同，则会报错。\"]},\"224\":{\"h\":\"内置注解 - @Deprecated\",\"t\":[\"这个注解的定义如下：\",\"@Documented @Retention(RetentionPolicy.RUNTIME) @Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE}) public @interface Deprecated { } \",\"从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。\"]},\"225\":{\"h\":\"内置注解 - @SuppressWarnings\",\"t\":[\"这个注解我们也比较常用到，先来看下它的定义：\",\"@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) @Retention(RetentionPolicy.SOURCE) public @interface SuppressWarnings { String[] value(); } \",\"它能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量，只能存活在源码时，取值为String[]。它的作用是告诉编译器忽略指定的警告信息，它可以取的值如下所示：\",\"参数\",\"作用\",\"原描述\",\"all\",\"抑制所有警告\",\"to suppress all warnings\",\"boxing\",\"抑制装箱、拆箱操作时候的警告\",\"to suppress warnings relative to boxing/unboxing operations\",\"cast\",\"抑制映射相关的警告\",\"to suppress warnings relative to cast operations\",\"dep-ann\",\"抑制启用注释的警告\",\"to suppress warnings relative to deprecated annotation\",\"deprecation\",\"抑制过期方法警告\",\"to suppress warnings relative to deprecation\",\"fallthrough\",\"抑制确在switch中缺失breaks的警告\",\"to suppress warnings relative to missing breaks in switch statements\",\"finally\",\"抑制finally模块没有返回的警告\",\"to suppress warnings relative to finally block that don’t return\",\"hiding\",\"抑制与隐藏变数的区域变数相关的警告\",\"to suppress warnings relative to locals that hide variable（）\",\"incomplete-switch\",\"忽略没有完整的switch语句\",\"to suppress warnings relative to missing entries in a switch statement (enum case)\",\"nls\",\"忽略非nls格式的字符\",\"to suppress warnings relative to non-nls string literals\",\"null\",\"忽略对null的操作\",\"to suppress warnings relative to null analysis\",\"rawtype\",\"使用generics时忽略没有指定相应的类型\",\"to suppress warnings relative to un-specific types when using\",\"restriction\",\"抑制与使用不建议或禁止参照相关的警告\",\"to suppress warnings relative to usage of discouraged or\",\"serial\",\"忽略在serializable类中没有声明serialVersionUID变量\",\"to suppress warnings relative to missing serialVersionUID field for a serializable class\",\"static-access\",\"抑制不正确的静态访问方式警告\",\"to suppress warnings relative to incorrect static access\",\"synthetic-access\",\"抑制子类没有按最优方法访问内部类的警告\",\"to suppress warnings relative to unoptimized access from inner classes\",\"unchecked\",\"抑制没有进行类型检查操作的警告\",\"to suppress warnings relative to unchecked operations\",\"unqualified-field-access\",\"抑制没有权限访问的域的警告\",\"to suppress warnings relative to field access unqualified\",\"unused\",\"抑制没被使用过的代码的警告\",\"to suppress warnings relative to unused code\"]},\"226\":{\"h\":\"元注解\",\"t\":[\"上述内置注解的定义中使用了一些元注解（注解类型进行注解的注解类），在JDK 1.5中提供了4个标准的元注解：@Target，@Retention，@Documented，@Inherited, 在JDK 1.8中提供了两个元注解 @Repeatable和@Native。\"]},\"227\":{\"h\":\"元注解 - @Target\",\"t\":[\"Target注解的作用是：描述注解的使用范围（即：被修饰的注解可以用在什么地方） 。\",\"Target注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了@Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在ElementType 枚举中。\",\"public enum ElementType { TYPE, // 类、接口、枚举类 FIELD, // 成员变量（包括：枚举常量） METHOD, // 成员方法 PARAMETER, // 方法参数 CONSTRUCTOR, // 构造方法 LOCAL_VARIABLE, // 局部变量 ANNOTATION_TYPE, // 注解类 PACKAGE, // 可用于修饰：包 TYPE_PARAMETER, // 类型参数，JDK 1.8 新增 TYPE_USE // 使用类型的任何地方，JDK 1.8 新增 } \"]},\"228\":{\"h\":\"元注解 - @Retention & @RetentionTarget\",\"t\":[\"Reteniton注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。\",\"Reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在RetentionPolicy枚举中。\",\"public enum RetentionPolicy { SOURCE, // 源文件保留 CLASS, // 编译期保留，默认值 RUNTIME // 运行期保留，可通过反射去获取注解信息 } \",\"为了验证应用了这三种策略的注解类有何区别，分别使用三种策略各定义一个注解类做测试。\",\"@Retention(RetentionPolicy.SOURCE) public @interface SourcePolicy { } @Retention(RetentionPolicy.CLASS) public @interface ClassPolicy { } @Retention(RetentionPolicy.RUNTIME) public @interface RuntimePolicy { } \",\"用定义好的三个注解类分别去注解一个方法。\",\"public class RetentionTest { @SourcePolicy public void sourcePolicy() { } @ClassPolicy public void classPolicy() { } @RuntimePolicy public void runtimePolicy() { } } \",\"通过执行 javap -verbose RetentionTest命令获取到的RetentionTest 的 class 字节码内容如下。\",\"{ public retention.RetentionTest(); flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\\\"<init>\\\":()V 4: return LineNumberTable: line 3: 0 public void sourcePolicy(); flags: ACC_PUBLIC Code: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 7: 0 public void classPolicy(); flags: ACC_PUBLIC Code: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 11: 0 RuntimeInvisibleAnnotations: 0: #11() public void runtimePolicy(); flags: ACC_PUBLIC Code: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 15: 0 RuntimeVisibleAnnotations: 0: #14() } \",\"从 RetentionTest 的字节码内容我们可以得出以下两点结论：\",\"编译器并没有记录下 sourcePolicy() 方法的注解信息；\",\"编译器分别使用了 RuntimeInvisibleAnnotations 和 RuntimeVisibleAnnotations 属性去记录了classPolicy()方法 和 runtimePolicy()方法 的注解信息；\"]},\"229\":{\"h\":\"元注解 - @Documented\",\"t\":[\"Documented注解的作用是：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。\",\"以下代码在使用Javadoc工具可以生成@TestDocAnnotation注解信息。\",\"import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Target; @Documented @Target({ElementType.TYPE,ElementType.METHOD}) public @interface TestDocAnnotation { public String value() default \\\"default\\\"; } @TestDocAnnotation(\\\"myMethodDoc\\\") public void testDoc() { } \"]},\"230\":{\"h\":\"元注解 - @Inherited\",\"t\":[\"Inherited注解的作用：被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。\",\"我们来测试下这个注解：\",\"定义@Inherited注解：\",\"@Inherited @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE,ElementType.METHOD}) public @interface TestInheritedAnnotation { String [] values(); int number(); } \",\"使用这个注解\",\"@TestInheritedAnnotation(values = {\\\"value\\\"}, number = 10) public class Person { } class Student extends Person{ @Test public void test(){ Class clazz = Student.class; Annotation[] annotations = clazz.getAnnotations(); for (Annotation annotation : annotations) { System.out.println(annotation.toString()); } } } \",\"输出\",\"xxxxxxx.TestInheritedAnnotation(values=[value], number=10) \",\"即使Student类没有显示地被注解@TestInheritedAnnotation，但是它的父类Person被注解，而且@TestInheritedAnnotation被@Inherited注解，因此Student类自动有了该注解。\"]},\"231\":{\"h\":\"元注解 - @Repeatable (Java8)\",\"t\":[\"@Repeatable请参考Java 8 - 重复注解\"]},\"232\":{\"h\":\"元注解 - @Native (Java8)\",\"t\":[\"使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可\"]},\"233\":{\"h\":\"注解与反射接口\",\"t\":[\"定义注解后，如何获取注解中的内容呢？反射包java.lang.reflect下的AnnotatedElement接口提供这些方法。这里注意：只有注解被定义为RUNTIME后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。\",\"AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。我们看下具体的先关接口\",\"boolean isAnnotationPresent(Class<?extends Annotation> annotationClass)\",\"判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。\",\"<T extends Annotation> T getAnnotation(Class<T> annotationClass)\",\"返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。\",\"Annotation[] getAnnotations()\",\"返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。\",\"<T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass)\",\"返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为0的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。getAnnotationsByType方法与 getAnnotation的区别在于，getAnnotationsByType会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。\",\"<T extends Annotation> T getDeclaredAnnotation(Class<T> annotationClass)\",\"返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null\",\"<T extends Annotation> T[] getDeclaredAnnotationsByType(Class<T> annotationClass)\",\"返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释\",\"Annotation[] getDeclaredAnnotations()\",\"返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。\"]},\"234\":{\"h\":\"自定义注解\",\"t\":[\"当我们理解了内置注解, 元注解和获取注解的反射接口后，我们便可以开始自定义注解了。这个例子我把上述的知识点全部融入进来, 代码很简单：\",\"定义自己的注解\",\"package com.pdai.java.annotation; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface MyMethodAnnotation { public String title() default \\\"\\\"; public String description() default \\\"\\\"; } \",\"使用注解\",\"package com.pdai.java.annotation; import java.io.FileNotFoundException; import java.lang.annotation.Annotation; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.List; public class TestMethodAnnotation { @Override @MyMethodAnnotation(title = \\\"toStringMethod\\\", description = \\\"override toString method\\\") public String toString() { return \\\"Override toString method\\\"; } @Deprecated @MyMethodAnnotation(title = \\\"old static method\\\", description = \\\"deprecated old static method\\\") public static void oldMethod() { System.out.println(\\\"old method, don't use it.\\\"); } @SuppressWarnings({\\\"unchecked\\\", \\\"deprecation\\\"}) @MyMethodAnnotation(title = \\\"test method\\\", description = \\\"suppress warning static method\\\") public static void genericsTest() throws FileNotFoundException { List l = new ArrayList(); l.add(\\\"abc\\\"); oldMethod(); } } \",\"用反射接口获取注解信息\",\"在TestMethodAnnotation中添加Main方法进行测试：\",\"public static void main(String[] args) { try { // 获取所有methods Method[] methods = TestMethodAnnotation.class.getClassLoader() .loadClass((\\\"com.pdai.java.annotation.TestMethodAnnotation\\\")) .getMethods(); // 遍历 for (Method method : methods) { // 方法上是否有MyMethodAnnotation注解 if (method.isAnnotationPresent(MyMethodAnnotation.class)) { try { // 获取并遍历方法上的所有注解 for (Annotation anno : method.getDeclaredAnnotations()) { System.out.println(\\\"Annotation in Method '\\\" + method + \\\"' : \\\" + anno); } // 获取MyMethodAnnotation对象信息 MyMethodAnnotation methodAnno = method .getAnnotation(MyMethodAnnotation.class); System.out.println(methodAnno.title()); } catch (Throwable ex) { ex.printStackTrace(); } } } } catch (SecurityException | ClassNotFoundException e) { e.printStackTrace(); } } \",\"测试的输出\",\"Annotation in Method 'public static void com.pdai.java.annotation.TestMethodAnnotation.oldMethod()' : @java.lang.Deprecated() Annotation in Method 'public static void com.pdai.java.annotation.TestMethodAnnotation.oldMethod()' : @com.pdai.java.annotation.MyMethodAnnotation(title=old static method, description=deprecated old static method) old static method Annotation in Method 'public static void com.pdai.java.annotation.TestMethodAnnotation.genericsTest() throws java.io.FileNotFoundException' : @com.pdai.java.annotation.MyMethodAnnotation(title=test method, description=suppress warning static method) test method Annotation in Method 'public java.lang.String com.pdai.java.annotation.TestMethodAnnotation.toString()' : @com.pdai.java.annotation.MyMethodAnnotation(title=toStringMethod, description=override toString method) toStringMethod \"]},\"235\":{\"h\":\"深入理解注解\",\"t\":[\"提示\",\"接下来，我们从其它角度深入理解注解\"]},\"236\":{\"h\":\"Java8提供了哪些新的注解？\",\"t\":[\"@Repeatable\",\"请参考Java 8 - 重复注解\",\"ElementType.TYPE_USE\",\"请参考Java 8 - 类型注解\",\"ElementType.TYPE_PARAMETER\",\"ElementType.TYPE_USE(此类型包括类型声明和类型参数声明，是为了方便设计者进行类型检查)包含了ElementType.TYPE(类、接口（包括注解类型）和枚举的声明)和ElementType.TYPE_PARAMETER(类型参数声明), 不妨再看个例子\",\"// 自定义ElementType.TYPE_PARAMETER注解 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE_PARAMETER) public @interface MyNotEmpty { } // 自定义ElementType.TYPE_USE注解 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE_USE) public @interface MyNotNull { } // 测试类 public class TypeParameterAndTypeUseAnnotation<@MyNotEmpty T>{ //使用TYPE_PARAMETER类型，会编译不通过 // public @MyNotEmpty T test(@MyNotEmpty T a){ // new ArrayList<@MyNotEmpty String>(); // return a; // } //使用TYPE_USE类型，编译通过 public @MyNotNull T test2(@MyNotNull T a){ new ArrayList<@MyNotNull String>(); return a; } } \"]},\"237\":{\"h\":\"注解支持继承吗？\",\"t\":[\"注解是不支持继承的\",\"不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继承java.lang.annotation.Annotation接口.\",\"虽然反编译后发现注解继承了Annotation接口，请记住，即使Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。\",\"区别于注解的继承，被注解的子类继承父类注解可以用@Inherited： 如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。\"]},\"238\":{\"h\":\"注解实现的原理？\",\"t\":[\"网上很多标注解的原理文章根本没有说到点子上。\",\"这里推荐你两篇文章：\",\"https://blog.csdn.net/qq_20009015/article/details/106038023\",\"https://www.race604.com/annotation-processing/\"]},\"239\":{\"h\":\"注解的应用场景\",\"t\":[\"提示\",\"最后我们再看看实际开发中注解的一些应用场景。@pdai\"]},\"240\":{\"h\":\"配置化到注解化 - 框架的演进\",\"t\":[\"Spring 框架 配置化到注解化的转变。\"]},\"241\":{\"h\":\"继承实现到注解实现 - Junit3到Junit4\",\"t\":[\"一个模块的封装大多数人都是通过继承和组合等模式来实现的，但是如果结合注解将可以极大程度提高实现的优雅度（降低耦合度）。而Junit3 到Junit4的演化就是最好的一个例子。\",\"被测试类\",\"public class HelloWorld { public void sayHello(){ System.out.println(\\\"hello....\\\"); throw new NumberFormatException(); } public void sayWorld(){ System.out.println(\\\"world....\\\"); } public String say(){ return \\\"hello world!\\\"; } } \",\"Junit 3 实现UT\",\"通过继承 TestCase来实现，初始化是通过Override父类方法来进行，测试方式通过test的前缀方法获取。\",\"public class HelloWorldTest extends TestCase{ private HelloWorld hw; @Override protected void setUp() throws Exception { super.setUp(); hw=new HelloWorld(); } //1.测试没有返回值 public void testHello(){ try { hw.sayHello(); } catch (Exception e) { System.out.println(\\\"发生异常.....\\\"); } } public void testWorld(){ hw.sayWorld(); } //2.测试有返回值的方法 // 返回字符串 public void testSay(){ assertEquals(\\\"测试失败\\\", hw.say(), \\\"hello world!\\\"); } //返回对象 public void testObj(){ assertNull(\\\"测试对象不为空\\\", null); assertNotNull(\\\"测试对象为空\\\",new String()); } @Override protected void tearDown() throws Exception { super.tearDown(); hw=null; } } \",\"Junit 4 实现UT\",\"通过定义@Before，@Test，@After等等注解来实现。\",\"public class HelloWorldTest { private HelloWorld hw; @Before public void setUp() { hw = new HelloWorld(); } @Test(expected=NumberFormatException.class) // 1.测试没有返回值,有别于junit3的使用，更加方便 public void testHello() { hw.sayHello(); } @Test public void testWorld() { hw.sayWorld(); } @Test // 2.测试有返回值的方法 // 返回字符串 public void testSay() { assertEquals(\\\"测试失败\\\", hw.say(), \\\"hello world!\\\"); } @Test // 返回对象 public void testObj() { assertNull(\\\"测试对象不为空\\\", null); assertNotNull(\\\"测试对象为空\\\", new String()); } @After public void tearDown() throws Exception { hw = null; } } \",\"这里我们发现通过注解的方式，我们实现单元测试时将更为优雅。如果你还期望了解Junit4是如何实现运行的呢？可以看这篇文章：JUnit4源码分析运行原理在新窗口打开。\"]},\"242\":{\"h\":\"自定义注解和AOP - 通过切面实现解耦\",\"t\":[\"最为常见的就是使用Spring AOP切面实现统一的操作日志管理，我这里找了一个开源项目中的例子（只展示主要代码），给你展示下如何通过注解实现解耦的。\",\"自定义Log注解\",\"@Target({ ElementType.PARAMETER, ElementType.METHOD }) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Log { /** * 模块 */ public String title() default \\\"\\\"; /** * 功能 */ public BusinessType businessType() default BusinessType.OTHER; /** * 操作人类别 */ public OperatorType operatorType() default OperatorType.MANAGE; /** * 是否保存请求的参数 */ public boolean isSaveRequestData() default true; } \",\"实现日志的切面, 对自定义注解Log作切点进行拦截\",\"即对注解了@Log的方法进行切点拦截，\",\"@Aspect @Component public class LogAspect { private static final Logger log = LoggerFactory.getLogger(LogAspect.class); /** * 配置织入点 - 自定义注解的包路径 * */ @Pointcut(\\\"@annotation(com.xxx.aspectj.lang.annotation.Log)\\\") public void logPointCut() { } /** * 处理完请求后执行 * * @param joinPoint 切点 */ @AfterReturning(pointcut = \\\"logPointCut()\\\", returning = \\\"jsonResult\\\") public void doAfterReturning(JoinPoint joinPoint, Object jsonResult) { handleLog(joinPoint, null, jsonResult); } /** * 拦截异常操作 * * @param joinPoint 切点 * @param e 异常 */ @AfterThrowing(value = \\\"logPointCut()\\\", throwing = \\\"e\\\") public void doAfterThrowing(JoinPoint joinPoint, Exception e) { handleLog(joinPoint, e, null); } protected void handleLog(final JoinPoint joinPoint, final Exception e, Object jsonResult) { try { // 获得注解 Log controllerLog = getAnnotationLog(joinPoint); if (controllerLog == null) { return; } // 获取当前的用户 User currentUser = ShiroUtils.getSysUser(); // *========数据库日志=========*// OperLog operLog = new OperLog(); operLog.setStatus(BusinessStatus.SUCCESS.ordinal()); // 请求的地址 String ip = ShiroUtils.getIp(); operLog.setOperIp(ip); // 返回参数 operLog.setJsonResult(JSONObject.toJSONString(jsonResult)); operLog.setOperUrl(ServletUtils.getRequest().getRequestURI()); if (currentUser != null) { operLog.setOperName(currentUser.getLoginName()); if (StringUtils.isNotNull(currentUser.getDept()) && StringUtils.isNotEmpty(currentUser.getDept().getDeptName())) { operLog.setDeptName(currentUser.getDept().getDeptName()); } } if (e != null) { operLog.setStatus(BusinessStatus.FAIL.ordinal()); operLog.setErrorMsg(StringUtils.substring(e.getMessage(), 0, 2000)); } // 设置方法名称 String className = joinPoint.getTarget().getClass().getName(); String methodName = joinPoint.getSignature().getName(); operLog.setMethod(className + \\\".\\\" + methodName + \\\"()\\\"); // 设置请求方式 operLog.setRequestMethod(ServletUtils.getRequest().getMethod()); // 处理设置注解上的参数 getControllerMethodDescription(controllerLog, operLog); // 保存数据库 AsyncManager.me().execute(AsyncFactory.recordOper(operLog)); } catch (Exception exp) { // 记录本地异常日志 log.error(\\\"==前置通知异常==\\\"); log.error(\\\"异常信息:{}\\\", exp.getMessage()); exp.printStackTrace(); } } /** * 获取注解中对方法的描述信息 用于Controller层注解 * * @param log 日志 * @param operLog 操作日志 * @throws Exception */ public void getControllerMethodDescription(Log log, OperLog operLog) throws Exception { // 设置action动作 operLog.setBusinessType(log.businessType().ordinal()); // 设置标题 operLog.setTitle(log.title()); // 设置操作人类别 operLog.setOperatorType(log.operatorType().ordinal()); // 是否需要保存request，参数和值 if (log.isSaveRequestData()) { // 获取参数的信息，传入到数据库中。 setRequestValue(operLog); } } /** * 获取请求的参数，放到log中 * * @param operLog * @param request */ private void setRequestValue(OperLog operLog) { Map<String, String[]> map = ServletUtils.getRequest().getParameterMap(); String params = JSONObject.toJSONString(map); operLog.setOperParam(StringUtils.substring(params, 0, 2000)); } /** * 是否存在注解，如果存在就获取 */ private Log getAnnotationLog(JoinPoint joinPoint) throws Exception { Signature signature = joinPoint.getSignature(); MethodSignature methodSignature = (MethodSignature) signature; Method method = methodSignature.getMethod(); if (method != null) { return method.getAnnotation(Log.class); } return null; } } \",\"使用@Log注解\",\"以一个简单的CRUD操作为例, 这里展示部分代码：每对“部门”进行操作就会产生一条操作日志存入数据库。\",\"@Controller @RequestMapping(\\\"/system/dept\\\") public class DeptController extends BaseController { private String prefix = \\\"system/dept\\\"; @Autowired private IDeptService deptService; /** * 新增保存部门 */ @Log(title = \\\"部门管理\\\", businessType = BusinessType.INSERT) @RequiresPermissions(\\\"system:dept:add\\\") @PostMapping(\\\"/add\\\") @ResponseBody public AjaxResult addSave(@Validated Dept dept) { if (UserConstants.DEPT_NAME_NOT_UNIQUE.equals(deptService.checkDeptNameUnique(dept))) { return error(\\\"新增部门'\\\" + dept.getDeptName() + \\\"'失败，部门名称已存在\\\"); } return toAjax(deptService.insertDept(dept)); } /** * 保存 */ @Log(title = \\\"部门管理\\\", businessType = BusinessType.UPDATE) @RequiresPermissions(\\\"system:dept:edit\\\") @PostMapping(\\\"/edit\\\") @ResponseBody public AjaxResult editSave(@Validated Dept dept) { if (UserConstants.DEPT_NAME_NOT_UNIQUE.equals(deptService.checkDeptNameUnique(dept))) { return error(\\\"修改部门'\\\" + dept.getDeptName() + \\\"'失败，部门名称已存在\\\"); } else if(dept.getParentId().equals(dept.getDeptId())) { return error(\\\"修改部门'\\\" + dept.getDeptName() + \\\"'失败，上级部门不能是自己\\\"); } return toAjax(deptService.updateDept(dept)); } /** * 删除 */ @Log(title = \\\"部门管理\\\", businessType = BusinessType.DELETE) @RequiresPermissions(\\\"system:dept:remove\\\") @GetMapping(\\\"/remove/{deptId}\\\") @ResponseBody public AjaxResult remove(@PathVariable(\\\"deptId\\\") Long deptId) { if (deptService.selectDeptCount(deptId) > 0) { return AjaxResult.warn(\\\"存在下级部门,不允许删除\\\"); } if (deptService.checkDeptExistUser(deptId)) { return AjaxResult.warn(\\\"部门存在用户,不允许删除\\\"); } return toAjax(deptService.deleteDeptById(deptId)); } // ... } \",\"同样的，你也可以看到权限管理也是通过类似的注解（@RequiresPermissions）机制来实现的。所以我们可以看到，通过注解+AOP最终的目标是为了实现模块的解耦。\"]},\"243\":{\"h\":\"参考文章\",\"t\":[\"https://blog.csdn.net/javazejian/article/details/71860633\",\"https://blog.csdn.net/qq_20009015/article/details/106038023\",\"https://www.zhihu.com/question/47449512\",\"https://www.race604.com/annotation-processing/\",\"https://www.runoob.com/w3cnote/java-annotation.html\",\"著作权归@pdai所有 原文链接：https://pdai.tech/md/java/basic/java-basic-x-annotation.html\"]},\"244\":{\"h\":\"异常机制详解\",\"t\":[\"Java异常是Java提供的一种识别及响应错误的一致性机制，java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。本文综合多篇文章后，总结了Java 异常的相关知识，希望可以提升你对Java中异常的认知效率。@pdai\"]},\"245\":{\"h\":\"异常的层次结构\",\"t\":[\"异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。\",\"Java异常类层次结构图：\",\"img\"]},\"246\":{\"h\":\"Throwable\",\"t\":[\"Throwable 是 Java 语言中所有错误与异常的超类。\",\"Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。\",\"Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。\"]},\"247\":{\"h\":\"Error（错误）\",\"t\":[\"Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。\",\"此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。\",\"这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！\"]},\"248\":{\"h\":\"Exception（异常）\",\"t\":[\"程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。\",\"运行时异常\",\"都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。\",\"运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。\",\"非运行时异常 （编译异常）\",\"是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。\"]},\"249\":{\"h\":\"可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）\",\"t\":[\"可查异常（编译器要求必须处置的异常）：\",\"正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。\",\"除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。\",\"不可查异常(编译器不要求强制处置的异常)\",\"包括运行时异常（RuntimeException与其子类）和错误（Error）。\"]},\"250\":{\"h\":\"异常基础\",\"t\":[\"提示\",\"接下来我们看下异常使用的基础。\"]},\"251\":{\"h\":\"异常关键字\",\"t\":[\"try – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。\",\"catch – 用于捕获异常。catch用来捕获try语句块中发生的异常。\",\"finally – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。\",\"throw – 用于抛出异常。\",\"throws – 用在方法签名中，用于声明该方法可能抛出的异常。\"]},\"252\":{\"h\":\"异常的申明(throws)\",\"t\":[\"在Java中，当前执行的语句必属于某个方法，Java解释器调用main方法执行开始执行程序。若方法中存在检查异常，如果不对其捕获，那必须在方法头中显式声明该异常，以便于告知方法调用者此方法有异常，需要进行处理。 在方法中声明一个异常，方法头中使用关键字throws，后面接上要声明的异常。若声明多个异常，则使用逗号分割。如下所示：\",\"public static void method() throws IOException, FileNotFoundException{ //something statements } \",\"注意：若是父类的方法没有声明异常，则子类继承方法后，也不能声明异常。\",\"通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。\",\"private static void readFile(String filePath) throws IOException { File file = new File(filePath); String result; BufferedReader reader = new BufferedReader(new FileReader(file)); while((result = reader.readLine())!=null) { System.out.println(result); } reader.close(); } \",\"Throws抛出异常的规则：\",\"如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。\",\"必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误\",\"仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。\",\"调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。\"]},\"253\":{\"h\":\"异常的抛出(throw)\",\"t\":[\"如果代码可能会引发某种错误，可以创建一个合适的异常类实例并抛出它，这就是抛出异常。如下所示：\",\"public static double method(int value) { if(value == 0) { throw new ArithmeticException(\\\"参数不能为0\\\"); //抛出一个运行时异常 } return 5.0 / value; } \",\"大部分情况下都不需要手动抛出异常，因为Java的大部分方法要么已经处理异常，要么已声明异常。所以一般都是捕获异常或者再往上抛。\",\"有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。\",\"private static void readFile(String filePath) throws MyException { try { // code } catch (IOException e) { MyException ex = new MyException(\\\"read file failed.\\\"); ex.initCause(e); throw ex; } } \"]},\"254\":{\"h\":\"异常的自定义\",\"t\":[\"习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）, 比如上面用到的自定义MyException：\",\"public class MyException extends Exception { public MyException(){ } public MyException(String msg){ super(msg); } // ... } \"]},\"255\":{\"h\":\"异常的捕获\",\"t\":[\"异常捕获处理的方法通常有：\",\"try-catch\",\"try-catch-finally\",\"try-finally\",\"try-with-resource\"]},\"256\":{\"h\":\"try-catch\",\"t\":[\"在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理\",\"private static void readFile(String filePath) { try { // code } catch (FileNotFoundException e) { // handle FileNotFoundException } catch (IOException e){ // handle IOException } } \",\"同一个 catch 也可以捕获多种类型异常，用 | 隔开\",\"private static void readFile(String filePath) { try { // code } catch (FileNotFoundException | UnknownHostException e) { // handle FileNotFoundException or UnknownHostException } catch (IOException e){ // handle IOException } } \"]},\"257\":{\"h\":\"try-catch-finally\",\"t\":[\"常规语法\",\"try { //执行程序代码，可能会出现异常 } catch(Exception e) { //捕获异常并处理 } finally { //必执行的代码 } \",\"执行的顺序 \",\"当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句；\",\"当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行；\",\"当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句；\",\"img\",\"一个完整的例子\",\"private static void readFile(String filePath) throws MyException { File file = new File(filePath); String result; BufferedReader reader = null; try { reader = new BufferedReader(new FileReader(file)); while((result = reader.readLine())!=null) { System.out.println(result); } } catch (IOException e) { System.out.println(\\\"readFile method catch block.\\\"); MyException ex = new MyException(\\\"read file failed.\\\"); ex.initCause(e); throw ex; } finally { System.out.println(\\\"readFile method finally block.\\\"); if (null != reader) { try { reader.close(); } catch (IOException e) { e.printStackTrace(); } } } } \"]},\"258\":{\"h\":\"try-finally\",\"t\":[\"可以直接用try-finally吗？ 可以。\",\"try块中引起异常，异常代码之后的语句不再执行，直接执行finally语句。 try块没有引发异常，则执行完try块就执行finally语句。\",\"try-finally可用在不需要捕获异常的代码，可以保证资源在使用后被关闭。例如IO流中执行完相应操作后，关闭相应资源；使用Lock对象保证线程同步，通过finally可以保证锁会被释放；数据库连接代码时，关闭连接操作等等。\",\"//以Lock加锁为例，演示try-finally ReentrantLock lock = new ReentrantLock(); try { //需要加锁的代码 } finally { lock.unlock(); //保证锁一定被释放 } \",\"finally遇见如下情况不会执行\",\"在前面的代码中用了System.exit()退出程序。\",\"finally语句块中发生了异常。\",\"程序所在的线程死亡。\",\"关闭CPU。\"]},\"259\":{\"h\":\"try-with-resource\",\"t\":[\"try-with-resource是Java 7中引入的，很容易被忽略。\",\"上面例子中，finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。\",\"代码实现\",\"private static void tryWithResourceTest(){ try (Scanner scanner = new Scanner(new FileInputStream(\\\"c:/abc\\\"),\\\"UTF-8\\\")){ // code } catch (IOException e){ // handle exception } } \",\"看下Scanner\",\"public final class Scanner implements Iterator<String>, Closeable { // ... } public interface Closeable extends AutoCloseable { public void close() throws IOException; } \",\"try 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取。\"]},\"260\":{\"h\":\"异常基础总结\",\"t\":[\"try、catch和finally都不能单独使用，只能是try-catch、try-finally或者try-catch-finally。\",\"try语句块监控代码，出现异常就停止执行下面的代码，然后将异常移交给catch语句块来处理。\",\"finally语句块中的代码一定会被执行，常用于回收资源 。\",\"throws：声明一个异常，告知方法调用者。\",\"throw ：抛出一个异常，至于该异常被捕获还是继续抛出都与它无关。\",\"Java编程思想一书中，对异常的总结。\",\"在恰当的级别处理问题。（在知道该如何处理的情况下了捕获异常。）\",\"解决问题并且重新调用产生异常的方法。\",\"进行少许修补，然后绕过异常发生的地方继续执行。\",\"用别的数据进行计算，以代替方法预计会返回的值。\",\"把当前运行环境下能做的事尽量做完，然后把相同的异常重抛到更高层。\",\"把当前运行环境下能做的事尽量做完，然后把不同的异常抛到更高层。\",\"终止程序。\",\"进行简化（如果你的异常模式使问题变得太复杂，那么用起来会非常痛苦）。\",\"让类库和程序更安全。\"]},\"261\":{\"h\":\"常用的异常\",\"t\":[\"在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类:\",\"RuntimeException\",\"java.lang.ArrayIndexOutOfBoundsException 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。\",\"java.lang.ArithmeticException 算术条件异常。譬如：整数除零等。\",\"java.lang.NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等\",\"java.lang.ClassNotFoundException 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。\",\"java.lang.NegativeArraySizeException 数组长度为负异常\",\"java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常\",\"java.lang.SecurityException 安全性异常\",\"java.lang.IllegalArgumentException 非法参数异常\",\"IOException\",\"IOException：操作输入流和输出流时可能出现的异常。\",\"EOFException 文件已结束异常\",\"FileNotFoundException 文件未找到异常\",\"其他\",\"ClassCastException 类型转换异常类\",\"ArrayStoreException 数组中包含不兼容的值抛出的异常\",\"SQLException 操作数据库异常类\",\"NoSuchFieldException 字段未找到异常\",\"NoSuchMethodException 方法未找到抛出的异常\",\"NumberFormatException 字符串转换为数字抛出的异常\",\"StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常\",\"IllegalAccessException 不允许访问某类异常\",\"InstantiationException 当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常\"]},\"262\":{\"h\":\"异常实践\",\"t\":[\"提示\",\"在 Java 中处理异常并不是一个简单的事情。不仅仅初学者很难理解，即使一些有经验的开发者也需要花费很多时间来思考如何处理异常，包括需要处理哪些异常，怎样处理等等。这也是绝大多数开发团队都会制定一些规则来规范进行异常处理的原因。\",\"当你抛出或捕获异常的时候，有很多不同的情况需要考虑，而且大部分事情都是为了改善代码的可读性或者 API 的可用性。\",\"异常不仅仅是一个错误控制机制，也是一个通信媒介。因此，为了和同事更好的合作，一个团队必须要制定出一个最佳实践和规则，只有这样，团队成员才能理解这些通用概念，同时在工作中使用它。\",\"这里给出几个被很多团队使用的异常处理最佳实践。\"]},\"263\":{\"h\":\"只针对不正常的情况才使用异常\",\"t\":[\"异常只应该被用于不正常的条件，它们永远不应该被用于正常的控制流。《阿里手册》中：【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。\",\"比如，在解析字符串形式的数字时，可能存在数字格式错误，不得通过catch Exception来实现\",\"代码1\",\"if (obj != null) { //... } \",\"代码2\",\"try { obj.method(); } catch (NullPointerException e) { //... } \",\"主要原因有三点：\",\"异常机制的设计初衷是用于不正常的情况，所以很少会会JVM实现试图对它们的性能进行优化。所以，创建、抛出和捕获异常的开销是很昂贵的。\",\"把代码放在try-catch中返回阻止了JVM实现本来可能要执行的某些特定的优化。\",\"对数组进行遍历的标准模式并不会导致冗余的检查，有些现代的JVM实现会将它们优化掉。\"]},\"264\":{\"h\":\"在 finally 块中清理资源或者使用 try-with-resource 语句\",\"t\":[\"当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源。\",\"错误示例\",\"public void doNotCloseResourceInTry() { FileInputStream inputStream = null; try { File file = new File(\\\"./tmp.txt\\\"); inputStream = new FileInputStream(file); // use the inputStream to read a file // do NOT do this inputStream.close(); } catch (FileNotFoundException e) { log.error(e); } catch (IOException e) { log.error(e); } } \",\"问题就是，只有没有异常抛出的时候，这段代码才可以正常工作。try 代码块内代码会正常执行，并且资源可以正常关闭。但是，使用 try 代码块是有原因的，一般调用一个或多个可能抛出异常的方法，而且，你自己也可能会抛出一个异常，这意味着代码可能不会执行到 try 代码块的最后部分。结果就是，你并没有关闭资源。\",\"所以，你应该把清理工作的代码放到 finally 里去，或者使用 try-with-resource 特性。\",\"方法一：使用 finally 代码块\",\"与前面几行 try 代码块不同，finally 代码块总是会被执行。不管 try 代码块成功执行之后还是你在 catch 代码块中处理完异常后都会执行。因此，你可以确保你清理了所有打开的资源。\",\"public void closeResourceInFinally() { FileInputStream inputStream = null; try { File file = new File(\\\"./tmp.txt\\\"); inputStream = new FileInputStream(file); // use the inputStream to read a file } catch (FileNotFoundException e) { log.error(e); } finally { if (inputStream != null) { try { inputStream.close(); } catch (IOException e) { log.error(e); } } } } \",\"方法二：Java 7 的 try-with-resource 语法\",\"如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。\",\"public void automaticallyCloseResource() { File file = new File(\\\"./tmp.txt\\\"); try (FileInputStream inputStream = new FileInputStream(file);) { // use the inputStream to read a file } catch (FileNotFoundException e) { log.error(e); } catch (IOException e) { log.error(e); } } \"]},\"265\":{\"h\":\"尽量使用标准的异常\",\"t\":[\"代码重用是值得提倡的，这是一条通用规则，异常也不例外。\",\"重用现有的异常有几个好处：\",\"它使得你的API更加易于学习和使用，因为它与程序员原来已经熟悉的习惯用法是一致的。\",\"对于用到这些API的程序而言，它们的可读性更好，因为它们不会充斥着程序员不熟悉的异常。\",\"异常类越少，意味着内存占用越小，并且转载这些类的时间开销也越小。\",\"Java标准异常中有几个是经常被使用的异常。如下表格：\",\"异常\",\"使用场合\",\"IllegalArgumentException\",\"参数的值不合适\",\"IllegalStateException\",\"参数的状态不合适\",\"NullPointerException\",\"在null被禁止的情况下参数值为null\",\"IndexOutOfBoundsException\",\"下标越界\",\"ConcurrentModificationException\",\"在禁止并发修改的情况下，对象检测到并发修改\",\"UnsupportedOperationException\",\"对象不支持客户请求的方法\",\"虽然它们是Java平台库迄今为止最常被重用的异常，但是，在许可的条件下，其它的异常也可以被重用。例如，如果你要实现诸如复数或者矩阵之类的算术对象，那么重用ArithmeticException和NumberFormatException将是非常合适的。如果一个异常满足你的需要，则不要犹豫，使用就可以，不过你一定要确保抛出异常的条件与该异常的文档中描述的条件一致。这种重用必须建立在语义的基础上，而不是名字的基础上。\",\"最后，一定要清楚，选择重用哪一种异常并没有必须遵循的规则。例如，考虑纸牌对象的情形，假设有一个用于发牌操作的方法，它的参数(handSize)是发一手牌的纸牌张数。假设调用者在这个参数中传递的值大于整副牌的剩余张数。那么这种情形既可以被解释为IllegalArgumentException(handSize的值太大)，也可以被解释为IllegalStateException(相对客户的请求而言，纸牌对象的纸牌太少)。\"]},\"266\":{\"h\":\"对异常进行文档说明\",\"t\":[\"当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。\",\"在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。\",\"/** * Method description * * @throws MyBusinessException - businuess exception description */ public void doSomething(String input) throws MyBusinessException { // ... } \",\"同时，在抛出MyBusinessException 异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是在监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。\"]},\"267\":{\"h\":\"优先捕获最具体的异常\",\"t\":[\"大多数 IDE 都可以帮助你实现这个最佳实践。当你尝试首先捕获较不具体的异常时，它们会报告无法访问的代码块。\",\"但问题在于，只有匹配异常的第一个 catch 块会被执行。 因此，如果首先捕获 IllegalArgumentException ，则永远不会到达应该处理更具体的 NumberFormatException 的 catch 块，因为它是 IllegalArgumentException 的子类。\",\"总是优先捕获最具体的异常类，并将不太具体的 catch 块添加到列表的末尾。\",\"你可以在下面的代码片断中看到这样一个 try-catch 语句的例子。 第一个 catch 块处理所有 NumberFormatException 异常，第二个处理所有非 NumberFormatException 异常的IllegalArgumentException 异常。\",\"public void catchMostSpecificExceptionFirst() { try { doSomething(\\\"A message\\\"); } catch (NumberFormatException e) { log.error(e); } catch (IllegalArgumentException e) { log.error(e) } } \"]},\"268\":{\"h\":\"不要捕获 Throwable 类\",\"t\":[\"Throwable 是所有异常和错误的超类。你可以在 catch 子句中使用它，但是你永远不应该这样做！\",\"如果在 catch 子句中使用 Throwable ，它不仅会捕获所有异常，也将捕获所有的错误。JVM 抛出错误，指出不应该由应用程序处理的严重问题。 典型的例子是 OutOfMemoryError 或者 StackOverflowError 。两者都是由应用程序控制之外的情况引起的，无法处理。\",\"所以，最好不要捕获 Throwable ，除非你确定自己处于一种特殊的情况下能够处理错误。\",\"public void doNotCatchThrowable() { try { // do something } catch (Throwable t) { // don't do this! } } \"]},\"269\":{\"h\":\"不要忽略异常\",\"t\":[\"很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。\",\"public void doNotIgnoreExceptions() { try { // do something } catch (NumberFormatException e) { // this will never happen } } \",\"但现实是经常会出现无法预料的异常，或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。\",\"合理的做法是至少要记录异常的信息。\",\"public void logAnException() { try { // do something } catch (NumberFormatException e) { log.error(\\\"This should never happen: \\\" + e); // see this line } } \"]},\"270\":{\"h\":\"不要记录并抛出异常\",\"t\":[\"这可能是本文中最常被忽略的最佳实践。\",\"可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下：\",\"try { new Long(\\\"xyz\\\"); } catch (NumberFormatException e) { log.error(e); throw e; } \",\"这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。如下：\",\"17:44:28,945 ERROR TestExceptionHandling:65 - java.lang.NumberFormatException: For input string: \\\"xyz\\\" Exception in thread \\\"main\\\" java.lang.NumberFormatException: For input string: \\\"xyz\\\" at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Long.parseLong(Long.java:589) at java.lang.Long.(Long.java:965) at com.stackify.example.TestExceptionHandling.logAndThrowException(TestExceptionHandling.java:63) at com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.java:58) \",\"如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。\",\"public void wrapException(String input) throws MyBusinessException { try { // do something } catch (NumberFormatException e) { throw new MyBusinessException(\\\"A message that describes the error.\\\", e); } } \",\"因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。\"]},\"271\":{\"h\":\"包装异常时不要抛弃原始的异常\",\"t\":[\"捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。 在你这样做时，请确保将原始异常设置为原因（注：参考下方代码 NumberFormatException e 中的原始异常 e ）。Exception 类提供了特殊的构造函数方法，它接受一个 Throwable 作为参数。否则，你将会丢失堆栈跟踪和原始异常的消息，这将会使分析导致异常的异常事件变得困难。\",\"public void wrapException(String input) throws MyBusinessException { try { // do something } catch (NumberFormatException e) { throw new MyBusinessException(\\\"A message that describes the error.\\\", e); } } \"]},\"272\":{\"h\":\"不要使用异常控制程序的流程\",\"t\":[\"不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。\"]},\"273\":{\"h\":\"不要在finally块中使用return。\",\"t\":[\"try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。\",\"如下是一个反例：\",\"private int x = 0; public int checkReturn() { try { // x等于1，此处不返回 return ++x; } finally { // 返回的结果是2 return ++x; } } \"]},\"274\":{\"h\":\"深入理解异常\",\"t\":[\"提示\",\"我们再深入理解下异常，看下底层实现。\"]},\"275\":{\"h\":\"JVM处理异常的机制？\",\"t\":[\"提到JVM处理异常的机制，就需要提及Exception Table，以下称为异常表。我们暂且不急于介绍异常表，先看一个简单的 Java 处理异常的小例子。\",\"public static void simpleTryCatch() { try { testNPE(); } catch (Exception e) { e.printStackTrace(); } } \",\"上面的代码是一个很简单的例子，用来捕获处理一个潜在的空指针异常。\",\"当然如果只是看简简单单的代码，我们很难看出什么高深之处，更没有了今天文章要谈论的内容。\",\"所以这里我们需要借助一把神兵利器，它就是javap,一个用来拆解class文件的工具，和javac一样由JDK提供。\",\"然后我们使用javap来分析这段代码（需要先使用javac编译）\",\"//javap -c Main public static void simpleTryCatch(); Code: 0: invokestatic #3 // Method testNPE:()V 3: goto 11 6: astore_0 7: aload_0 8: invokevirtual #5 // Method java/lang/Exception.printStackTrace:()V 11: return Exception table: from to target type 0 3 6 Class java/lang/Exception \",\"看到上面的代码，应该会有会心一笑，因为终于看到了Exception table，也就是我们要研究的异常表。\",\"异常表中包含了一个或多个异常处理者(Exception Handler)的信息，这些信息包含如下\",\"from 可能发生异常的起始点\",\"to 可能发生异常的结束点\",\"target 上述from和to之前发生异常后的异常处理者的位置\",\"type 异常处理者处理的异常的类信息\",\"那么异常表用在什么时候呢\",\"答案是异常发生的时候，当一个异常发生时\",\"1.JVM会在当前出现异常的方法中，查找异常表，是否有合适的处理者来处理\",\"2.如果当前方法异常表不为空，并且异常符合处理者的from和to节点，并且type也匹配，则JVM调用位于target的调用者来处理。\",\"3.如果上一条未找到合理的处理者，则继续查找异常表中的剩余条目\",\"4.如果当前方法的异常表无法处理，则向上查找（弹栈处理）刚刚调用该方法的调用处，并重复上面的操作。\",\"5.如果所有的栈帧被弹出，仍然没有处理，则抛给当前的Thread，Thread则会终止。\",\"6.如果当前Thread为最后一个非守护线程，且未处理异常，则会导致JVM终止运行。\",\"以上就是JVM处理异常的一些机制。\",\"try catch -finally\",\"除了简单的try-catch外，我们还常常和finally做结合使用。比如这样的代码\",\"public static void simpleTryCatchFinally() { try { testNPE(); } catch (Exception e) { e.printStackTrace(); } finally { System.out.println(\\\"Finally\\\"); } } \",\"同样我们使用javap分析一下代码\",\"public static void simpleTryCatchFinally(); Code: 0: invokestatic #3 // Method testNPE:()V 3: getstatic #6 // Field java/lang/System.out:Ljava/io/PrintStream; 6: ldc #7 // String Finally 8: invokevirtual #8 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 11: goto 41 14: astore_0 15: aload_0 16: invokevirtual #5 // Method java/lang/Exception.printStackTrace:()V 19: getstatic #6 // Field java/lang/System.out:Ljava/io/PrintStream; 22: ldc #7 // String Finally 24: invokevirtual #8 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 27: goto 41 30: astore_1 31: getstatic #6 // Field java/lang/System.out:Ljava/io/PrintStream; 34: ldc #7 // String Finally 36: invokevirtual #8 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 39: aload_1 40: athrow 41: return Exception table: from to target type 0 3 14 Class java/lang/Exception 0 3 30 any 14 19 30 any \",\"和之前有所不同，这次异常表中，有三条数据，而我们仅仅捕获了一个Exception, 异常表的后两个item的type为any; 上面的三条异常表item的意思为:\",\"如果0到3之间，发生了Exception类型的异常，调用14位置的异常处理者。\",\"如果0到3之间，无论发生什么异常，都调用30位置的处理者\",\"如果14到19之间（即catch部分），不论发生什么异常，都调用30位置的处理者。\",\"再次分析上面的Java代码，finally里面的部分已经被提取到了try部分和catch部分。我们再次调一下代码来看一下\",\"public static void simpleTryCatchFinally(); Code: //try 部分提取finally代码，如果没有异常发生，则执行输出finally操作，直至goto到41位置，执行返回操作。 0: invokestatic #3 // Method testNPE:()V 3: getstatic #6 // Field java/lang/System.out:Ljava/io/PrintStream; 6: ldc #7 // String Finally 8: invokevirtual #8 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 11: goto 41 //catch部分提取finally代码，如果没有异常发生，则执行输出finally操作，直至执行got到41位置，执行返回操作。 14: astore_0 15: aload_0 16: invokevirtual #5 // Method java/lang/Exception.printStackTrace:()V 19: getstatic #6 // Field java/lang/System.out:Ljava/io/PrintStream; 22: ldc #7 // String Finally 24: invokevirtual #8 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 27: goto 41 //finally部分的代码如果被调用，有可能是try部分，也有可能是catch部分发生异常。 30: astore_1 31: getstatic #6 // Field java/lang/System.out:Ljava/io/PrintStream; 34: ldc #7 // String Finally 36: invokevirtual #8 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 39: aload_1 40: athrow //如果异常没有被catch捕获，而是到了这里，执行完finally的语句后，仍然要把这个异常抛出去，传递给调用处。 41: return \",\"Catch先后顺序的问题\",\"我们在代码中的catch的顺序决定了异常处理者在异常表的位置，所以，越是具体的异常要先处理，否则就会出现下面的问题\",\"private static void misuseCatchException() { try { testNPE(); } catch (Throwable t) { t.printStackTrace(); } catch (Exception e) { //error occurs during compilings with tips Exception Java.lang.Exception has already benn caught. e.printStackTrace(); } } \",\"这段代码会导致编译失败，因为先捕获Throwable后捕获Exception，会导致后面的catch永远无法被执行。\",\"Return 和finally的问题\",\"这算是我们扩展的一个相对比较极端的问题，就是类似这样的代码，既有return，又有finally，那么finally导致会不会执行\",\"public static String tryCatchReturn() { try { testNPE(); return \\\"OK\\\"; } catch (Exception e) { return \\\"ERROR\\\"; } finally { System.out.println(\\\"tryCatchReturn\\\"); } } \",\"答案是finally会执行，那么还是使用上面的方法，我们来看一下为什么finally会执行。\",\"public static java.lang.String tryCatchReturn(); Code: 0: invokestatic #3 // Method testNPE:()V 3: ldc #6 // String OK 5: astore_0 6: getstatic #7 // Field java/lang/System.out:Ljava/io/PrintStream; 9: ldc #8 // String tryCatchReturn 11: invokevirtual #9 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 14: aload_0 15: areturn 返回OK字符串，areturn意思为return a reference from a method 16: astore_0 17: ldc #10 // String ERROR 19: astore_1 20: getstatic #7 // Field java/lang/System.out:Ljava/io/PrintStream; 23: ldc #8 // String tryCatchReturn 25: invokevirtual #9 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 28: aload_1 29: areturn //返回ERROR字符串 30: astore_2 31: getstatic #7 // Field java/lang/System.out:Ljava/io/PrintStream; 34: ldc #8 // String tryCatchReturn 36: invokevirtual #9 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 39: aload_2 40: athrow 如果catch有未处理的异常，抛出去。 \"]},\"276\":{\"h\":\"异常是否耗时？为什么会耗时？\",\"t\":[\"说用异常慢，首先来看看异常慢在哪里？有多慢？下面的测试用例简单的测试了建立对象、建立异常对象、抛出并接住异常对象三者的耗时对比：\",\"public class ExceptionTest { private int testTimes; public ExceptionTest(int testTimes) { this.testTimes = testTimes; } public void newObject() { long l = System.nanoTime(); for (int i = 0; i < testTimes; i++) { new Object(); } System.out.println(\\\"建立对象：\\\" + (System.nanoTime() - l)); } public void newException() { long l = System.nanoTime(); for (int i = 0; i < testTimes; i++) { new Exception(); } System.out.println(\\\"建立异常对象：\\\" + (System.nanoTime() - l)); } public void catchException() { long l = System.nanoTime(); for (int i = 0; i < testTimes; i++) { try { throw new Exception(); } catch (Exception e) { } } System.out.println(\\\"建立、抛出并接住异常对象：\\\" + (System.nanoTime() - l)); } public static void main(String[] args) { ExceptionTest test = new ExceptionTest(10000); test.newObject(); test.newException(); test.catchException(); } } \",\"运行结果：\",\"建立对象：575817 建立异常对象：9589080 建立、抛出并接住异常对象：47394475 \",\"建立一个异常对象，是建立一个普通Object耗时的约20倍（实际上差距会比这个数字更大一些，因为循环也占用了时间，追求精确的读者可以再测一下空循环的耗时然后在对比前减掉这部分），而抛出、接住一个异常对象，所花费时间大约是建立异常对象的4倍。\",\"那占用时间的“大头”：抛出、接住异常，系统到底做了什么事情？请参考这篇文章：\",\"https://www.iteye.com/blog/icyfenix-857722\"]},\"277\":{\"h\":\"参考文章\",\"t\":[\"https://blog.csdn.net/MacWx/article/details/90204111\",\"https://blog.csdn.net/hguisu/article/details/6155636\",\"https://blog.csdn.net/ThinkWon/article/details/101681073\",\"https://www.cnblogs.com/skywang12345/p/3544287.html\",\"https://www.codercto.com/a/33350.html\",\"著作权归@pdai所有 原文链接：https://pdai.tech/md/java/basic/java-basic-x-exception.html\"]},\"278\":{\"h\":\"泛型机制详解\",\"t\":[\"Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。本文综合多篇文章后，总结了Java 泛型的相关知识，希望可以提升你对Java中泛型的认知效率。@pdai\"]},\"279\":{\"h\":\"为什么会引入泛型\",\"t\":[\"泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。\",\"引入泛型的意义在于：\",\"适用于多种数据类型执行相同的代码（代码复用）\",\"我们通过一个例子来阐述，先看下下面的代码：\",\"private static int add(int a, int b) { System.out.println(a + \\\"+\\\" + b + \\\"=\\\" + (a + b)); return a + b; } private static float add(float a, float b) { System.out.println(a + \\\"+\\\" + b + \\\"=\\\" + (a + b)); return a + b; } private static double add(double a, double b) { System.out.println(a + \\\"+\\\" + b + \\\"=\\\" + (a + b)); return a + b; } \",\"如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法：\",\"private static <T extends Number> double add(T a, T b) { System.out.println(a + \\\"+\\\" + b + \\\"=\\\" + (a.doubleValue() + b.doubleValue())); return a.doubleValue() + b.doubleValue(); } \",\"泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）\",\"看下这个例子：\",\"List list = new ArrayList(); list.add(\\\"xxString\\\"); list.add(100d); list.add(new Person()); \",\"我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现java.lang.ClassCastException异常。\",\"引入泛型，它将提供类型的约束，提供编译前的检查：\",\"List<String> list = new ArrayList<String>(); // list中只能放String, 不能放其它类型的元素 \"]},\"280\":{\"h\":\"泛型的基本使用\",\"t\":[\"提示\",\"我们通过一些例子来学习泛型的使用；泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法。一些例子可以参考《李兴华 - Java实战经典》。@pdai\"]},\"281\":{\"h\":\"泛型类\",\"t\":[\"从一个简单的泛型类看起：\",\"class Point<T>{ // 此处可以随便写标识符号，T是type的简称 private T var ; // var的类型由T指定，即：由外部指定 public T getVar(){ // 返回值的类型由外部决定 return var ; } public void setVar(T var){ // 设置的类型也由外部决定 this.var = var ; } } public class GenericsDemo06{ public static void main(String args[]){ Point<String> p = new Point<String>() ; // 里面的var类型为String类型 p.setVar(\\\"it\\\") ; // 设置字符串 System.out.println(p.getVar().length()) ; // 取得字符串的长度 } } \",\"多元泛型\",\"class Notepad<K,V>{ // 此处指定了两个泛型类型 private K key ; // 此变量的类型由外部决定 private V value ; // 此变量的类型由外部决定 public K getKey(){ return this.key ; } public V getValue(){ return this.value ; } public void setKey(K key){ this.key = key ; } public void setValue(V value){ this.value = value ; } } public class GenericsDemo09{ public static void main(String args[]){ Notepad<String,Integer> t = null ; // 定义两个泛型类型的对象 t = new Notepad<String,Integer>() ; // 里面的key为String，value为Integer t.setKey(\\\"汤姆\\\") ; // 设置第一个内容 t.setValue(20) ; // 设置第二个内容 System.out.print(\\\"姓名；\\\" + t.getKey()) ; // 取得信息 System.out.print(\\\"，年龄；\\\" + t.getValue()) ; // 取得信息 } } \"]},\"282\":{\"h\":\"泛型接口\",\"t\":[\"简单的泛型接口\",\"interface Info<T>{ // 在接口上定义泛型 public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型 } class InfoImpl<T> implements Info<T>{ // 定义泛型接口的子类 private T var ; // 定义属性 public InfoImpl(T var){ // 通过构造方法设置属性内容 this.setVar(var) ; } public void setVar(T var){ this.var = var ; } public T getVar(){ return this.var ; } } public class GenericsDemo24{ public static void main(String arsg[]){ Info<String> i = null; // 声明接口对象 i = new InfoImpl<String>(\\\"汤姆\\\") ; // 通过子类实例化对象 System.out.println(\\\"内容：\\\" + i.getVar()) ; } } \"]},\"283\":{\"h\":\"泛型方法\",\"t\":[\"泛型方法，是在调用方法的时候指明泛型的具体类型。重点看下泛型的方法（图参考自：https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html）\",\"定义泛型方法语法格式\",\"img\",\"调用泛型方法语法格式\",\"img\",\"说明一下，定义泛型方法时，必须在返回值前边加一个<T>，来声明这是一个泛型方法，持有一个泛型T，然后才可以用泛型T作为方法的返回值。\",\"Class<T>的作用就是指明泛型的具体类型，而Class<T>类型的变量c，可以用来创建泛型类的对象。\",\"为什么要用变量c来创建对象呢？既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newInstance方法去创建对象，也就是利用反射创建对象。\",\"泛型方法要求的参数是Class<T>类型，而Class.forName()方法的返回值也是Class<T>，因此可以用Class.forName()作为参数。其中，forName()方法中的参数是何种类型，返回的Class<T>就是何种类型。在本例中，forName()方法中传入的是User类的完整路径，因此返回的是Class<User>类型的对象，因此调用泛型方法时，变量c的类型就是Class<User>，因此泛型方法中的泛型T就被指明为User，因此变量obj的类型为User。\",\"当然，泛型方法不是仅仅可以有一个参数Class<T>，可以根据需要添加其他参数。\",\"为什么要使用泛型方法呢？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。\"]},\"284\":{\"h\":\"泛型的上下限\",\"t\":[\"先看下如下的代码，很明显是会报错的 （具体错误原因请参考后文）。\",\"class A{} class B extends A {} // 如下两个方法不会报错 public static void funA(A a) { // ... } public static void funB(B b) { funA(b); // ... } // 如下funD方法会报错 public static void funC(List<A> listA) { // ... } public static void funD(List<B> listB) { funC(listB); // Unresolved compilation problem: The method doPrint(List<A>) in the type test is not applicable for the arguments (List<B>) // ... } \",\"那么如何解决呢？\",\"为了解决泛型中隐含的转换问题，Java泛型加入了类型参数的上下边界机制。<? extends A>表示该类型参数可以是A(上边界)或者A的子类类型。编译时擦除到类型A，即用A类型代替类型参数。这种方法可以解决开始遇到的问题，编译器知道类型参数的范围，如果传入的实例类型B是在这个范围内的话允许转换，这时只要一次类型转换就可以了，运行时会把对象当做A的实例看待。\",\"public static void funC(List<? extends A> listA) { // ... } public static void funD(List<B> listB) { funC(listB); // OK // ... } \",\"泛型上下限的引入\",\"在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。\",\"上限\",\"class Info<T extends Number>{ // 此处泛型只能是数字类型 private T var ; // 定义泛型变量 public void setVar(T var){ this.var = var ; } public T getVar(){ return this.var ; } public String toString(){ // 直接打印 return this.var.toString() ; } } public class demo1{ public static void main(String args[]){ Info<Integer> i1 = new Info<Integer>() ; // 声明Integer的泛型对象 } } \",\"下限\",\"class Info<T>{ private T var ; // 定义泛型变量 public void setVar(T var){ this.var = var ; } public T getVar(){ return this.var ; } public String toString(){ // 直接打印 return this.var.toString() ; } } public class GenericsDemo21{ public static void main(String args[]){ Info<String> i1 = new Info<String>() ; // 声明String的泛型对象 Info<Object> i2 = new Info<Object>() ; // 声明Object的泛型对象 i1.setVar(\\\"hello\\\") ; i2.setVar(new Object()) ; fun(i1) ; fun(i2) ; } public static void fun(Info<? super String> temp){ // 只能接收String或Object类型的泛型，String类的父类只有Object类 System.out.print(temp + \\\", \\\") ; } } \",\"小结\",\"<?> 无限制通配符 <? extends E> extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类 <? super E> super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类 // 使用原则《Effictive Java》 // 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限 1. 如果参数化类型表示一个 T 的生产者，使用 < ? extends T>; 2. 如果它表示一个 T 的消费者，就使用 < ? super T>； 3. 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。 \",\"再看一个实际例子，加深印象\",\"private <E extends Comparable<? super E>> E max(List<? extends E> e1) { if (e1 == null){ return null; } //迭代器返回的元素属于 E 的某个子类型 Iterator<? extends E> iterator = e1.iterator(); E result = iterator.next(); while (iterator.hasNext()){ E next = iterator.next(); if (next.compareTo(result) > 0){ result = next; } } return result; } \",\"上述代码中的类型参数 E 的范围是<E extends Comparable<? super E>>，我们可以分步查看：\",\"要进行比较，所以 E 需要是可比较的类，因此需要 extends Comparable<…>（注意这里不要和继承的 extends 搞混了，不一样）\",\"Comparable< ? super E> 要对 E 进行比较，即 E 的消费者，所以需要用 super\",\"而参数 List< ? extends E> 表示要操作的数据是 E 的子类的列表，指定上限，这样容器才够大\",\"多个限制\",\"使用&符号\",\"public class Client { //工资低于2500元的上斑族并且站立的乘客车票打8折 public static <T extends Staff & Passenger> void discount(T t){ if(t.getSalary()<2500 && t.isStanding()){ System.out.println(\\\"恭喜你！您的车票打八折！\\\"); } } public static void main(String[] args) { discount(new Me()); } } \"]},\"285\":{\"h\":\"泛型数组\",\"t\":[\"具体可以参考下文中关于泛型数组的理解。\",\"首先，我们泛型数组相关的申明：\",\"List<String>[] list11 = new ArrayList<String>[10]; //编译错误，非法创建 List<String>[] list12 = new ArrayList<?>[10]; //编译错误，需要强转类型 List<String>[] list13 = (List<String>[]) new ArrayList<?>[10]; //OK，但是会有警告 List<?>[] list14 = new ArrayList<String>[10]; //编译错误，非法创建 List<?>[] list15 = new ArrayList<?>[10]; //OK List<String>[] list6 = new ArrayList[10]; //OK，但是会有警告 \",\"那么通常我们如何用呢？\",\"讨巧的使用场景\",\"public class GenericsDemo30{ public static void main(String args[]){ Integer i[] = fun1(1,2,3,4,5,6) ; // 返回泛型数组 fun2(i) ; } public static <T> T[] fun1(T...arg){ // 接收可变参数 return arg ; // 返回泛型数组 } public static <T> void fun2(T param[]){ // 输出 System.out.print(\\\"接收泛型数组：\\\") ; for(T t:param){ System.out.print(t + \\\"、\\\") ; } } } \",\"合理使用\",\"public ArrayWithTypeToken(Class<T> type, int size) { array = (T[]) Array.newInstance(type, size); } \",\"具体可以查看后文解释。\"]},\"286\":{\"h\":\"深入理解泛型\",\"t\":[\"提示\",\"我们通过泛型背后的类型擦除以及相关的问题来进一步理解泛型。@pdai\"]},\"287\":{\"h\":\"如何理解Java中的泛型是伪泛型？泛型中类型擦除\",\"t\":[\"Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。理解类型擦除对于用好泛型是很有帮助的，尤其是一些看起来“疑难杂症”的问题，弄明白了类型擦除也就迎刃而解了。\",\"泛型的类型擦除原则是：\",\"消除类型参数声明，即删除<>及其包围的部分。\",\"根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。\",\"为了保证类型安全，必要时插入强制类型转换代码。\",\"自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。\",\"那么如何进行擦除的呢？\",\"参考自：http://softlab.sdut.edu.cn/blog/subaochen/2017/01/generics-type-erasure/\",\"擦除类定义中的类型参数 - 无限制类型擦除\",\"当类定义中的类型参数没有任何限制时，在类型擦除中直接被替换为Object，即形如<T>和<?>的类型参数都被替换为Object。\",\"img\",\"擦除类定义中的类型参数 - 有限制类型擦除\",\"当类定义中的类型参数存在限制（上下界）时，在类型擦除中替换为类型参数的上界或者下界，比如形如<T extends Number>和<? extends Number>的类型参数被替换为Number，<? super Number>被替换为Object。\",\"img\",\"擦除方法定义中的类型参数\",\"擦除方法定义中的类型参数原则和擦除类定义中的类型参数是一样的，这里仅以擦除方法定义中的有限制类型参数为例。\",\"img\"]},\"288\":{\"h\":\"如何证明类型的擦除呢？\",\"t\":[\"我们通过两个例子证明Java类型的类型擦除\",\"原始类型相等\",\"public class Test { public static void main(String[] args) { ArrayList<String> list1 = new ArrayList<String>(); list1.add(\\\"abc\\\"); ArrayList<Integer> list2 = new ArrayList<Integer>(); list2.add(123); System.out.println(list1.getClass() == list2.getClass()); // true } } \",\"在这个例子中，我们定义了两个ArrayList数组，不过一个是ArrayList<String>泛型类型的，只能存储字符串；一个是ArrayList<Integer>泛型类型的，只能存储整数，最后，我们通过list1对象和list2对象的getClass()方法获取他们的类的信息，最后发现结果为true。说明泛型类型String和Integer都被擦除掉了，只剩下原始类型。\",\"通过反射添加其它类型元素\",\"public class Test { public static void main(String[] args) throws Exception { ArrayList<Integer> list = new ArrayList<Integer>(); list.add(1); //这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer list.getClass().getMethod(\\\"add\\\", Object.class).invoke(list, \\\"asd\\\"); for (int i = 0; i < list.size(); i++) { System.out.println(list.get(i)); } } } \",\"在程序中定义了一个ArrayList泛型类型实例化为Integer对象，如果直接调用add()方法，那么只能存储整数数据，不过当我们利用反射调用add()方法的时候，却可以存储字符串，这说明了Integer泛型实例在编译之后被擦除掉了，只保留了原始类型。\"]},\"289\":{\"h\":\"如何理解类型擦除后保留的原始类型?\",\"t\":[\"在上面，两次提到了原始类型，什么是原始类型？\",\"原始类型 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。\",\"原始类型Object\",\"class Pair<T> { private T value; public T getValue() { return value; } public void setValue(T value) { this.value = value; } } \",\"Pair的原始类型为:\",\"class Pair { private Object value; public Object getValue() { return value; } public void setValue(Object value) { this.value = value; } } \",\"因为在Pair<T>中，T 是一个无限定的类型变量，所以用Object替换，其结果就是一个普通的类，如同泛型加入Java语言之前的已经实现的样子。在程序中可以包含不同类型的Pair，如Pair<String>或Pair<Integer>，但是擦除类型后他们的就成为原始的Pair类型了，原始类型都是Object。\",\"从上面章节，我们也可以明白ArrayList被擦除类型后，原始类型也变为Object，所以通过反射我们就可以存储字符串了。\",\"如果类型变量有限定，那么原始类型就用第一个边界的类型变量类替换。\",\"比如: Pair这样声明的话\",\"public class Pair<T extends Comparable> {} \",\"那么原始类型就是Comparable。\",\"要区分原始类型和泛型变量的类型。\",\"在调用泛型方法时，可以指定泛型，也可以不指定泛型:\",\"在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object\",\"在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类\",\"public class Test { public static void main(String[] args) { /**不指定泛型的时候*/ int i = Test.add(1, 2); //这两个参数都是Integer，所以T为Integer类型 Number f = Test.add(1, 1.2); //这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Number Object o = Test.add(1, \\\"asd\\\"); //这两个参数一个是Integer，一个是String，所以取同一父类的最小级，为Object /**指定泛型的时候*/ int a = Test.<Integer>add(1, 2); //指定了Integer，所以只能为Integer类型或者其子类 int b = Test.<Integer>add(1, 2.2); //编译错误，指定了Integer，不能为Float Number c = Test.<Number>add(1, 2.2); //指定为Number，所以可以为Integer和Float } //这是一个简单的泛型方法 public static <T> T add(T x,T y){ return y; } } \",\"其实在泛型类中，不指定泛型的时候，也差不多，只不过这个时候的泛型为Object，就比如ArrayList中，如果不指定泛型，那么这个ArrayList可以存储任意的对象。\",\"Object泛型\",\"public static void main(String[] args) { ArrayList list = new ArrayList(); list.add(1); list.add(\\\"121\\\"); list.add(new Date()); } \"]},\"290\":{\"h\":\"如何理解泛型的编译期检查？\",\"t\":[\"既然说类型变量会在编译的时候擦除掉，那为什么我们往 ArrayList 创建的对象中添加整数会报错呢？不是说泛型变量String会在编译的时候变为Object类型吗？为什么不能存别的类型呢？既然类型擦除了，如何保证我们只能使用泛型变量限定的类型呢？\",\"Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。\",\"例如：\",\"public static void main(String[] args) { ArrayList<String> list = new ArrayList<String>(); list.add(\\\"123\\\"); list.add(123);//编译错误 } \",\"在上面的程序中，使用add方法添加一个整型，在IDE中，直接会报错，说明这就是在编译之前的检查，因为如果是在编译之后检查，类型擦除后，原始类型为Object，是应该允许任意引用类型添加的。可实际上却不是这样的，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。\",\"那么，这个类型检查是针对谁的呢？我们先看看参数化类型和原始类型的兼容。\",\"以 ArrayList举例子，以前的写法:\",\"ArrayList list = new ArrayList(); \",\"现在的写法:\",\"ArrayList<String> list = new ArrayList<String>(); \",\"如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况：\",\"ArrayList<String> list1 = new ArrayList(); //第一种 情况 ArrayList list2 = new ArrayList<String>(); //第二种 情况 \",\"这样是没有错误的，不过会有个编译时警告。\",\"不过在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则没有效果。\",\"因为类型检查就是编译时完成的，new ArrayList()只是在内存中开辟了一个存储空间，可以存储任何类型对象，而真正涉及类型检查的是它的引用，因为我们是使用它引用list1来调用它的方法，比如说调用add方法，所以list1引用能完成泛型类型的检查。而引用list2没有使用泛型，所以不行。\",\"举例子：\",\"public class Test { public static void main(String[] args) { ArrayList<String> list1 = new ArrayList(); list1.add(\\\"1\\\"); //编译通过 list1.add(1); //编译错误 String str1 = list1.get(0); //返回类型就是String ArrayList list2 = new ArrayList<String>(); list2.add(\\\"1\\\"); //编译通过 list2.add(1); //编译通过 Object object = list2.get(0); //返回类型就是Object new ArrayList<String>().add(\\\"11\\\"); //编译通过 new ArrayList<String>().add(22); //编译错误 String str2 = new ArrayList<String>().get(0); //返回类型就是String } } \",\"通过上面的例子，我们可以明白，类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。\",\"泛型中参数话类型为什么不考虑继承关系？\",\"在Java中，像下面形式的引用传递是不允许的:\",\"ArrayList<String> list1 = new ArrayList<Object>(); //编译错误 ArrayList<Object> list2 = new ArrayList<String>(); //编译错误 \",\"我们先看第一种情况，将第一种情况拓展成下面的形式：\",\"ArrayList<Object> list1 = new ArrayList<Object>(); list1.add(new Object()); list1.add(new Object()); ArrayList<String> list2 = list1; //编译错误 \",\"实际上，在第4行代码的时候，就会有编译错误。那么，我们先假设它编译没错。那么当我们使用list2引用用get()方法取值的时候，返回的都是String类型的对象（上面提到了，类型检测是根据引用来决定的），可是它里面实际上已经被我们存放了Object类型的对象，这样就会有ClassCastException了。所以为了避免这种极易出现的错误，Java不允许进行这样的引用传递。（这也是泛型出现的原因，就是为了解决类型转换的问题，我们不能违背它的初衷）。\",\"再看第二种情况，将第二种情况拓展成下面的形式：\",\"ArrayList<String> list1 = new ArrayList<String>(); list1.add(new String()); list1.add(new String()); ArrayList<Object> list2 = list1; //编译错误 \",\"没错，这样的情况比第一种情况好的多，最起码，在我们用list2取值的时候不会出现ClassCastException，因为是从String转换为Object。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。\",\"我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以java不允许这么干。再说，你如果又用list2往里面add()新的对象，那么到时候取得时候，我怎么知道我取出来的到底是String类型的，还是Object类型的呢？\",\"所以，要格外注意，泛型中的引用传递的问题。\"]},\"291\":{\"h\":\"如何理解泛型的多态？泛型的桥接方法\",\"t\":[\"类型擦除会造成多态的冲突，而JVM解决方法就是桥接方法。\",\"现在有这样一个泛型类：\",\"class Pair<T> { private T value; public T getValue() { return value; } public void setValue(T value) { this.value = value; } } \",\"然后我们想要一个子类继承它。\",\"class DateInter extends Pair<Date> { @Override public void setValue(Date value) { super.setValue(value); } @Override public Date getValue() { return super.getValue(); } } \",\"在这个子类中，我们设定父类的泛型类型为Pair<Date>，在子类中，我们覆盖了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为Date，那么父类里面的两个方法的参数都为Date类型。\",\"public Date getValue() { return value; } public void setValue(Date value) { this.value = value; } \",\"所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的@Override标签中也可以看到，一点问题也没有，实际上是这样的吗？\",\"分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型Object，所以父类编译之后会变成下面的样子：\",\"class Pair { private Object value; public Object getValue() { return value; } public void setValue(Object value) { this.value = value; } } \",\"再看子类的两个重写的方法的类型：\",\"@Override public void setValue(Date value) { super.setValue(value); } @Override public Date getValue() { return super.getValue(); } \",\"先来分析setValue方法，父类的类型是Object，而子类的类型是Date，参数类型不一样，这如果实在普通的继承关系中，根本就不会是重写，而是重载。 我们在一个main方法测试一下：\",\"public static void main(String[] args) throws ClassNotFoundException { DateInter dateInter = new DateInter(); dateInter.setValue(new Date()); dateInter.setValue(new Object()); //编译错误 } \",\"如果是重载，那么子类中两个setValue方法，一个是参数Object类型，一个是Date类型，可是我们发现，根本就没有这样的一个子类继承自父类的Object类型参数的方法。所以说，却是是重写了，而不是重载了。\",\"为什么会这样呢？\",\"原因是这样的，我们传入父类的泛型类型是Date，Pair<Date>，我们的本意是将泛型类变为如下：\",\"class Pair { private Date value; public Date getValue() { return value; } public void setValue(Date value) { this.value = value; } } \",\"然后再子类中重写参数类型为Date的那两个方法，实现继承中的多态。\",\"可是由于种种原因，虚拟机并不能将泛型类型变为Date，只能将类型擦除掉，变为原始类型Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的Date类型参数的方法啊。\",\"于是JVM采用了一个特殊的方法，来完成这项功能，那就是桥方法。\",\"首先，我们用javap -c className的方式反编译下DateInter子类的字节码，结果如下：\",\"class com.tao.test.DateInter extends com.tao.test.Pair<java.util.Date> { com.tao.test.DateInter(); Code: 0: aload_0 1: invokespecial #8 // Method com/tao/test/Pair.\\\"<init>\\\":()V 4: return public void setValue(java.util.Date); //我们重写的setValue方法 Code: 0: aload_0 1: aload_1 2: invokespecial #16 // Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V 5: return public java.util.Date getValue(); //我们重写的getValue方法 Code: 0: aload_0 1: invokespecial #23 // Method com/tao/test/Pair.getValue:()Ljava/lang/Object; 4: checkcast #26 // class java/util/Date 7: areturn public java.lang.Object getValue(); //编译时由编译器生成的桥方法 Code: 0: aload_0 1: invokevirtual #28 // Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法; 4: areturn public void setValue(java.lang.Object); //编译时由编译器生成的桥方法 Code: 0: aload_0 1: aload_1 2: checkcast #26 // class java/util/Date 5: invokevirtual #30 // Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V 8: return } \",\"从编译的结果来看，我们本意重写setValue和getValue方法的子类，竟然有4个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue和getValue方法上面的@Oveerride只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。\",\"所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。\",\"不过，要提到一点，这里面的setValue和getValue这两个桥方法的意义又有不同。\",\"setValue方法是为了解决类型擦除与多态之间的冲突。\",\"而getValue却有普遍的意义，怎么说呢，如果这是一个普通的继承关系：\",\"那么父类的getValue方法如下：\",\"public Object getValue() { return super.getValue(); } \",\"而子类重写的方法是：\",\"public Date getValue() { return super.getValue(); } \",\"其实这在普通的类继承中也是普遍存在的重写，这就是协变。\",\"并且，还有一点也许会有疑问，子类中的桥方法Object getValue()和Date getValue()是同时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。\"]},\"292\":{\"h\":\"如何理解基本类型不能作为泛型类型？\",\"t\":[\"比如，我们没有ArrayList<int>，只有ArrayList<Integer>, 为何？\",\"因为当类型擦除后，ArrayList的原始类型变为Object，但是Object类型不能存储int值，只能引用Integer的值。\",\"另外需要注意，我们能够使用list.add(1)是因为Java基础类型的自动装箱拆箱操作。\"]},\"293\":{\"h\":\"如何理解泛型类型不能实例化？\",\"t\":[\"不能实例化泛型类型, 这本质上是由于类型擦除决定的：\",\"我们可以看到如下代码会在编译器中报错：\",\"T test = new T(); // ERROR \",\"因为在 Java 编译期没法确定泛型参数化类型，也就找不到对应的类字节码文件，所以自然就不行了，此外由于T 被擦除为 Object，如果可以 new T() 则就变成了 new Object()，失去了本意。 如果我们确实需要实例化一个泛型，应该如何做呢？可以通过反射实现：\",\"static <T> T newTclass (Class < T > clazz) throws InstantiationException, IllegalAccessException { T obj = clazz.newInstance(); return obj; } \"]},\"294\":{\"h\":\"泛型数组：能不能采用具体的泛型类型进行初始化？\",\"t\":[\"我们先来看下Oracle官网提供的一个例子：\",\"List<String>[] lsa = new List<String>[10]; // Not really allowed. Object o = lsa; Object[] oa = (Object[]) o; List<Integer> li = new ArrayList<Integer>(); li.add(new Integer(3)); oa[1] = li; // Unsound, but passes run time store check String s = lsa[1].get(0); // Run-time error ClassCastException. \",\"由于 JVM 泛型的擦除机制，所以上面代码可以给 oa[1] 赋值为 ArrayList 也不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现 ClassCastException，如果可以进行泛型数组的声明则上面说的这种情况在编译期不会出现任何警告和错误，只有在运行时才会出错，但是泛型的出现就是为了消灭 ClassCastException，所以如果 Java 支持泛型数组初始化操作就是搬起石头砸自己的脚。\",\"而对于下面的代码来说是成立的：\",\"List<?>[] lsa = new List<?>[10]; // OK, array of unbounded wildcard type. Object o = lsa; Object[] oa = (Object[]) o; List<Integer> li = new ArrayList<Integer>(); li.add(new Integer(3)); oa[1] = li; // Correct. Integer i = (Integer) lsa[1].get(0); // OK \",\"所以说采用通配符的方式初始化泛型数组是允许的，因为对于通配符的方式最后取出数据是要做显式类型转换的，符合预期逻辑。综述就是说Java 的泛型数组初始化时数组类型不能是具体的泛型类型，只能是通配符的形式，因为具体类型会导致可存入任意类型对象，在取出时会发生类型转换异常，会与泛型的设计思想冲突，而通配符形式本来就需要自己强转，符合预期。\",\"Oracle 官方文档：https://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html在新窗口打开\",\"更进一步的，我们看看如下的代码：\",\"List<String>[] list11 = new ArrayList<String>[10]; //编译错误，非法创建 List<String>[] list12 = new ArrayList<?>[10]; //编译错误，需要强转类型 List<String>[] list13 = (List<String>[]) new ArrayList<?>[10]; //OK，但是会有警告 List<?>[] list14 = new ArrayList<String>[10]; //编译错误，非法创建 List<?>[] list15 = new ArrayList<?>[10]; //OK List<String>[] list6 = new ArrayList[10]; //OK，但是会有警告 \",\"因为在 Java 中是不能创建一个确切的泛型类型的数组的，除非是采用通配符的方式且要做显式类型转换才可以。\"]},\"295\":{\"h\":\"泛型数组：如何正确的初始化泛型数组实例？\",\"t\":[\"这个无论我们通过new ArrayList[10] 的形式还是通过泛型通配符的形式初始化泛型数组实例都是存在警告的，也就是说仅仅语法合格，运行时潜在的风险需要我们自己来承担，因此那些方式初始化泛型数组都不是最优雅的方式。\",\"我们在使用到泛型数组的场景下应该尽量使用列表集合替换，此外也可以通过使用 java.lang.reflect.Array.newInstance(Class<T> componentType, int length) 方法来创建一个具有指定类型和维度的数组，如下：\",\"public class ArrayWithTypeToken<T> { private T[] array; public ArrayWithTypeToken(Class<T> type, int size) { array = (T[]) Array.newInstance(type, size); } public void put(int index, T item) { array[index] = item; } public T get(int index) { return array[index]; } public T[] create() { return array; } } //... ArrayWithTypeToken<Integer> arrayToken = new ArrayWithTypeToken<Integer>(Integer.class, 100); Integer[] array = arrayToken.create(); \",\"所以使用反射来初始化泛型数组算是优雅实现，因为泛型类型 T在运行时才能被确定下来，我们能创建泛型数组也必然是在 Java 运行时想办法，而运行时能起作用的技术最好的就是反射了。\"]},\"296\":{\"h\":\"如何理解泛型类中的静态方法和静态变量？\",\"t\":[\"泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数\",\"举例说明：\",\"public class Test2<T> { public static T one; //编译错误 public static T show(T one){ //编译错误 return null; } } \",\"因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。\",\"但是要注意区分下面的一种情况：\",\"public class Test2<T> { public static <T >T show(T one){ //这是正确的 return null; } } \",\"因为这是一个泛型方法，在泛型方法中使用的T是自己在方法中定义的 T，而不是泛型类中的T。\"]},\"297\":{\"h\":\"如何理解异常中使用泛型？\",\"t\":[\"不能抛出也不能捕获泛型类的对象。事实上，泛型类扩展Throwable都不合法。例如：下面的定义将不会通过编译：\",\"public class Problem<T> extends Exception { } \",\"为什么不能扩展Throwable，因为异常都是在运行时捕获和抛出的，而在编译的时候，泛型信息全都会被擦除掉，那么，假设上面的编译可行，那么，在看下面的定义：\",\"try{ } catch(Problem<Integer> e1) { } catch(Problem<Number> e2) { } \",\"类型信息被擦除后，那么两个地方的catch都变为原始类型Object，那么也就是说，这两个地方的catch变的一模一样,就相当于下面的这样\",\"try{ } catch(Problem<Object> e1) { } catch(Problem<Object> e2) { } \",\"这个当然就是不行的。\",\"不能再catch子句中使用泛型变量\",\"public static <T extends Throwable> void doWork(Class<T> t) { try { ... } catch(T e) { //编译错误 ... } } \",\"因为泛型信息在编译的时候已经变为原始类型，也就是说上面的T会变为原始类型Throwable，那么如果可以再catch子句中使用泛型变量，那么，下面的定义呢：\",\"public static <T extends Throwable> void doWork(Class<T> t){ try { } catch(T e) { //编译错误 } catch(IndexOutOfBounds e) { } } \",\"根据异常捕获的原则，一定是子类在前面，父类在后面，那么上面就违背了这个原则。即使你在使用该静态方法的使用T是ArrayIndexOutofBounds，在编译之后还是会变成Throwable，ArrayIndexOutofBounds是IndexOutofBounds的子类，违背了异常捕获的原则。所以java为了避免这样的情况，禁止在catch子句中使用泛型变量。\",\"但是在异常声明中可以使用类型变量。下面方法是合法的。\",\"public static<T extends Throwable> void doWork(T t) throws T { try{ ... } catch(Throwable realCause) { t.initCause(realCause); throw t; } } \",\"上面的这样使用是没问题的。\"]},\"298\":{\"h\":\"如何获取泛型的参数类型？\",\"t\":[\"既然类型被擦除了，那么如何获取泛型的参数类型呢？可以通过反射（java.lang.reflect.Type）获取泛型\",\"java.lang.reflect.Type是Java中所有类型的公共高级接口, 代表了Java中的所有类型. Type体系中类型的包括：数组类型(GenericArrayType)、参数化类型(ParameterizedType)、类型变量(TypeVariable)、通配符类型(WildcardType)、原始类型(Class)、基本类型(Class), 以上这些类型都实现Type接口。\",\"public class GenericType<T> { private T data; public T getData() { return data; } public void setData(T data) { this.data = data; } public static void main(String[] args) { GenericType<String> genericType = new GenericType<String>() {}; Type superclass = genericType.getClass().getGenericSuperclass(); //getActualTypeArguments 返回确切的泛型参数, 如Map<String, Integer>返回[String, Integer] Type type = ((ParameterizedType) superclass).getActualTypeArguments()[0]; System.out.println(type);//class java.lang.String } } \",\"其中 ParameterizedType:\",\"public interface ParameterizedType extends Type { // 返回确切的泛型参数, 如Map<String, Integer>返回[String, Integer] Type[] getActualTypeArguments(); //返回当前class或interface声明的类型, 如List<?>返回List Type getRawType(); //返回所属类型. 如,当前类型为O<T>.I<S>, 则返回O<T>. 顶级类型将返回null Type getOwnerType(); } \"]},\"299\":{\"h\":\"参考文章\",\"t\":[\"泛型作为Java基础知识点之一，网上知识点比较多也比较散，本文主要综合了网络上比较好的文章，方便你快速学习。（以下是一部分我参考的链接）\",\"https://blog.csdn.net/sunxianghuang/article/details/51982979\",\"https://blog.csdn.net/LonelyRoamer/article/details/7868820\",\"https://docs.oracle.com/javase/tutorial/extra/generics/index.html\",\"https://blog.csdn.net/s10461/article/details/53941091\",\"https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html\",\"https://www.cnblogs.com/rudy-laura/articles/3391013.html\",\"https://www.jianshu.com/p/986f732ed2f1\",\"https://blog.csdn.net/u011240877/article/details/53545041\",\"著作权归@pdai所有 原文链接：https://pdai.tech/md/java/basic/java-basic-x-generic.html\"]},\"300\":{\"h\":\"反射机制详解\",\"t\":[\"JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。Java反射机制在框架设计中极为广泛，需要深入理解。本文综合多篇文章后，总结了Java 反射的相关知识，希望可以提升你对Java中反射的认知效率。@pdai\"]},\"301\":{\"h\":\"反射基础\",\"t\":[\"RTTI（Run-Time Type Identification）运行时类型识别。在《Thinking in Java》一书第十四章中有提到，其作用是在运行时识别一个对象的类型和类的信息。主要有两种方式：一种是“传统的”RTTI，它假定我们在编译时已经知道了所有的类型；另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。\",\"反射就是把java类中的各种成分映射成一个个的Java对象\",\"例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。\",\"这里我们首先需要理解 Class类，以及类的加载机制； 然后基于此我们如何通过反射获取Class类以及类中的成员变量、方法、构造方法等。\"]},\"302\":{\"h\":\"Class类\",\"t\":[\"Class类，Class类也是一个实实在在的类，存在于JDK的java.lang包中。Class类的实例表示java应用运行时的类(class ans enum)或接口(interface and annotation)（每个java类运行时都在JVM里表现为一个class对象，可通过类名.class、类型.getClass()、Class.forName(\\\"类名\\\")等方法获取class对象）。数组同样也被映射为class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本类型boolean，byte，char，short，int，long，float，double和关键字void同样表现为 class 对象。\",\"public final class Class<T> implements java.io.Serializable, GenericDeclaration, Type, AnnotatedElement { private static final int ANNOTATION= 0x00002000; private static final int ENUM = 0x00004000; private static final int SYNTHETIC = 0x00001000; private static native void registerNatives(); static { registerNatives(); } /* * Private constructor. Only the Java Virtual Machine creates Class objects. //私有构造器，只有JVM才能调用创建Class对象 * This constructor is not used and prevents the default constructor being * generated. */ private Class(ClassLoader loader) { // Initialize final field for classLoader. The initialization value of non-null // prevents future JIT optimizations from assuming this final field is null. classLoader = loader; } \",\"到这我们也就可以得出以下几点信息：\",\"Class类也是类的一种，与class关键字是不一样的。\",\"手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)\",\"每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。\",\"Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载\",\"Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要(关于反射稍后分析)。\"]},\"303\":{\"h\":\"类加载\",\"t\":[\"类加载机制和类字节码技术可以参考如下两篇文章：\",\"JVM基础 - 类字节码详解 \",\"源代码通过编译器编译为字节码，再通过类加载子系统进行加载到JVM中运行\",\"JVM基础 - Java 类加载机制 \",\"这篇文章将带你深入理解Java 类加载机制\",\"其中，这里我们需要回顾的是：\",\"类加载机制流程\",\"img\",\"类的加载\",\"img\"]},\"304\":{\"h\":\"反射的使用\",\"t\":[\"提示\",\"基于此我们如何通过反射获取Class类对象以及类中的成员变量、方法、构造方法等\",\"在Java中，Class类与java.lang.reflect类库一起对反射技术进行了全力的支持。在反射包中，我们常用的类主要有Constructor类表示的是Class 对象所表示的类的构造方法，利用它可以在运行时动态创建对象、Field表示Class对象所表示的类的成员变量，通过它可以在运行时动态修改成员变量的属性值(包含private)、Method表示Class对象所表示的类的成员方法，通过它可以动态调用对象的方法(包含private)，下面将对这几个重要类进行分别说明。\"]},\"305\":{\"h\":\"Class类对象的获取\",\"t\":[\"在类加载的时候，jvm会创建一个class对象\",\"class对象是可以说是反射中最常用的，获取class对象的方式的主要有三种\",\"根据类名：类名.class\",\"根据对象：对象.getClass()\",\"根据全限定类名：Class.forName(全限定类名)\",\" @Test public void classTest() throws Exception { // 获取Class对象的三种方式 logger.info(\\\"根据类名: \\\\t\\\" + User.class); logger.info(\\\"根据对象: \\\\t\\\" + new User().getClass()); logger.info(\\\"根据全限定类名:\\\\t\\\" + Class.forName(\\\"com.test.User\\\")); // 常用的方法 logger.info(\\\"获取全限定类名:\\\\t\\\" + userClass.getName()); logger.info(\\\"获取类名:\\\\t\\\" + userClass.getSimpleName()); logger.info(\\\"实例化:\\\\t\\\" + userClass.newInstance()); } // ... package com.test; public class User { private String name = \\\"init\\\"; private int age; public User() {} public User(String name, int age) { super(); this.name = name; this.age = age; } private String getName() { return name; } private void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \\\"User [name=\\\" + name + \\\", age=\\\" + age + \\\"]\\\"; } } \",\"输出结果：\",\"根据类名: class com.test.User 根据对象: class com.test.User 根据全限定类名: class com.test.User 获取全限定类名: com.test.User 获取类名: User 实例化: User [name=init, age=0] \",\"再来看看 Class类的方法\",\"方法名\",\"说明\",\"forName()\",\"(1)获取Class对象的一个引用，但引用的类还没有加载(该类的第一个对象没有生成)就加载了这个类。\",\"(2)为了产生Class引用，forName()立即就进行了初始化。\",\"Object-getClass()\",\"获取Class对象的一个引用，返回表示该对象的实际类型的Class引用。\",\"getName()\",\"取全限定的类名(包括包名)，即类的完整名字。\",\"getSimpleName()\",\"获取类名(不包括包名)\",\"getCanonicalName()\",\"获取全限定的类名(包括包名)\",\"isInterface()\",\"判断Class对象是否是表示一个接口\",\"getInterfaces()\",\"返回Class对象数组，表示Class对象所引用的类所实现的所有接口。\",\"getSupercalss()\",\"返回Class对象，表示Class对象所引用的类所继承的直接基类。应用该方法可在运行时发现一个对象完整的继承结构。\",\"newInstance()\",\"返回一个Oject对象，是实现“虚拟构造器”的一种途径。使用该方法创建的类，必须带有无参的构造器。\",\"getFields()\",\"获得某个类的所有的公共（public）的字段，包括继承自父类的所有公共字段。 类似的还有getMethods和getConstructors。\",\"getDeclaredFields\",\"获得某个类的自己声明的字段，即包括public、private和proteced，默认但是不包括父类声明的任何字段。类似的还有getDeclaredMethods和getDeclaredConstructors。\",\"简单测试下（这里例子源于https://blog.csdn.net/mcryeasy/article/details/52344729）\",\"package com.cry; import java.lang.reflect.Field; interface I1 { } interface I2 { } class Cell{ public int mCellPublic; } class Animal extends Cell{ private int mAnimalPrivate; protected int mAnimalProtected; int mAnimalDefault; public int mAnimalPublic; private static int sAnimalPrivate; protected static int sAnimalProtected; static int sAnimalDefault; public static int sAnimalPublic; } class Dog extends Animal implements I1, I2 { private int mDogPrivate; public int mDogPublic; protected int mDogProtected; private int mDogDefault; private static int sDogPrivate; protected static int sDogProtected; static int sDogDefault; public static int sDogPublic; } public class Test { public static void main(String[] args) throws IllegalAccessException, InstantiationException { Class<Dog> dog = Dog.class; //类名打印 System.out.println(dog.getName()); //com.cry.Dog System.out.println(dog.getSimpleName()); //Dog System.out.println(dog.getCanonicalName());//com.cry.Dog //接口 System.out.println(dog.isInterface()); //false for (Class iI : dog.getInterfaces()) { System.out.println(iI); } /* interface com.cry.I1 interface com.cry.I2 */ //父类 System.out.println(dog.getSuperclass());//class com.cry.Animal //创建对象 Dog d = dog.newInstance(); //字段 for (Field f : dog.getFields()) { System.out.println(f.getName()); } /* mDogPublic sDogPublic mAnimalPublic sAnimalPublic mCellPublic //父类的父类的公共字段也打印出来了 */ System.out.println(\\\"---------\\\"); for (Field f : dog.getDeclaredFields()) { System.out.println(f.getName()); } /** 只有自己类声明的字段 mDogPrivate mDogPublic mDogProtected mDogDefault sDogPrivate sDogProtected sDogDefault sDogPublic */ } } \",\"getName、getCanonicalName与getSimpleName的区别：\",\"getSimpleName：只获取类名\",\"getName：类的全限定名，jvm中Class的表示，可以用于动态加载Class对象，例如Class.forName。\",\"getCanonicalName：返回更容易理解的表示，主要用于输出（toString）或log打印，大多数情况下和getName一样，但是在内部类、数组等类型的表示形式就不同了。\",\"package com.cry; public class Test { private class inner{ } public static void main(String[] args) throws ClassNotFoundException { //普通类 System.out.println(Test.class.getSimpleName()); //Test System.out.println(Test.class.getName()); //com.cry.Test System.out.println(Test.class.getCanonicalName()); //com.cry.Test //内部类 System.out.println(inner.class.getSimpleName()); //inner System.out.println(inner.class.getName()); //com.cry.Test$inner System.out.println(inner.class.getCanonicalName()); //com.cry.Test.inner //数组 System.out.println(args.getClass().getSimpleName()); //String[] System.out.println(args.getClass().getName()); //[Ljava.lang.String; System.out.println(args.getClass().getCanonicalName()); //java.lang.String[] //我们不能用getCanonicalName去加载类对象，必须用getName //Class.forName(inner.class.getCanonicalName()); 报错 Class.forName(inner.class.getName()); } } \"]},\"306\":{\"h\":\"Constructor类及其用法\",\"t\":[\"Constructor类存在于反射包(java.lang.reflect)中，反映的是Class 对象所表示的类的构造方法。\",\"获取Constructor对象是通过Class类中的方法获取的，Class类与Constructor相关的主要方法如下：\",\"方法返回值\",\"方法名称\",\"方法说明\",\"static Class<?>\",\"forName(String className)\",\"返回与带有给定字符串名的类或接口相关联的 Class 对象。\",\"Constructor\",\"getConstructor(Class<?>... parameterTypes)\",\"返回指定参数类型、具有public访问权限的构造函数对象\",\"Constructor<?>[]\",\"getConstructors()\",\"返回所有具有public访问权限的构造函数的Constructor对象数组\",\"Constructor\",\"getDeclaredConstructor(Class<?>... parameterTypes)\",\"返回指定参数类型、所有声明的（包括private）构造函数对象\",\"Constructor<?>[]\",\"getDeclaredConstructors()\",\"返回所有声明的（包括private）构造函数对象\",\"T\",\"newInstance()\",\"调用无参构造器创建此 Class 对象所表示的类的一个新实例。\",\"下面看一个简单例子来了解Constructor对象的使用：\",\"public class ConstructionTest implements Serializable { public static void main(String[] args) throws Exception { Class<?> clazz = null; //获取Class对象的引用 clazz = Class.forName(\\\"com.example.javabase.User\\\"); //第一种方法，实例化默认构造方法，User必须无参构造函数,否则将抛异常 User user = (User) clazz.newInstance(); user.setAge(20); user.setName(\\\"Jack\\\"); System.out.println(user); System.out.println(\\\"--------------------------------------------\\\"); //获取带String参数的public构造函数 Constructor cs1 =clazz.getConstructor(String.class); //创建User User user1= (User) cs1.newInstance(\\\"hiway\\\"); user1.setAge(22); System.out.println(\\\"user1:\\\"+user1.toString()); System.out.println(\\\"--------------------------------------------\\\"); //取得指定带int和String参数构造函数,该方法是私有构造private Constructor cs2=clazz.getDeclaredConstructor(int.class,String.class); //由于是private必须设置可访问 cs2.setAccessible(true); //创建user对象 User user2= (User) cs2.newInstance(25,\\\"hiway2\\\"); System.out.println(\\\"user2:\\\"+user2.toString()); System.out.println(\\\"--------------------------------------------\\\"); //获取所有构造包含private Constructor<?> cons[] = clazz.getDeclaredConstructors(); // 查看每个构造方法需要的参数 for (int i = 0; i < cons.length; i++) { //获取构造函数参数类型 Class<?> clazzs[] = cons[i].getParameterTypes(); System.out.println(\\\"构造函数[\\\"+i+\\\"]:\\\"+cons[i].toString() ); System.out.print(\\\"参数类型[\\\"+i+\\\"]:(\\\"); for (int j = 0; j < clazzs.length; j++) { if (j == clazzs.length - 1) System.out.print(clazzs[j].getName()); else System.out.print(clazzs[j].getName() + \\\",\\\"); } System.out.println(\\\")\\\"); } } } class User { private int age; private String name; public User() { super(); } public User(String name) { super(); this.name = name; } /** * 私有构造 * @param age * @param name */ private User(int age, String name) { super(); this.age = age; this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \\\"User{\\\" + \\\"age=\\\" + age + \\\", name='\\\" + name + '\\\\'' + '}'; } } \",\"输出结果\",\"/* output User{age=20, name='Jack'} -------------------------------------------- user1:User{age=22, name='hiway'} -------------------------------------------- user2:User{age=25, name='hiway2'} -------------------------------------------- 构造函数[0]:private com.example.javabase.User(int,java.lang.String) 参数类型[0]:(int,java.lang.String) 构造函数[1]:public com.example.javabase.User(java.lang.String) 参数类型[1]:(java.lang.String) 构造函数[2]:public com.example.javabase.User() 参数类型[2]:() \",\"关于Constructor类本身一些常用方法如下(仅部分，其他可查API)\",\"方法返回值\",\"方法名称\",\"方法说明\",\"Class\",\"getDeclaringClass()\",\"返回 Class 对象，该对象表示声明由此 Constructor 对象表示的构造方法的类,其实就是返回真实类型（不包含参数）\",\"Type[]\",\"getGenericParameterTypes()\",\"按照声明顺序返回一组 Type 对象，返回的就是 Constructor对象构造函数的形参类型。\",\"String\",\"getName()\",\"以字符串形式返回此构造方法的名称。\",\"Class<?>[]\",\"getParameterTypes()\",\"按照声明顺序返回一组 Class 对象，即返回Constructor 对象所表示构造方法的形参类型\",\"T\",\"newInstance(Object... initargs)\",\"使用此 Constructor对象表示的构造函数来创建新实例\",\"String\",\"toGenericString()\",\"返回描述此 Constructor 的字符串，其中包括类型参数。\",\"代码演示如下：\",\"Constructor cs3 = clazz.getDeclaredConstructor(int.class,String.class); System.out.println(\\\"-----getDeclaringClass-----\\\"); Class uclazz=cs3.getDeclaringClass(); //Constructor对象表示的构造方法的类 System.out.println(\\\"构造方法的类:\\\"+uclazz.getName()); System.out.println(\\\"-----getGenericParameterTypes-----\\\"); //对象表示此 Constructor 对象所表示的方法的形参类型 Type[] tps=cs3.getGenericParameterTypes(); for (Type tp:tps) { System.out.println(\\\"参数名称tp:\\\"+tp); } System.out.println(\\\"-----getParameterTypes-----\\\"); //获取构造函数参数类型 Class<?> clazzs[] = cs3.getParameterTypes(); for (Class claz:clazzs) { System.out.println(\\\"参数名称:\\\"+claz.getName()); } System.out.println(\\\"-----getName-----\\\"); //以字符串形式返回此构造方法的名称 System.out.println(\\\"getName:\\\"+cs3.getName()); System.out.println(\\\"-----getoGenericString-----\\\"); //返回描述此 Constructor 的字符串，其中包括类型参数。 System.out.println(\\\"getoGenericString():\\\"+cs3.toGenericString()); \",\"输出结果\",\"-----getDeclaringClass----- 构造方法的类:com.example.javabase.User -----getGenericParameterTypes----- 参数名称tp:int 参数名称tp:class java.lang.String -----getParameterTypes----- 参数名称:int 参数名称:java.lang.String -----getName----- getName:com.example.javabase.User -----getoGenericString----- getoGenericString():private com.example.javabase.User(int,java.lang.String) \"]},\"307\":{\"h\":\"Field类及其用法\",\"t\":[\"Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。\",\"同样的道理，我们可以通过Class类的提供的方法来获取代表字段信息的Field对象，Class类与Field对象相关方法如下：\",\"方法返回值\",\"方法名称\",\"方法说明\",\"Field\",\"getDeclaredField(String name)\",\"获取指定name名称的(包含private修饰的)字段，不包括继承的字段\",\"Field[]\",\"getDeclaredFields()\",\"获取Class对象所表示的类或接口的所有(包含private修饰的)字段,不包括继承的字段\",\"Field\",\"getField(String name)\",\"获取指定name名称、具有public修饰的字段，包含继承字段\",\"Field[]\",\"getFields()\",\"获取修饰符为public的字段，包含继承字段\",\"下面的代码演示了上述方法的使用过程\",\"public class ReflectField { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException { Class<?> clazz = Class.forName(\\\"reflect.Student\\\"); //获取指定字段名称的Field类,注意字段修饰符必须为public而且存在该字段, // 否则抛NoSuchFieldException Field field = clazz.getField(\\\"age\\\"); System.out.println(\\\"field:\\\"+field); //获取所有修饰符为public的字段,包含父类字段,注意修饰符为public才会获取 Field fields[] = clazz.getFields(); for (Field f:fields) { System.out.println(\\\"f:\\\"+f.getDeclaringClass()); } System.out.println(\\\"================getDeclaredFields====================\\\"); //获取当前类所字段(包含private字段),注意不包含父类的字段 Field fields2[] = clazz.getDeclaredFields(); for (Field f:fields2) { System.out.println(\\\"f2:\\\"+f.getDeclaringClass()); } //获取指定字段名称的Field类,可以是任意修饰符的自动,注意不包含父类的字段 Field field2 = clazz.getDeclaredField(\\\"desc\\\"); System.out.println(\\\"field2:\\\"+field2); } /** 输出结果: field:public int reflect.Person.age f:public java.lang.String reflect.Student.desc f:public int reflect.Person.age f:public java.lang.String reflect.Person.name ================getDeclaredFields==================== f2:public java.lang.String reflect.Student.desc f2:private int reflect.Student.score field2:public java.lang.String reflect.Student.desc */ } class Person{ public int age; public String name; //省略set和get方法 } class Student extends Person{ public String desc; private int score; //省略set和get方法 } \",\"上述方法需要注意的是，如果我们不期望获取其父类的字段，则需使用Class类的getDeclaredField/getDeclaredFields方法来获取字段即可，倘若需要连带获取到父类的字段，那么请使用Class类的getField/getFields，但是也只能获取到public修饰的的字段，无法获取父类的私有字段。下面将通过Field类本身的方法对指定类属性赋值，代码演示如下：\",\"//获取Class对象引用 Class<?> clazz = Class.forName(\\\"reflect.Student\\\"); Student st= (Student) clazz.newInstance(); //获取父类public字段并赋值 Field ageField = clazz.getField(\\\"age\\\"); ageField.set(st,18); Field nameField = clazz.getField(\\\"name\\\"); nameField.set(st,\\\"Lily\\\"); //只获取当前类的字段,不获取父类的字段 Field descField = clazz.getDeclaredField(\\\"desc\\\"); descField.set(st,\\\"I am student\\\"); Field scoreField = clazz.getDeclaredField(\\\"score\\\"); //设置可访问，score是private的 scoreField.setAccessible(true); scoreField.set(st,88); System.out.println(st.toString()); //输出结果：Student{age=18, name='Lily ,desc='I am student', score=88} //获取字段值 System.out.println(scoreField.get(st)); // 88 \",\"其中的set(Object obj, Object value)方法是Field类本身的方法，用于设置字段的值，而get(Object obj)则是获取字段的值，当然关于Field类还有其他常用的方法如下：\",\"方法返回值\",\"方法名称\",\"方法说明\",\"void\",\"set(Object obj, Object value)\",\"将指定对象变量上此 Field 对象表示的字段设置为指定的新值。\",\"Object\",\"get(Object obj)\",\"返回指定对象上此 Field 表示的字段的值\",\"Class<?>\",\"getType()\",\"返回一个 Class 对象，它标识了此Field 对象所表示字段的声明类型。\",\"boolean\",\"isEnumConstant()\",\"如果此字段表示枚举类型的元素则返回 true；否则返回 false\",\"String\",\"toGenericString()\",\"返回一个描述此 Field（包括其一般类型）的字符串\",\"String\",\"getName()\",\"返回此 Field 对象表示的字段的名称\",\"Class<?>\",\"getDeclaringClass()\",\"返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段\",\"void\",\"setAccessible(boolean flag)\",\"将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性\",\"上述方法可能是较为常用的，事实上在设置值的方法上，Field类还提供了专门针对基本数据类型的方法，如setInt()/getInt()、setBoolean()/getBoolean、setChar()/getChar()等等方法，这里就不全部列出了，需要时查API文档即可。需要特别注意的是被final关键字修饰的Field字段是安全的，在运行时可以接收任何修改，但最终其实际值是不会发生改变的。\"]},\"308\":{\"h\":\"Method类及其用法\",\"t\":[\"Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）。\",\"下面是Class类获取Method对象相关的方法：\",\"方法返回值\",\"方法名称\",\"方法说明\",\"Method\",\"getDeclaredMethod(String name, Class<?>... parameterTypes)\",\"返回一个指定参数的Method对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。\",\"Method[]\",\"getDeclaredMethods()\",\"返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。\",\"Method\",\"getMethod(String name, Class<?>... parameterTypes)\",\"返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。\",\"Method[]\",\"getMethods()\",\"返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。\",\"同样通过案例演示上述方法：\",\"import java.lang.reflect.Method; public class ReflectMethod { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException { Class clazz = Class.forName(\\\"reflect.Circle\\\"); //根据参数获取public的Method,包含继承自父类的方法 Method method = clazz.getMethod(\\\"draw\\\",int.class,String.class); System.out.println(\\\"method:\\\"+method); //获取所有public的方法: Method[] methods =clazz.getMethods(); for (Method m:methods){ System.out.println(\\\"m::\\\"+m); } System.out.println(\\\"=========================================\\\"); //获取当前类的方法包含private,该方法无法获取继承自父类的method Method method1 = clazz.getDeclaredMethod(\\\"drawCircle\\\"); System.out.println(\\\"method1::\\\"+method1); //获取当前类的所有方法包含private,该方法无法获取继承自父类的method Method[] methods1=clazz.getDeclaredMethods(); for (Method m:methods1){ System.out.println(\\\"m1::\\\"+m); } } } class Shape { public void draw(){ System.out.println(\\\"draw\\\"); } public void draw(int count , String name){ System.out.println(\\\"draw \\\"+ name +\\\",count=\\\"+count); } } class Circle extends Shape{ private void drawCircle(){ System.out.println(\\\"drawCircle\\\"); } public int getAllCount(){ return 100; } } \",\"输出结果:\",\"method:public void reflect.Shape.draw(int,java.lang.String) m::public int reflect.Circle.getAllCount() m::public void reflect.Shape.draw() m::public void reflect.Shape.draw(int,java.lang.String) m::public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException m::public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException m::public final void java.lang.Object.wait() throws java.lang.InterruptedException m::public boolean java.lang.Object.equals(java.lang.Object) m::public java.lang.String java.lang.Object.toString() m::public native int java.lang.Object.hashCode() m::public final native java.lang.Class java.lang.Object.getClass() m::public final native void java.lang.Object.notify() m::public final native void java.lang.Object.notifyAll() ========================================= method1::private void reflect.Circle.drawCircle() m1::public int reflect.Circle.getAllCount() m1::private void reflect.Circle.drawCircle() \",\"在通过getMethods方法获取Method对象时，会把父类的方法也获取到，如上的输出结果，把Object类的方法都打印出来了。而getDeclaredMethod/getDeclaredMethods方法都只能获取当前类的方法。我们在使用时根据情况选择即可。下面将演示通过Method对象调用指定类的方法：\",\"Class clazz = Class.forName(\\\"reflect.Circle\\\"); //创建对象 Circle circle = (Circle) clazz.newInstance(); //获取指定参数的方法对象Method Method method = clazz.getMethod(\\\"draw\\\",int.class,String.class); //通过Method对象的invoke(Object obj,Object... args)方法调用 method.invoke(circle,15,\\\"圈圈\\\"); //对私有无参方法的操作 Method method1 = clazz.getDeclaredMethod(\\\"drawCircle\\\"); //修改私有方法的访问标识 method1.setAccessible(true); method1.invoke(circle); //对有返回值得方法操作 Method method2 =clazz.getDeclaredMethod(\\\"getAllCount\\\"); Integer count = (Integer) method2.invoke(circle); System.out.println(\\\"count:\\\"+count); \",\"输出结果\",\"draw 圈圈,count=15 drawCircle count:100 \",\"在上述代码中调用方法，使用了Method类的invoke(Object obj,Object... args)第一个参数代表调用的对象，第二个参数传递的调用方法的参数。这样就完成了类方法的动态调用。\",\"方法返回值\",\"方法名称\",\"方法说明\",\"Object\",\"invoke(Object obj, Object... args)\",\"对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。\",\"Class<?>\",\"getReturnType()\",\"返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型,即方法的返回类型\",\"Type\",\"getGenericReturnType()\",\"返回表示由此 Method 对象所表示方法的正式返回类型的 Type 对象，也是方法的返回类型。\",\"Class<?>[]\",\"getParameterTypes()\",\"按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型。即返回方法的参数类型组成的数组\",\"Type[]\",\"getGenericParameterTypes()\",\"按照声明顺序返回 Type 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型的，也是返回方法的参数类型\",\"String\",\"getName()\",\"以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称\",\"boolean\",\"isVarArgs()\",\"判断方法是否带可变参数，如果将此方法声明为带有可变数量的参数，则返回 true；否则，返回 false。\",\"String\",\"toGenericString()\",\"返回描述此 Method 的字符串，包括类型参数。\",\"getReturnType方法/getGenericReturnType方法都是获取Method对象表示的方法的返回类型，只不过前者返回的Class类型后者返回的Type(前面已分析过)，Type就是一个接口而已，在Java8中新增一个默认的方法实现，返回的就参数类型信息\",\"public interface Type { //1.8新增 default String getTypeName() { return toString(); } } \",\"而getParameterTypes/getGenericParameterTypes也是同样的道理，都是获取Method对象所表示的方法的参数类型，其他方法与前面的Field和Constructor是类似的。\"]},\"309\":{\"h\":\"反射机制执行的流程\",\"t\":[\"这部分主要参考自https://www.cnblogs.com/yougewe/p/10125073.html\",\"先看个例子\",\"public class HelloReflect { public static void main(String[] args) { try { // 1. 使用外部配置的实现，进行动态加载类 TempFunctionTest test = (TempFunctionTest)Class.forName(\\\"com.tester.HelloReflect\\\").newInstance(); test.sayHello(\\\"call directly\\\"); // 2. 根据配置的函数名，进行方法调用（不需要通用的接口抽象） Object t2 = new TempFunctionTest(); Method method = t2.getClass().getDeclaredMethod(\\\"sayHello\\\", String.class); method.invoke(test, \\\"method invoke\\\"); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (NoSuchMethodException e ) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } public void sayHello(String word) { System.out.println(\\\"hello,\\\" + word); } } \",\"来看执行流程\",\"img\"]},\"310\":{\"h\":\"反射获取类实例\",\"t\":[\"首先调用了 java.lang.Class 的静态方法，获取类信息。\",\" @CallerSensitive public static Class<?> forName(String className) throws ClassNotFoundException { // 先通过反射，获取调用进来的类信息，从而获取当前的 classLoader Class<?> caller = Reflection.getCallerClass(); // 调用native方法进行获取class信息 return forName0(className, true, ClassLoader.getClassLoader(caller), caller); } \",\"forName()反射获取类信息，并没有将实现留给了java,而是交给了jvm去加载。\",\"主要是先获取 ClassLoader, 然后调用 native 方法，获取信息，加载类则是回调 java.lang.ClassLoader.\",\"最后，jvm又会回调 ClassLoader 进类加载。\",\" // public Class<?> loadClass(String name) throws ClassNotFoundException { return loadClass(name, false); } // sun.misc.Launcher public Class<?> loadClass(String var1, boolean var2) throws ClassNotFoundException { int var3 = var1.lastIndexOf(46); if(var3 != -1) { SecurityManager var4 = System.getSecurityManager(); if(var4 != null) { var4.checkPackageAccess(var1.substring(0, var3)); } } if(this.ucp.knownToNotExist(var1)) { Class var5 = this.findLoadedClass(var1); if(var5 != null) { if(var2) { this.resolveClass(var5); } return var5; } else { throw new ClassNotFoundException(var1); } } else { return super.loadClass(var1, var2); } } // java.lang.ClassLoader protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException { // 先获取锁 synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded // 如果已经加载了的话，就不用再加载了 Class<?> c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { // 双亲委托加载 if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } // 父类没有加载到时，再自己加载 if (c == null) { // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } } protected Object getClassLoadingLock(String className) { Object lock = this; if (parallelLockMap != null) { // 使用 ConcurrentHashMap来保存锁 Object newLock = new Object(); lock = parallelLockMap.putIfAbsent(className, newLock); if (lock == null) { lock = newLock; } } return lock; } protected final Class<?> findLoadedClass(String name) { if (!checkName(name)) return null; return findLoadedClass0(name); } \",\"下面来看一下 newInstance() 的实现方式。\",\" // 首先肯定是 Class.newInstance @CallerSensitive public T newInstance() throws InstantiationException, IllegalAccessException { if (System.getSecurityManager() != null) { checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), false); } // NOTE: the following code may not be strictly correct under // the current Java memory model. // Constructor lookup // newInstance() 其实相当于调用类的无参构造函数，所以，首先要找到其无参构造器 if (cachedConstructor == null) { if (this == Class.class) { // 不允许调用 Class 的 newInstance() 方法 throw new IllegalAccessException( \\\"Can not call newInstance() on the Class for java.lang.Class\\\" ); } try { // 获取无参构造器 Class<?>[] empty = {}; final Constructor<T> c = getConstructor0(empty, Member.DECLARED); // Disable accessibility checks on the constructor // since we have to do the security check here anyway // (the stack depth is wrong for the Constructor's // security check to work) java.security.AccessController.doPrivileged( new java.security.PrivilegedAction<Void>() { public Void run() { c.setAccessible(true); return null; } }); cachedConstructor = c; } catch (NoSuchMethodException e) { throw (InstantiationException) new InstantiationException(getName()).initCause(e); } } Constructor<T> tmpConstructor = cachedConstructor; // Security check (same as in java.lang.reflect.Constructor) int modifiers = tmpConstructor.getModifiers(); if (!Reflection.quickCheckMemberAccess(this, modifiers)) { Class<?> caller = Reflection.getCallerClass(); if (newInstanceCallerCache != caller) { Reflection.ensureMemberAccess(caller, this, null, modifiers); newInstanceCallerCache = caller; } } // Run constructor try { // 调用无参构造器 return tmpConstructor.newInstance((Object[])null); } catch (InvocationTargetException e) { Unsafe.getUnsafe().throwException(e.getTargetException()); // Not reached return null; } } \",\"newInstance() 主要做了三件事：\",\"权限检测，如果不通过直接抛出异常；\",\"查找无参构造器，并将其缓存起来；\",\"调用具体方法的无参构造方法，生成实例并返回；\",\"下面是获取构造器的过程：\",\" private Constructor<T> getConstructor0(Class<?>[] parameterTypes, int which) throws NoSuchMethodException { // 获取所有构造器 Constructor<T>[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC)); for (Constructor<T> constructor : constructors) { if (arrayContentsEq(parameterTypes, constructor.getParameterTypes())) { return getReflectionFactory().copyConstructor(constructor); } } throw new NoSuchMethodException(getName() + \\\".<init>\\\" + argumentTypesToString(parameterTypes)); } \",\"getConstructor0() 为获取匹配的构造方器；分三步：\",\"先获取所有的constructors, 然后通过进行参数类型比较；\",\"找到匹配后，通过 ReflectionFactory copy一份constructor返回；\",\"否则抛出 NoSuchMethodException;\",\" // 获取当前类所有的构造方法，通过jvm或者缓存 // Returns an array of \\\"root\\\" constructors. These Constructor // objects must NOT be propagated to the outside world, but must // instead be copied via ReflectionFactory.copyConstructor. private Constructor<T>[] privateGetDeclaredConstructors(boolean publicOnly) { checkInitted(); Constructor<T>[] res; // 调用 reflectionData(), 获取保存的信息，使用软引用保存，从而使内存不够可以回收 ReflectionData<T> rd = reflectionData(); if (rd != null) { res = publicOnly ? rd.publicConstructors : rd.declaredConstructors; // 存在缓存，则直接返回 if (res != null) return res; } // No cached value available; request value from VM if (isInterface()) { @SuppressWarnings(\\\"unchecked\\\") Constructor<T>[] temporaryRes = (Constructor<T>[]) new Constructor<?>[0]; res = temporaryRes; } else { // 使用native方法从jvm获取构造器 res = getDeclaredConstructors0(publicOnly); } if (rd != null) { // 最后，将从jvm中读取的内容，存入缓存 if (publicOnly) { rd.publicConstructors = res; } else { rd.declaredConstructors = res; } } return res; } // Lazily create and cache ReflectionData private ReflectionData<T> reflectionData() { SoftReference<ReflectionData<T>> reflectionData = this.reflectionData; int classRedefinedCount = this.classRedefinedCount; ReflectionData<T> rd; if (useCaches && reflectionData != null && (rd = reflectionData.get()) != null && rd.redefinedCount == classRedefinedCount) { return rd; } // else no SoftReference or cleared SoftReference or stale ReflectionData // -> create and replace new instance return newReflectionData(reflectionData, classRedefinedCount); } // 新创建缓存，保存反射信息 private ReflectionData<T> newReflectionData(SoftReference<ReflectionData<T>> oldReflectionData, int classRedefinedCount) { if (!useCaches) return null; // 使用cas保证更新的线程安全性，所以反射是保证线程安全的 while (true) { ReflectionData<T> rd = new ReflectionData<>(classRedefinedCount); // try to CAS it... if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference<>(rd))) { return rd; } // 先使用CAS更新，如果更新成功，则立即返回，否则测查当前已被其他线程更新的情况，如果和自己想要更新的状态一致，则也算是成功了 oldReflectionData = this.reflectionData; classRedefinedCount = this.classRedefinedCount; if (oldReflectionData != null && (rd = oldReflectionData.get()) != null && rd.redefinedCount == classRedefinedCount) { return rd; } } } \",\"如上，privateGetDeclaredConstructors(), 获取所有的构造器主要步骤；\",\"先尝试从缓存中获取；\",\"如果缓存没有，则从jvm中重新获取，并存入缓存，缓存使用软引用进行保存，保证内存可用；\",\"另外，使用 relactionData() 进行缓存保存；ReflectionData 的数据结构如下。\",\" // reflection data that might get invalidated when JVM TI RedefineClasses() is called private static class ReflectionData<T> { volatile Field[] declaredFields; volatile Field[] publicFields; volatile Method[] declaredMethods; volatile Method[] publicMethods; volatile Constructor<T>[] declaredConstructors; volatile Constructor<T>[] publicConstructors; // Intermediate results for getFields and getMethods volatile Field[] declaredPublicFields; volatile Method[] declaredPublicMethods; volatile Class<?>[] interfaces; // Value of classRedefinedCount when we created this ReflectionData instance final int redefinedCount; ReflectionData(int redefinedCount) { this.redefinedCount = redefinedCount; } } \",\"其中，还有一个点，就是如何比较构造是否是要查找构造器，其实就是比较类型完成相等就完了，有一个不相等则返回false。\",\" private static boolean arrayContentsEq(Object[] a1, Object[] a2) { if (a1 == null) { return a2 == null || a2.length == 0; } if (a2 == null) { return a1.length == 0; } if (a1.length != a2.length) { return false; } for (int i = 0; i < a1.length; i++) { if (a1[i] != a2[i]) { return false; } } return true; } // sun.reflect.ReflectionFactory /** Makes a copy of the passed constructor. The returned constructor is a \\\"child\\\" of the passed one; see the comments in Constructor.java for details. */ public <T> Constructor<T> copyConstructor(Constructor<T> arg) { return langReflectAccess().copyConstructor(arg); } // java.lang.reflect.Constructor, copy 其实就是新new一个 Constructor 出来 Constructor<T> copy() { // This routine enables sharing of ConstructorAccessor objects // among Constructor objects which refer to the same underlying // method in the VM. (All of this contortion is only necessary // because of the \\\"accessibility\\\" bit in AccessibleObject, // which implicitly requires that new java.lang.reflect // objects be fabricated for each reflective call on Class // objects.) if (this.root != null) throw new IllegalArgumentException(\\\"Can not copy a non-root Constructor\\\"); Constructor<T> res = new Constructor<>(clazz, parameterTypes, exceptionTypes, modifiers, slot, signature, annotations, parameterAnnotations); // root 指向当前 constructor res.root = this; // Might as well eagerly propagate this if already present res.constructorAccessor = constructorAccessor; return res; } \",\"通过上面，获取到 Constructor 了。\",\"接下来就只需调用其相应构造器的 newInstance()，即返回实例了。\",\" // return tmpConstructor.newInstance((Object[])null); // java.lang.reflect.Constructor @CallerSensitive public T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { if (!override) { if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) { Class<?> caller = Reflection.getCallerClass(); checkAccess(caller, clazz, null, modifiers); } } if ((clazz.getModifiers() & Modifier.ENUM) != 0) throw new IllegalArgumentException(\\\"Cannot reflectively create enum objects\\\"); ConstructorAccessor ca = constructorAccessor; // read volatile if (ca == null) { ca = acquireConstructorAccessor(); } @SuppressWarnings(\\\"unchecked\\\") T inst = (T) ca.newInstance(initargs); return inst; } // sun.reflect.DelegatingConstructorAccessorImpl public Object newInstance(Object[] args) throws InstantiationException, IllegalArgumentException, InvocationTargetException { return delegate.newInstance(args); } // sun.reflect.NativeConstructorAccessorImpl public Object newInstance(Object[] args) throws InstantiationException, IllegalArgumentException, InvocationTargetException { // We can't inflate a constructor belonging to a vm-anonymous class // because that kind of class can't be referred to by name, hence can't // be found from the generated bytecode. if (++numInvocations > ReflectionFactory.inflationThreshold() && !ReflectUtil.isVMAnonymousClass(c.getDeclaringClass())) { ConstructorAccessorImpl acc = (ConstructorAccessorImpl) new MethodAccessorGenerator(). generateConstructor(c.getDeclaringClass(), c.getParameterTypes(), c.getExceptionTypes(), c.getModifiers()); parent.setDelegate(acc); } // 调用native方法，进行调用 constructor return newInstance0(c, args); } \",\"返回构造器的实例后，可以根据外部进行进行类型转换，从而使用接口或方法进行调用实例功能了。\"]},\"311\":{\"h\":\"反射获取方法\",\"t\":[\"第一步，先获取 Method;\",\" // java.lang.Class @CallerSensitive public Method getDeclaredMethod(String name, Class<?>... parameterTypes) throws NoSuchMethodException, SecurityException { checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true); Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes); if (method == null) { throw new NoSuchMethodException(getName() + \\\".\\\" + name + argumentTypesToString(parameterTypes)); } return method; } \",\"忽略第一个检查权限，剩下就只有两个动作了。\",\"获取所有方法列表；\",\"根据方法名称和方法列表，选出符合要求的方法；\",\"如果没有找到相应方法，抛出异常，否则返回对应方法；\",\"所以，先看一下怎样获取类声明的所有方法？\",\" // Returns an array of \\\"root\\\" methods. These Method objects must NOT // be propagated to the outside world, but must instead be copied // via ReflectionFactory.copyMethod. private Method[] privateGetDeclaredMethods(boolean publicOnly) { checkInitted(); Method[] res; ReflectionData<T> rd = reflectionData(); if (rd != null) { res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods; if (res != null) return res; } // No cached value available; request value from VM res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly)); if (rd != null) { if (publicOnly) { rd.declaredPublicMethods = res; } else { rd.declaredMethods = res; } } return res; } \",\"很相似，和获取所有构造器的方法很相似，都是先从缓存中获取方法，如果没有，则从jvm中获取。\",\"不同的是，方法列表需要进行过滤 Reflection.filterMethods;当然后面看来，这个方法我们一般不会派上用场。\",\" // sun.misc.Reflection public static Method[] filterMethods(Class<?> containingClass, Method[] methods) { if (methodFilterMap == null) { // Bootstrapping return methods; } return (Method[])filter(methods, methodFilterMap.get(containingClass)); } // 可以过滤指定的方法，一般为空，如果要指定过滤，可以调用 registerMethodsToFilter(), 或者... private static Member[] filter(Member[] members, String[] filteredNames) { if ((filteredNames == null) || (members.length == 0)) { return members; } int numNewMembers = 0; for (Member member : members) { boolean shouldSkip = false; for (String filteredName : filteredNames) { if (member.getName() == filteredName) { shouldSkip = true; break; } } if (!shouldSkip) { ++numNewMembers; } } Member[] newMembers = (Member[])Array.newInstance(members[0].getClass(), numNewMembers); int destIdx = 0; for (Member member : members) { boolean shouldSkip = false; for (String filteredName : filteredNames) { if (member.getName() == filteredName) { shouldSkip = true; break; } } if (!shouldSkip) { newMembers[destIdx++] = member; } } return newMembers; } \",\"第二步，根据方法名和参数类型过滤指定方法返回：\",\" private static Method searchMethods(Method[] methods, String name, Class<?>[] parameterTypes) { Method res = null; // 使用常量池，避免重复创建String String internedName = name.intern(); for (int i = 0; i < methods.length; i++) { Method m = methods[i]; if (m.getName() == internedName && arrayContentsEq(parameterTypes, m.getParameterTypes()) && (res == null || res.getReturnType().isAssignableFrom(m.getReturnType()))) res = m; } return (res == null ? res : getReflectionFactory().copyMethod(res)); } \",\"大概意思看得明白，就是匹配到方法名，然后参数类型匹配，才可以。\",\"但是可以看到，匹配到一个方法，并没有退出for循环，而是继续进行匹配。\",\"这里是匹配最精确的子类进行返回（最优匹配）\",\"最后，还是通过 ReflectionFactory, copy 方法后返回。\"]},\"312\":{\"h\":\"调用method.invoke()方法\",\"t\":[\" @CallerSensitive public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException { if (!override) { if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) { Class<?> caller = Reflection.getCallerClass(); checkAccess(caller, clazz, obj, modifiers); } } MethodAccessor ma = methodAccessor; // read volatile if (ma == null) { ma = acquireMethodAccessor(); } return ma.invoke(obj, args); } \",\"invoke时，是通过 MethodAccessor 进行调用的，而 MethodAccessor 是个接口，在第一次时调用 acquireMethodAccessor() 进行新创建。\",\" // probably make the implementation more scalable. private MethodAccessor acquireMethodAccessor() { // First check to see if one has been created yet, and take it // if so MethodAccessor tmp = null; if (root != null) tmp = root.getMethodAccessor(); if (tmp != null) { // 存在缓存时，存入 methodAccessor，否则调用 ReflectionFactory 创建新的 MethodAccessor methodAccessor = tmp; } else { // Otherwise fabricate one and propagate it up to the root tmp = reflectionFactory.newMethodAccessor(this); setMethodAccessor(tmp); } return tmp; } // sun.reflect.ReflectionFactory public MethodAccessor newMethodAccessor(Method method) { checkInitted(); if (noInflation && !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) { return new MethodAccessorGenerator(). generateMethod(method.getDeclaringClass(), method.getName(), method.getParameterTypes(), method.getReturnType(), method.getExceptionTypes(), method.getModifiers()); } else { NativeMethodAccessorImpl acc = new NativeMethodAccessorImpl(method); DelegatingMethodAccessorImpl res = new DelegatingMethodAccessorImpl(acc); acc.setParent(res); return res; } } \",\"两个Accessor详情：\",\"// NativeMethodAccessorImpl / DelegatingMethodAccessorImpl class NativeMethodAccessorImpl extends MethodAccessorImpl { private final Method method; private DelegatingMethodAccessorImpl parent; private int numInvocations; NativeMethodAccessorImpl(Method method) { this.method = method; } public Object invoke(Object obj, Object[] args) throws IllegalArgumentException, InvocationTargetException { // We can't inflate methods belonging to vm-anonymous classes because // that kind of class can't be referred to by name, hence can't be // found from the generated bytecode. if (++numInvocations > ReflectionFactory.inflationThreshold() && !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) { MethodAccessorImpl acc = (MethodAccessorImpl) new MethodAccessorGenerator(). generateMethod(method.getDeclaringClass(), method.getName(), method.getParameterTypes(), method.getReturnType(), method.getExceptionTypes(), method.getModifiers()); parent.setDelegate(acc); } return invoke0(method, obj, args); } void setParent(DelegatingMethodAccessorImpl parent) { this.parent = parent; } private static native Object invoke0(Method m, Object obj, Object[] args); } class DelegatingMethodAccessorImpl extends MethodAccessorImpl { private MethodAccessorImpl delegate; DelegatingMethodAccessorImpl(MethodAccessorImpl delegate) { setDelegate(delegate); } public Object invoke(Object obj, Object[] args) throws IllegalArgumentException, InvocationTargetException { return delegate.invoke(obj, args); } void setDelegate(MethodAccessorImpl delegate) { this.delegate = delegate; } } \",\"进行 ma.invoke(obj, args); 调用时，调用 DelegatingMethodAccessorImpl.invoke();\",\"最后被委托到 NativeMethodAccessorImpl.invoke(), 即：\",\" public Object invoke(Object obj, Object[] args) throws IllegalArgumentException, InvocationTargetException { // We can't inflate methods belonging to vm-anonymous classes because // that kind of class can't be referred to by name, hence can't be // found from the generated bytecode. if (++numInvocations > ReflectionFactory.inflationThreshold() && !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) { MethodAccessorImpl acc = (MethodAccessorImpl) new MethodAccessorGenerator(). generateMethod(method.getDeclaringClass(), method.getName(), method.getParameterTypes(), method.getReturnType(), method.getExceptionTypes(), method.getModifiers()); parent.setDelegate(acc); } // invoke0 是个 native 方法，由jvm进行调用业务方法。从而完成反射调用功能。 return invoke0(method, obj, args); } \",\"其中， generateMethod() 是生成具体类的方法：\",\" /** This routine is not thread-safe */ public MethodAccessor generateMethod(Class<?> declaringClass, String name, Class<?>[] parameterTypes, Class<?> returnType, Class<?>[] checkedExceptions, int modifiers) { return (MethodAccessor) generate(declaringClass, name, parameterTypes, returnType, checkedExceptions, modifiers, false, false, null); } \",\"generate() 戳详情。\",\" /** This routine is not thread-safe */ private MagicAccessorImpl generate(final Class<?> declaringClass, String name, Class<?>[] parameterTypes, Class<?> returnType, Class<?>[] checkedExceptions, int modifiers, boolean isConstructor, boolean forSerialization, Class<?> serializationTargetClass) { ByteVector vec = ByteVectorFactory.create(); asm = new ClassFileAssembler(vec); this.declaringClass = declaringClass; this.parameterTypes = parameterTypes; this.returnType = returnType; this.modifiers = modifiers; this.isConstructor = isConstructor; this.forSerialization = forSerialization; asm.emitMagicAndVersion(); // Constant pool entries: // ( * = Boxing information: optional) // (+ = Shared entries provided by AccessorGenerator) // (^ = Only present if generating SerializationConstructorAccessor) // [UTF-8] [This class's name] // [CONSTANT_Class_info] for above // [UTF-8] \\\"sun/reflect/{MethodAccessorImpl,ConstructorAccessorImpl,SerializationConstructorAccessorImpl}\\\" // [CONSTANT_Class_info] for above // [UTF-8] [Target class's name] // [CONSTANT_Class_info] for above // ^ [UTF-8] [Serialization: Class's name in which to invoke constructor] // ^ [CONSTANT_Class_info] for above // [UTF-8] target method or constructor name // [UTF-8] target method or constructor signature // [CONSTANT_NameAndType_info] for above // [CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info] for target method // [UTF-8] \\\"invoke\\\" or \\\"newInstance\\\" // [UTF-8] invoke or newInstance descriptor // [UTF-8] descriptor for type of non-primitive parameter 1 // [CONSTANT_Class_info] for type of non-primitive parameter 1 // ... // [UTF-8] descriptor for type of non-primitive parameter n // [CONSTANT_Class_info] for type of non-primitive parameter n // + [UTF-8] \\\"java/lang/Exception\\\" // + [CONSTANT_Class_info] for above // + [UTF-8] \\\"java/lang/ClassCastException\\\" // + [CONSTANT_Class_info] for above // + [UTF-8] \\\"java/lang/NullPointerException\\\" // + [CONSTANT_Class_info] for above // + [UTF-8] \\\"java/lang/IllegalArgumentException\\\" // + [CONSTANT_Class_info] for above // + [UTF-8] \\\"java/lang/InvocationTargetException\\\" // + [CONSTANT_Class_info] for above // + [UTF-8] \\\"<init>\\\" // + [UTF-8] \\\"()V\\\" // + [CONSTANT_NameAndType_info] for above // + [CONSTANT_Methodref_info] for NullPointerException's constructor // + [CONSTANT_Methodref_info] for IllegalArgumentException's constructor // + [UTF-8] \\\"(Ljava/lang/String;)V\\\" // + [CONSTANT_NameAndType_info] for \\\"<init>(Ljava/lang/String;)V\\\" // + [CONSTANT_Methodref_info] for IllegalArgumentException's constructor taking a String // + [UTF-8] \\\"(Ljava/lang/Throwable;)V\\\" // + [CONSTANT_NameAndType_info] for \\\"<init>(Ljava/lang/Throwable;)V\\\" // + [CONSTANT_Methodref_info] for InvocationTargetException's constructor // + [CONSTANT_Methodref_info] for \\\"super()\\\" // + [UTF-8] \\\"java/lang/Object\\\" // + [CONSTANT_Class_info] for above // + [UTF-8] \\\"toString\\\" // + [UTF-8] \\\"()Ljava/lang/String;\\\" // + [CONSTANT_NameAndType_info] for \\\"toString()Ljava/lang/String;\\\" // + [CONSTANT_Methodref_info] for Object's toString method // + [UTF-8] \\\"Code\\\" // + [UTF-8] \\\"Exceptions\\\" // * [UTF-8] \\\"java/lang/Boolean\\\" // * [CONSTANT_Class_info] for above // * [UTF-8] \\\"(Z)V\\\" // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] \\\"booleanValue\\\" // * [UTF-8] \\\"()Z\\\" // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] \\\"java/lang/Byte\\\" // * [CONSTANT_Class_info] for above // * [UTF-8] \\\"(B)V\\\" // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] \\\"byteValue\\\" // * [UTF-8] \\\"()B\\\" // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] \\\"java/lang/Character\\\" // * [CONSTANT_Class_info] for above // * [UTF-8] \\\"(C)V\\\" // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] \\\"charValue\\\" // * [UTF-8] \\\"()C\\\" // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] \\\"java/lang/Double\\\" // * [CONSTANT_Class_info] for above // * [UTF-8] \\\"(D)V\\\" // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] \\\"doubleValue\\\" // * [UTF-8] \\\"()D\\\" // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] \\\"java/lang/Float\\\" // * [CONSTANT_Class_info] for above // * [UTF-8] \\\"(F)V\\\" // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] \\\"floatValue\\\" // * [UTF-8] \\\"()F\\\" // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] \\\"java/lang/Integer\\\" // * [CONSTANT_Class_info] for above // * [UTF-8] \\\"(I)V\\\" // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] \\\"intValue\\\" // * [UTF-8] \\\"()I\\\" // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] \\\"java/lang/Long\\\" // * [CONSTANT_Class_info] for above // * [UTF-8] \\\"(J)V\\\" // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] \\\"longValue\\\" // * [UTF-8] \\\"()J\\\" // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] \\\"java/lang/Short\\\" // * [CONSTANT_Class_info] for above // * [UTF-8] \\\"(S)V\\\" // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] \\\"shortValue\\\" // * [UTF-8] \\\"()S\\\" // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above short numCPEntries = NUM_BASE_CPOOL_ENTRIES + NUM_COMMON_CPOOL_ENTRIES; boolean usesPrimitives = usesPrimitiveTypes(); if (usesPrimitives) { numCPEntries += NUM_BOXING_CPOOL_ENTRIES; } if (forSerialization) { numCPEntries += NUM_SERIALIZATION_CPOOL_ENTRIES; } // Add in variable-length number of entries to be able to describe // non-primitive parameter types and checked exceptions. numCPEntries += (short) (2 * numNonPrimitiveParameterTypes()); asm.emitShort(add(numCPEntries, S1)); final String generatedName = generateName(isConstructor, forSerialization); asm.emitConstantPoolUTF8(generatedName); asm.emitConstantPoolClass(asm.cpi()); thisClass = asm.cpi(); if (isConstructor) { if (forSerialization) { asm.emitConstantPoolUTF8 (\\\"sun/reflect/SerializationConstructorAccessorImpl\\\"); } else { asm.emitConstantPoolUTF8(\\\"sun/reflect/ConstructorAccessorImpl\\\"); } } else { asm.emitConstantPoolUTF8(\\\"sun/reflect/MethodAccessorImpl\\\"); } asm.emitConstantPoolClass(asm.cpi()); superClass = asm.cpi(); asm.emitConstantPoolUTF8(getClassName(declaringClass, false)); asm.emitConstantPoolClass(asm.cpi()); targetClass = asm.cpi(); short serializationTargetClassIdx = (short) 0; if (forSerialization) { asm.emitConstantPoolUTF8(getClassName(serializationTargetClass, false)); asm.emitConstantPoolClass(asm.cpi()); serializationTargetClassIdx = asm.cpi(); } asm.emitConstantPoolUTF8(name); asm.emitConstantPoolUTF8(buildInternalSignature()); asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi()); if (isInterface()) { asm.emitConstantPoolInterfaceMethodref(targetClass, asm.cpi()); } else { if (forSerialization) { asm.emitConstantPoolMethodref(serializationTargetClassIdx, asm.cpi()); } else { asm.emitConstantPoolMethodref(targetClass, asm.cpi()); } } targetMethodRef = asm.cpi(); if (isConstructor) { asm.emitConstantPoolUTF8(\\\"newInstance\\\"); } else { asm.emitConstantPoolUTF8(\\\"invoke\\\"); } invokeIdx = asm.cpi(); if (isConstructor) { asm.emitConstantPoolUTF8(\\\"([Ljava/lang/Object;)Ljava/lang/Object;\\\"); } else { asm.emitConstantPoolUTF8 (\\\"(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;\\\"); } invokeDescriptorIdx = asm.cpi(); // Output class information for non-primitive parameter types nonPrimitiveParametersBaseIdx = add(asm.cpi(), S2); for (int i = 0; i < parameterTypes.length; i++) { Class<?> c = parameterTypes[i]; if (!isPrimitive(c)) { asm.emitConstantPoolUTF8(getClassName(c, false)); asm.emitConstantPoolClass(asm.cpi()); } } // Entries common to FieldAccessor, MethodAccessor and ConstructorAccessor emitCommonConstantPoolEntries(); // Boxing entries if (usesPrimitives) { emitBoxingContantPoolEntries(); } if (asm.cpi() != numCPEntries) { throw new InternalError(\\\"Adjust this code (cpi = \\\" + asm.cpi() + \\\", numCPEntries = \\\" + numCPEntries + \\\")\\\"); } // Access flags asm.emitShort(ACC_PUBLIC); // This class asm.emitShort(thisClass); // Superclass asm.emitShort(superClass); // Interfaces count and interfaces asm.emitShort(S0); // Fields count and fields asm.emitShort(S0); // Methods count and methods asm.emitShort(NUM_METHODS); emitConstructor(); emitInvoke(); // Additional attributes (none) asm.emitShort(S0); // Load class vec.trim(); final byte[] bytes = vec.getData(); // Note: the class loader is the only thing that really matters // here -- it's important to get the generated code into the // same namespace as the target class. Since the generated code // is privileged anyway, the protection domain probably doesn't // matter. return AccessController.doPrivileged( new PrivilegedAction<MagicAccessorImpl>() { public MagicAccessorImpl run() { try { return (MagicAccessorImpl) ClassDefiner.defineClass (generatedName, bytes, 0, bytes.length, declaringClass.getClassLoader()).newInstance(); } catch (InstantiationException | IllegalAccessException e) { throw new InternalError(e); } } }); } \",\"咱们主要看这一句：ClassDefiner.defineClass(xx, declaringClass.getClassLoader()).newInstance();\",\"在ClassDefiner.defineClass方法实现中，每被调用一次都会生成一个DelegatingClassLoader类加载器对象 ，这里每次都生成新的类加载器，是为了性能考虑，在某些情况下可以卸载这些生成的类，因为类的卸载是只有在类加载器可以被回收的情况下才会被回收的，如果用了原来的类加载器，那可能导致这些新创建的类一直无法被卸载。\",\"而反射生成的类，有时候可能用了就可以卸载了，所以使用其独立的类加载器，从而使得更容易控制反射类的生命周期。\"]},\"313\":{\"h\":\"反射调用流程小结\",\"t\":[\"最后，用几句话总结反射的实现原理：\",\"反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；\",\"每个类都会有一个与之对应的Class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上；\",\"反射也是考虑了线程安全的，放心使用；\",\"反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销；\",\"反射调用多次生成新代理Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；\",\"当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；\",\"调度反射方法，最终是由jvm执行invoke0()执行；\"]},\"314\":{\"h\":\"参考文章\",\"t\":[\"https://www.codercto.com/a/46094.html\",\"https://blog.csdn.net/sinat_38259539/article/details/71799078\",\"https://blog.csdn.net/qq_40896997/article/details/94483820\",\"https://www.cnblogs.com/zhaoguhong/p/6937364.html\",\"https://juejin.im/post/5c160420e51d452a60684431\",\"https://blog.csdn.net/mcryeasy/java/article/details/52344729\",\"著作权归@pdai所有 原文链接：https://pdai.tech/md/java/basic/java-basic-x-reflection.html\"]},\"315\":{\"h\":\"Collection - ArrayList 源码解析\"},\"316\":{\"h\":\"Collection - LinkedList源码解析\"},\"317\":{\"h\":\"Collection - PriorityQueue源码解析\"},\"318\":{\"h\":\"Collection - Stack & Queue 源码解析\"},\"319\":{\"h\":\"Collection 类关系图\"},\"320\":{\"h\":\"Map - HashSet & HashMap 源码解析\"},\"321\":{\"h\":\"Map - LinkedHashSet&Map源码解析\"},\"322\":{\"h\":\"Map - TreeSet & TreeMap 源码解析\"},\"323\":{\"h\":\"Map - WeakHashMap源码解析\"},\"324\":{\"h\":\"Java AIO - 异步IO详解\"},\"325\":{\"h\":\"Java IO - 分类(传输，操作)\"},\"326\":{\"h\":\"Java IO - 源码: InputStream\"},\"327\":{\"h\":\"Java IO - 源码: OutputStream\"},\"328\":{\"h\":\"Java IO - 设计模式(装饰者模式)\"},\"329\":{\"h\":\"Java IO - 常见类使用\"},\"330\":{\"h\":\"Java IO - BIO 详解\"},\"331\":{\"h\":\"IO 模型 - Unix IO 模型\"},\"332\":{\"h\":\"Java N(A)IO - 框架: Netty\"},\"333\":{\"h\":\"Java NIO - IO多路复用详解\"},\"334\":{\"h\":\"Java NIO - 零拷贝实现\"},\"335\":{\"h\":\"Java NIO - 基础详解\"},\"336\":{\"h\":\"♥Java IO知识体系详解♥\"},\"337\":{\"h\":\"♥Java8+特性知识体系详解♥\"},\"338\":{\"h\":\"Java 10 新特性概述\"},\"339\":{\"h\":\"Java 11 新特性概述\"},\"340\":{\"h\":\"Java 11 升Java 17 重要特性必读\"},\"341\":{\"h\":\"Java 12 新特性概述\"},\"342\":{\"h\":\"Java 13 新特性概述\"},\"343\":{\"h\":\"Java 14 新特性概述\"},\"344\":{\"h\":\"Java 15 新特性概述\"},\"345\":{\"h\":\"Java 16 新特性概述\"},\"346\":{\"h\":\"Java 17 新特性概述\"},\"347\":{\"h\":\"Java 8 - 重复注解\"},\"348\":{\"h\":\"Java 8 - 默认方法\"},\"349\":{\"h\":\"Java 8 - JavaFx 2.0\"},\"350\":{\"h\":\"Java 8 - JRE精简\"},\"351\":{\"h\":\"Java 8 - LocalDate/LocalDateTime\"},\"352\":{\"h\":\"Java 8 - Optional类深度解析\"},\"353\":{\"h\":\"Java 8 - 其它更新: 字符串，base64,...\"},\"354\":{\"h\":\"Java 8 - 移除Permgen\"},\"355\":{\"h\":\"Java 8 - StampedLock\"},\"356\":{\"h\":\"Java 8 - 函数编程(lambda表达式)\"},\"357\":{\"h\":\"Java 8 - 类型注解\"},\"358\":{\"h\":\"Java 8 - 类型推断优化\"},\"359\":{\"h\":\"♥Java8特性知识体系详解♥\"},\"360\":{\"h\":\"Java 8 升Java 11 重要特性必读\"},\"361\":{\"h\":\"Java 9 新特性概述\"},\"362\":{\"h\":\"调试排错 - Java 问题排查之应用在线调试Arthas\"},\"363\":{\"h\":\"调试排错 - Java动态调试技术原理\"},\"364\":{\"h\":\"JVM 基础 - 字节码的增强技术\"},\"365\":{\"h\":\"JVM 基础 - 类字节码详解\"},\"366\":{\"h\":\"JVM 基础 - Java 类加载机制\"},\"367\":{\"h\":\"GC - Java 垃圾回收器之CMS GC问题分析与解决\"},\"368\":{\"h\":\"调试排错 - Java 问题排查之使用IDEA本地调试和远程调试\"},\"369\":{\"h\":\"调试排错 - Java 问题排查之Linux命令\"},\"370\":{\"h\":\"调试排错 - Java 问题排查之工具单\"},\"371\":{\"h\":\"GC - Java 垃圾回收器之G1详解\"},\"372\":{\"h\":\"GC - Java 垃圾回收器之ZGC详解\"},\"373\":{\"h\":\"GC - Java 垃圾回收基础知识\"},\"374\":{\"h\":\"JVM 基础 - Java 内存模型详解\"},\"375\":{\"h\":\"调试排错 - Java 内存分析之堆外内存\"},\"376\":{\"h\":\"调试排错 - Java 问题排查之JVM可视化工具\"},\"377\":{\"h\":\"调试排错 - Java 内存分析之堆内存和MetaSpace内存\"},\"378\":{\"h\":\"调试排错 - JVM 调优参数\"},\"379\":{\"h\":\"JVM 基础 - JVM 内存结构\"},\"380\":{\"h\":\"调试排错 - Java 线程分析之线程Dump分析\"},\"381\":{\"h\":\"JVM 基础 - Java 内存模型引入\"},\"382\":{\"h\":\"♥JVM相关知识体系详解♥\"},\"383\":{\"h\":\"Java资源大全中文版\",\"t\":[\"Awesome 系列虽然挺全，但基本只对收录的资源做了极为简要的介绍，如果有更详细的中文介绍，对相应开发者的帮助会更大。这也是我们发起这个开源项目的初衷。\"]},\"384\":{\"h\":\"古董级工具\",\"t\":[\"这些工具伴随着Java一起出现，在各自辉煌之后还在一直使用。\",\"Apache Ant：基于XML的构建管理工具。官网\",\"cglib：字节码生成库。官网\",\"GlassFish：应用服务器，由Oracle赞助支持的Java EE参考实现。官网\",\"Hudson：持续集成服务器，目前仍在活跃开发。官网\",\"JavaServer Faces：Mojarra是JSF标准的一个开源实现，由Oracle开发。官网\",\"JavaServer Pages：支持自定义标签库的网站通用模板库。官网\",\"Liquibase：与具体数据库独立的追踪、管理和应用数据库Scheme变化的工具。官网\"]},\"385\":{\"h\":\"构建工具\",\"t\":[\"构建及应用依赖关系处理工具。\",\"Apache Maven：Maven是一款声明式构建及依赖管理工具，采用约定优于配置方式进行管理。相对Apache Ant更推荐使用Maven，前者采用了过程式管理，维护相对困难。官网\",\"Bazel：来自Google的构建工具，可以快速、可靠地构建代码。官网\",\"Gradle：使用Groovy（非XML）进行增量构建，可以很好地与Maven依赖管理配合工作。官网\",\"Buck：Facebook构建工具。官网\"]},\"386\":{\"h\":\"字节码操作\",\"t\":[\"编程方式操作字节码的开发库。\",\"ASM：通用底层字节码操作和分析开发库。官网\",\"Byte Buddy：使用流式API进一步简化字节码生成。官网\",\"Byteman：在运行时通过DSL（规则）操作字节码进行测试和故障排除。官网\",\"Javassist：一个简化字节码编辑尝试。官网\"]},\"387\":{\"h\":\"集群管理\",\"t\":[\"在集群内动态管理应用程序的框架。\",\"Apache Aurora：Apache Aurora是一个Mesos框架，用于长时间运行服务和定时任务（cron job）。官网\",\"Singularity：Singularity是一个Mesos框架，方便部署和操作。它支持Web Service、后台运行、调度作业和一次性任务。官网\"]},\"388\":{\"h\":\"代码分析\",\"t\":[\"测量代码指标和质量工具。\",\"Checkstyle：代码编写规范和标准静态分析工具。官网\",\"Error Prone：将常见编程错误作为运行时错误报告。官网\",\"FindBugs：通过字节码静态分析查找隐藏bug。官网\",\"jQAssistant：使用基于Neo4J查询语言进行代码静态分析。官网\",\"PMD：对源代码分析查找不良的编程习惯。官网\",\"SonarQube：通过插件集成其它分析组件，对过去一段时间内的数据进行统计。官网\"]},\"389\":{\"h\":\"编译器生成工具\",\"t\":[\"用来创建解析器、解释器或编译器的框架。\",\"ANTLR：复杂的全功能自顶向下解析框架。官网\",\"JavaCC：JavaCC是更加专门的轻量级工具，易于上手且支持语法超前预测。官网\"]},\"390\":{\"h\":\"外部配置工具\",\"t\":[\"支持外部配置的开发库。\",\"config：针对JVM语言的配置库。官网\",\"owner：减少冗余配置属性。官网\"]},\"391\":{\"h\":\"约束满足问题求解程序\",\"t\":[\"帮助解决约束满足问题的开发库。\",\"Choco：可直接使用的约束满足问题求解程序，使用了约束规划技术。官网\",\"JaCoP：为FlatZinc语言提供了一个接口，可以执行MiniZinc模型。官网\",\"OptaPlanner：业务规划与资源调度优化求解程序。官网\",\"Sat4J：逻辑代数与优化问题最先进的求解程序。官网\"]},\"392\":{\"h\":\"持续集成\",\"t\":[\"Bamboo：Atlassian解决方案，可以很好地集成Atlassian的其他产品。可以选择开源许可，也可以购买商业版。官网\",\"CircleCI：提供托管服务，可以免费试用。官网\",\"Codeship：提供托管服务，提供有限的免费模式。官网\",\"fabric8：容器集成平台。官网\",\"Go：ThoughtWork开源解决方案。官网\",\"Jenkins：支持基于服务器的部署服务。官网\",\"TeamCity：JetBrain的持续集成解决方案，有免费版。官网\",\"Travis：通常用作开源项目的托管服务。官网\",\"Buildkite: 持续集成工具，用简单的脚本就能设置pipeline，而且能快速构建，可以免费试用。官网\"]},\"393\":{\"h\":\"CSV解析\",\"t\":[\"简化CSV数据读写的框架与开发库\",\"uniVocity-parsers：速度最快功能最全的CSV开发库之一，同时支持TSV与固定宽度记录的读写。官网\"]},\"394\":{\"h\":\"数据库\",\"t\":[\"简化数据库交互的相关工具。\",\"Apache Phoenix：HBase针对低延时应用程序的高性能关系数据库层。官网\",\"Crate：实现了数据同步、分片、缩放、复制的分布式数据存储。除此之外还可以使用基于SQL的语法跨集群查询。官网\",\"Flyway：简单的数据库迁移工具。官网\",\"H2：小型SQL数据库，以可以作为内存数据库使用著称。官网\",\"HikariCP：高性能JDBC连接工具。官网\",\"JDBI：便捷的JDBC抽象。官网\",\"jOOQ：为SQL schema生成typesafe代码。官网\",\"MapDB：以磁盘或堆内存中并发集合为基础的嵌入式数据库引擎。官网\",\"Presto：针对大数据的分布式SQL查询引擎。官网\",\"Querydsl：Typesafe统一查询。官网\"]},\"395\":{\"h\":\"数据结构\",\"t\":[\"Apache Parquet：Google Dremel论文中发布的基于组装算法的列式（Columnar）存储格式。官网\",\"Protobuf：Google数据交换格式。官网\",\"SBE：简单二进制编码，是最快速的消息格式之一。官网\",\"Wire：整洁轻量级协议缓存。官网\"]},\"396\":{\"h\":\"时间日期工具库\",\"t\":[\"处理时间和日期的开发库。\",\"Joda-Time：在Java 8发布前，Joda-Time是实际使用的时间日期库标准。官网\",\"Time4J：高级时间和日期库。官网\",\"ThreeTen：JSR-310实现，为JDK提供更具特点的时间和日期API。官网\"]},\"397\":{\"h\":\"依赖注入\",\"t\":[\"帮实现依赖翻转范式的开发库。官网\",\"Apache DeltaSpike：CDI扩展框架。官网\",\"Dagger2：编译时注入框架，不需要使用反射。官网\",\"Guice：可以匹敌Dagger的轻量级注入框架。官网\",\"HK2：轻量级动态依赖注入框架。官网\"]},\"398\":{\"h\":\"开发流程增强工具\",\"t\":[\"从最基本的层面增强开发流程。\",\"ADT4J：针对代数数据类型的JSR-269代码生成器。官网\",\"AspectJ：面向切面编程（AOP）的无缝扩展。官网\",\"Auto：源代码生成器集合。官网\",\"DCEVM：通过修改JVM在运行时支持对已加载的类进行无限次重定义。官网\",\"HotswapAgent：支持无限次重定义运行时类与资源。官网\",\"Immutables：类似Scala的条件类。官网\",\"JHipster：基于Spring Boot与AngularJS应用程序的Yeoman源代码生成器。官网\",\"JRebel：无需重新部署，可以即时重新加载代码与配置的商业软件。官网\",\"Lombok：减少冗余的代码生成器。官网\",\"Spring Loaded：类重载代理。官网\",\"vert.x：多语言事件驱动应用框架。官网\"]},\"399\":{\"h\":\"分布式应用\",\"t\":[\"用来编写分布式容错应用的开发库和框架。\",\"Akka：用来编写分布式容错并发事件驱动应用程序的工具和运行时。官网\",\"Apache Storm：实时计算系统。官网\",\"Apache ZooKeeper：针对大型分布式系统的协调服务，支持分布式配置、同步和名称注册。官网\",\"Hazelcast：高可扩展内存数据网格。官网\",\"Hystrix：提供延迟和容错。官网\",\"JGroups：提供可靠的消息传递和集群创建的工具。官网\",\"Orbit：支持虚拟角色（Actor），在传统角色的基础上增加了另外一层抽象。官网\",\"Quasar：为JVM提供轻量级线程和角色。官网\"]},\"400\":{\"h\":\"分布式数据库\",\"t\":[\"对应用程序而言，在分布式系统中的数据库看起来就像是只有一个数据源。\",\"Apache Cassandra：列式数据库，可用性高且没有单点故障。官网\",\"Apache HBase：针对大数据的Hadoop数据库。官网\",\"Druid：实时和历史OLAP数据存储，在聚集查询和近似查询方面表现不俗。官网\",\"Infinispan：针对缓存的高并发键值对数据存储。官网\",\"TiDB：开源分布式HTAP数据库，结合了传统的RDBMS和NoSQL的最佳特性。官网\"]},\"401\":{\"h\":\"发布\",\"t\":[\"以本机格式发布应用程序的工具。\",\"Bintray：发布二进制文件版本控制工具。可以于Maven或Gradle一起配合使用。提供开源免费版本和几种商业收费版本。官网\",\"Central Repository：最大的二进制组件仓库，面向开源社区提供免费服务。Apache Maven默认使用Central 官网Repository，也可以在所有其他构建工具中使用。\",\"IzPack：为跨平台部署建立创作工具（Authoring Tool）。官网\",\"JitPack：打包GitHub仓库的便捷工具。可根据需要构建Maven、Gradle项目，发布可立即使用的组件。官网\",\"Launch4j：将JAR包装为轻量级本机Windows可执行程序。官网\",\"Nexus：支持代理和缓存功能的二进制管理工具。官网\",\"packr：将JAR、资源和JVM打包成Windows、Linux和Mac OS X本地发布文件。官网\"]},\"402\":{\"h\":\"文档处理工具\",\"t\":[\"处理Office文档的开发库。\",\"Apache POI：支持OOXML规范（XLSX、DOCX、PPTX）以及OLE2规范（XLS、DOC、PPT）。官网\",\"documents4j：使用第三方转换器进行文档格式转换，转成类似MS Word这样的格式。官网\",\"jOpenDocument：处理OpenDocument格式（由Sun公司提出基于XML的文档格式）。官网\"]},\"403\":{\"h\":\"函数式编程\",\"t\":[\"函数式编程支持库。\",\"Cyclops：支持一元（Monad）操作和流操作工具类、comprehension（List语法）、模式匹配、trampoline等特性。官网\",\"Fugue：Guava的函数式编程扩展。官网\",\"Functional Java：实现了多种基础和高级编程抽象，用来辅助面向组合开发（composition-oriented development）。官网\",\"Javaslang：一个函数式组件库，提供持久化数据类型和函数式控制结构。官网\",\"jOOλ：旨在填补Java 8 lambda差距的扩展，提供了众多缺失的类型和一组丰富的顺序流API。官网\"]},\"404\":{\"h\":\"游戏开发\",\"t\":[\"游戏开发框架。\",\"jMonkeyEngine：现代3D游戏开发引擎。官网\",\"libGDX：全面的跨平台高级框架。官网\",\"LWJGL：对OpenGL/CL/AL等技术进行抽象的健壮框架。官网\",\"jPCT：基于OpenGL技术开发的3D图形引擎。纯Java的3D引擎。官网\"]},\"405\":{\"h\":\"GUI\",\"t\":[\"现代图形化用户界面开发库。\",\"JavaFX：Swing的后继者。官网\",\"Scene Builder：开发JavaFX应用的可视化布局工具。官网\"]},\"406\":{\"h\":\"高性能计算\",\"t\":[\"涵盖了从集合到特定开发库的高性能计算相关工具。\",\"Agrona：高性能应用中常见的数据结构和工具方法。官网\",\"Disruptor：线程间消息传递开发库。官网\",\"fastutil：快速紧凑的特定类型集合（Collection）。官网\",\"GS Collections：受Smalltalk启发的集合框架。官网\",\"HPPC：基础类型集合。官网\",\"Javolution：实时和嵌入式系统的开发库。官网\",\"JCTools：JDK中缺失的并发工具。官网\",\"Koloboke：Hash set和hash map。官网\",\"Trove：基础类型集合。官网\",\"High-scale-lib:Cliff Click 个人开发的高性能并发库官网\"]},\"407\":{\"h\":\"IDE\",\"t\":[\"简化开发的集成开发环境。\",\"Eclipse：老牌开源项目，支持多种插件和编程语言。官网\",\"IntelliJ IDEA：支持众多JVM语言，是安卓开发者好的选择。商业版主要针对企业客户。官网\",\"NetBeans：为多种技术提供集成化支持，包括Java SE、Java EE、数据库访问、HTML5等。官网\",\"Scala IDE：一款基于Eclipse开源平台打造的Scala集成开发环境。官网\",\"SpringSource Tool Suite（STS）:一款基于Eclipse开源平台打造的Spring应用开发环境。官网\"]},\"408\":{\"h\":\"图像处理\",\"t\":[\"创建、评价和操作图片的支持库。\",\"Imgscalr：纯Java 2D实现，简单、高效、支持硬件加速的图像缩放开发库。官网\",\"Picasso：安卓图片下载和图片缓存开发库。官网\",\"Thumbnailator：Thumbnailator是一个高质量Java缩略图开发库。官网\",\"ZXing：支持多种格式的一维、二维条形码图片处理开发库。官网\",\"im4java: 基于ImageMagick或GraphicsMagick命令行的图片处理开发库，基本上ImageMagick能够支持的图片格式和处理方式都能够处理。官网\",\"Apache Batik：在Java应用中程序以SVG格式显示、生成及处理图像的工具集，包括SVG解析器、SVG生成器、SVG DOM等模块，可以集成使用也可以单独使用，还可以扩展自定义的SVG标签。官网\"]},\"409\":{\"h\":\"JSON\",\"t\":[\"简化JSON处理的开发库。\",\"Genson：强大且易于使用的Java到JSON转换开发库。官网\",\"Gson：谷歌官方推出的JSON处理库，支持在对象与JSON之间双向序列化，性能良好且可以实时调用。官网\",\"Jackson：与GSON类似，在频繁使用时性能更佳。官网\",\"LoganSquare：基于Jackson流式API，提供对JSON解析和序列化。比GSON与Jackson组合方式效果更好。官网\",\"Fastjson：一个Java语言编写的高性能功能完善的JSON库。官网\",\"Kyro：快速、高效、自动化的Java对象序列化和克隆库。官网\"]},\"410\":{\"h\":\"JVM与JDK\",\"t\":[\"目前的JVM和JDK实现。\",\"JDK 9：JDK 9的早期访问版本。官网\",\"OpenJDK：JDK开源实现。官网\"]},\"411\":{\"h\":\"基于JVM的语言\",\"t\":[\"除Java外，可以用来编写JVM应用程序的编程语言。\",\"Scala：融合了面向对象和函数式编程思想的静态类型编程语言。官网\",\"Groovy：类型可选（Optionally typed）的动态语言，支持静态类型和静态编译。目前是一个Apache孵化器项目。官网\",\"Clojure：可看做现代版Lisp的动态类型语言。官网\",\"Ceylon：RedHat开发的面向对象静态类型编程语言。官网\",\"Kotlin：JetBrain针对JVM、安卓和浏览器提供的静态类型编程语言。官网\",\"Xtend：一种静态编程语言，能够将其代码转换为简洁高效的Java代码，并基于JVM运行。官网\"]},\"412\":{\"h\":\"日志\",\"t\":[\"记录应用程序行为日志的开发库。\",\"Apache Log4j 2：使用强大的插件和配置架构进行完全重写。官网\",\"kibana：分析及可视化日志文件。官网\",\"Logback：强健的日期开发库，通过Groovy提供很多有趣的选项。官网\",\"logstash：日志文件管理工具。官网\",\"Metrics：通过JMX或HTTP发布参数，并且支持存储到数据库。官网\",\"SLF4J：日志抽象层，需要与具体的实现配合使用。官网\"]},\"413\":{\"h\":\"机器学习\",\"t\":[\"提供具体统计算法的工具。其算法可从数据中学习。\",\"Apache Flink：快速、可靠的大规模数据处理引擎。官网\",\"Apache Hadoop：在商用硬件集群上用来进行大规模数据存储的开源软件框架。官网\",\"Apache Mahout：专注协同过滤、聚类和分类的可扩展算法。官网\",\"Apache Spark：开源数据分析集群计算框架。官网\",\"DeepDive：从非结构化数据建立结构化信息并集成到已有数据库的工具。官网\",\"Deeplearning4j：分布式多线程深度学习开发库。官网\",\"H2O：用作大数据统计的分析引擎。官网\",\"Weka：用作数据挖掘的算法集合，包括从预处理到可视化的各个层次。官网\",\"QuickML：高效机器学习库。官网、GitHub\"]},\"414\":{\"h\":\"消息传递\",\"t\":[\"在客户端之间进行消息传递，确保协议独立性的工具。\",\"Aeron：高效可扩展的单播、多播消息传递工具。官网\",\"Apache ActiveMQ：实现JMS的开源消息代理（broker），可将同步通讯转为异步通讯。官网\",\"Apache Camel：通过企业级整合模式（Enterprise Integration Pattern EIP）将不同的消息传输API整合在一起。官网\",\"Apache Kafka：高吞吐量分布式消息系统。官网\",\"Apache RocketMQ: Apache RocketMQ是一个开源的分布式消息传递和流数据平台。官网\",\"Hermes：快速、可靠的消息代理（Broker），基于Kafka构建。官网\",\"JBoss HornetQ：清晰、准确、模块化，可以方便嵌入的消息工具。官网\",\"JeroMQ：ZeroMQ的纯Java实现。官网\",\"Smack：跨平台XMPP客户端函数库。官网\",\"Openfire：是开源的、基于XMPP、采用Java编程语言开发的实时协作服务器。 Openfire安装和使用都非常简单，并可利用Web界面进行管理。 官网GitHub\",\"Spark：是一个开源，跨平台IM客户端。它的特性支持集组聊天，电话集成和强大安全性能。如果企业内部部署IM使用Openfire+Spark是最佳的组合。 官网GitHub\",\"Tigase： 是一个轻量级的可伸缩的 Jabber/XMPP 服务器。无需其他第三方库支持，可以处理非常高的复杂和大量的用户数，可以根据需要进行水平扩展。 官网\"]},\"415\":{\"h\":\"杂项\",\"t\":[\"未分类其它资源。\",\"Design Patterns：实现并解释了最常见的设计模式。官网\",\"Jimfs：内存文件系统。官网\",\"Lanterna：类似curses的简单console文本GUI函数库。官网\",\"LightAdmin：可插入式CRUD UI函数库，可用来快速应用开发。官网\",\"OpenRefine：用来处理混乱数据的工具，包括清理、转换、使用Web Service进行扩展并将其关联到数据库。官网\",\"RoboVM：Java编写原生iOS应用。官网\",\"Quartz：强大的任务调度库.官网\"]},\"416\":{\"h\":\"应用监控工具\",\"t\":[\"监控生产环境中应用程序的工具。\",\"AppDynamics：性能监测商业工具。官网\",\"JavaMelody：性能监测和分析工具。官网\",\"Kamon：Kamon用来监测在JVM上运行的应用程序。官网\",\"New Relic：性能监测商业工具。官网\",\"SPM：支持对JVM应用程序进行分布式事务追踪的性能监测商业工具。官网\",\"OverOps(Takipi)：产品运行时错误监测及调试商业工具。官网\"]},\"417\":{\"h\":\"原生开发库\",\"t\":[\"用来进行特定平台开发的原生开发库。\",\"JNA：不使用JNI就可以使用原生开发库。此外，还为常见系统函数提供了接口。官网\"]},\"418\":{\"h\":\"自然语言处理\",\"t\":[\"用来专门处理文本的函数库。\",\"Apache OpenNLP：处理类似分词等常见任务的工具。官网\",\"CoreNLP：斯坦佛CoreNLP提供了一组基础工具，可以处理类似标签、实体名识别和情感分析这样的任务。官网\",\"LingPipe：一组可以处理各种任务的工具集，支持POS标签、情感分析等。官网\",\"Mallet：统计学自然语言处理、文档分类、聚类、主题建模等。官网\"]},\"419\":{\"h\":\"网络\",\"t\":[\"网络编程函数库。\",\"Async Http Client：异步HTTP和WebSocket客户端函数库。官网\",\"Grizzly：NIO框架，在Glassfish中作为网络层使用。官网\",\"Netty：构建高性能网络应用程序开发框架。官网\",\"OkHttp：一个Android和Java应用的HTTP+SPDY客户端。官网\",\"Undertow：基于NIO实现了阻塞和非阻塞API的Web服务器，在WildFly中作为网络层使用。官网\",\"unirest-java: Unirest 是一个轻量级的 HTTP 请求库，涵盖 Node、Ruby、Java、PHP、Python、Objective-C、.NET 等多种语言。可发起 GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS 请求。官网\",\"brpc-java: java版baidu rpc框架，高性能、多协议、易扩展、低耦合。官网\"]},\"420\":{\"h\":\"ORM\",\"t\":[\"处理对象持久化的API。\",\"Ebean：支持快速数据访问和编码的ORM框架。官网\",\"EclipseLink：支持许多持久化标准，JPA、JAXB、JCA和SDO。官网\",\"Hibernate：广泛使用、强健的持久化框架。Hibernate的技术社区非常活跃。官网\",\"MyBatis：带有存储过程或者SQL语句的耦合对象（Couples object）。官网\",\"OrmLite：轻量级开发包，免除了其它ORM产品中的复杂性和开销。官网\",\"Nutz：另一个SSH。官网，Github，论坛\",\"JFinal：JAVA WEB + ORM框架。官网，Github\",\"Apache OpenJPA: 实现了 EJB 3.0 中的 JPA 标准,为开发者提供功能强大、使用简单的持久化数据管理框架。 官网\"]},\"421\":{\"h\":\"PDF\",\"t\":[\"用来帮助创建PDF文件的资源。\",\"Apache FOP：从XSL-FO创建PDF。官网\",\"Apache PDFBox：用来创建和操作PDF的工具集。官网\",\"DynamicReports：JasperReports的精简版。官网\",\"flyingsaucer：XML/XHTML和CSS 2.1渲染器。官网\",\"iText：一个易于使用的PDF函数库，用来编程创建PDF文件。注意，用于商业用途时需要许可证。官网\",\"JasperReports：一个复杂的报表引擎。官网\"]},\"422\":{\"h\":\"性能分析\",\"t\":[\"性能分析、性能剖析及基准测试工具。\",\"jHiccup：提供平台中JVM暂停的日志和记录。官网\",\"JMH：JVM基准测试工具。官网\",\"JProfiler：商业分析器。官网\",\"LatencyUtils：测量和报告延迟的工具。官网\",\"VisualVM：对运行中的应用程序信息提供了可视化界面。官网\",\"YourKit Java Profiler：商业分析器。官网\"]},\"423\":{\"h\":\"响应式开发库\",\"t\":[\"用来开发响应式应用程序的开发库。\",\"Reactive Streams：异步流处理标准，支持非阻塞式反向压力（backpressure）。官网\",\"Reactor：构建响应式快速数据（fast-data）应用程序的开发库。官网\",\"RxJava：通过JVM可观察序列（observable sequence）构建异步和基于事件的程序。官网\"]},\"424\":{\"h\":\"REST框架\",\"t\":[\"用来创建RESTful 服务的框架。\",\"Dropwizard：偏向于自己使用的Web框架。用来构建Web应用程序，使用了Jetty、Jackson、Jersey和Metrics。官网\",\"Feign：受Retrofit、JAXRS-2.0和WebSocket启发的HTTP客户端连接器（binder）。官网\",\"Jersey：JAX-RS参考实现。官网\",\"RESTEasy：经过JAX-RS规范完全认证的可移植实现。官网\",\"RestExpress：一个Java类型安全的REST客户端。官网\",\"RestX：基于注解处理和编译时源码生成的框架。官网\",\"Retrofit：类型安全的REST客户端。官网\",\"Spark：受到Sinatra启发的Java REST框架。官网\",\"Swagger：Swagger是一个规范且完整的框架，提供描述、生产、消费和可视化RESTful Web Service。官网\",\"Blade：国人开发的一个轻量级的MVC框架. 它拥有简洁的代码，优雅的设计。官网\"]},\"425\":{\"h\":\"科学计算与分析\",\"t\":[\"用于科学计算和分析的函数库。\",\"DataMelt：用于科学计算、数据分析及数据可视化的开发环境。官网\",\"JGraphT：支持数学图论对象和算法的图形库。官网\",\"JScience：用来进行科学测量和单位的一组类。官网\"]},\"426\":{\"h\":\"搜索引擎\",\"t\":[\"文档索引引擎，用于搜索和分析。\",\"Apache Solr：一个完全的企业搜索引擎。为高吞吐量通信进行了优化。官网\",\"Elasticsearch：一个分布式、支持多租户（multitenant）全文本搜索引擎。提供了RESTful Web接口和无schema的JSON文档。官网\",\"Apache Lucene：是一个开放源代码的全文检索引擎工具包，是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎。官网\"]},\"427\":{\"h\":\"安全\",\"t\":[\"用于处理安全、认证、授权或会话管理的函数库。\",\"Apache Shiro：执行认证、授权、加密和会话管理。官网\",\"Bouncy Castle，涵盖了从基础的帮助函数到PGP/SMIME操作。官网：多途加密开发库。支持JCA提供者（JCA provider)\",\"Cryptomator：在云上进行客户端跨平台透明加密。官网\",\"Keycloak：为浏览器应用和RESTful Web Service集成SSO和IDM。目前还处于beta版本，但是看起来非常有前途。官网\",\"PicketLink：PicketLink是一个针对Java应用进行安全和身份认证管理的大型项目（Umbrella Project）。官网\",\"Sa-Token：Sa-Token 是一个轻量级 Java 权限认证框架，主要解决：登录认证、权限认证、Session会话、单点登录、OAuth2.0、微服务网关鉴权 等一系列权限相关问题。官网\"]},\"428\":{\"h\":\"序列化\",\"t\":[\"用来高效处理序列化的函数库。\",\"FlatBuffers：高效利用内存的序列化函数库，无需解包和解析即可高效访问序列化数据。官网\",\"Kryo：快速、高效的对象图形序列化框架。官网\",\"FST：提供兼容JDK的高性能对象图形序列化。官网\",\"MessagePack：一种高效的二进制序列化格式。官网\"]},\"429\":{\"h\":\"应用服务器\",\"t\":[\"用来部署应用程序的服务器。\",\"Apache Tomcat：针对Servlet和JSP的应用服务器，健壮性好且适用性强。官网\",\"Apache TomEE：Tomcat加Java EE。官网\",\"Jetty：轻量级、小巧的应用服务器，通常会嵌入到项目中。官网\",\"WebSphere Liberty：轻量级、模块化应用服务器，由IBM开发。官网\",\"WildFly：之前被称作JBoss，由Red Hat开发。支持很多Java EE功能。官网\"]},\"430\":{\"h\":\"模板引擎\",\"t\":[\"在模板中替换表达式的工具。\",\"Apache Velocity：提供HTML页面模板、email模板和通用开源代码生成器模板。官网\",\"FreeMarker：通用模板引擎，不需要任何重量级或自己使用的依赖关系。官网\",\"Handlebars.java：使用Java编写的模板引擎，逻辑简单，支持语义扩展（semantic Mustache）。官网\",\"Thymeleaf：旨在替换JSP，支持XML文件的工具。官网\",\"Beetl：新一代的模板引擎，功能强大，性能良好，超过当前流行的模板引擎。而且还易学易用。官网\"]},\"431\":{\"h\":\"测试\",\"t\":[\"测试内容从对象到接口，涵盖性能测试和基准测试工具。\",\"Apache JMeter：功能性测试和性能评测。官网\",\"Arquillian：集成测试和功能行测试平台，集成Java EE容器。官网\",\"AssertJ：支持流式断言提高测试的可读性。官网\",\"Awaitility：用来同步异步操作的DSL。官网\",\"Cucumber：BDD测试框架。官网\",\"Gatling：设计为易于使用、可维护的和高性能负载测试工具。官网\",\"Hamcrest：可用来灵活创建意图（intent）表达式的匹配器。官网\",\"JMockit：用来模拟静态、final方法等。官网\",\"JUnit：通用测试框架。官网\",\"Mockito：在自动化单元测试中创建测试对象，为TDD或BDD提供支持。官网\",\"PowerMock： 支持模拟静态方法、构造函数、final类和方法、私有方法以及移除静态初始化器的模拟工具。官网\",\"REST Assured：为REST/HTTP服务提供方便测试的Java DSL。官网\",\"Selenide：为Selenium提供精准的周边API，用来编写稳定且可读的UI测试。官网\",\"Selenium：为Web应用程序提供可移植软件测试框架。官网\",\"Spock：JUnit-compatible framework featuring an expressive Groovy-derived specification language.官网兼容JUnit框架，支持衍生的Groovy范的语言。\",\"TestNG：测试框架。官网\",\"Truth：Google的断言和命题（proposition）框架。官网\",\"Unitils：模块化测试函数库，支持单元测试和集成测试。官网\",\"WireMock：Web Service测试桩（Stub）和模拟函数。官网\"]},\"432\":{\"h\":\"通用工具库\",\"t\":[\"通用工具类函数库。\",\"Apache Commons：提供各种用途的函数，比如配置、验证、集合、文件上传或XML处理等。官网\",\"args4j：命令行参数解析器。官网\",\"CRaSH：为运行进行提供CLI。官网\",\"Gephi：可视化跨平台网络图形化操作程序。官网\",\"Guava：集合、缓存、支持基本类型、并发函数库、通用注解、字符串处理、I/O等。官网\",\"JADE：构建、调试多租户系统的框架和环境。官网\",\"javatuples：正如名字表示的那样，提供tuple支持。尽管目前tuple的概念还有留有争议。官网\",\"JCommander：命令行参数解析器。官网\",\"Protégé：提供存在论（ontology）编辑器以及构建知识系统的框架。官网\",\"Hutool：一个Java工具集，缓存、HTTP、加密解密、DFA、JSON、分组配置文件、数据库操作、图片验证码、Excel读写、定时任务、模板引擎、邮件、Servlet、二维码、Emoji、分词等一系列工具类。官网\"]},\"433\":{\"h\":\"网络爬虫\",\"t\":[\"用于分析网站内容的函数库。\",\"Apache Nutch：可用于生产环境的高度可扩展、可伸缩的网络爬虫。官网\",\"Crawler4j：简单的轻量级网络爬虫。官网\",\"JSoup：刮取、解析、操作和清理HTML。官网\",\"webmagic：一个可扩展的Java爬虫框架，架构类似Python的Scrapy。\"]},\"434\":{\"h\":\"Web框架\",\"t\":[\"用于处理Web应用程序不同层次间通讯的框架。\",\"Apache Tapestry：基于组件的框架，使用Java创建动态、强健的、高度可扩展的Web应用程序。官网\",\"Apache Wicket：基于组件的Web应用框架，与Tapestry类似带有状态显示GUI。官网\",\"Google Web Toolkit：一组Web开发工具集，包含在客户端将Java代码转为JavaScript的编译器、XML解析器、RCP 官网API、JUnit集成、国际化支持和GUI控件。\",\"Grails：Groovy框架，旨在提供一个高效开发环境，使用约定而非配置、没有XML并支持混入（mixin）。官网\",\"Ninja：Java全栈Web开发框架。非常稳固、快速和高效。官网\",\"Pippo：小型、高度模块化的类Sinatra框架。官网\",\"Play：使用约定而非配置，支持代码热加载并在浏览器中显示错误。官网\",\"PrimeFaces：JSF框架，提供免费和带支持的商业版本。包括若干前端组件。官网\",\"Ratpack：一组Java开发函数库，用于构建快速、高效、可扩展且测试完备的HTTP应用程序。官网\",\"Spring Boot：微框架，简化了Spring新程序的开发过程。官网\",\"Spring：旨在简化Java EE的开发过程，提供依赖注入相关组件并支持面向切面编程。官网\",\"Vaadin：基于GWT构建的事件驱动框架。使用服务端架构，客户端使用Ajax。官网\",\"Blade：国人开发的一个轻量级的MVC框架. 它拥有简洁的代码，优雅的设计。官网\"]},\"435\":{\"h\":\"业务流程管理套件\",\"t\":[\"流程驱动的软件系统构建。\",\"jBPM：非常灵活的业务流程管理框架，致力于构建开发与业务分析人员之间的桥梁。官网\",\"Activity：轻量级工作流和业务流程管理框架。官网github\"]},\"436\":{\"h\":\"资源\"},\"437\":{\"h\":\"社区\",\"t\":[\"r/java：Reddit的Java子社区。官网\",\"stackoverflow：问答平台。官网\",\"vJUG：虚拟Java用户组。官网\",\"java8 新特性教程例子。github\"]},\"438\":{\"h\":\"有影响力的书\",\"t\":[\"具有广泛影响且值得阅读的Java经典书籍。\",\"Effective Java (2nd Edition)\",\"Java 8 in Action\",\"Java Concurrency in Practice | Java并发编程实战\",\"Thinking in Java | Java编程思想\",\"Java Puzzlers | Java解惑\"]},\"439\":{\"h\":\"播客\",\"t\":[\"可以一边编程一边听的东西。\",\"Java Council：官网\",\"Java Posse：Discontinued as of 02/2015.官网\"]},\"440\":{\"h\":\"Twitter\",\"t\":[\"Adam Bien：自由职业者、作家、JavaONE明星演讲者、顾问、Java Champion。\",\"Antonio Goncalves：Java Champion、JUG Leader、Devoxx France、Java EE 6/7、JCP、作家。\",\"Arun Gupta：Java Champion、JavaONE明星演讲者、JUG Leader、Devoxx4Kids成员、Red Hatter。\",\"Bruno Borges：Oracle产品经理、Java Jock。\",\"Ed Burns：Oracle技术团队顾问。\",\"Eugen Paraschiv：Spring安全课程作者。\",\"James Weaver：Java、JavaFX、IoT开发者、作者和演讲者。\",\"Java EE：Java EE Twitter官方账号。\",\"Java Magazine：Java杂志官方账号。\",\"Java.net：Java.net官方账号。\",\"Java：Java Twitter官方账号。\",\"Javin Paul：知名Java博客作者。\",\"Lukas Eder：Data Geekery（jOOQ）创始人兼CEO。\",\"Mario Fusco：RedHatter、JUG协调、活跃讲师和作者。\",\"Mark Reinhold：Oracle首席架构师、Java平台开发组。\",\"Martijn Verburg：London JUG co-leader、演讲者、作家、Java Champion等。\",\"OpenJDK：OpenJDK官方账号。\",\"Reza Rahman：Java EE、GlassFish、WebLogic传道者、作家、演讲者、开源黑客。\",\"Simon Maple：Java Champion、virtualJUG创始人、LJC leader、RebelLabs作者。\",\"Stephen Colebourne： Java Champion、演讲者。\",\"Tim Boudreau：作家、NetBeans大牛。\",\"Trisha Gee：Java Champion、演讲者。\"]},\"441\":{\"h\":\"知名网站\",\"t\":[\"值得关注的Java技术站点。\"]},\"442\":{\"h\":\"英文站点\",\"t\":[\"Android Arsenal\",\"Google Java Style：官网\",\"InfoQ：官网\",\"Java Code Geeks\",\"Java, SQL, and jOOQ\",\"Java.net\",\"Javalobby\",\"JavaWorld：官网\",\"JAXenter：官网\",\"RebelLabs\",\"The Java Specialist' Newsletter：官网\",\"The Takipi Blog\",\"TheServerSide.com：服务器编程交流平台是一个老牌的IT信息网站，关注服务器端编程的，以Java和.Net周边信息为主。官网\",\"Thoughts On Java\",\"Vanilla Java\",\"Vlad Mihalcea on Hibernate\",\"Voxxed\",\"OnJava：O'Reilly Java包含最新的Java技术资讯，优质代码，完全的实例和详解。官网\"]},\"443\":{\"h\":\"Better Java\",\"t\":[\"Java 虽作为最流行的编程语言之一，但是似乎并没有什么人很享受用它。好吧，Java 确实是这样的一门编程语言，从最近发布不久的 Java 8 开始，为了更好的使用 Java，我决定收集一些库，实践和工具等相关资料。“更好” 是主观的，所以推荐使用我所说的建议的某些部分，而不是一下子全部按照这些建议来做。请尽情添加其他意见并提交 PR。\"]},\"444\":{\"h\":\"Style\",\"t\":[\"Java 传统的代码风格是被用来编写非常复杂的企业级 JavaBean。新的代码风格看起来会更加整洁，更加正确，并且更加简单。\"]},\"445\":{\"h\":\"Structs\",\"t\":[\"对我们程序员来说，包装数据是最简单的事情之一。下面是传统的通过定义一个 JavaBean 的实现方式：\",\"public class DataHolder { private String data; public DataHolder() { } public void setData(String data) { this.data = data; } public String getData() { return this.data; } } \",\"这种方式既繁琐又浪费代码。即使你的 IDE 可以自动生成这些代码，也是浪费。因此，别这么干.\",\"相反，我更喜欢 C 语言保存数据的风格来写一个类：\",\"public class DataHolder { public final String data; public DataHolder(String data) { this.data = data; } } \",\"这样不仅减少了近一半的代码行数。并且，这个类里面保存的数据除了你去继承它，否则不会改变，由于它不可变性，我们可以认为这会更加简单。\",\"如果你想保存很容易修改的对象数据，像 Map 或者 List，你应该使用 ImmutableMap 或者 ImmutableList，这些会在不变性那一部分讨论。\"]},\"446\":{\"h\":\"The Builder Pattern\",\"t\":[\"如果你想用这种构造的方式构造更复杂的对象，请考虑构建器模式。\",\"你可以建一个静态内部类来构建你的对象。构建器构建对象的时候，对象的状态是可变的，但是一旦你调用了 build 方法之后，构建的对象就变成了不可变的了。\",\"想象一下我们有一个更复杂的 DataHolder。那么它的构建器看起来应该是这样的：\",\"public class ComplicatedDataHolder { public final String data; public final int num; // lots more fields and a constructor public static class Builder { private String data; private int num; public Builder data(String data) { this.data = data; return this; } public Builder num(int num) { this.num = num; return this; } public ComplicatedDataHolder build() { return new ComplicatedDataHolder(data, num); // etc } } } \",\"然后调用它：\",\"final ComplicatedDataHolder cdh = new ComplicatedDataHolder.Builder() .data(\\\"set this\\\") .num(523) .build(); \",\"这有关于构建器更好的例子，他会让你感受到构建器到底是怎么回事。它没有使用许多我们尽力避免使用的样板，并且它会给你不可变的对象和非常好用的接口。\",\"可以考虑下在众多的库中选择一个来帮你生成构建器，取代你亲手去写构建器的方式。\"]},\"447\":{\"h\":\"Immutable Object Generation\",\"t\":[\"如果你要手动创建许多不可变对象，请考虑用注解处理器的方式从它们的接口自动生成。它使样板代码减少到最小化，减少产生 bug 的可能性，促进了对象的不可变性。看这 presentation 有常见的 Java 设计模式中一些问题的有趣的讨论。\",\"一些非常棒的代码生成库如 [immutables] (https://github.com/immutables/immutables), 谷歌的auto-value 和Lombok\"]},\"448\":{\"h\":\"Exceptions\",\"t\":[\"使用检查异常的时候一定要注意，或者干脆别用。它会强制你去用 try/catch 代码块包裹住可能抛出异常的部分。比较好的方式就是使你自定义的异常继承自运行时异常来取而代之。这样，可以让你的用户使用他们喜欢的方式去处理异常，而不是每次抛出异常的时候都强制它们去处理/声明，这样会污染代码。\",\"一个比较漂亮的绝招是在你的方法异常声明中声明 RuntimeExceptions。这对编译器没有影响，但是可以通过文档告诉你的用户在这里可能会有异常抛出。\"]},\"449\":{\"h\":\"Dependency injection\",\"t\":[\"在软件工程领域，而不仅是在 Java 领域，使用依赖注入是编写可测试软件最好的方法之一。 由于 Java 强烈鼓励使用面向对象的设计，所以在 Java 中为了开发可测试软件，你不得不使用依赖注入。\",\"在 Java 中，通常使用Spring 框架来完成依赖注入。Spring 有基于代码的和基于 XML 配置文件的两种连接方式。如果你使用基于 XML 配置文件的方式，注意不要过度使用 Spring，正是由于它使用的基于 XML 配置文件的格式。在 XML 配置文件中绝对不应该有逻辑或者控制结构。它应该仅仅被用来做依赖注入。\",\"使用 Google 和 Square 的 Dagger 或者 Google 的 Guice 库是 Spring 比较好的替代品。它们不使用像 Spring 那样的 XML 配置文件的格式，相反它们把注入逻辑以注解的方式写到代码中。\"]},\"450\":{\"h\":\"Avoid Nulls\",\"t\":[\"尽量避免使用空值。不要返回 null 的集合，你应该返回一个 empty 的集合。如果你确实准备使用 null 请考虑使用 @Nullable 注解。IntelliJ IDEA 内置支持 @Nullable 注解。\",\"阅读计算机科学领域最糟糕的错误了解更多为何不使用 null。\",\"如果你使用的是 Java 8，你可以用新出的优秀的 Optional 类型。如果有一个值你不确定是否存在，你可以像这样在类中用 Optional 包裹住它们：\",\"public class FooWidget { private final String data; private final Optional<Bar> bar; public FooWidget(String data) { this(data, Optional.empty()); } public FooWidget(String data, Optional<Bar> bar) { this.data = data; this.bar = bar; } public Optional<Bar> getBar() { return bar; } } \",\"这样，现在你可以清晰地知道 data 肯定不为 null，但是 bar 不清楚是不是存在。Optional 有如 isPresent 这样的方法，可以用来检查是否为 null，感觉和原来的方式并没有太大区别。但是它允许你可以这样写：\",\"final Optional<FooWidget> fooWidget = maybeGetFooWidget(); final Baz baz = fooWidget.flatMap(FooWidget::getBar) .flatMap(BarWidget::getBaz) .orElse(defaultBaz); \",\"这样比写一连串的判断是否为空的检查代码更好。使用 Optional 唯一不好的是标准库对 Optional 的支持并不是很好，所以对 null 的处理仍然是必要的。\"]},\"451\":{\"h\":\"Immutable-by-default\",\"t\":[\"变量，类和集合应该设置为不可变的，除非你有很好的理由去修改他们。\",\"变量可以用 final 关键字使起不可变：\",\"final FooWidget fooWidget; if (condition()) { fooWidget = getWidget(); } else { try { fooWidget = cachedFooWidget.get(); } catch (CachingException e) { log.error(\\\"Couldn't get cached value\\\", e); throw e; } } // fooWidget is guaranteed to be set here \",\"现在你可以确定 fooWidget 对象不会意外地被重新赋值了。final 关键词也可以在 if/else 和 try/catch 代码块中使用。当然，如果 fooWidget 对象本身不是不可变的，你可以很容易去修改它。\",\"使用集合的时候，任何可能的情况下尽量使用 Guava 的 ImmutableMap, ImmutableList, 或者ImmutableSet 类。这些类都有构建器，你可以很容易地动态构建集合，一旦你执行了 build 方法，集合就变成了不可变的。\",\"类应该声明不可变的字段（通过 final 实现）和不可变的集合使该类不可变。或者，可以对类本身使用 final 关键词，这样这个类就不会被继承也不会被修改了。\"]},\"452\":{\"h\":\"Avoid lots of Util classes\",\"t\":[\"如果你发现在你正在往工具类中添加很多方法，就要注意了。\",\"public class MiscUtil { public static String frobnicateString(String base, int times) { // ... etc } public static void throwIfCondition(boolean condition, String msg) { // ... etc } } \",\"乍一看这些工具类似乎很不错，因为里面的那些方法放在别处确实都不太合适。因此，你以可重用代码的名义全放这了。\",\"这个想法比本身这么做还要糟糕。请把这些类放到它应该在的地方去并积极重构。不要命名一些像 \\\"MiscUtils\\\" 或者 \\\"ExtrasLibrary\\\" 这样的很普通的类，包或者库。这会鼓励产生无关代码。\"]},\"453\":{\"h\":\"Formatting\",\"t\":[\"格式化代码对大多数程序员来说并没有它应有的那么重要。统一化你的代码格式对阅读你的代码的人有帮助吗？当然了。但是别在为了 if 代码块匹配添加空格上耗一天。\",\"如果你确实需要一个代码格式风格的教程，我高度推荐 Google's Java Style 这个教程。写的最好的部分是 Programming Practices。绝对值得一读。\"]},\"454\":{\"h\":\"Javadoc\",\"t\":[\"文档对对你代码的阅读着来说也很重要。这意味着你要给出使用示例，并且给出你的变量，方法和类清晰地描述。\",\"这样做的必然结果是不要对不需要写文档的地方填写文档。如果你对一个参数的含义没什么可说的，或者它本身已经很明显是什么意思了，就不要为其写文档了。统一样板的文档比没有文档更加糟糕，这样会让读你代码的人误以为那就是文档。\"]},\"455\":{\"h\":\"Streams\",\"t\":[\"Java 8 有很棒的 stream and lambda 语法。你可以像这样来写代码：\",\"final List<String> filtered = list.stream() .filter(s -> s.startsWith(\\\"s\\\")) .map(s -> s.toUpperCase()) .collect(Collectors.toList()); \",\"取代这样的写法:\",\"final List<String> filtered = new ArrayList<>(); for (String str : list) { if (str.startsWith(\\\"s\\\") { filtered.add(str.toUpperCase()); } } \",\"它让你可以写更多的流畅的代码，并且可读性更高。\"]},\"456\":{\"h\":\"Deploying\",\"t\":[\"Java 的部署问题确实有点棘手。现如今有两种主流的方式：使用框架或者灵活性更高的内部研发的解决方案。\"]},\"457\":{\"h\":\"Frameworks\",\"t\":[\"由于 Java 的部署并不容易，所以使用框架还是很有帮助的。最好的两个框架是 Dropwizard 和 Spring Boot。Play 框架 也可以被看作为一种部署框架。\",\"这些框架都是尽力地降低你部署代码的壁垒。它们对 Java 新手或者想提高效率的人尤有帮助。单独的 JAR 包部署会比复杂的 WAR 包或者 EAR 包部署更简单一点。\",\"然而，这些框架并没有你想象的那么灵活，如果你的项目的开发者选择的框架并不合适，你不得不迁移到手动配置更多的部署方案上来。\"]},\"458\":{\"h\":\"Maven\",\"t\":[\"不错的替代工具: Gradle.\",\"Maven 仍然是构建，打包和测试的标准。有很多不错的替代工具，如 Gradle，但是他们同样都没有像 Maven 那样的适应性。如果你是 Maven 新手，你应该从Maven 实例这里开始。\",\"我喜欢用一个根 POM（Project Object Model，项目对象模型）来管理所有用到的外部依赖。它会像这个样子。这个根 POM 仅仅包含一个外部依赖，但是如果你的产品足够大，你将会有几十个外部依赖了。你的根 POM 应该像其他 Java 项目一样采用版本控制和发布的方式，有一个自己的项目。\",\"如果你认为你的根 POM 每添加一个外部依赖都打上一个标签很麻烦，那你肯定没有遇到过为了排查依赖错误引起的问题，浪费一周的时间翻遍整个项目的情况。\",\"你所有的 Maven 项目都应该包含你的根 POM，以及这些项目的所有版本信息。这样你会清除地了解到你们公司选择的每一个外部依赖的版本，以及所有正确的 Maven 插件。如果你要引入很多的外部依赖，它将会是这样子的：\",\"<dependencies> <dependency> <groupId>org.third.party</groupId> <artifactId>some-artifact</artifactId> </dependency> </dependencies> \",\"如果你想使用内部依赖，它应该被每一个单独项目的 <dependencyManagement>部分来管理。否则那将会很难保持根 POM 的版本号是正常的。\"]},\"459\":{\"h\":\"Dependency Convergence\",\"t\":[\"Java 最好的一方面就是拥有大量的第三方库可以做任何事。基本上每一个 API 或者工具包都有一个 Java SDK，可以很方便的用 Maven 引入。\",\"并且这些第三方 Java 库本身依赖特定版本的其他的库。如果你引入足够多的库，你会发现有些库的版本是冲突的，像这样：\",\"Foo library depends on Bar library v1.0 Widget library depends on Bar library v0.9 \",\"你的项目到底要引入哪一个版本呢？\",\"如果你的项目依赖于不同版本的同一个库，使用 Maven 依赖趋同插件构建时将会报错。然后你有两个方案来解决这个冲突：\",\"在你的 dependencyManagement 部分明确地支出你所使用的 Bar 的版本号\",\"在 FOO 或者 Widget 中排除对 Bar 的依赖。\",\"这两个方案到底选哪一个要看你面对的是什么情况：如果你想跟踪一个项目的版本，那么选择排除的方案是不错的。另一方面，如果你想明确地指出它，你可以选择一个版本，尽管你在需要更新其他依赖的时候也需要更新它。\"]},\"460\":{\"h\":\"Continuous Integration\",\"t\":[\"很明显，你需要某种形式的持续集成服务器来帮你不断构建你的快照版本和基于 git 标签构建。\",\"Jenkins 和 Travis-CI 就成了很自然的选择.\",\"代码覆盖率非常有用，Cobertura 就有 一个很好的 Maven 插件a good Maven plugin 并且支持 CI。还有一些其他的支持 Java 的代码覆盖率工具，但是我只用过 Cobertura。\"]},\"461\":{\"h\":\"Maven repository\",\"t\":[\"你需要一个地方存储你生成的 JAR 包，WAR 包或者 EAR 包，因此，你需要一个仓库。\",\"一般选择有 Artifactory 和 Nexus 这两个。它们都可以用，但是它们都有着各自的优缺点。\",\"你应该有自己的 Artifactory/Nexus 设备和镜像 使你的依赖基于此。这样就不会由于上游的 Maven 库宕机而使你的构建崩溃了。\"]},\"462\":{\"h\":\"Configuration management\",\"t\":[\"现在，你的代码已经编译完了，你的仓库也跑起来了，最终你需要把你的代码从开发环境部署到生产环境了。到了这里，千万不要吝啬，因为将来很长一段时间，你会从这些自动化方式中尝到很多的甜头。\",\"Chef，Puppet，和 Ansible 是很典型的选择。我曾经也写了一个叫 Squadron 的也可供选择，当然，我认为你应该仔细看看这个，因为它使用起来比其他的更为简单方便。\",\"无论你选择了什么工具，不要忘了使你的部署实现自动化。\"]},\"463\":{\"h\":\"Libraries\",\"t\":[\"对 Java 来说，拥有大量的扩展库也许是最大的特点了。下面这些一小部分的扩展库对大部分人来说很适用的。\"]},\"464\":{\"h\":\"Missing Features\",\"t\":[\"Java 标准库曾经作出过惊人的改进，但是现在来看，它仍然缺少一些关键的特性。\"]},\"465\":{\"h\":\"Apache Commons\",\"t\":[\"Apache Commons 项目 拥有大量的有用的扩展库。\",\"Commons Codec 对 Base64 和 16 进制字符串来说有很多有用的编/解码方法。不要再浪费时间重写这些东西了。\",\"Commons Lang 有许多关于字符串的操作和创建，字符集和许多各种各样的实用的方法。\",\"Commons IO 拥有所有你能想到的关于文件操作的方法。有FileUtils.copyDirectory，FileUtils.writeStringToFile，IOUtils.readLines 和更多实用的方法。\"]},\"466\":{\"h\":\"Guava\",\"t\":[\"Guava 是谷歌优秀的对 Java 标准库缺少的特性进行补充的扩展库。虽然这很难提炼总结出我有多喜欢这个库，但是我会尽力的。\",\"Cache 让你可以用很简单的方法，实现把网络访问，磁盘访问，缓存函数或者其他任何你想要缓存的内容，缓存到内存当中。你仅仅只需要实现 CacheBuilder 类并且告诉 Guava 怎么样构建你的缓存，一切就搞定了！\",\"Immutable 集合。它有许多如：ImmutableMap，ImmutableList，或者甚至 ImmutableSortedMultiSet 等不可变集合可以使用，如果你喜欢用这种风格的话。\",\"我也喜欢用 Guava 的方式来写一些可变的集合：\",\"// Instead of final Map<String, Widget> map = new HashMap<>(); // You can use final Map<String, Widget> map = Maps.newHashMap(); \",\"它还有一些静态类如 Lists，Maps和Sets 等。使用起来它们显得更整洁，并且可读性更强。\",\"如果你坚持使用 Java 6 或者 7 的话，你可以使用 Collections2 这个类，它有一些像 filter 和 transform 这样的方法。能够让你没有 Java 8 的 Stream 的支持也能写出流畅的代码。\",\"Guava 也可以做一些很简单的事情，比如 Joiner 类可以用来用分隔符把字符串拼接起来，并且可以用忽略的方式来处理打断程序的数据。\"]},\"467\":{\"h\":\"Gson\",\"t\":[\"谷歌的 Gson 库是一个简单快速的 JSON 解析库。可以这样用：\",\"final Gson gson = new Gson(); final String json = gson.toJson(fooWidget); final FooWidget newFooWidget = gson.fromJson(json, FooWidget.class); \",\"这用起来真的很简单，很愉悦。Gson 用户手册 有很多的使用示例。\"]},\"468\":{\"h\":\"Java Tuples\",\"t\":[\"Java 令我比较烦恼的问题之一 Java 标准库中没有内置对元组的支持。幸运的是，Java tuples 项目解决了这个问题。\",\"它使用用起来很简单，很棒：\",\"Pair<String, Integer> func(String input) { // something... return Pair.with(stringResult, intResult); } \"]},\"469\":{\"h\":\"Javaslang\",\"t\":[\"Javaslang 是一个函数式编程库，它被设计用来弥补本应该出现在 Java 8 中但缺失的一些特性。它有这样的一些特点：\",\"一个全新函数式集合库\",\"紧密集成的元组功能\",\"模式匹配\",\"通过不可变性保证线程安全\",\"饥汉式和懒汉式的数据类型\",\"通过 Option 实现了 null 的安全性\",\"通过 Try 更好的实现异常处理\",\"有一些 Java 库依赖于原始的 Java 集合类。它们通过以面向对象和被设计为可变的方式来保证和其他的类的兼容性。而 Javaslang 的集合的设计灵感来源于 Haskell, Clojure 和 Scala，是一个全新的飞跃。它们被设计为函数式风格并且遵循不可变性的设计风格。\",\"像下面这样的代码就可以自动实现线程安全，并且不用 try-catch 语句处理异常：\",\"// Success/Failure containing the result/exception public static Try<User> getUser(int userId) { return Try.of(() -> DB.findUser(userId)) .recover(x -> Match.of(x) .whenType(RemoteException.class).then(e -> ...) .whenType(SQLException.class).then(e -> ...)); } // Thread-safe, reusable collections public static List<String> sayByeBye() { return List.of(\\\"bye, \\\"bye\\\", \\\"collect\\\", \\\"mania\\\") .map(String::toUpperCase) .intersperse(\\\" \\\"); } \"]},\"470\":{\"h\":\"Joda-Time\",\"t\":[\"Joda-Time 是我用过的最简单的时间处理库。简单，直接，并且很容易测试。夫复何求？\",\"因为 Java 8 已经有了自己的新的 时间处理库， 所以如果你还没有用 Java 8，你需要这一个库足矣。\"]},\"471\":{\"h\":\"Lombok\",\"t\":[\"Lombok 是一个很有意思的库。它可以让你以注解的方式减少 Java 中糟糕的样板代码。\",\"想为你的类的变量添加 setter 和 getter 方法吗？像这样：\",\"public class Foo { @Getter @Setter private int var; } \",\"现在你就可以这么用了：\",\"final Foo foo = new Foo(); foo.setVar(5); \",\"这还有很多例子。我在之前的产品中还没有用过 Lombok，但是现在我等不急了。\"]},\"472\":{\"h\":\"Play framework\",\"t\":[\"好的替代品: Jersey 或者 Spark\",\"在 Java 实现 RESTful web services 有两大主要阵营：JAX-RS 和其他。\",\"JAX-RS 是传统的实现方式。你可以用像 Jersey 这样的框架，以注解的方式来实现接口及其实现的结合。这样你就可以很容易的根据接口类来开发客户端。\",\"Play 框架 基于 JVM 的 web services 实现和其他根本框架不同：它有一个路由文件，你写的类要和路由文件中的路由信息关联起来。Play 框架其实是一个完整的 MVC 框架，但是你可以很简单地仅仅使用它的 REST web services 部分的功能。\",\"它同时支持 Java 和 Scala。虽然对重点支持的 Scala 稍有不足，但是对 Java 的支持还是很好用的。\",\"如果你在 Python 中用过像 Flask 这样的微框架，你对 Spark 肯定会很熟悉。它对 Java 8 的支持尤其的好。\"]},\"473\":{\"h\":\"SLF4J\",\"t\":[\"有很多 Java 日志解决方案。我最喜欢的是 SLF4J，因为它拥有非常棒的可插拔性，同时能够和很多的日志框架想结合。有没有做过同时使用 java.util.logging，JCL，和 log4j 的奇葩项目？SLF4J 就是为你而生。\",\"这两页手册足够你可以开始入门使用 SLF4J 了。\"]},\"474\":{\"h\":\"jOOQ\",\"t\":[\"我不喜欢重量级的 ORM 框架，因为我喜欢 SQL。所以我写了很多 JDBC 模板，但是很难去维护它。jOOQ 是一个更好的解决方案。\",\"它让你在 Java 中用类型安全的方式编写 SQL：\",\"// Typesafely execute the SQL statement directly with jOOQ Result<Record3<String, String, String>> result = create.select(BOOK.TITLE, AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME) .from(BOOK) .join(AUTHOR) .on(BOOK.AUTHOR_ID.equal(AUTHOR.ID)) .where(BOOK.PUBLISHED_IN.equal(1948)) .fetch(); \",\"使用 jOOQ 和 DAO 的模式让你的数据库访问变得轻而易举。\"]},\"475\":{\"h\":\"Testing\",\"t\":[\"测试是软件的关键环节。下面这些软件包能够让你更容易地测试。\"]},\"476\":{\"h\":\"jUnit 4\",\"t\":[\"好的替代品：TestNG.\",\"jUnit 就无需多言了。它是 Java 单元测试中的标准工具。\",\"但是很可能你使用的 jUnit 并没有发挥它的全部潜力。jUnit 支持参数化测试，规则化测试，theories 可以随机测试特定代码，还有 assumptions，可以让你少写很多样板代码。\"]},\"477\":{\"h\":\"jMock\",\"t\":[\"如果你完成了依赖注入，这是它的回报：可以 mock 出有副作用（比如和 REST 服务器交互）的代码，并且可以断言调用这段代码的行为。\",\"jMock 是标准的 Java mock 工具。像这样使用：\",\"public class FooWidgetTest { private Mockery context = new Mockery(); @Test public void basicTest() { final FooWidgetDependency dep = context.mock(FooWidgetDependency.class); context.checking(new Expectations() {{ oneOf(dep).call(with(any(String.class))); atLeast(0).of(dep).optionalCall(); }}); final FooWidget foo = new FooWidget(dep); Assert.assertTrue(foo.doThing()); context.assertIsSatisfied(); } } \",\"这段代码通过 jMock 建立了一个 FooWidgetDependency，然后添加你所期望结果的条件。我们期望 dep 的 call 方法会被以一个字符串为参数的形式调用，并且会被调用 0 次或者多次。\",\"如果你想一遍又一遍地设置相同的依赖，你应该把它放到 test fixture 中，并且把assertIsSatisfied 放在以 @After 注解的 fixture 中。\"]},\"478\":{\"h\":\"AssertJ\",\"t\":[\"你曾经用 jUnit 干过这个吗？\",\"final List<String> result = some.testMethod(); assertEquals(4, result.size()); assertTrue(result.contains(\\\"some result\\\")); assertTrue(result.contains(\\\"some other result\\\")); assertFalse(result.contains(\\\"shouldn't be here\\\")); \",\"这是很恶心的样板代码。AssertJ 可以解决这个问题。你可以把相同的代码转换成这个样子：\",\"assertThat(some.testMethod()).hasSize(4) .contains(\\\"some result\\\", \\\"some other result\\\") .doesNotContain(\\\"shouldn't be here\\\"); \",\"这样的流畅接口让你的测试更具有可读性。你还想咋地？\"]},\"479\":{\"h\":\"Tools\"},\"480\":{\"h\":\"IntelliJ IDEA\",\"t\":[\"好的替代品: Eclipse 和 Netbeans\",\"Java 最好的 IDE 是 IntelliJ IDEA。它有大量的牛逼的特性，它是真正的能让 Java 用来像不戴套做爱那么爽的工具。自动完成功能超棒，代码检查功能也是顶尖的，重构工具那是相当有帮助。\",\"免费的社区版对我来说已经足够好了，但是它的旗舰版加载了更多的牛逼的特性，如数据库工具，Spring 框架的支持和对 Chronon 的支持。\"]},\"481\":{\"h\":\"Chronon\",\"t\":[\"我最喜欢 GDB 7 的特性之一就是调试的时候能够按照时间跟踪回来。当你拥有了旗舰版的 IntelliJ，你可以通过安装 Chronon IntelliJ 插件实现。\",\"你可以获取到变量的变化历史，后退，方法的历史以及更多的信息。如果你是第一次用会觉得有点怪，但是它真的能够帮你解决很复杂的 bug，诸如海森堡类的 bug。\"]},\"482\":{\"h\":\"JRebel\",\"t\":[\"好的替代品: DCEVM\",\"持续集成往往以软件即服务为产品目标。想象一下如果你不用等待代码构建完成而能实时看到代码的变化会是怎样？\",\"这就是 JRebel 所做的。一旦你将你的服务器和你的 JReble 以 hook 方式连接，你就可以从服务器看到实时变化。当你想快速试验的时候它能为你节省大量的时间。\"]},\"483\":{\"h\":\"The Checker Framework\",\"t\":[\"Java 的类型系统很差劲。它不能够区分正常的字符串和正则表达式字符串，更不用说坏点检查了。不过 Checker Framework 可以完成这个功能并且能够实现更多的东西。\",\"它使用像 @Nullable 这样的注解来检查类型。你甚至可以使用自定义注解来实现静态分析，甚至更强大的功能。\"]},\"484\":{\"h\":\"Code Quality\",\"t\":[\"即使遵循着最佳实践的原则，即使是最好的开发者，也都会犯错误。这有很多工具，你可以使用它们验证你的代码从而检查代码是否有问题。下面是选出的最流行的一部分工具。很多这些工具都可以和流行的 IDE 如 Eclipse 或者 IntelliJ 集成，可以让你更快地发现代码中的错误。\",\"Checkstyle：一个静态代码分析工具，它主要着力于保证你的代码符合代码标准。检查规则在一个 XML 文件中定义，你可以把它检入你的版本控制工具，和你的代码放在一起。\",\"FindBugs：主要集中于发现你的代码中可能导致产生 bug 或者错误的部分。虽然作为独立的进程运行，但是对流行的 IDE 和构建工具的支持也很好。\",\"PMD：和 FindBugs 很相似，PMD 着力于发现你代码中的错误和整理的你的代码。你可以把针对你的代码的检查规则控制在 XML 文件中，和你的代码放在一块儿提交。\",\"SonarQube：和前面所述的工具不同，它是在本地运行的，SonarQube 启动一个服务器，你把你代码提交到这个服务器来进行分析。它提供了 web 界面，你可以看到你的代码的健康状况信息，如不好的做法，潜在的 bug，测试覆盖率百分比，和你写代码的技术水平\",\"除了在开发工程中使用这些工具，把它们用在你的构建阶段往往也是一个不错的想法。它可以和想 Maven 或者 Gradle 这样的构建工具绑定到一起，也可以和持续集成工具绑定使用。\"]},\"485\":{\"h\":\"Eclipse Memory Analyzer\",\"t\":[\"即使在 Java 中内存泄露也时有发生。幸运的是，我们有一些工具就是为此而生。Eclipse Memory Analyzer 是我用过的最好用的解决内存泄露问题的工具。它能够获取到堆栈信息让你查阅，去发现问题所在。\",\"有几种方法可以获取到 JVM 进程的堆栈信息，但是我用 jmap 工具实现：\",\"$ jmap -dump:live,format=b,file=heapdump.hprof -F 8152 Attaching to process ID 8152, please wait... Debugger attached successfully. Server compiler detected. JVM version is 23.25-b01 Dumping heap to heapdump.hprof ... ... snip ... Heap dump file created \",\"然后你可以用内存分析器打开 heapdump.hprof 文件，快看看到底是怎么回事。\"]},\"486\":{\"h\":\"Resources\",\"t\":[\"这些资源能够帮你成为 Java 大牛。\"]},\"487\":{\"h\":\"Books\",\"t\":[\"Effective Java\",\"Java Concurrency in Practice\",\"Clean Code\"]},\"488\":{\"h\":\"Podcasts\",\"t\":[\"The Java Posse (discontinued)\",\"vJUG\",\"Les Cast Codeurs (French)\",\"Java Pub House\",\"Java Off Heap\",\"Enterprise Java Newscast\"]},\"489\":{\"h\":\"Videos\",\"t\":[\"Effective Java - Still Effective After All These Years\",\"InfoQ - see especially presentations and interviews\",\"Parleys\"]},\"490\":{\"h\":\"JUC原子类: CAS, Unsafe和原子类详解\"},\"491\":{\"h\":\"JUC集合: BlockingQueue详解\"},\"492\":{\"h\":\"JUC集合: ConcurrentHashMap详解\"},\"493\":{\"h\":\"JUC集合: ConcurrentLinkedQueue详解\"},\"494\":{\"h\":\"JUC集合: CopyOnWriteArrayList详解\"},\"495\":{\"h\":\"JUC线程池: Fork/Join框架详解\"},\"496\":{\"h\":\"JUC线程池: FutureTask详解\"},\"497\":{\"h\":\"JUC线程池: ScheduledThreadPoolExecutor详解\"},\"498\":{\"h\":\"JUC线程池: ThreadPoolExecutor详解\"},\"499\":{\"h\":\"JUC - 类汇总和学习指南\"},\"500\":{\"h\":\"JUC工具类: CountDownLatch详解\"},\"501\":{\"h\":\"JUC工具类: CyclicBarrier详解\"},\"502\":{\"h\":\"JUC工具类: Exchanger详解\"},\"503\":{\"h\":\"JUC工具类: Phaser详解\"},\"504\":{\"h\":\"JUC工具类: Semaphore详解\"},\"505\":{\"h\":\"关键字: final详解\"},\"506\":{\"h\":\"关键字: synchronized详解\"},\"507\":{\"h\":\"关键字: volatile详解\"},\"508\":{\"h\":\"JUC锁: 锁核心类AQS详解\"},\"509\":{\"h\":\"JUC锁: LockSupport详解\"},\"510\":{\"h\":\"JUC锁: ReentrantLock详解\"},\"511\":{\"h\":\"JUC锁: ReentrantReadWriteLock详解\"},\"512\":{\"h\":\"Java并发 - Java中所有的锁\"},\"513\":{\"h\":\"♥Java并发知识体系详解♥\"},\"514\":{\"h\":\"Java 并发 - 理论基础\"},\"515\":{\"h\":\"Java 并发 - 线程基础\"},\"516\":{\"h\":\"Java 并发 - ThreadLocal详解\"},\"517\":{\"h\":\"结构型适配器模式\"},\"518\":{\"h\":\"基本介绍\",\"t\":[\"在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。\",\"在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。\",\"适配器模式（Adapter Pattern）将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器（Wrapper）。\",\"适配器模式属于结构型模式，主要分为三类：类适配器模式、对象适配器模式、接口适配器模式。\",\"主要优点\",\"客户端通过适配器可以透明地调用目标接口\",\"复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类\",\"将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题\",\"在很多业务场景中符合开闭原则\",\"主要缺点\",\"适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性\",\"增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱\"]},\"519\":{\"h\":\"模式的结构\",\"t\":[\"适配器模式（Adapter）包含以下主要角色：\",\"目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口\",\"适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口\",\"适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者\"]},\"520\":{\"h\":\"工作原理\",\"t\":[\"适配器模式：将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容\",\"从用户的角度看不到被适配者，是解耦的\",\"用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法\",\"用户收到反馈结果，感觉只是和目标接口交互，如图\",\"image-20220307113733499\"]},\"521\":{\"h\":\"现实生活中的适配器例子\",\"t\":[\"泰国插座用的是两孔的（欧标），可以买个多功能转换插头 (适配器) ，这样就可以使用了。\",\"image-20220307113604066\"]},\"522\":{\"h\":\"类适配器模式\"},\"523\":{\"h\":\"类适配器模式介绍\",\"t\":[\"基本介绍：Adapter 类，通过继承 被适配类，实现 适配接口，完成被适配类到适配接口的适配。\",\"image-20220314150218744\"]},\"524\":{\"h\":\"类适配器模式应用实例\",\"t\":[\"应用实例说明：以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src（即被适配者），我们的目标是 5V 直流电。\",\"思路分析（类图）：\",\"image-20220307113851301\",\"代码实现\",\"// dst 适配接口（充电器需要 5V） public interface IVoltage5V { public int output5V(); } // 被适配的类（插排的 220V） public class Voltage220V { // 输出 220V 的电压 public int output220V() { int src = 220; System.out.println(\\\"电压=\\\" + src + \\\"伏\\\"); return src; } } // 适配器类（充电器）需要将插排的 220V 转为实际需要的 5V public class VoltageAdapter extends Voltage220V implements IVoltage5V { @Override public int output5V() { // 获取到 220V 电压 int srcV = output220V(); int dstV = srcV / 44 ; // 转成 5v return dstV; } } \",\"手机类和测试类\",\"public class Phone { // 充电 public void charging(IVoltage5V iVoltage5V) { if(iVoltage5V.output5V() == 5) { System.out.println(\\\"电压为5V, 可以充电~~\\\"); } else if (iVoltage5V.output5V() > 5) { System.out.println(\\\"电压大于5V, 不能充电~~\\\"); } } } public class Client { public static void main(String[] args) { System.out.println(\\\" === 类适配器模式 ====\\\"); Phone phone = new Phone(); phone.charging(new VoltageAdapter()); } } \"]},\"525\":{\"h\":\"类适配器模式注意事项和细节\",\"t\":[\"Java 是单继承机制，所以类适配器需要继承 src（被适配类）类这一点算是一个缺点，因为这要求 dst（适配接口） 必须是接口，有一定局限性\",\"src 类的方法在 Adapter 中都会暴露出来，也增加了使用的成本\",\"由于其继承了 src 类，所以它可以根据需求重写 src 类的方法，使得 Adapter 的灵活性增强了\"]},\"526\":{\"h\":\"对象适配器模式\"},\"527\":{\"h\":\"对象适配器模式介绍\",\"t\":[\"基本思路和类的适配器模式相同，只是将 Adapter 类作修改，不是继承 src 类，而是持有 src 类的实例，以解决兼容性的问题。即：持有 src 类，实现 dst 类接口，完成 src 到 dst 的适配。\",\"根据「合成复用原则」，在系统中尽量使用 关联关系（聚合）来替代继承 关系。\",\"对象适配器模式是适配器模式常用的一种。\",\"image-20220314150231277\"]},\"528\":{\"h\":\"对象适配器模式应用实例\",\"t\":[\"应用实例说明\",\"以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们的 dst（即目标）是 5V 直流电，使用对象适配器模式完成。\",\"思路分析（类图）\",\"只需修改适配器即可，如下：\",\"image-20220307153329627\",\"代码实现\",\"// 适配接口（充电器需要 5V） public interface IVoltage5V { public int output5V(); } // 被适配的类（插排的 220V） public class Voltage220V { // 输出 220V 的电压，不变 public int output220V() { int src = 220; System.out.println(\\\"电压=\\\" + src + \\\"伏\\\"); return src; } } // 适配器类（充电器）需要将插排的 220V 转为实际需要的 5V public class VoltageAdapter implements IVoltage5V { private Voltage220V voltage220V; // 关联关系-聚合 // 通过构造器，传入一个 Voltage220V 实例 public VoltageAdapter(Voltage220V voltage220v) { this.voltage220V = voltage220v; } @Override public int output5V() { int dst = 0; if(null != voltage220V) { int src = voltage220V.output220V(); //获取 220V 电压 System.out.println(\\\"使用对象适配器，进行适配~~\\\"); dst = src / 44; System.out.println(\\\"适配完成，输出的电压为=\\\" + dst); } return dst; } } \",\"手机类和测试类\",\"public class Phone { // 充电 public void charging(IVoltage5V iVoltage5V) { if(iVoltage5V.output5V() == 5) { System.out.println(\\\"电压为5V, 可以充电~~\\\"); } else if (iVoltage5V.output5V() > 5) { System.out.println(\\\"电压大于5V, 不能充电~~\\\"); } } } public class Client { public static void main(String[] args) { System.out.println(\\\" === 对象适配器模式 ====\\\"); Phone phone = new Phone(); phone.charging(new VoltageAdapter(new Voltage220V())); } } \"]},\"529\":{\"h\":\"对象适配器模式注意事项和细节\",\"t\":[\"对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合成复用原则，使用组合替代继承，所以它解决了类适配器必须继承 src 的局限性问题，也不再要求 dst 必须是接口\",\"使用成本更低，更灵活\"]},\"530\":{\"h\":\"接口适配器模式\"},\"531\":{\"h\":\"接口适配器模式介绍\",\"t\":[\"一些书籍称为：适配器模式（Default Adapter Pattern）或缺省适配器模式\",\"核心思路：当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求\",\"适用于一个接口不想使用其所有的方法的情况\"]},\"532\":{\"h\":\"接口适配器模式应用实例\",\"t\":[\"Android 中的属性动画 ValueAnimator 类可以通过 addListener(AnimatorListener listener) 方法添加监听器，那么常规写法如下：\",\"ValueAnimator valueAnimator = ValueAnimator.oflnt(0, 100); valueAnimator.addListener(new Animator.AnimatorListener() { @Override public void onAnimationStart(Animator animation) {} @Override public void onAnimationEnd(Animator animation) {} @Override public void onAnimationCancel(Animator animation) {} @Override public void onAnimationRepeat(Animator animation) {} }); valueAnimator.start(); \",\"有时候我们不想实现 Animator.AnimatorListener 接口的全部方法，我们只想监听 onAnimationStart，我们会如下写：\",\"ValueAnimator valueAnimator = ValueAnimator.oflnt(0,100); valueAnimator.addListener(new AnimatorListenerAdapter(){ @Override public void onAnimationStart(Animator animation) { // xxxx 具体实现 } }); valueAnimator.start(; \",\"AnimatorListenerAdapter 类，就是一个接口适配器，代码如下：它空实现了 Animator.AnimatorListener 类(src)的所有方法\",\"public abstract class AnimatorListenerAdapter implements Animator.Animator extends Animator.AnimatorPauseListener { @Override // 默认实现 public void onAnimationCancel(Animator animation) {} @Override public void onAnimationEnd(Animator animation) {} @Override public void onAnimationRepeat(Animator animation) {} @Override public void onAnimationStart(Animator animation) {} @Override public void onAnimationPause(Animator animation) {} @Override public void onAnimationResume(Animator animation) {} } \",\"AnimatorListener 是一个接口：\",\"public static interface AnimatorListener { void onAnimationStart(Animator animation); void onAnimationEnd(Animator animation); void onAnimationCancel(Animator animation); void onAnimationRepeat(Animator animation); } \",\"程序里的匿名内部类就是 Listener 具体实现类\",\"new AnimatorListenerAdapter(){ @Override public void onAnimationStart(Animator animation) { // xxxx 具体实现 } } \",\"案例说明\",\"image-20220307154814117\",\"public interface Interface4 { public void m1(); public void m2(); public void m3(); public void m4(); } // 在 AbsAdapter 我们将 Interface4 的方法进行默认实现 public abstract class AbsAdapter implements Interface4 { // 默认实现 public void m1() { } public void m2() { } public void m3() { } public void m4() { } } \",\"测试类：\",\"public class Client { public static void main(String[] args) { AbsAdapter absAdapter = new AbsAdapter() { // 只需要去覆盖我们 需要使用 接口方法 @Override public void m1() { System.out.println(\\\"使用了m1的方法\\\"); } }; absAdapter.m1(); } } \"]},\"533\":{\"h\":\"SpringMVC 的适配器模式剖析\",\"t\":[\"SpringMVC 中的 HandlerAdapter, 就使用了适配器模式\",\"SpringMVC 处理请求的流程回顾\",\"使用 HandlerAdapter 的原因分析：\",\"可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用 Controller 方法，需要调用的时候就得不断是使用 if-else 来进行判断是哪一种子类然后执行。那么如果后面要扩展 Controller，就得修改原来的代码，这样违背了 OCP 原则。\",\"image-20220307155052736\"]},\"534\":{\"h\":\"适配器模式的注意事项和细节\",\"t\":[\"三种命名方式，是根据 src 是以怎样的形式给到 Adapter（在 Adapter 里的形式）来命名的\",\"类适配器：以类给到，在 Adapter 里，就是将 src 当做类，继承 \",\"对象适配器：以对象给到，在 Adapter 里，将 src 作为一个对象，持有\",\"接口适配器：以接口给到，在 Adapter 里，将 src 作为一个接口，实现\",\"Adapter 模式最大的作用还是将原本不兼容的接口融合在一起工作\",\"实际开发中，实现起来不拘泥于我们讲解的三种经典形式\"]},\"535\":{\"h\":\"适配器模式的应用场景\",\"t\":[\"适配器模式（Adapter）通常适用于以下场景：\",\"以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致\",\"使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同\"]},\"536\":{\"h\":\"结构型桥接模式\"},\"537\":{\"h\":\"桥接模式基本介绍\",\"t\":[\"在现实生活中，某些类具有两个或多个维度的变化，如图形既可按形状分，又可按颜色分。如何设计类似于 Photoshop 这样的软件，能画不同形状和不同颜色的图形呢？如果用继承方式，m 种形状和 n 种颜色的图形就有 m×n 种，不但对应的子类很多，而且扩展困难。\",\"当然，这样的例子还有很多，如不同颜色和字体的文字、不同品牌和功率的汽车、不同性别和职业的男女、支持不同平台和不同文件格式的媒体播放器等。如果用桥接模式就能很好地解决这些问题。\",\"桥接模式（Bridge Pattern）是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变，是一种结构型设计模式。\",\"桥接模式 基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象（Abstraction）与行为实现（Implementation）分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展。\",\"主要优点\",\"抽象与实现分离，扩展能力强\",\"符合开闭原则\",\"符合合成复用原则\",\"其实现细节对客户透明\",\"主要缺点\",\"由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。\"]},\"538\":{\"h\":\"桥接模式的结构与实现\",\"t\":[\"桥接（Bridge）模式包含以下主要角色：\",\"抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用\",\"扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法\",\"实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用\",\"具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现\",\"image-20220314154132216\",\"上面图片桥接模式的代码如下：\",\"// 实现化角色 interface Implementor { public void OperationImpl(); } // 具体实现化角色 class ConcreteImplementorA implements Implementor { public void OperationImpl() { System.out.println(\\\"具体实现化(Concrete Implementor)角色被访问\\\"); } } // 抽象化角色 abstract class Abstraction { protected Implementor imple; protected Abstraction(Implementor imple) { this.imple = imple; } public abstract void Operation(); } // 扩展抽象化角色 class RefinedAbstraction extends Abstraction { protected RefinedAbstraction(Implementor imple) { super(imple); } public void Operation() { System.out.println(\\\"扩展抽象化(Refined Abstraction)角色被访问\\\"); imple.OperationImpl(); } } public class BridgeTest { public static void main(String[] args) { Implementor imple = new ConcreteImplementorA(); Abstraction abs = new RefinedAbstraction(imple); abs.Operation(); } } \"]},\"539\":{\"h\":\"手机操作问题\",\"t\":[\"现在对不同手机类型的不同品牌实现操作编程（比如:开机、关机、上网，打电话等），如图：\",\"image-20220314153744545\"]},\"540\":{\"h\":\"传统方案解决手机操作问题\",\"t\":[\"传统方法对应的类图：\",\"image-20220314153823688\"]},\"541\":{\"h\":\"传统方案解决手机操作问题分析\",\"t\":[\"扩展性问题（类爆炸），如果我们再增加手机的样式（旋转式），就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。\",\"违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本。\",\"解决方案：使用桥接模式。\"]},\"542\":{\"h\":\"桥接模式解决手机操作问题\",\"t\":[\"使用桥接模式改进传统方式，让程序具有搞好的扩展性，利用程序维护。\",\"使用桥接模式对应的类图：\",\"image-20220314154311971\",\"代码示例：\",\"手机品牌代码\",\"// 接口 public interface Brand { void open(); void close(); void call(); } public class Vivo implements Brand { @Override public void open() { System.out.println(\\\" Vivo手机开机 \\\"); } @Override public void close() { System.out.println(\\\" Vivo手机关机 \\\"); } @Override public void call() { System.out.println(\\\" Vivo手机打电话 \\\"); } } public class XiaoMi implements Brand { @Override public void open() { System.out.println(\\\" 小米手机开机 \\\"); } @Override public void close() { System.out.println(\\\" 小米手机关机 \\\"); } @Override public void call() { System.out.println(\\\" 小米手机打电话 \\\"); } } \",\"手机代码\",\"public abstract class Phone { // 组合品牌 private Brand brand; // 构造器 public Phone(Brand brand) { super(); this.brand = brand; } protected void open() { this.brand.open(); } protected void close() { brand.close(); } protected void call() { brand.call(); } } // 折叠式手机类，继承 抽象类 Phone public class FoldedPhone extends Phone { // 构造器 public FoldedPhone(Brand brand) { super(brand); } public void open() { super.open(); System.out.println(\\\" 折叠样式手机 \\\"); } public void close() { super.close(); System.out.println(\\\" 折叠样式手机 \\\"); } public void call() { super.call(); System.out.println(\\\" 折叠样式手机 \\\"); } } // 直立样式手机 public class UpRightPhone extends Phone { // 构造器 public UpRightPhone(Brand brand) { super(brand); } public void open() { super.open(); System.out.println(\\\" 直立样式手机 \\\"); } public void close() { super.close(); System.out.println(\\\" 直立样式手机 \\\"); } public void call() { super.call(); System.out.println(\\\" 直立样式手机 \\\"); } } \",\"测试代码\",\"public class Client { public static void main(String[] args) { // 获取折叠式手机（样式 + 品牌） Phone phone1 = new FoldedPhone(new XiaoMi()); phone1.open(); phone1.call(); phone1.close(); System.out.println(\\\"=======================\\\"); Phone phone2 = new FoldedPhone(new Vivo()); phone2.open(); phone2.call(); phone2.close(); System.out.println(\\\"==============\\\"); UpRightPhone phone3 = new UpRightPhone(new XiaoMi()); phone3.open(); phone3.call(); phone3.close(); System.out.println(\\\"==============\\\"); UpRightPhone phone4 = new UpRightPhone(new Vivo()); phone4.open(); phone4.call(); phone4.close(); } } \"]},\"543\":{\"h\":\"JDBC 的桥接模式剖析\",\"t\":[\"JDBC 的 Driver 接口，如果从桥接模式来看，Driver 就是一个接口，下面可以有 MySQL 的 Driver，Oracle 的 Driver，这些就可以当做实现接口类。\",\"image-20220314154935717\",\"对 jdbc 源码分析的类图：\",\"image-20220314154956046\"]},\"544\":{\"h\":\"桥接模式的注意事项和细节\",\"t\":[\"实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统\",\"对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成\",\"桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本\",\"桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程\",\"桥接模式要求正确识别出系统中两个独立变化的维度（抽象、和实现），因此其使用范围有一定的局限性，即需要有这样的应用场景\"]},\"545\":{\"h\":\"桥接模式的应用场景\",\"t\":[\"当一个类内部具备两种或多种变化维度时，使用桥接模式可以解耦这些变化的维度，使高层代码架构稳定。\",\"对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。\",\"桥接模式通常适用于以下场景：\",\"当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时\",\"当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时\",\"当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时\",\"桥接模式的一个常见使用场景就是 替换掉继承。我们知道，继承拥有很多优点，比如，抽象、封装、多态等，父类封装共性，子类实现特性。继承可以很好的实现代码复用（封装）的功能，但这也是继承的一大缺点。\",\"因为父类拥有的方法，子类也会继承得到，无论子类需不需要，这说明 继承具备强侵入性（父类代码侵入子类），同时会导致子类臃肿。因此，在设计模式中，有一个原则为优先使用组合/聚合，而不是继承。\",\"很多时候，我们分不清该使用继承还是组合/聚合或其他方式等，其实可以从现实语义进行思考。因为软件最终还是提供给现实生活中的人使用的，是服务于人类社会的，软件是具备现实场景的。当我们从纯代码角度无法看清问题时，现实角度可能会提供更加开阔的思路。\"]},\"546\":{\"h\":\"常见的应用场景\",\"t\":[\"JDBC 驱动程序\",\"银行转账系统 \",\"转账分类: 网上转账，柜台转账，AMT 转账\",\"转账用户类型：普通用户，银卡用户，金卡用户\",\"消息管理 \",\"消息类型：即时消息，延时消息\",\"消息分类：手机短信，邮件消息，QQ 消息\"]},\"547\":{\"h\":\"桥接模式模式的扩展\",\"t\":[\"在软件开发中，有时桥接（Bridge）模式可与 适配器模式 联合使用。当桥接（Bridge）模式的实现化角色的接口与现有类的接口不一致时，可以在二者中间定义一个适配器将二者连接起来，其具体结构图如下图所示\",\"image-20220314155454968\"]},\"548\":{\"h\":\"创建型建造者模式\"},\"549\":{\"h\":\"建造者模式基本介绍\",\"t\":[\"在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。例如，计算机是由 CPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等部件组装而成的，采购员不可能自己去组装计算机，而是将计算机的配置要求告诉计算机销售公司，计算机销售公司安排技术人员去组装计算机，然后再交给要买计算机的采购员。\",\"生活中这样的例子很多，如游戏中的不同角色，其性别、个性、能力、脸型、体型、服装、发型等特性都有所差异；还有汽车中的方向盘、发动机、车架、轮胎等部件也多种多样；每封电子邮件的发件人、收件人、主题、内容、附件等内容也各不相同。\",\"以上所有这些产品都是由多个部件构成的，各个部件可以灵活选择，但其创建步骤都大同小异。这类产品的创建无法用前面介绍的工厂模式描述，只有建造者模式可以很好地描述该类产品的创建。\",\"建造者模式（Builder Pattern）又叫 生成器模式，是一种对象 构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。\",\"建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们， 用户不需要知道内部的具体构建细节。\",\"主要优点\",\"封装性好，构建和表示分离\",\"扩展性好，各个具体的建造者相互独立，有利于系统的解耦\",\"客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险\",\"主要缺点\",\"产品的组成部分必须相同，这限制了其使用范围\",\"如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大\",\"建造者（Builder Pattern）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而 工厂方法模式 更注重零部件的创建过程，但两者可以结合使用。\"]},\"550\":{\"h\":\"建造者模式的四个角色\",\"t\":[\"Product（产品角色）：一个具体的产品对象\",\"Builder（抽象建造者）：创建一个 Product 对象的各个部件指定的接口 / 抽象类\",\"ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件\",\"Director（指挥者）：构建一个使用 Builder 接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程\"]},\"551\":{\"h\":\"建造者模式结构图\",\"t\":[\"建造者（Builder）模式的主要角色如下：\",\"产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件\",\"抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()\",\"具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法\",\"指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息\",\"image-20220316221946018\"]},\"552\":{\"h\":\"盖房案例\",\"t\":[\"需要建房子：这一过程为打桩、砌墙、封顶\",\"房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的\"]},\"553\":{\"h\":\"传统方式解决盖房案例\",\"t\":[\"思路分析（图解）\",\"image-20220301194218699\",\"AbstractHouse 类：\",\"public abstract class AbstractHouse { // 打地基 public abstract void buildBasic(); // 砌墙 public abstract void buildWalls(); // 封顶 public abstract void roofed(); public void build() { buildBasic(); buildWalls(); roofed(); } } \",\"CommonHouse 类\",\"public class CommonHouse extends AbstractHouse { @Override public void buildBasic() { System.out.println(\\\" 普通房子打地基 \\\"); } @Override public void buildWalls() { System.out.println(\\\" 普通房子砌墙 \\\"); } @Override public void roofed() { System.out.println(\\\" 普通房子封顶 \\\"); } } \",\"Client 类\",\"public class Client { public static void main(String[] args) { CommonHouse commonHouse = new CommonHouse(); commonHouse.build(); } } \"]},\"554\":{\"h\":\"传统方式的问题分析\",\"t\":[\"优点是比较好理解，简单易操作。\",\"设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好. 也就是说，这种设计方案，把产品（即：房子）和创建产品的过程（即：建房子流程）封装在一起，耦合性增强了。\",\"解决方案：将产品和产品建造的过程解耦：建造者模式。\"]},\"555\":{\"h\":\"建造者模式解决盖房案例\",\"t\":[\"需要建房子：这一过程为打桩、砌墙、封顶。不管是普通房子也好，别墅也好都需要经历这些过程，下面我们使用建造者模式（Builder Pattern）来完成\",\"思路分析图解（类图）\",\"image-20220301195650273\",\"房子 House 类\",\"public class House { private String baise; private String wall; private String roofed; public String getBaise() { return baise; } public void setBaise(String baise) { this.baise = baise; } public String getWall() { return wall; } public void setWall(String wall) { this.wall = wall; } public String getRoofed() { return roofed; } public void setRoofed(String roofed) { this.roofed = roofed; } } \",\"建造者类以及子类：\",\"public abstract class HouseBuilder { protected House house = new House(); // 将建造的流程写好，抽象的方法 public abstract void buildBasic(); public abstract void buildWalls(); public abstract void roofed(); // 建造房子好， 将产品（房子）返回 public House buildHouse() { return house; } } public class CommonHouse extends HouseBuilder { @Override public void buildBasic() { System.out.println(\\\" 普通房子打地基 5 米 \\\"); } @Override public void buildWalls() { System.out.println(\\\" 普通房子砌墙 10cm \\\"); } @Override public void roofed() { System.out.println(\\\" 普通房子屋顶 \\\"); } } public class HighBuilding extends HouseBuilder { @Override public void buildBasic() { System.out.println(\\\" 高楼的打地基 100 米 \\\"); } @Override public void buildWalls() { System.out.println(\\\" 高楼的砌墙 20cm \\\"); } @Override public void roofed() { System.out.println(\\\" 高楼的透明屋顶 \\\"); } } \",\"HouseDirector 类\",\"public class HouseDirector { HouseBuilder houseBuilder = null; // 构造器传入 houseBuilder public HouseDirector(HouseBuilder houseBuilder) { this.houseBuilder = houseBuilder; } // 通过 setter 传入 houseBuilder public void setHouseBuilder(HouseBuilder houseBuilder) { this.houseBuilder = houseBuilder; } // 如何处理建造房子的流程，交给指挥者 public House constructHouse() { houseBuilder.buildBasic(); houseBuilder.buildWalls(); houseBuilder.roofed(); return houseBuilder.buildHouse(); } } \",\"Client 测试类\",\"public class Client { public static void main(String[] args) { // 盖普通房子 CommonHouse commonHouse = new CommonHouse(); // 准备创建房子的指挥者 HouseDirector houseDirector = new HouseDirector(commonHouse); // 完成盖房子，返回产品(普通房子) House house = houseDirector.constructHouse(); // System.out.println(\\\"输出流程\\\"); System.out.println(\\\"--------------------------\\\"); // 盖高楼 HighBuilding highBuilding = new HighBuilding(); // 重置建造者 houseDirector.setHouseBuilder(highBuilding); // 完成盖房子，返回产品(高楼) houseDirector.constructHouse(); } } \"]},\"556\":{\"h\":\"建造者模式的 JDK 应用\",\"t\":[\"java.lang.StringBuilder 使用了建造者模式\",\"image-20220301201855363\",\"源码中建造者模式角色分析：\",\"Appendable 接口定义了多个 append 方法（抽象方法），即 Appendable 为抽象建造者，定义了抽象方法\",\"AbstractStringBuilder 实现了 Appendable 接口方法，这里的 AbstractStringBuilder 已经是建造者，只是不能实例化\",\"StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由 AbstractStringBuilder 完成, 而 StringBuilder 继承了 AbstractStringBuilder\"]},\"557\":{\"h\":\"建造者模式的注意事项和细节\",\"t\":[\"客户端（使用程序）不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象\",\"每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象\",\"可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程\",\"增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合 开闭原则\",\"建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制\",\"如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式\",\"抽象工厂模式 VS 建造者\",\"抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。\"]},\"558\":{\"h\":\"建造者模式的应用场景\",\"t\":[\"建造者模式唯一区别于工厂模式的是针对复杂对象的创建。也就是说，如果创建简单对象，通常都是使用工厂模式进行创建，而如果创建复杂对象，就可以考虑使用建造者模式。\",\"当需要创建的产品具备复杂创建过程时，可以抽取出共性创建过程，然后交由具体实现类自定义创建流程，使得同样的创建行为可以生产出不同的产品，分离了创建与表示，使创建产品的灵活性大大增加。\",\"建造者模式主要适用于以下应用场景：\",\"相同的方法，不同的执行顺序，产生不同的结果\",\"多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同\",\"产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用\",\"初始化一个对象特别复杂，参数多，而且很多参数都具有默认值\"]},\"559\":{\"h\":\"行为型命令模式\"},\"560\":{\"h\":\"命令模式基本介绍\",\"t\":[\"在软件开发系统中，「方法的请求者」与「方法的实现者」之间经常存在紧密的耦合关系，这不利于软件功能的扩展与维护。例如，想对方法进行「撤销、重做、记录」等处理都很不方便，因此「如何将方法的请求者与实现者解耦？」变得很重要，命令模式就能很好地解决这个问题。\",\"命令模式（Command Pattern）：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计。\",\"命名模式使得 请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。\",\"在命名模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求（即命名），同时命令模式也支持可撤销的操作。\",\"通俗易懂的理解：将军发布命令，士兵去执行。其中有几个角色：将军（命令发布者）、士兵（命令的具体执行者）、命令（连接将军和士兵）\",\"Invoker 是调用者（将军），Receiver 是被调用者（士兵），MyCommand 是命令，实现了 Command 接口，持有接收对象\",\"再比如，我们去餐厅吃饭，菜单不是等到客人来了之后才定制的，而是已经预先配置好的。这样，客人来了就只需要点菜，而不是任由客人临时定制。餐厅提供的菜单就相当于把请求和处理进行了解耦，这就是命令模式的体现\",\"主要优点\",\"通过引入中间件（抽象接口）降低系统的耦合度\",\"扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，且满足「开闭原则」\",\"可以实现宏命令。命令模式可以与 组合模式 结合，将多个命令装配成一个组合命令，即宏命令\",\"方便实现 Undo 和 Redo 操作。命令模式可以与 备忘录模式 结合，实现命令的撤销与恢复\",\"可以在现有命令的基础上，增加额外功能。比如日志记录，结合装饰器模式会更加灵活\",\"主要缺点\",\"可能产生大量具体的命令类。因为每一个具体操作都需要设计一个具体命令类，这会增加系统的复杂性\",\"命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），增加了理解上的困难。不过这也是设计模式的通病，抽象必然会额外增加类的数量，代码抽离肯定比代码聚合更加难理解\"]},\"561\":{\"h\":\"命令模式的结构与实现\",\"t\":[\"可以将系统中的相关操作抽象成命令，使调用者与实现者相关分离。\",\"命令模式包含以下主要角色：\",\"抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()\",\"具体命令类（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作\",\"实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者\",\"调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者\",\"结构图如下：\",\"image-20220326120837468\",\"代码实现：\",\"// 抽象命令 interface Command { public abstract void execute(); } // 接收者 class Receiver { public void action() { System.out.println(\\\"接收者的action()方法被调用...\\\"); } } // 具体命令 class ConcreteCommand implements Command { private Receiver receiver; ConcreteCommand() { receiver = new Receiver(); } public void execute() { receiver.action(); } } // 调用者 class Invoker { private Command command; public Invoker(Command command) { this.command = command; } public void setCommand(Command command) { this.command = command; } public void call() { System.out.println(\\\"调用者执行命令command...\\\"); command.execute(); } } public class CommandPattern { public static void main(String[] args) { Command cmd = new ConcreteCommand(); Invoker ir = new Invoker(cmd); System.out.println(\\\"客户访问调用者的call()方法...\\\"); ir.call(); } } \"]},\"562\":{\"h\":\"命令模式解决智能生活项目\",\"t\":[\"我们买了一套智能家电，有照明灯、风扇、冰箱、洗衣机，我们只要在手机上安装 APP 就可以控制对这些家电工作\",\"这些智能家电来自不同的厂家，我们不想针对每一种家电都安装一个 APP，分别控制，我们希望只要一个 APP 就可以控制全部智能家电\",\"要实现一个 APP 控制所有智能家电的需要，则每个智能家电厂家都要提供一个统一的接口给 APP 调用，这时就可以考虑使用 命令模式。\",\"命令模式可将 动作的请求者 从 动作的执行者 对象中解耦出来。\",\"在我们的例子中，动作的请求者是手机 APP，动作的执行者是每个厂商的一个家电产品。\",\"思路分析和类图：\",\"image-20220326121345564\",\"代码实现：\",\"命令类\",\"// 创建命令接口 public interface Command { // 执行动作(操作) public void execute(); // 撤销动作(操作) public void undo(); } // 灯的开启类 public class LightOnCommand implements Command { LightReceiver lightReceiver; public LightOnCommand() { lightReceiver = new LightReceiver(); } @Override public void execute() { lightReceiver.on(); } @Override public void undo() { lightReceiver.off(); } } // 灯的关闭类 public class LightOffCommand implements Command { private LightReceiver lightReceiver; public LightOffCommand() { lightReceiver = new LightReceiver(); } @Override public void execute() { lightReceiver.off(); } @Override public void undo() { lightReceiver.on(); } } // 电视的开机类 public class TVOnCommand implements Command { TVReceiver tvReceiver; public TVOnCommand() { tvReceiver = new TVReceiver(); } @Override public void execute() { tvReceiver.on(); } @Override public void undo() { tvReceiver.off(); } } // 电视的关机类 public class TVOffCommand implements Command { private TVReceiver tvReceiver; public TVOffCommand() { tvReceiver = new TVReceiver(); } @Override public void execute() { tvReceiver.off(); } @Override public void undo() { tvReceiver.on(); } } /** * 没有任何命令，即空执行: 用于初始化每个按钮, 当调用空命令时，对象什么都不做 * 其实，这样是一种设计模式, 可以省掉对空判断 * */ public class NoCommand implements Command { @Override public void execute() { } @Override public void undo() { } } \",\"控制器类\",\"// 灯的遥控器 public class LightReceiver { public void on() { System.out.println(\\\" 电灯打开了.. \\\"); } public void off() { System.out.println(\\\" 电灯关闭了.. \\\"); } } // 电视的遥控器 public class TVReceiver { public void on() { System.out.println(\\\" 电视机打开了.. \\\"); } public void off() { System.out.println(\\\" 电视机关闭了.. \\\"); } } \",\"调用者类\",\"public class RemoteController { // 开按钮的命令数组 Command[] onCommands; Command[] offCommands; // 执行撤销的命令 Command undoCommand; // 构造器，完成对按钮初始化 public RemoteController() { onCommands = new Command[5]; offCommands = new Command[5]; for (int i = 0; i < 5; i++) { onCommands[i] = new NoCommand(); offCommands[i] = new NoCommand(); } } // 给我们的按钮设置你需要的命令 public void setCommand(int no, Command onCommand, Command offCommand) { onCommands[no] = onCommand; offCommands[no] = offCommand; } // 按下开按钮 public void onButtonWasPushed(int no) { // no 0 // 找到你按下的开的按钮， 并调用对应方法 onCommands[no].execute(); // 记录这次的操作，用于撤销 undoCommand = onCommands[no]; } // 按下开按钮 public void offButtonWasPushed(int no) { // no 0 // 找到你按下的关的按钮，并调用对应方法 offCommands[no].execute(); // 记录这次的操作，用于撤销 undoCommand = offCommands[no]; } // 按下撤销按钮 public void undoButtonWasPushed() { undoCommand.undo(); } } \",\"测试类\",\"public class Client { public static void main(String[] args) { // 使用命令设计模式，完成通过遥控器，对电灯的操作 // 创建电灯相关的开关命令 LightOnCommand lightOnCommand = new LightOnCommand(); LightOffCommand lightOffCommand = new LightOffCommand(); // 需要一个遥控器 RemoteController remoteController = new RemoteController(); // 给我们的遥控器设置命令, 比如 no = 0 是电灯的开和关的操作 remoteController.setCommand(0, lightOnCommand, lightOffCommand); System.out.println(\\\"--------按下灯的开按钮-----------\\\"); remoteController.onButtonWasPushed(0); System.out.println(\\\"--------按下灯的关按钮-----------\\\"); remoteController.offButtonWasPushed(0); System.out.println(\\\"--------按下撤销按钮-----------\\\"); remoteController.undoButtonWasPushed(); System.out.println(\\\"=========使用遥控器操作电视机==========\\\"); TVOffCommand tvOffCommand = new TVOffCommand(); TVOnCommand tvOnCommand = new TVOnCommand(); // 给我们的遥控器设置命令, 比如 no = 1 是电视机的开和关的操作 remoteController.setCommand(1, tvOnCommand, tvOffCommand); System.out.println(\\\"--------按下电视机的开按钮-----------\\\"); remoteController.onButtonWasPushed(1); System.out.println(\\\"--------按下电视机的关按钮-----------\\\"); remoteController.offButtonWasPushed(1); System.out.println(\\\"--------按下撤销按钮-----------\\\"); remoteController.undoButtonWasPushed(); } } \"]},\"563\":{\"h\":\"JdbcTemplate 的命令模式分析\",\"t\":[\"Spring 框架的 JdbcTemplate 就使用到了命令模式。\",\"image-20220326122114890\",\"StatementCallback 接口，类似命令接口（Command）\",\"class QueryStatementCallback implements StatementCallback, SqlProvider，是个匿名内部类，实现了命令接口，同时也充当命令接收者\",\"命令调用者是 JdbcTemplate，其中 execute(StatementCallback action) 方法中，调用 action.doInStatement() 方法，不同的实现 StatementCallback 接口的对象，对应不同的 doInStatemnt\",\"另外实现 StatementCallback 命令接口的子类还有 QueryStatementCallback 等，如下图：\",\"image-20220326122132691\"]},\"564\":{\"h\":\"命令模式的注意事项和细节\",\"t\":[\"将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的 execute() 方法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：「请求发起者」和「请求执行者」之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用。\",\"容易设计一个命令队列。只要把命令对象放到列队，就可以多线程的执行命令，容易实现对请求的撤销和重做。\",\"命令模式不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在在使用的时候要注意。\",\"空命令 也是一种设计模式，它为我们省去了判空的操作。在上面的实例中，如果没有用空命令，我们每按下一个按键都要判空，这给我们编码带来一定的麻烦。\"]},\"565\":{\"h\":\"命令模式的应用场景\",\"t\":[\"当系统的某项操作具备命令语义，且命令实现不稳定（变化）时，可以通过命令模式解耦请求与实现。使用抽象命令接口使请求方的代码架构稳定，封装接收方具体命令的实现细节。接收方与抽象命令呈现弱耦合（内部方法无需一致），具备良好的扩展性。\",\"命令模式通常适用于以下场景：\",\"请求调用者需要与请求接收者解耦时，命令模式可以使调用者和接收者不直接交互\",\"系统随机请求命令或经常增加、删除命令时，命令模式可以方便地实现这些功能\",\"当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能\",\"当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现\"]},\"566\":{\"h\":\"结构型组合模式\"},\"567\":{\"h\":\"组合模式基本介绍\",\"t\":[\"在现实生活中，存在很多「部分-整体」的关系，例如，大学中的部门与学院、总公司中的部门与分公司、学习用品中的书与书包、生活用品中的衣服与衣柜、以及厨房中的锅碗瓢盆等。在软件开发中也是这样，例如，文件系统中的文件与文件夹、窗体程序中的简单控件与容器控件等。对这些简单对象与复合对象的处理，如果用组合模式来实现会很方便。\",\"组合模式（Composite Pattern），又叫 部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示「整体-部分」的层次关系，属于结构型模式。\",\"组合模式依据树形结构来组合对象，用来表示部分以及整体层次。\",\"组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象。\",\"主要优点\",\"组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码\",\"更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足「开闭原则」\",\"主要缺点\",\"设计较复杂，客户端需要花更多时间理清类之间的层次关系；\",\"不容易限制容器中的构件\",\"不容易用继承的方法来增加构件的新功能\"]},\"568\":{\"h\":\"组合模式结构与实现\",\"t\":[\"抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。（总的抽象类或接口，定义一些通用的方法，比如新增、删除）\",\"树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于继承或实现抽象构件\",\"树枝构件（Composite）角色 / 中间构件：是组合中的分支节点对象，它有子节点，用于继承和实现抽象构件。它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法\",\"组合模式分为透明式的组合模式和安全式的组合模式。\"]},\"569\":{\"h\":\"透明方式\",\"t\":[\"在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。其结构图如图所示。\",\"image-20220314164535175\"]},\"570\":{\"h\":\"安全方式\",\"t\":[\"在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。其结构图如图所示。\",\"image-20220314170025485\"]},\"571\":{\"h\":\"模式的实现\",\"t\":[\"假如要访问集合 c0={leaf1,{leaf2,leaf3}} 中的元素，其对应的树状图如图所示。\",\"image-20220314170106903\",\"下面为透明式的组合模式的实现代码\",\"// 抽象构件 interface Component { public void add(Component c); public void remove(Component c); public Component getChild(int i); public void operation(); } // 树叶构件 class Leaf implements Component { private String name; public Leaf(String name) { this.name = name; } public void add(Component c) { } public void remove(Component c) { } public Component getChild(int i) { return null; } public void operation() { System.out.println(\\\"树叶\\\" + name + \\\"：被访问！\\\"); } } // 树枝构件 class Composite implements Component { private ArrayList<Component> children = new ArrayList<Component>(); public void add(Component c) { children.add(c); } public void remove(Component c) { children.remove(c); } public Component getChild(int i) { return children.get(i); } public void operation() { for (Object obj : children) { ((Component) obj).operation(); } } } public class CompositePattern { public static void main(String[] args) { Component c0 = new Composite(); Component c1 = new Composite(); Component leaf1 = new Leaf(\\\"1\\\"); Component leaf2 = new Leaf(\\\"2\\\"); Component leaf3 = new Leaf(\\\"3\\\"); c0.add(leaf1); c0.add(c1); c1.add(leaf2); c1.add(leaf3); c0.operation(); } } \",\"下面为安全的组合模式的实现代码\",\"// 抽象构件 interface Component { public void operation(); } // 树叶构件 class Leaf implements Component { private String name; public Leaf(String name) { this.name = name; } public void add(Component c) { } public void remove(Component c) { } public Component getChild(int i) { return null; } public void operation() { System.out.println(\\\"树叶\\\" + name + \\\"：被访问！\\\"); } } // 树枝构件 class Composite implements Component { private ArrayList<Component> children = new ArrayList<Component>(); public void add(Component c) { children.add(c); } public void remove(Component c) { children.remove(c); } public Component getChild(int i) { return children.get(i); } public void operation() { for (Object obj : children) { ((Component) obj).operation(); } } } public class CompositePattern { public static void main(String[] args) { Composite c0 = new Composite(); Composite c1 = new Composite(); Component leaf1 = new Leaf(\\\"1\\\"); Component leaf2 = new Leaf(\\\"2\\\"); Component leaf3 = new Leaf(\\\"3\\\"); c0.add(leaf1); c0.add(c1); c1.add(leaf2); c1.add(leaf3); c0.operation(); } } \"]},\"572\":{\"h\":\"学校院系展示需求\",\"t\":[\"编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。如图：\",\"image-20220314163409100\"]},\"573\":{\"h\":\"传统方案解决学校院系展示\",\"t\":[\"类图：\",\"image-20220314163646797\",\"分析：\",\"将学院看做是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的\",\"实际上我们的要求是：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系， 因此这种方案，不能很好实现的管理的操作，比如对学院、系的添加，删除，遍历等\",\"解决方案：把学校、院、系都看做是组织结构，他们之间没有继承的关系，而是一个树形结构，可以更好的实现管理操作，即使用 组合模式\"]},\"574\":{\"h\":\"组合模式解决学校院系展示\",\"t\":[\"思路分析和图解（类图）\",\"image-20220314164610345\",\"代码示例\",\"公共抽象组件\",\"public abstract class OrganizationComponent { private String name; // 名字 private String des; // 说明 protected void add(OrganizationComponent organizationComponent) { // 默认实现 throw new UnsupportedOperationException(); } protected void remove(OrganizationComponent organizationComponent) { // 默认实现 throw new UnsupportedOperationException(); } // 构造器 public OrganizationComponent(String name, String des) { super(); this.name = name; this.des = des; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDes() { return des; } public void setDes(String des) { this.des = des; } // 方法 print，做成抽象的，子类都需要实现 protected abstract void print(); } \",\"大学类\",\"public class University extends OrganizationComponent { List<OrganizationComponent> organizationComponents = new ArrayList<OrganizationComponent>(); // 构造器 public University(String name, String des) { super(name, des); } // 重写 add @Override protected void add(OrganizationComponent organizationComponent) { organizationComponents.add(organizationComponent); } // 重写 remove @Override protected void remove(OrganizationComponent organizationComponent) { organizationComponents.remove(organizationComponent); } @Override public String getName() { return super.getName(); } @Override public String getDes() { return super.getDes(); } // print 方法，就是输出 University 包含的学院 @Override protected void print() { System.out.println(\\\"--------------\\\" + getName() + \\\"--------------\\\"); // 遍历 organizationComponents for (OrganizationComponent organizationComponent : organizationComponents) { organizationComponent.print(); } } } \",\"学院类\",\"public class College extends OrganizationComponent { // List 中 存放的 Department List<OrganizationComponent> organizationComponents = new ArrayList<OrganizationComponent>(); // 构造器 public College(String name, String des) { super(name, des); } // 重写 add @Override protected void add(OrganizationComponent organizationComponent) { // 将来实际业务中，Colleage 的 add 和 University add 不一定完全一样 organizationComponents.add(organizationComponent); } // 重写remove @Override protected void remove(OrganizationComponent organizationComponent) { organizationComponents.remove(organizationComponent); } @Override public String getName() { return super.getName(); } @Override public String getDes() { return super.getDes(); } // print 方法，就是输出 University 包含的学院 @Override protected void print() { System.out.println(\\\"--------------\\\" + getName() + \\\"--------------\\\"); // 遍历 organizationComponents for (OrganizationComponent organizationComponent : organizationComponents) { organizationComponent.print(); } } } \",\"专业类\",\"public class Department extends OrganizationComponent { //没有集合 public Department(String name, String des) { super(name, des); } //add , remove 就不用写了，因为他是叶子节点 @Override public String getName() { return super.getName(); } @Override public String getDes() { return super.getDes(); } @Override protected void print() { System.out.println(getName()); } } \",\"测试代码\",\"public class Client { public static void main(String[] args) { //从大到小创建对象 学校 OrganizationComponent university = new University(\\\"清华大学\\\", \\\" 中国顶级大学 \\\"); //创建 学院 OrganizationComponent computerCollege = new College(\\\"计算机学院\\\", \\\" 计算机学院 \\\"); OrganizationComponent infoEngineercollege = new College(\\\"信息工程学院\\\", \\\" 信息工程学院 \\\"); //创建各个学院下面的系(专业) computerCollege.add(new Department(\\\"软件工程\\\", \\\" 软件工程不错 \\\")); computerCollege.add(new Department(\\\"网络工程\\\", \\\" 网络工程不错 \\\")); computerCollege.add(new Department(\\\"计算机科学与技术\\\", \\\" 计算机科学与技术是老牌的专业 \\\")); // infoEngineercollege.add(new Department(\\\"通信工程\\\", \\\" 通信工程不好学 \\\")); infoEngineercollege.add(new Department(\\\"信息工程\\\", \\\" 信息工程好学 \\\")); //将学院加入到 学校 university.add(computerCollege); university.add(infoEngineercollege); //university.print(); infoEngineercollege.print(); } } \"]},\"575\":{\"h\":\"JDK 集合的组合模式剖析\",\"t\":[\"Java 的集合类 HashMap 就使用了组合模式。\",\"类图：\",\"image-20220314165737331\"]},\"576\":{\"h\":\"组合模式的注意事项和细节\",\"t\":[\"简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。\",\"具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动。\",\"方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的 树形结构。\",\"需要 遍历组织机构，或者处理的对象具有树形结构时, 非常 适合使用组合模式。\",\"要求较高的抽象性，如果 节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式。\"]},\"577\":{\"h\":\"组合模式的应用场景\",\"t\":[\"前面分析了组合模式的结构与特点，下面分析它适用的以下应用场景。\",\"在需要表示一个对象整体与部分的层次结构的场合\",\"要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合\"]},\"578\":{\"h\":\"结构型装饰者模式\"},\"579\":{\"h\":\"装饰器模式的定义与特点\",\"t\":[\"上班族大多都有睡懒觉的习惯，每天早上上班时间都很紧张，于是很多人为了多睡一会，就会用方便的方式解决早餐问题。有些人早餐可能会吃煎饼，煎饼中可以加鸡蛋，也可以加香肠，但是不管怎么「加码」，都还是一个煎饼。在现实生活中，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等，都是装饰器模式。\",\"在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以釆用装饰器模式来实现。\",\"装饰器模式（Decorator Pattern）的定义：指 在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式，也体现了开闭原则（OCP）。\",\"主要优点\",\"装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用\",\"通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果\",\"装饰器模式完全遵守开闭原则\",\"主要缺点\",\"装饰器模式会增加许多子类，过度使用会增加程序得复杂性。\"]},\"580\":{\"h\":\"装饰器模式的结构与实现\",\"t\":[\"通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰器模式的目标。下面来分析其基本结构和实现方法。\",\"装饰器模式主要包含以下角色：\",\"抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象\",\"具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责\",\"抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能\",\"具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任\",\"装饰器模式的结构图如图所示：\",\"image-20220314162328427\",\"代码实现：\",\"// 抽象构件角色 interface Component { public void operation(); } // 具体构件角色 class ConcreteComponent implements Component { public ConcreteComponent() { System.out.println(\\\"创建具体构件角色\\\"); } public void operation() { System.out.println(\\\"调用具体构件角色的方法 operation()\\\"); } } // 抽象装饰角色 class Decorator implements Component { private Component component; public Decorator(Component component) { this.component = component; } public void operation() { component.operation(); } } // 具体装饰角色 class ConcreteDecorator extends Decorator { public ConcreteDecorator(Component component) { super(component); } public void operation() { super.operation(); addedFunction(); } public void addedFunction() { System.out.println(\\\"为具体构件角色增加额外的功能addedFunction()\\\"); } } public class DecoratorPattern { public static void main(String[] args) { Component p = new ConcreteComponent(); p.operation(); System.out.println(\\\"---------------------------------\\\"); Component d = new ConcreteDecorator(p); d.operation(); } } \"]},\"581\":{\"h\":\"星巴克咖啡订单项目\",\"t\":[\"咖啡种类/单品咖啡：Espresso（意大利浓咖啡）、ShortBlack、LongBlack（美式咖啡）、Decaf（无因咖啡）\",\"调料：Milk、Soy（豆浆）、Chocolate\",\"要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便\",\"使用 OO 的来计算不同种类咖啡的费用: 客户可以点单品咖啡，也可以单品咖啡 + 调料组合\"]},\"582\":{\"h\":\"方案 1（较差）\",\"t\":[\"类图\",\"image-20220314160422590\",\"Drink 是一个抽象类，表示饮料\",\"des 就是对咖啡的描述，比如咖啡的名字\",\"cost() 方法就是计算费用，Drink 类中做成一个抽象方法\",\"Decaf 就是单品咖啡，继承 Drink, 并实现 cost 方法\",\"Espress 和 Milk 就是单品咖啡 + 调料，这个组合很多\",\"问题：这样设计，会有很多类，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增，就会出现 类爆炸。\"]},\"583\":{\"h\":\"方案 2（较好）\",\"t\":[\"前面分析到方案 1 因为咖啡单品 + 调料组合会造成类的倍增，因此可以做改进，将调料内置到 Drink 类，这样就不会造成类数量过多。从而提高项目的维护性，如图\",\"image-20220314160744377\",\"milk、soy、chocolate 可以设计为 Boolean，表示是否要添加相应的调料。\",\"方案 2 可以控制类的数量，不至于造成很多的类\",\"在增加或者删除调料种类时，代码的维护量很大\",\"考虑到用户可以添加多份调料时，可以将 hasMilk 返回一个对应 int\",\"考虑使用 装饰者模式\"]},\"584\":{\"h\":\"装饰者模式解决订单项目\",\"t\":[\"image-20220314161222580\",\"订单分析图：\",\"image-20220314161323609\",\"代码示例\",\"public abstract class Drink { public String des; // 描述 private float price = 0.0f; public String getDes() { return des; } public void setDes(String des) { this.des = des; } public float getPrice() { return price; } public void setPrice(float price) { this.price = price; } // 计算费用的抽象方法 // 子类来实现 public abstract float cost(); } \",\"咖啡代码：\",\"public class Coffee extends Drink { @Override public float cost() { return super.getPrice(); } } public class DeCaf extends Coffee { public DeCaf() { setDes(\\\" 无因咖啡 \\\"); setPrice(1.0f); } } public class Espresso extends Coffee { public Espresso() { setDes(\\\" 意大利咖啡 \\\"); setPrice(6.0f); } } public class LongBlack extends Coffee { public LongBlack() { setDes(\\\" longblack \\\"); setPrice(5.0f); } } public class ShortBlack extends Coffee{ public ShortBlack() { setDes(\\\" shortblack \\\"); setPrice(4.0f); } } \",\"装饰者代码\",\"public class Decorator extends Drink { private Drink obj; public Decorator(Drink obj) { // 组合 this.obj = obj; } @Override public float cost() { // getPrice 自己价格 return super.getPrice() + obj.cost(); } @Override public String getDes() { // obj.getDes() 输出被装饰者的信息 return des + \\\" \\\" + getPrice() + \\\" && \\\" + obj.getDes(); } } public class Chocolate extends Decorator { public Chocolate(Drink obj) { super(obj); setDes(\\\" 巧克力 \\\"); setPrice(3.0f); // 调味品的价格 } } public class Soy extends Decorator{ public Soy(Drink obj) { super(obj); setDes(\\\" 豆浆 \\\"); setPrice(1.5f); } } public class Milk extends Decorator { public Milk(Drink obj) { super(obj); setDes(\\\" 牛奶 \\\"); setPrice(2.0f); } } \",\"测试代码\",\"public class CoffeeBar { public static void main(String[] args) { // 装饰者模式下的订单：2 份巧克力 + 一份牛奶的 LongBlack // 1. 点一份 LongBlack Drink order = new LongBlack(); System.out.println(\\\"费用1=\\\" + order.cost()); System.out.println(\\\"描述=\\\" + order.getDes()); // 2. order 加入一份牛奶 order = new Milk(order); System.out.println(\\\"order 加入一份牛奶 费用 =\\\" + order.cost()); System.out.println(\\\"order 加入一份牛奶 描述 = \\\" + order.getDes()); // 3. order 加入一份巧克力 order = new Chocolate(order); System.out.println(\\\"order 加入一份牛奶 加入一份巧克力 费用 =\\\" + order.cost()); System.out.println(\\\"order 加入一份牛奶 加入一份巧克力 描述 = \\\" + order.getDes()); // 4. order 加入两份巧克力 order = new Chocolate(order); System.out.println(\\\"order 加入一份牛奶 加入2份巧克力 费用 =\\\" + order.cost()); System.out.println(\\\"order 加入一份牛奶 加入2份巧克力 描述 = \\\" + order.getDes()); System.out.println(\\\"===========================\\\"); Drink order2 = new DeCaf(); System.out.println(\\\"order2 无因咖啡 费用 =\\\" + order2.cost()); System.out.println(\\\"order2 无因咖啡 描述 = \\\" + order2.getDes()); order2 = new Milk(order2); System.out.println(\\\"order2 无因咖啡 加入一份牛奶 费用 =\\\" + order2.cost()); System.out.println(\\\"order2 无因咖啡 加入一份牛奶 描述 = \\\" + order2.getDes()); } } \"]},\"585\":{\"h\":\"JDK IO 的装饰者模式剖析\",\"t\":[\"Java 的 IO 结构，FilterInputStream 就是一个装饰者。\",\"image-20220314162102077\",\"InputStream 是抽象类, 类似我们前面讲的 Drink\",\"FileInputStream 是 InputStream 子类，类似我们前面的 DeCaf、LongBlack\",\"FilterInputStream 是 InputStream 子类：类似我们前面的 Decorator 修饰者\",\"DataInputStream 是 FilterInputStream 子类，具体的修饰者，类似前面的 Milk、Soy 等\",\"FilterInputStream 类有 protected volatile InputStream in; 即含被装饰者\",\"分析得出在 JDK 的 IO 体系中，就是使用装饰者模式。\"]},\"586\":{\"h\":\"装饰器模式的应用场景\",\"t\":[\"装饰器模式通常在以下几种情况使用。\",\"当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类\",\"当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰器模式却很好实现\",\"当对象的功能要求可以动态地添加，也可以再动态地撤销时\",\"装饰器模式最著名的应用莫过于 Java I/O 标准库的设计了（上面已经介绍）。例如，InputStream 的子类 FilterInputStream，OutputStream 的子类 FilterOutputStream，Reader 的子类 BufferedReader 以及 FilterReader，还有 Writer 的子类 BufferedWriter、FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。\"]},\"587\":{\"h\":\"设计模式总结\"},\"588\":{\"h\":\"总结\",\"t\":[\"23 种设计模式表格总结：\"]},\"589\":{\"h\":\"创建型设计模式\",\"t\":[\"简单来说就是用来创建对象的\",\"设计模式\",\"分类\",\"简述\",\"一句话归纳\",\"目的\",\"生活案例\",\"工厂模式（Factory Pattern）\",\"不同条件下创建不同实例\",\"工厂生产物品\",\"产品标准化，生产更高效\",\"封装创建细节\",\"实体工厂\",\"单例模式（Singleton Pattern）\",\"保证一个类仅有一个实例，并且提供一个全局访问点\",\"世上只有一个我\",\"保证独一无二\",\"CEO\",\"原型模式（Prototype Pattern）\",\"通过拷贝原型创建新的对象\",\"拔一根猴毛，吹出千万个\",\"高效创建对象\",\"克隆\",\"建造者模式（Builder Pattern）\",\"用来创建复杂的复合对象\",\"高配中配和低配，想选哪配就哪配\",\"开放个性配置步骤\",\"选配\"]},\"590\":{\"h\":\"结构型设计模式\",\"t\":[\"关注类和对象的组合\",\"设计模式\",\"分类\",\"简述\",\"一句话归纳\",\"目的\",\"生活案例\",\"代理模式（Proxy Pattern）\",\"为其他对象提供一种代理以控制对这个对象的访问\",\"没有资源没时间，得找别人来帮忙\",\"没有资源没时间，得找别人来帮忙\",\"增强职责\",\"媒婆\",\"外观模式（Facade Pattern）\",\"对外提供一个统一的接口用来访问子系统\",\"打开一扇门，通向全世界\",\"统一访问入口\",\"前台\",\"装饰器模式（Decorator Pattern）\",\"为对象添加新功能\",\"他大舅他二舅都是他舅\",\"灵活扩展、同宗同源\",\"煎饼\",\"享元模式（Flyweight Pattern）\",\"使用对象池来减少重复对象的创建\",\"优化资源配置，减少重复浪费\",\"共享资源池\",\"全国社保联网\",\"组合模式（Composite Pattern）\",\"将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理\",\"人在一起叫团伙，心在一起叫团队\",\"统一整体和个体\",\"组织架构树\",\"适配器模式（Adapter Pattern）\",\"将原来不兼容的两个类融合在一起\",\"万能充电器\",\"兼容转换\",\"电源适配\",\"桥接模式（Bridge Pattern）\",\"将两个能够独立变化的部分分离开来\",\"约定优于配置\",\"不允许用继承\",\"桥\"]},\"591\":{\"h\":\"行为型设计模式\",\"t\":[\"关注对象之间的通信\",\"设计模式\",\"分类\",\"简述\",\"一句话归纳\",\"目的\",\"生活案例\",\"模板模式（Template Pattern）\",\"定义一套流程模板，根据需要实现模板中的操作\",\"流程全部标准化，需要微调请覆盖\",\"流程全部标准化，需要微调请覆盖\",\"逻辑复用\",\"把大象装进冰箱\",\"策略模式（Strategy Pattern）\",\"封装不同的算法，算法之间能互相替换\",\"条条大道通罗马，具体哪条你来定\",\"把选择权交给用户\",\"选择支付方式\",\"责任链模式（Chain of Responsibility Pattern）\",\"拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。\",\"各人自扫门前雪，莫管他们瓦上霜\",\"解耦处理逻辑\",\"踢皮球\",\"迭代器模式（Iterator Pattern）\",\"提供一种方法顺序访问一个聚合对象中的各个元素\",\"流水线上坐一天，每个包裹扫一遍\",\"统一对集合的访问方式\",\"逐个检票进站\",\"命令模式（Command Pattern）\",\"将请求封装成命令，并记录下来，能够撤销与重做\",\"运筹帷幄之中，决胜千里之外\",\"解耦请求和处理\",\"遥控器\",\"状态模式（State Pattern）\",\"根据不同的状态做出不同的行为\",\"状态驱动行为，行为决定状态\",\"绑定状态和行为\",\"订单状态跟踪\",\"备忘录模式（Memento Pattern）\",\"保存对象的状态，在需要时进行恢复\",\"失足不成千古恨，想重来时就重来\",\"备份、后悔机制\",\"草稿箱\",\"中介者模式（Mediator Pattern）\",\"将对象之间的通信关联关系封装到一个中介类中单独处理，从而使其耦合松散\",\"联系方式我给你，怎么搞定我不管\",\"统一管理网状资源\",\"朋友圈\",\"解释器模式（Interpreter Pattern）\",\"给定一个语言，定义它的语法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子\",\"我想说「方言」，一切解释权都归我\",\"实现特定语法解析\",\"摩斯密码\",\"观察者模式（Observer Pattern）\",\"状态发生改变时通知观察者，一对多的关系\",\"到点就通知我\",\"解耦观察者与被观察者\",\"闹钟\",\"访问者模式（Visitor Pattern）\",\"稳定数据结构，定义新的操作行为\",\"横看成岭侧成峰，远近高低各不同\",\"解耦数据结构和数据操作\",\"KPI考核\",\"委派模式（Delegate Pattern）\",\"允许对象组合实现与继承相同的代码重用，负责任务的调用和分配\",\"允许对象组合实现与继承相同的代码重用，负责任务的调用和分配\",\"这个需求很简单，怎么实现我不管\",\"只对结果负责\",\"授权委托书\",\"来自：http://c.biancheng.net/view/8462.html。\"]},\"592\":{\"h\":\"结构型外观模式\"},\"593\":{\"h\":\"外观模式基本介绍\",\"t\":[\"现实生活中，常常存在办事较复杂的例子，如办房产证或注册一家公司，有时要同多个部门联系，这时要是有一个综合部门能解决一切手续问题就好了。\",\"软件设计也是这样，当一个系统的功能越来越强，子系统会越来越多，客户对系统的访问也变得越来越复杂。这时如果系统内部发生改变，客户端也要跟着改变，这违背了「开闭原则」，也违背了「迪米特法则」，所以有必要为多个子系统提供一个统一的接口，从而降低系统的耦合度，这就是外观模式的目标。\",\"外观模式（Facade Pattern），也叫 过程模式、门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。\",\"在日常编码工作中，我们都在有意无意的大量使用外观模式。只要是高层模块需要调度多个子系统（2个以上的类对象），我们都会自觉地创建一个新的类封装这些子系统，提供精简的接口，让高层模块可以更加容易地间接调用这些子系统的功能。尤其是现阶段各种第三方SDK、开源类库，很大概率都会使用外观模式。\",\"外观（Facade）模式是 迪米特法则 的典型应用。\",\"主要优点\",\"降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类\",\"对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易\",\"降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象\",\"主要缺点\",\"不能很好地限制客户使用子系统类，很容易带来未知风险\",\"增加新的子系统可能需要修改外观类或客户端的源代码，违背了 开闭原则\"]},\"594\":{\"h\":\"外观模式的结构与实现\",\"t\":[\"外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。现在来分析其基本结构和实现方法。\"]},\"595\":{\"h\":\"模式的结构\",\"t\":[\"外观（Facade）模式包含以下主要角色：\",\"外观（Facade）角色：为多个子系统对外提供一个共同的接口\",\"子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它\",\"客户（Client）角色：通过一个外观角色访问各个子系统的功能\",\"image-20220314175538719\"]},\"596\":{\"h\":\"模式的实现\",\"t\":[\"// 子系统角色 class SubSystem01 { public void method1() { System.out.println(\\\"子系统01的method1()被调用！\\\"); } } // 子系统角色 class SubSystem02 { public void method2() { System.out.println(\\\"子系统02的method2()被调用！\\\"); } } // 子系统角色 class SubSystem03 { public void method3() { System.out.println(\\\"子系统03的method3()被调用！\\\"); } } // 外观角色 class Facade { private SubSystem01 obj1 = new SubSystem01(); private SubSystem02 obj2 = new SubSystem02(); private SubSystem03 obj3 = new SubSystem03(); public void method() { obj1.method1(); obj2.method2(); obj3.method3(); } } // 客户角色 public class FacadePattern { public static void main(String[] args) { Facade f = new Facade(); f.method(); } } \"]},\"597\":{\"h\":\"影院管理项目\",\"t\":[\"组建一个家庭影院：DVD 播放器、投影仪、自动屏幕、环绕立体声、爆米花机，灯光。\",\"过程：开爆米花机、开爆米花机、开投影仪、开音响、开 DVD、选 DVD、去拿爆米花、调暗灯光、播放、观影结束后，关闭各种设备。\"]},\"598\":{\"h\":\"传统方式解决影院管理\"},\"599\":{\"h\":\"传统方式解决问题图\",\"t\":[\"image-20220314175108493\"]},\"600\":{\"h\":\"传统方式解决问题分析\",\"t\":[\"在 ClientTest 的 main 方法中，创建各个子系统的对象，并直接去调用子系统(对象)相关方法，会造成调用过程混乱，没有清晰的过程，不利于在 ClientTest 中，去维护对子系统的操作\",\"解决思路：定义一个高层接口，给子系统中的一组接口提供一个一致的界面（比如在高层接口提供四个方法 ready, play, pause, end），用来访问子系统中的一群接口。\",\"也就是说就是通过定义一个一致的接口（界面类），用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节，即使用 外观模式。\"]},\"601\":{\"h\":\"外观模式解决影院管理\",\"t\":[\"外观模式可以理解为转换一群接口，客户只要调用一个接口，而不用调用多个接口才能达到目的。比如：在 PC 上安装软件的时候经常有一键安装选项（省去选择安装目录、安装的组件等等），还有就是手机的重启功能（把关机和启动合为一个操作）。\",\"外观模式就是解决多个复杂接口带来的使用困难，起到简化用户操作的作用。\",\"示意图：\",\"image-20220314175728964\",\"影院管理项目类图：\",\"image-20220314175754422\",\"代码示例：\",\"影院的 DVD 播放器、投影仪、自动屏幕、环绕立体声、爆米花机、灯光类\",\"// DVD 播放器 public class DVDPlayer { // 使用单例模式, 使用饿汉式 private static DVDPlayer instance = new DVDPlayer(); public static DVDPlayer getInstanc() { return instance; } public void on() { System.out.println(\\\" dvd on \\\"); } public void off() { System.out.println(\\\" dvd off \\\"); } public void play() { System.out.println(\\\" dvd is playing \\\"); } // .... public void pause() { System.out.println(\\\" dvd pause ..\\\"); } } // 投影仪 public class Projector { private static Projector instance = new Projector(); public static Projector getInstance() { return instance; } public void on() { System.out.println(\\\" Projector on \\\"); } public void off() { System.out.println(\\\" Projector ff \\\"); } public void focus() { System.out.println(\\\" Projector is Projector \\\"); } //... } // 自动屏幕 public class Screen { private static Screen instance = new Screen(); public static Screen getInstance() { return instance; } public void up() { System.out.println(\\\" Screen up \\\"); } public void down() { System.out.println(\\\" Screen down \\\"); } } // 爆米花机 public class Popcorn { private static Popcorn instance = new Popcorn(); public static Popcorn getInstance() { return instance; } public void on() { System.out.println(\\\" popcorn on \\\"); } public void off() { System.out.println(\\\" popcorn ff \\\"); } public void pop() { System.out.println(\\\" popcorn is poping \\\"); } } // 环绕立体声 public class Stereo { private static Stereo instance = new Stereo(); public static Stereo getInstance() { return instance; } public void on() { System.out.println(\\\" Stereo on \\\"); } public void off() { System.out.println(\\\" Screen off \\\"); } public void up() { System.out.println(\\\" Screen up.. \\\"); } //... } // 灯光 public class TheaterLight { private static TheaterLight instance = new TheaterLight(); public static TheaterLight getInstance() { return instance; } public void on() { System.out.println(\\\" TheaterLight on \\\"); } public void off() { System.out.println(\\\" TheaterLight off \\\"); } public void dim() { System.out.println(\\\" TheaterLight dim.. \\\"); } public void bright() { System.out.println(\\\" TheaterLight bright.. \\\"); } } \",\"每一步的过程类\",\"public class HomeTheaterFacade { // 定义各个子系统对象 private TheaterLight theaterLight; private Popcorn popcorn; private Stereo stereo; private Projector projector; private Screen screen; private DVDPlayer dVDPlayer; // 构造器 public HomeTheaterFacade() { super(); this.theaterLight = TheaterLight.getInstance(); this.popcorn = Popcorn.getInstance(); this.stereo = Stereo.getInstance(); this.projector = Projector.getInstance(); this.screen = Screen.getInstance(); this.dVDPlayer = DVDPlayer.getInstanc(); } // 操作分成 4 步 public void ready() { popcorn.on(); popcorn.pop(); screen.down(); projector.on(); stereo.on(); dVDPlayer.on(); theaterLight.dim(); } public void play() { dVDPlayer.play(); } public void pause() { dVDPlayer.pause(); } public void end() { popcorn.off(); theaterLight.bright(); screen.up(); projector.off(); stereo.off(); dVDPlayer.off(); } } \",\"测试类：\",\"public class Client { public static void main(String[] args) { HomeTheaterFacade homeTheaterFacade = new HomeTheaterFacade(); homeTheaterFacade.ready(); homeTheaterFacade.play(); homeTheaterFacade.end(); } } \"]},\"602\":{\"h\":\"MyBatis 框架的外观模式剖析\",\"t\":[\"MyBatis 中的 Configuration 去创建 MetaObject 对象使用到外观模式。\",\"image-20220314180358602\",\"对源码中使用到的外观模式的角色类图\",\"image-20220314180442486\"]},\"603\":{\"h\":\"外观模式的注意事项和细节\",\"t\":[\"外观模式 对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性\",\"外观模式对客户端与子系统的耦合关系：解耦，让子系统内部的模块更易维护和扩展\",\"通过合理的使用外观模式，可以帮我们更好的 划分访问的层次\",\"当系统需要进行分层设计时，可以考虑使用 Facade 模式\",\"在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个 Facade 类，来提供遗留系统的比较清晰简单的接口，让新系统与 Facade 类交互，提高复用性\",\"不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的\"]},\"604\":{\"h\":\"外观模式的应用场景\",\"t\":[\"通常在以下情况下可以考虑使用外观模式：\",\"对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系\",\"当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问\",\"当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性\"]},\"605\":{\"h\":\"创建型工厂模式\"},\"606\":{\"h\":\"工厂模式概述\",\"t\":[\"工厂模式很重要，后面的很多架构设计，都是工厂模式联合着其它设计模式使用。\",\"一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在 GOF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，在今天的讲解中，我们沿用第一种分类方法。\",\"在这三种细分的工厂模式中，简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。\",\"除此之外，本内容讲解的重点也不是原理和实现，因为这些都很简单，重点还是要搞清楚应用场景：什么时候该用工厂模式？相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处呢？\",\"简单工厂模式\",\"用来生产同一等级结构中的任意产品（对于增加新的产品，需要覆盖已有代码）\",\"工厂方法模式\",\"用来生产同一等级结构中的固定产品（支持增加任意产品）\",\"抽象工厂模式\",\"围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂\"]},\"607\":{\"h\":\"简单工厂（Simple Factory）\"},\"608\":{\"h\":\"简单工厂模式基本介绍\",\"t\":[\"简单工厂模式是属于 创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是 工厂模式家族 中最简单实用的模式。\",\"简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码）。\",\"在简单工厂模式中创建实例的方法通常为静态（static）方法，因此 简单工厂模式（Simple Factory Pattern）又叫作 静态工厂方法模式（Static Factory Method Pattern）。\",\"在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。\",\"主要优点\",\"工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确\",\"客户端无需知道所创建具体产品的类名，只需知道参数即可\",\"也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类\",\"主要缺点\",\"简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则\",\"使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度\",\"系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂\",\"简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构\",\"主要角色\",\"简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象\",\"抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口\",\"具体产品（ConcreteProduct）：是简单工厂模式的创建目标\",\"结构图\",\"image-20220326223625612\"]},\"609\":{\"h\":\"传统方式完成披萨案例\",\"t\":[\"看一个披萨的项目：要便于披萨种类的扩展，要便于维护\",\"披萨的种类很多（比如 GreekPizz、CheesePizz 等）\",\"披萨的制作有 prepare，bake, cut, box\",\"完成披萨店订购功能\",\"思路分析（类图）\",\"image-20220227134528102\",\"编写制作披萨的过程类 Pizza.java\",\"public abstract class Pizza { protected String name; // 名字 // 准备原材料, 不同的披萨不一样，因此，我们做成抽象方法 public abstract void prepare(); // 省略 setter、getter 方法 } class CheesePizza extends Pizza { @Override public void prepare() { System.out.println(\\\" 给制作奶酪披萨 准备原材料 \\\"); } } class GreekPizza extends Pizza { @Override public void prepare() { System.out.println(\\\" 给希腊披萨 准备原材料 \\\"); } } \",\"编写 OrderPizza.java 去订购需要的各种披萨\",\"public class OrderPizza { public static void main(String[] args) { CheesePizza cheesePizza = new CheesePizza(); GreekPizza greekPizza = new GreekPizza(); System.out.println(cheesePizza.getName); System.out.println(greekPizza.getName); } } \",\"需要什么类型的披萨，new 出该对象。\",\"传统的方式的优缺点\",\"优点是比较好理解，简单易操作\",\"缺点是依赖性太强，不应该直接去 new 一个类\",\"改进的思路分析\",\"分析：修改代码可以接受，但是如果我们在其它的地方也有创建 Pizza 的代码，就意味着，也需要修改，而创建 Pizza 的代码，往往有多处。\",\"思路：把创建 Pizza 对象封装到一个类中，这样我们有新的 Pizza 种类时，只需要修改该类就可，其它有创建到 Pizza 对象的代码就不需要修改了，即 简单工厂模式。\"]},\"610\":{\"h\":\"简单工厂模式完成案例\",\"t\":[\"简单工厂模式的设计方案: 定义一个可以实例化 Pizaa 对象的类，封装创建对象的代码。\",\"image-20220227140036784\",\"Pizza 类代码保持不变（上面有）。\",\"简单工厂模式代码：\",\"public class SimpleFactory { // 方法一：if-else，缺点，违反了 OCP 原则 public Pizza createPizza(String orderType) { Pizza pizza = null; System.out.println(\\\"使用简单工厂模式\\\"); if (orderType.equals(\\\"greek\\\")) { pizza = new GreekPizza(); pizza.setName(\\\" 希腊披萨 \\\"); } else if (orderType.equals(\\\"cheese\\\")) { pizza = new CheesePizza(); pizza.setName(\\\" 奶酪披萨 \\\"); } return pizza; } // 方法二：利用方法代替 if-else，虽然也违反了 OCP 原则，但是为了迎合 OCP 原则，会花费大量的代价 public Pizza getGreekPizza() { Pizza pizza = new GreekPizza(); pizza.setName(\\\" 希腊披萨 \\\"); return pizza; } public Pizza getCheesePizza() { Pizza pizza = new CheesePizza(); pizza.setName(\\\" 奶酪披萨 \\\"); return pizza; } // 简单工厂模式 也叫 静态工厂模式（全部替换成 static 即可） public static Pizza createPizza2(String orderType) { Pizza pizza = null; System.out.println(\\\"使用简单工厂模式2\\\"); if (orderType.equals(\\\"greek\\\")) { pizza = new GreekPizza(); pizza.setName(\\\" 希腊披萨 \\\"); } else if (orderType.equals(\\\"cheese\\\")) { pizza = new CheesePizza(); pizza.setName(\\\" 奶酪披萨 \\\"); } return pizza; } } \",\"此时的 OrderPizza.java 文件也要修改：\",\"public class OrderPizza { public static void main(String[] args) { SimpleFactory simpleFactory = new SimpleFactory(); Pizza pizza = simpleFactory.createPizza(\\\"greek\\\"); // Pizza pizza = SimpleFactory.createPizza(\\\"greek\\\"); // 静态工厂模式 System.out.println(pizza.getName); } } \",\"简单工厂模式虽然违反了 OCP 原则，但是花费的代价非常小，所以经常被使用。\"]},\"611\":{\"h\":\"工厂方法（Factory Method）\"},\"612\":{\"h\":\"工厂方法模式介绍\",\"t\":[\"工厂方法模式 是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。\",\"主要优点\",\"用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程\",\"灵活性增强，对于新产品的创建，只需多写一个相应的工厂类\",\"典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则\",\"主要缺点\",\"类的个数容易过多，增加复杂度\",\"增加了系统的抽象性和理解难度\",\"抽象产品只能生产一种产品，此弊端可使用 抽象工厂模式 解决\",\"工厂方法模式：定义了一个创建对象的抽象方法，由 子类决定要实例化的类。工厂方法模式将 对象的实例化推迟到子类。\",\"主要角色\",\"抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品\",\"具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建\",\"抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能\",\"具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应\",\"其结构图如下所示：\",\"image-20220326222947461\"]},\"613\":{\"h\":\"工厂方法模式完成案例\",\"t\":[\"披萨项目新的需求：客户在点披萨时，可以点不同口味的披萨，比如北京的奶酪 pizza、北京的胡椒 pizza 或者是伦敦的奶酪 pizza、伦敦的胡椒 pizza。\",\"思路 1\",\"使用简单工厂模式，创建不同的简单工厂类，比如 BJPizzaSimpleFactory、LDPizzaSimpleFactory 等等。从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好。\",\"思路 2\",\"使用工厂模式。\",\"工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。\",\"思路分析图解\",\"image-20220227140635359\",\"代码实现\",\"披萨类代码：\",\"// 将 Pizza 类做成抽象 public abstract class Pizza { protected String name; //名字 // 准备原材料, 不同的披萨不一样，因此，我们做成抽象方法 public abstract void prepare(); // 省略 setter、getter 方法 } class BJCheesePizza extends Pizza { @Override public void prepare() { setName(\\\"北京的奶酪 pizza\\\"); System.out.println(\\\" 北京的奶酪 pizza 准备原材料\\\"); } } class BJPepperPizza extends Pizza { @Override public void prepare() { setName(\\\"北京的胡椒 pizza\\\"); System.out.println(\\\" 北京的胡椒 pizza 准备原材料\\\"); } } class LDCheesePizza extends Pizza{ @Override public void prepare() { setName(\\\"伦敦的奶酪 pizza\\\"); System.out.println(\\\" 伦敦的奶酪 pizza 准备原材料\\\"); } } class LDPepperPizza extends Pizza{ @Override public void prepare() { setName(\\\"伦敦的奶酪 pizza\\\"); System.out.println(\\\" 伦敦的奶酪 pizza 准备原材料\\\"); } } \",\"工厂方法模式代码：\",\"public abstract class OrderPizzaFactory { // 定义一个抽象方法，createPizza，让各个工厂子类自己实现 abstract Pizza createPizza(String orderType); // 构造器 public OrderPizza(String orderType) { Pizza pizza = null; pizza = createPizza(orderType); // 抽象方法，由工厂子类完成 } } \",\"由工厂方法模式创建的子类：\",\"public class PizzaStore { public static void main(String[] args) { // 创建北京口味的各种 Pizza BJOrderPizzaFactory bJOrderPizzaFactory = new BJOrderPizzaFactory(); Pizza pizza1 = bJOrderPizzaFactory.createPizza(\\\"cheese\\\"); Pizza pizza2= bJOrderPizzaFactory.createPizza(\\\"pepper\\\"); System.out.print(pizza1.getName()); System.out.print(pizza2.getName()); // 创建伦敦口味的各种 Pizza LDOrderPizzaFactory lDOrderPizzaFactory = new LDOrderPizzaFactory(); Pizza pizza3 = lDOrderPizzaFactory.createPizza(\\\"cheese\\\"); Pizza pizza4 = lDOrderPizzaFactory.createPizza(\\\"pepper\\\"); System.out.print(pizza3.getName()); System.out.print(pizza4.getName()); } } class BJOrderPizzaFactory extends OrderPizzaFactory { @Override Pizza createPizza(String orderType) { Pizza pizza = null; if(orderType.equals(\\\"cheese\\\")) { pizza = new BJCheesePizza(); } else if (orderType.equals(\\\"pepper\\\")) { pizza = new BJPepperPizza(); } return pizza; } } class LDOrderPizzaFactory extends OrderPizzaFactory { @Override Pizza createPizza(String orderType) { Pizza pizza = null; if(orderType.equals(\\\"cheese\\\")) { pizza = new LDCheesePizza(); } else if (orderType.equals(\\\"pepper\\\")) { pizza = new LDPepperPizza(); } return pizza; } } \",\"如果新增一个新的类如希腊披萨，则只需要新增两个类：希腊披萨类（继承 Pizza 类）、希腊披萨工厂类（继承 OrderPizzaFactory）。不会修改其他的代码，满足了 OCP 开闭原则，但是相比较简单工厂模式，花费的代码比较高。\"]},\"614\":{\"h\":\"什么时候该用工厂方法模式，而非简单工厂模式呢？\",\"t\":[\"之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。\",\"基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。\",\"除此之外，在某些场景下，如果对象不可复用，那工厂类 每次都要返回不同的对象。如果我们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。\",\"工厂方法模式可以理解为在多个简单工厂模式（子工厂）的基础上再创建一个大的工厂，统一管理多个子工厂。\",\"复杂度\",\"优势模式\",\"结构复杂度\",\"简单工厂模式\",\"代码复杂度\",\"简单工厂模式\",\"编程复杂度\",\"简单工厂模式\",\"管理复杂度\",\"简单工厂模式\",\"根据实际业务\",\"简单工厂模式\",\"根据设计原则\",\"工厂方法模式\",\"应用场景：\",\"客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等\",\"创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口\",\"客户不关心创建产品的细节，只关心产品的品牌\"]},\"615\":{\"h\":\"抽象工厂（Abstract Factory）\"},\"616\":{\"h\":\"基本介绍\",\"t\":[\"抽象工厂模式：定义了一个 interface 用于创建相关或有依赖关系的对象簇，而无需指明具体的类\",\"抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合，是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品\",\"从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或者称为进一步的抽象）\",\"将工厂抽象成两层，AbsFactory（抽象工厂）和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了 工厂簇，更利于代码的维护和扩展\",\"优点\",\"除了具有工厂方法模式的优点外，还有：\",\"可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。\",\"当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。\",\"抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。\",\"主要缺点\",\"当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。\",\"主要角色\",\"抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品\",\"具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建\",\"抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品\",\"具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系\",\"抽象工厂结构图：\",\"image-20220326223223254\",\"上面的披萨案例抽象工厂类图：\",\"image-20220227141801967\"]},\"617\":{\"h\":\"抽象工厂模式应用实例\",\"t\":[\"换个案例：生产小米手机、小米路由器；华为手机、华为路由器。\",\"image-20220301171914376\",\"小米手机和华为手机称为 产品线，小米手机和小米路由器称为 产品簇。\",\"首先创建手机和路由器的接口类：（为了方便，放在一个代码块里）\",\"// 手机接口 public interface IPhoneProduct { void start(); void shutdown(); void sendMes(); void call(); } // 路由器接口 public interface IRouterProduct { void start(); void shutdown(); void setting(); void link(); } \",\"创建小米和华为的手机：（为了方便，放在一个代码块里）\",\"// 小米手机 public class XiaoMiPhone implements IPhoneProduct { @Override public void start() { System.out.println(\\\"打开小米手机\\\"); } @Override public void shutdown() { System.out.println(\\\"关闭小米手机\\\"); } @Override public void sendMes() { System.out.println(\\\"小米手机发送消息\\\"); } @Override public void call() { System.out.println(\\\"小米手机打电话\\\"); } } // 华为手机 public class HuaWeiPhone implements IPhoneProduct{ @Override public void start() { System.out.println(\\\"打开华为手机\\\"); } @Override public void shutdown() { System.out.println(\\\"关闭华为手机\\\"); } @Override public void sendMes() { System.out.println(\\\"华为手机发送消息\\\"); } @Override public void call() { System.out.println(\\\"华为手机打电话\\\"); } } \",\"创建小米和华为的路由器：（为了方便，放在一个代码块里）\",\"// 小米路由器 public class XiaoMiRouter implements IRouterProduct{ @Override public void start() { System.out.println(\\\"打开小米路由器\\\"); } @Override public void shutdown() { System.out.println(\\\"关闭小米路由器\\\"); } @Override public void setting() { System.out.println(\\\"设置小米路由器\\\"); } @Override public void link() { System.out.println(\\\"连接小米路由器\\\"); } } // 华为路由器 public class HuaWeiMiRouter implements IRouterProduct{ @Override public void start() { System.out.println(\\\"打开华为路由器\\\"); } @Override public void shutdown() { System.out.println(\\\"关闭华为路由器\\\"); } @Override public void setting() { System.out.println(\\\"设置华为路由器\\\"); } @Override public void link() { System.out.println(\\\"连接华为路由器\\\"); } } \",\"创建抽象工厂和子工厂（小米工厂、华为工厂）（为了方便，放在一个代码块里）\",\"// 抽象工厂 public interface IProductFactory { IPhoneProduct phoneProduct(); IRouterProduct routerProduct(); } // 小米工厂 public class XiaoMiFactory implements IProductFactory{ @Override public IPhoneProduct phoneProduct() { return new XiaoMiPhone(); } @Override public IRouterProduct routerProduct() { return new XiaoMiRouter(); } } // 华为工厂 public class HuaWeiFactory implements IProductFactory{ @Override public IPhoneProduct phoneProduct() { return new HuaWeiPhone(); } @Override public IRouterProduct routerProduct() { return new HuaWeiMiRouter(); } } \",\"测试抽象工厂模式：\",\"public class Client { public static void main(String[] args) { System.out.println(\\\"-------------- 小米系列工厂 --------------\\\"); XiaoMiFactory xiaoMiFactory = new XiaoMiFactory(); IPhoneProduct iPhoneProduct = xiaoMiFactory.phoneProduct(); iPhoneProduct.start(); iPhoneProduct.call(); iPhoneProduct.sendMes(); iPhoneProduct.shutdown(); IRouterProduct iRouterProduct = xiaoMiFactory.routerProduct(); iRouterProduct.start(); iRouterProduct.link(); iRouterProduct.shutdown(); iRouterProduct.setting(); System.out.println(\\\"-------------- 华为系列工厂 --------------\\\"); HuaWeiFactory huaWeiFactory = new HuaWeiFactory(); IPhoneProduct iPhoneProduct1 = huaWeiFactory.phoneProduct(); iPhoneProduct1.start(); iPhoneProduct1.call(); iPhoneProduct1.sendMes(); iPhoneProduct1.shutdown(); IRouterProduct iRouterProduct1 = huaWeiFactory.routerProduct(); iRouterProduct1.start(); iRouterProduct1.link(); iRouterProduct1.shutdown(); iRouterProduct1.setting(); } } \"]},\"618\":{\"h\":\"工厂模式在 JDK-Calendar 应用的源码分析\",\"t\":[\"JDK 中的 Calendar 类中，就使用了简单工厂模式。\",\"public class Factory { public static void main(String[] args) { // getInstance 是 Calendar 静态方法 Calendar cal = Calendar.getInstance(); // 注意月份下标从 0 开始，所以取月份要+1 System.out.println(\\\"年:\\\" + cal.get(Calendar.YEAR)); System.out.println(\\\"月:\\\" + (cal.get(Calendar.MONTH) + 1)); System.out.println(\\\"日:\\\" + cal.get(Calendar.DAY_OF_MONTH)); System.out.println(\\\"时:\\\" + cal.get(Calendar.HOUR_OF_DAY)); System.out.println(\\\"分:\\\" + cal.get(Calendar.MINUTE)); System.out.println(\\\"秒:\\\" + cal.get(Calendar.SECOND)); } } \",\"Calendar.java\",\"public class Calendar { public static Calendar getInstance() { return createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT)); } private static Calendar createCalendar(TimeZone zone,Locale aLocale) { // 根据 TimeZone zone, locale 创建对应的实例 CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale) .getCalendarProvider(); if (provider != null) { try { return provider.getInstance(zone, aLocale); } catch (IllegalArgumentException iae) { // fall back to the default instantiation } } Calendar cal = null; if (aLocale.hasExtensions()) { String caltype = aLocale.getUnicodeLocaleType(\\\"ca\\\"); if (caltype != null) { switch (caltype) { case \\\"buddhist\\\": cal = new BuddhistCalendar(zone, aLocale); break; case \\\"japanese\\\": cal = new JapaneseImperialCalendar(zone, aLocale); break; case \\\"gregory\\\": cal = new GregorianCalendar(zone, aLocale); break; } } } if (cal == null) { // If no known calendar type is explicitly specified // perform the traditional way to create a Calendar: // create a BuddhistCalendar for th_TH locale // a JapaneseImperialCalendar for ja_JP_JP locale, or // a GregorianCalendar for any other locales // NOTE: The language, country and variant strings are interned. if (aLocale.getLanguage() == \\\"th\\\" && aLocale.getCountry() == \\\"TH\\\") { cal = new BuddhistCalendar(zone, aLocale); } else if (aLocale.getVariant() == \\\"JP\\\" && aLocale.getLanguage() == \\\"ja\\\" && aLocale.getCountry() == \\\"JP\\\") { cal = new JapaneseImperialCalendar(zone, aLocale); } else { cal = new GregorianCalendar(zone, aLocale); } } return cal; } } \"]},\"619\":{\"h\":\"工厂模式小结\",\"t\":[\"工厂模式的意义将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性\",\"三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式）\",\"设计模式的依赖抽象原则 \",\"创建对象实例时，不要直接 new 类, 而是把这个 new 类的动作放在一个工厂的方法中，并返回。有的书上说，变量不要直接持有具体类的引用\",\"不要让类继承具体类，而是继承抽象类或者是实现 interface（接口）\",\"不要覆盖基类中已经实现的方法\"]},\"620\":{\"h\":\"如何设计实现一个Dependency Injection框架\",\"t\":[\"当创建对象是一个「大工程」的时候，我们一般会选择使用工厂模式，来封装对象复杂的创建过程，将对象的创建和使用分离，让代码更加清晰。那何为「大工程」呢？上面我们讲了两种情况，一种是创建过程涉及复杂的 if-else 分支判断，另一种是对象创建需要组装多个其他类对象或者需要复杂的初始化过程。\",\"我们来学习一个创建对象的「大工程」，依赖注入框架，或者叫依赖注入容器（Dependency Injection Container），简称 DI 容器。在今天的讲解中，我会带你一块搞清楚这样几个问题：DI 容器跟我们讲的工厂模式又有何区别和联系？DI 容器的核心功能有哪些，以及如何实现一个简单的 DI 容器？\"]},\"621\":{\"h\":\"工厂模式和 DI 容器有何区别\",\"t\":[\"实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为「容器」。\",\"DI 容器相对于我们上面讲的工厂模式的例子来说，它处理的是更大的对象创建工程。上面讲的工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 DI 容器负责的是整个应用中所有类对象的创建。\",\"除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。接下来，我们就详细讲讲，一个简单的 DI 容器应该包含哪些核心功能。\"]},\"622\":{\"h\":\"DI 容器的核心功能有哪些\",\"t\":[\"总结一下，一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。\",\"首先，我们来看配置解析。\",\"在上面讲的工厂模式中，工厂类要创建哪个类对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，我们需要通过一种形式，让应用告知 DI 容器要创建哪些对象。这种形式就是我们要讲的配置\",\"我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象\",\"下面是一个典型的 Spring 容器的配置文件。Spring 容器读取这个配置文件，解析出要创建的两个对象：rateLimiter 和 redisCounter，并且得到两者的依赖关系：rateLimiter 依赖 redisCounter\",\"public class RateLimiter { private RedisCounter redisCounter; public RateLimiter(RedisCounter redisCounter) { this.redisCounter = redisCounter; } public void test() { System.out.println(\\\"Hello World!\\\"); } // ... } public class RedisCounter { private String ipAddress; private int port; public RedisCounter(String ipAddress, int port) { this.ipAddress = ipAddress; this.port = port; } // ... } \",\"配置文件 beans.xml：\",\"<beans> <bean id=\\\"rateLimiter\\\" class=\\\"cn.gavin.RateLimiter\\\"> <constructor-arg ref=\\\"redisCounter\\\"/> </bean> <bean id=\\\"redisCounter\\\" class=\\\"cn.gavin.redisCounter\\\"> <constructor-arg type=\\\"String\\\" value=\\\"127.0.0.1\\\"/> <constructor-arg type=\\\"int\\\" value=1234/> </bean> </beans> \",\"其次，我们再来看对象创建。\",\"在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 BeansFactory。\",\"你可能会说，如果要创建的类对象非常多，BeansFactory 中的代码会不会线性膨胀（代码量跟创建对象的个数成正比）呢？实际上并不会。待会讲到 DI 容器的具体实现的时候，我们会讲「反射」这种机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的。\",\"最后，我们来看对象的生命周期管理。\",\"上面我们讲到，简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 Spring 框架中，我们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope=prototype 表示返回新创建的对象，scope=singleton 表示返回单例对象。\",\"除此之外，我们还可以配置对象是否支持懒加载。如果 lazy-init=true，对象在真正被使用到的时候（比如：BeansFactory.getBean(\\\"userService\\\")）才被被创建；如果 lazy-init=false，对象在应用启动的时候就事先创建好。\",\"不仅如此，我们还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method=loadProperties()，destroy-method=updateConfigFile()。DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。\"]},\"623\":{\"h\":\"如何实现一个简单的 DI 容器？\",\"t\":[\"用 Java 语言来实现一个简单的 DI 容器，核心逻辑只需要包括这样两个部分：配置文件解析、根据配置文件通过「反射」语法来创建对象。\"]},\"624\":{\"h\":\"最小原型设计\",\"t\":[\"因为我们主要是讲解设计模式，所以，在今天的讲解中，我们只实现一个 DI 容器的最小原型。像 Spring 框架这样的 DI 容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，我们只支持下面配置文件中涉及的配置语法。\",\"配置文件 beans.xml\",\"<beans> <bean id=\\\"rateLimiter\\\" class=\\\"cn.gavin.RateLimiter\\\"> <constructor-arg ref=\\\"redisCounter\\\"/> </bean> <bean id=\\\"redisCounter\\\" class=\\\"cn.gavin.redisCounter\\\" scope=\\\"singleton\\\" lazy-init=\\\"true\\\"> <constructor-arg type=\\\"String\\\" value=\\\"127.0.0.1\\\"/> <constructor-arg type=\\\"int\\\" value=1234/> </bean> </beans> \",\"最小原型的使用方式跟 Spring 框架非常类似，示例代码如下所示：\",\"public class Demo { public static void main(String[] args) { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\\\"beans.xml\\\"); RateLimiter rateLimiter = (RateLimiter) applicationContext.getBean(\\\"rateLimiter\\\"); rateLimiter.test(); // ... } } \"]},\"625\":{\"h\":\"提供执行入口\",\"t\":[\"面向对象设计的最后一步是：组装类并提供执行入口。在这里，执行入口就是一组暴露给外部使用的接口和类。通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分：ApplicationContext 和 ClassPathXmlApplicationContext。其中 ApplicationContext 是接口，ClassPathXmlApplicationContext 是接口的实现类。两个类具体实现如下所示：\",\"public interface ApplicationContext { Object getBean(String beanId); } public class ClassPathXmlApplicationContext implements ApplicationContext { private BeansFactory beansFactory; private BeanConfigParser beanConfigParser; public ClassPathXmlApplicationContext(String configLocation) { this.beansFactory = new BeansFactory(); this.beanConfigParser = new XmlBeanConfigParser(); loadBeanDefinitions(configLocation); } private void loadBeanDefinitions(String configLocation) { InputStream in = null; try { in = this.getClass().getResourceAsStream(\\\"/\\\" + configLocation); if (in == null) { throw new RuntimeException(\\\"Can not find config file: \\\" + configLocation); } List<BeanDefinition> beanDefinitions = beanConfigParser.parse(in); beansFactory.addBeanDefinitions(beanDefinitions); } finally { if (in != null) { try { in.close(); } catch (IOException e) { // TODO: log error } } } } @Override public Object getBean(String beanId) { return beansFactory.getBean(beanId); } } \",\"从上面的代码中，我们可以看出，ClassPathXmlApplicationContext 负责组装 BeansFactory 和 BeanConfigParser 两个类，串联执行流程：从 classpath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式，然后，BeansFactory 根据 BeanDefinition 来创建对象。\"]},\"626\":{\"h\":\"配置文件解析\",\"t\":[\"配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象。配置文件的解析比较繁琐，不涉及我们要讲的理论知识，不是我们讲解的重点，所以这里我只给出两个类的大致设计思路，并未给出具体的实现代码。如果感兴趣的话，你可以自行补充完整。具体的代码框架如下所示：\",\"public interface BeanConfigParser { List<BeanDefinition> parse(InputStream inputStream); List<BeanDefinition> parse(String configContent); } public class XmlBeanConfigParser implements BeanConfigParser { @Override public List<BeanDefinition> parse(InputStream inputStream) { String content = null; // TODO:... return parse(content); } @Override public List<BeanDefinition> parse(String configContent) { List<BeanDefinition> beanDefinitions = new ArrayList<>(); // TODO:... return beanDefinitions; } } public class BeanDefinition { private String id; private String className; private List<ConstructorArg> constructorArgs = new ArrayList<>(); private Scope scope = Scope.SINGLETON; private boolean lazyInit = false; // 省略必要的 getter/setter/constructors public boolean isSingleton() { return scope.equals(Scope.SINGLETON); } public static enum Scope { SINGLETON, PROTOTYPE } public static class ConstructorArg { private boolean isRef; private Class type; private Object arg; // 省略必要的 getter/setter/constructors } } \"]},\"627\":{\"h\":\"核心工厂类设计\",\"t\":[\"最后，我们来看，BeansFactory 是如何设计和实现的。这也是我们这个 DI 容器最核心的一个类了。它负责根据从配置文件解析得到的 BeanDefinition 来创建对象\",\"如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中，下次再请求此对象的时候，直接从 map 中取出返回，不需要重新创建。如果对象的 scope 属性是 prototype，那每次请求对象，BeansFactory 都会创建一个新的对象返回\",\"实际上，BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法：一种动态加载类和创建对象的机制。我们知道，JVM 在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 JVM 帮我们自动完成了，我们需要利用 Java 提供的反射语法自己去编写代码\",\"搞清楚了反射的原理，BeansFactory 的代码就不难看懂了。具体代码实现如下所示：\",\"public class BeansFactory { private ConcurrentHashMap<String, Object> singletonObjects = new ConcurrentHashMap<>(); private ConcurrentHashMap<String, BeanDefinition> beanDefinitions = new ConcurrentHashMap<>(); public void addBeanDefinitions(List<BeanDefinition> beanDefinitionList) { for (BeanDefinition beanDefinition : beanDefinitionList) { this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition); } for (BeanDefinition beanDefinition : beanDefinitionList) { if (beanDefinition.isLazyInit() == false && beanDefinition.isSingleton()) { createBean(beanDefinition); } } } public Object getBean(String beanId) { BeanDefinition beanDefinition = beanDefinitions.get(beanId); if (beanDefinition == null) { throw new NoSuchBeanDefinitionException(\\\"Bean is not defined: \\\" + beanId); } return createBean(beanDefinition); } @VisibleForTesting protected Object createBean(BeanDefinition beanDefinition) { if (beanDefinition.isSingleton() && singletonObjects.contains(beanDefinition.getId())) { return singletonObjects.get(beanDefinition.getId()); } Object bean = null; try { Class beanClass = Class.forName(beanDefinition.getClassName()); List<BeanDefinition.ConstructorArg> args = beanDefinition.getConstructorArgs(); if (args.isEmpty()) { bean = beanClass.newInstance(); } else { Class[] argClasses = new Class[args.size()]; Object[] argObjects = new Object[args.size()]; for (int i = 0; i < args.size(); ++i) { BeanDefinition.ConstructorArg arg = args.get(i); if (!arg.getIsRef()) { argClasses[i] = arg.getType(); argObjects[i] = arg.getArg(); } else { BeanDefinition refBeanDefinition = beanDefinitions.get(arg.getArg()); if (refBeanDefinition == null) { throw new NoSuchBeanDefinitionException(\\\"Bean is not defined: \\\" + arg.getArg()); } argClasses[i] = Class.forName(refBeanDefinition.getClassName()); argObjects[i] = createBean(refBeanDefinition); } } bean = beanClass.getConstructor(argClasses).newInstance(argObjects); } } catch (ClassNotFoundException | IllegalAccessException | InstantiationException | NoSuchMethodException | InvocationTargetException e) { throw new BeanCreationFailureException(\\\"\\\", e); } if (bean != null && beanDefinition.isSingleton()) { singletonObjects.putIfAbsent(beanDefinition.getId(), bean); return singletonObjects.get(beanDefinition.getId()); } return bean; } } \",\"执行入口那里调用 addBeanDefinitions\",\"然后 addBeanDefinitions 再调用 createBean 利用反射创建对象，如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 Map 中\",\"最后最小原型设计那里再调用 getBean从singletonObjects 获取对象\"]},\"628\":{\"h\":\"结构型享元模式\"},\"629\":{\"h\":\"享元模式基本介绍\",\"t\":[\"在面向对象程序设计过程中，有时会面临要创建大量相同或相似对象实例的问题。创建那么多的对象将会耗费很多的系统资源，它是系统性能提高的一个瓶颈。\",\"例如，围棋和五子棋中的黑白棋子，图像中的坐标点或颜色，局域网中的路由器、交换机和集线器，教室里的桌子和凳子等。这些对象有很多相似的地方，如果能把它们相同的部分提取出来共享，则能节省大量的系统资源，这就是享元模式的产生背景。\",\"享元模式（Flyweight Pattern） 也叫 蝇量模式: 运用共享技术有效地支持大量细粒度的对象。\",\"常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个。\",\"享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率。\",\"享元模式经典的应用场景就是池技术了，String 常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式。\",\"主要优点\",\"相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。\",\"主要缺点\",\"为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。\",\"读取享元模式的外部状态会使得运行时间稍微变长\"]},\"630\":{\"h\":\"享元模式的结构与实现\"},\"631\":{\"h\":\"内部状态和外部状态\",\"t\":[\"比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点，所以棋子颜色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同，当我们落子后，落子颜色是定的，但位置是变化的，所以棋子坐标就是棋子的外部状态。\",\"享元模式的定义提出了两个要求，细粒度和共享对象。因为要求细粒度，所以不可避免地会使对象数量多且性质相近，此时我们就将这些对象的信息分为两个部分：内部状态和外部状态。\",\"内部状态指对象共享出来的信息，存储在享元信息内部，并且不会随环境的改变而改变\",\"外部状态指对象得以依赖的一个标记，随环境的改变而改变，不可共享 比如，连接池中的连接对象，保存在连接对象中的用户名、密码、连接 URL 等信息，在创建对象的时候就设置好了，不会随环境的改变而改变，这些为内部状态。而当每个连接要被回收利用时，我们需要将它标记为可用状态，这些为外部状态\",\"举个例子：围棋理论上有 361 个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生，因为内存空间有限，一台服务器很难支持更多的玩家玩围棋游戏，如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题。\",\"享元模式的本质是缓存共享对象，降低内存消耗。\"]},\"632\":{\"h\":\"模式的结构\",\"t\":[\"享元模式的主要角色有如下：\",\"抽象享元角色（Flyweight）：是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入\",\"具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口\",\"非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中\",\"享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象\",\"image-20220314190648003\",\"下面享元模式的结构图，其中：\",\"UnsharedConcreteFlyweight 是非享元角色，里面包含了非共享的外部状态信息 info\",\"Flyweight 是抽象享元角色，里面包含了享元方法 operation(UnsharedConcreteFlyweight state)，非享元的外部状态以参数的形式通过该方法传入\",\"ConcreteFlyweight 是具体享元角色，包含了关键字 key，它实现了抽象享元接口\",\"FlyweightFactory 是享元工厂角色，它是关键字 key 来管理具体享元\",\"客户角色通过享元工厂获取具体享元，并访问具体享元的相关方法\",\"image-20220314190636066\",\"代码实现：\",\"// 抽象享元角色 interface Flyweight { public void operation(UnsharedConcreteFlyweight state); } // 具体享元角色 class ConcreteFlyweight implements Flyweight { private String key; ConcreteFlyweight(String key) { this.key = key; System.out.println(\\\"具体享元\\\" + key + \\\"被创建！\\\"); } public void operation(UnsharedConcreteFlyweight outState) { System.out.print(\\\"具体享元\\\" + key + \\\"被调用，\\\"); System.out.println(\\\"非享元信息是:\\\" + outState.getInfo()); } } // 非享元角色 class UnsharedConcreteFlyweight { private String info; UnsharedConcreteFlyweight(String info) { this.info = info; } public String getInfo() { return info; } public void setInfo(String info) { this.info = info; } } // 享元工厂角色 class FlyweightFactory { private HashMap<String, Flyweight> flyweights = new HashMap<String, Flyweight>(); public Flyweight getFlyweight(String key) { Flyweight flyweight = (Flyweight) flyweights.get(key); if (flyweight != null) { System.out.println(\\\"具体享元\\\" + key + \\\"已经存在，被成功获取！\\\"); } else { flyweight = new ConcreteFlyweight(key); flyweights.put(key, flyweight); } return flyweight; } } public class FlyweightPattern { public static void main(String[] args) { FlyweightFactory factory = new FlyweightFactory(); Flyweight f01 = factory.getFlyweight(\\\"a\\\"); // 初始 a 不存在，则创建 a Flyweight f02 = factory.getFlyweight(\\\"a\\\"); // 获取第一次创建的 a Flyweight f03 = factory.getFlyweight(\\\"a\\\"); // 获取第一次创建的 a Flyweight f11 = factory.getFlyweight(\\\"b\\\"); // 初始 b 不存在，则创建 b Flyweight f12 = factory.getFlyweight(\\\"b\\\"); // 获取第一次创建的 b f01.operation(new UnsharedConcreteFlyweight(\\\"第1次调用a。\\\")); f02.operation(new UnsharedConcreteFlyweight(\\\"第2次调用a。\\\")); f03.operation(new UnsharedConcreteFlyweight(\\\"第3次调用a。\\\")); f11.operation(new UnsharedConcreteFlyweight(\\\"第1次调用b。\\\")); f12.operation(new UnsharedConcreteFlyweight(\\\"第2次调用b。\\\")); } } \"]},\"633\":{\"h\":\"展示网站项目需求\",\"t\":[\"小型的外包项目，给客户 A 做一个产品展示网站，客户 A 的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同：\",\"有客户要求以新闻的形式发布\",\"有客户人要求以博客的形式发布\",\"有客户希望以微信公众号的形式发布\"]},\"634\":{\"h\":\"传统方案解决网站展现项目\",\"t\":[\"给每个网站租用一个空间。\",\"image-20220314190248901\"]},\"635\":{\"h\":\"问题分析\",\"t\":[\"需要的网站结构相似度很高，而且都不是高访问量网站，如果分成多个虚拟空间来处理，相当于一个相同网站的实例对象很多，造成服务器的资源浪费。\",\"解决思路：整合到一个网站中，共享其相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源 都可以达成共享，减少服务器资源。\",\"对于代码来说，由于是一份实例，维护和扩展都更加容易。\",\"上面的解决思路就可以使用 享元模式。\"]},\"636\":{\"h\":\"享元模式解决网站展现项目\",\"t\":[\"类图：\",\"image-20220314190856461\",\"代码实现：\",\"User 类：\",\"public class User { private String name; public User(String name) { super(); this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } } \",\"网站类和其子类\",\"public abstract class WebSite { public abstract void use(User user); // 抽象方法 } // 具体网站 public class ConcreteWebSite extends WebSite { // 共享的部分，内部状态 private String type = \\\"\\\"; // 网站发布的形式（类型） // 构造器 public ConcreteWebSite(String type) { this.type = type; } @Override public void use(User user) { System.out.println(\\\"网站的发布形式为:\\\" + type + \\\" 在使用中 .. 使用者是\\\" + user.getName()); } } \",\"网站工厂类：\",\"// 网站工厂类，根据需要返回压一个网站 public class WebSiteFactory { // 集合，充当池的作用 private HashMap<String, ConcreteWebSite> pool = new HashMap<>(); // 根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回 public WebSite getWebSiteCategory(String type) { if(!pool.containsKey(type)) { // 就创建一个网站，并放入到池中 pool.put(type, new ConcreteWebSite(type)); } return (WebSite)pool.get(type); } // 获取网站分类的总数 (池中有多少个网站类型) public int getWebSiteCount() { return pool.size(); } } \",\"测试类：\",\"public class Client { public static void main(String[] args) { // 创建一个工厂类 WebSiteFactory factory = new WebSiteFactory(); // 客户要一个以新闻形式发布的网站 WebSite webSite1 = factory.getWebSiteCategory(\\\"新闻\\\"); webSite1.use(new User(\\\"tom\\\")); // 客户要一个以博客形式发布的网站 WebSite webSite2 = factory.getWebSiteCategory(\\\"博客\\\"); webSite2.use(new User(\\\"jack\\\")); // 客户要一个以博客形式发布的网站 WebSite webSite3 = factory.getWebSiteCategory(\\\"博客\\\"); webSite3.use(new User(\\\"smith\\\")); // 客户要一个以博客形式发布的网站 WebSite webSite4 = factory.getWebSiteCategory(\\\"博客\\\"); webSite4.use(new User(\\\"king\\\")); System.out.println(\\\"网站的分类共=\\\" + factory.getWebSiteCount()); } } \"]},\"637\":{\"h\":\"JDK-Integer 的享元模式剖析\",\"t\":[\"JDK 中 Integer 使用到了享元模式。\",\"image-20220314191251956\",\"代码说明：\",\"public class FlyWeight { public static void main(String[] args) { // 如果 Integer.valueOf(x) x 在 -128 --- 127 直接，就是使用享元模式返回，如果不在 // 范围类，则仍然 new // 小结: // 1. 在 valueOf 方法中，先判断值是否在 IntegerCache 中，如果不在，就创建新的 Integer(new), 否则，就直接从缓存池返回 // 2. valueOf 方法，就使用到享元模式 // 3. 如果使用 valueOf 方法得到一个 Integer 实例，范围在 -128 - 127 ，执行速度比 new 快 Integer x = Integer.valueOf(127); // 得到 x 实例，类型 Integer Integer y = new Integer(127); // 得到 y 实例，类型 Integer Integer z = Integer.valueOf(127); // .. Integer w = new Integer(127); System.out.println(x.equals(y)); // 大小，true System.out.println(x == y ); // false System.out.println(x == z ); // true System.out.println(w == x ); // false System.out.println(w == y ); // false Integer x1 = Integer.valueOf(200); Integer x2 = Integer.valueOf(200); System.out.println(\\\"x1==x2\\\" + (x1 == x2)); // false，因为超出f } } \"]},\"638\":{\"h\":\"享元模式的注意事项和细节\",\"t\":[\"在享元模式这样理解，「享」就表示共享，「元」表示对象\",\"系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式\",\"用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用 HashMap/HashTable 存储\",\"享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率\",\"享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方\",\"使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制\",\"享元模式经典的应用场景是需要缓冲池的场景，比如 String 常量池、数据库连接池\"]},\"639\":{\"h\":\"享元模式的应用场景\",\"t\":[\"当系统中多处需要同一组信息时，可以把这些信息封装到一个对象中，然后对该对象进行缓存，这样，一个对象就可以提供给多出需要使用的地方，避免大量同一对象的多次创建，降低大量内存空间的消耗。\",\"享元模式其实是 工厂方法模式 的一个改进机制，享元模式同样要求创建一个或一组对象，并且就是通过工厂方法模式生成对象的，只不过享元模式为工厂方法模式增加了缓存这一功能。\",\"前面分析了享元模式的结构与特点，下面分析它适用的应用场景。享元模式是通过减少内存中对象的数量来节省内存空间的，所以以下几种情形适合采用享元模式：\",\"系统中存在大量相同或相似的对象，这些对象耗费大量的内存资源\",\"大部分的对象可以按照内部状态进行分组，且可将不同部分外部化，这样每一个组只需保存一个内部状态\",\"由于享元模式需要额外维护一个保存享元的数据结构，所以应当在有足够多的享元实例时才值得使用享元模式\"]},\"640\":{\"h\":\"行为型解释器模式\"},\"641\":{\"h\":\"解释器模式基本介绍\",\"t\":[\"在编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这里的词法分析器和语法分析器都可以看做是解释器。\",\"解释器模式（Interpreter Pattern）：是指给定一个语言（表达式），定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子（表达式）。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。\",\"这里提到的文法和句子的概念同编译原理中的描述相同，文法 指语言的语法规则，而 句子 是语言集中的元素。例如，汉语中的句子有很多，「我是中国人」是其中的一个句子，可以用一棵语法树来直观地描述语言中的句子。\",\"解释器模式是一种类行为型模式。\",\"主要优点\",\"扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法\",\"容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易\",\"主要缺点\",\"执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦\",\"会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护\",\"可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到\"]},\"642\":{\"h\":\"解释器模式的结构与实现\",\"t\":[\"解释器模式的结构与 组合模式 相似，不过其包含的组成元素比组合模式多，而且组合模式是对象结构型模式，而解释器模式是类行为型模式。\",\"解释器模式包含以下主要角色：\",\"抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()\",\"终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应\",\"非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式\",\"环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值\",\"客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法\",\"解释器模式的结构图如下图所示：\",\"image-20220326171643437\",\"代码实现：\",\"// 抽象表达式类 interface AbstractExpression { public void interpret(String info); // 解释方法 } // 终结符表达式类 class TerminalExpression implements AbstractExpression { public void interpret(String info) { // 对终结符表达式的处理 } } // 非终结符表达式类 class NonterminalExpression implements AbstractExpression { private AbstractExpression exp1; private AbstractExpression exp2; public void interpret(String info) { // 非对终结符表达式的处理 } } // 环境类 class Context { private AbstractExpression exp; public Context() { // 数据初始化 } public void operation(String info) { // 调用相关表达式类的解释方法 } } \"]},\"643\":{\"h\":\"四则运算问题\",\"t\":[\"先输入表达式的形式，分别输入 a、b、c、d、e 的值，比如 a + b + c - d + e，要求表达式的字母不能重复，最后求出结果：\",\"请输入表达式：a+b+c-d+e 请输入a的值：10 请输入b的值：11 请输入c的值：1 请输入d的值：2 请输入e的值：3 运算结果：a+b+c-d+e=23 \",\"如图\",\"image-20220326170939660\"]},\"644\":{\"h\":\"解释器模式来实现四则\",\"t\":[\"思路分析和类图：\",\"image-20220326171909429\",\"代码实现：\",\"解释器类\",\"// 抽象类表达式，通过 HashMap 键值对, 可以获取到变量的值 public abstract class Expression { // a + b - c // 解释公式和数值, key 就是公式(表达式) 参数[a,b,c], value 就是就是具体值 // HashMap {a=10, b=20} public abstract int interpreter(HashMap<String, Integer> var); } // 抽象运算符号解析器 这里，每个运算符号，都只和自己左右两个数字有关系，但左右两个数字有可能也是一个解析的结果，无论何种类型，都是 Expression 类的实现类 public class SymbolExpression extends Expression { protected Expression left; protected Expression right; public SymbolExpression(Expression left, Expression right) { this.left = left; this.right = right; } // 因为 SymbolExpression 是让其子类来实现，因此 interpreter 是一个默认实现 @Override public int interpreter(HashMap<String, Integer> var) { return 0; } } // 变量的解释器 public class VarExpression extends Expression { private String key; // key=a,key=b,key=c public VarExpression(String key) { this.key = key; } // var 就是 {a=10, b=20} // interpreter 根据 变量名称，返回对应值 @Override public int interpreter(HashMap<String, Integer> var) { return var.get(this.key); } } // 加法解释器 public class AddExpression extends SymbolExpression { public AddExpression(Expression left, Expression right) { super(left, right); } // 处理相加 // var 仍然是 {a=10,b=20} public int interpreter(HashMap<String, Integer> var) { return super.left.interpreter(var) + super.right.interpreter(var); } } // 减法解释器 public class SubExpression extends SymbolExpression { public SubExpression(Expression left, Expression right) { super(left, right); } // 求出left 和 right 表达式相减后的结果 public int interpreter(HashMap<String, Integer> var) { return super.left.interpreter(var) - super.right.interpreter(var); } } \",\"计算类\",\"public class Calculator { // 定义表达式 private Expression expression; // 构造函数传参，并解析 public Calculator(String expStr) { // expStr = a+b // 安排运算先后顺序 Stack<Expression> stack = new Stack<>(); // 表达式拆分成字符数组 char[] charArray = expStr.toCharArray(); // [a, +, b] Expression left = null; Expression right = null; // 遍历我们的字符数组，即遍历 [a, +, b] for (int i = 0; i < charArray.length; i++) { switch (charArray[i]) { case '+': // 从 stack 取出 left => \\\"a\\\" left = stack.pop(); // 取出右表达式 \\\"b\\\" right = new VarExpression(String.valueOf(charArray[++i])); // 然后根据得到 left 和 right 构建 AddExpresson 加入 stack stack.push(new AddExpression(left, right)); break; case '-': left = stack.pop(); right = new VarExpression(String.valueOf(charArray[++i])); stack.push(new SubExpression(left, right)); break; default: // 如果是一个 Var 就创建要给 VarExpression 对象，并 push 到 stack stack.push(new VarExpression(String.valueOf(charArray[i]))); break; } } // 当遍历完整个 charArray 数组后，stack 就得到最后 Expression this.expression = stack.pop(); } public int run(HashMap<String, Integer> var) { // 最后将表达式 a+b 和 var = {a=10,b=20} // 然后传递给 expression 的 interpreter 进行解释执行 return this.expression.interpreter(var); } } \",\"测试类\",\"public class ClientTest { public static void main(String[] args) throws IOException { String expStr = getExpStr(); // a+b HashMap<String, Integer> var = getValue(expStr); // var {a=10, b=20} Calculator calculator = new Calculator(expStr); System.out.println(\\\"运算结果：\\\" + expStr + \\\"=\\\" + calculator.run(var)); } // 获得表达式 public static String getExpStr() throws IOException { System.out.print(\\\"请输入表达式：\\\"); return (new BufferedReader(new InputStreamReader(System.in))).readLine(); } // 获得值映射 public static HashMap<String, Integer> getValue(String expStr) throws IOException { HashMap<String, Integer> map = new HashMap<>(); for (char ch : expStr.toCharArray()) { if (ch != '+' && ch != '-') { if (!map.containsKey(String.valueOf(ch))) { System.out.print(\\\"请输入\\\" + String.valueOf(ch) + \\\"的值：\\\"); String in = (new BufferedReader(new InputStreamReader(System.in))).readLine(); map.put(String.valueOf(ch), Integer.valueOf(in)); } } } return map; } } \"]},\"645\":{\"h\":\"解释器模式的注意事项和细节\",\"t\":[\"当有一个语言需要解释执行，可将该语言中的句子表示为一个抽象语法树，就可以考虑使用解释器模式，让程序具有良好的扩展性。\",\"使用解释器可能带来的问题：解释器模式会引起类膨胀、解释器模式采用递归调用方法，将会导致调试非常复杂、效率可能降低。\"]},\"646\":{\"h\":\"解释器模式的应用场景\",\"t\":[\"前面介绍了解释器模式的结构与特点，下面分析它的应用场景。\",\"当语言的文法较为简单，且执行效率不是关键问题时\",\"当问题重复出现，且可以用一种简单的语言来进行表达时\",\"当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释\",\"注意：解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。如果碰到对表达式的解释，在 Java 中可以用 Expression4J 或 Jep 等来设计。\"]},\"647\":{\"h\":\"行为型迭代器模式\"},\"648\":{\"h\":\"迭代器模式基本介绍\",\"t\":[\"迭代器模式在生活中应用的比较广泛，比如：物流系统中的传送带，不管传送的是什么物品，都会被打包成一个个箱子，并且有一个统一的二维码。这样我们不需要关心箱子里是什么，在分发时只需要一个个检查发送的目的地即可。再比如，我们平时乘坐交通工具，都是统一刷卡或者刷脸进站，而不需要关心是男性还是女性、是残疾人还是正常人等信息。\",\"迭代器模式（Iterator Pattern）是常用的设计模式，属于行为型模式。\",\"如果我们的集合元素是用不同的方式实现的，有数组，还有 Java 的集合类，或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。\",\"迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即：不暴露其内部的结构。\",\"主要优点\",\"访问一个聚合对象的内容而无须暴露它的内部表示\",\"遍历任务交由迭代器完成，这简化了聚合类\",\"它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历\",\"增加新的聚合类和迭代器类都很方便，无须修改原有代码\",\"封装性良好，为遍历不同的聚合结构提供一个统一的接口\",\"主要缺点\",\"增加了类的个数，这在一定程度上增加了系统的复杂性。\"]},\"649\":{\"h\":\"迭代器模式的结构与实现\",\"t\":[\"迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据。现在我们来分析其基本结构与实现方法。\",\"迭代器模式主要包含以下角色：\",\"抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口\",\"具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例\",\"抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法\",\"具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置\",\"结构图如下所示：\",\"image-20220326154814205\",\"代码实现：\",\"// 抽象迭代器 interface Iterator { Object first(); Object next(); boolean hasNext(); } // 具体迭代器 class ConcreteIterator implements Iterator { private List<Object> list = null; private int index = -1; public ConcreteIterator(List<Object> list) { this.list = list; } public boolean hasNext() { if (index < list.size() - 1) { return true; } else { return false; } } public Object first() { index = 0; Object obj = list.get(index); return obj; } public Object next() { Object obj = null; if (this.hasNext()) { obj = list.get(++index); } return obj; } } // 抽象聚合 interface Aggregate { public void add(Object obj); public void remove(Object obj); public Iterator getIterator(); } // 具体聚合 class ConcreteAggregate implements Aggregate { private List<Object> list = new ArrayList<Object>(); public void add(Object obj) { list.add(obj); } public void remove(Object obj) { list.remove(obj); } public Iterator getIterator() { return (new ConcreteIterator(list)); } } public class IteratorPattern { public static void main(String[] args) { Aggregate ag = new ConcreteAggregate(); ag.add(\\\"中山大学\\\"); ag.add(\\\"华南理工\\\"); ag.add(\\\"韶关学院\\\"); System.out.print(\\\"聚合的内容有：\\\"); Iterator it = ag.getIterator(); while (it.hasNext()) { Object ob = it.next(); System.out.print(ob.toString() + \\\"\\\\t\\\"); } Object ob = it.first(); System.out.println(\\\"\\\\nFirst：\\\" + ob.toString()); } } \"]},\"650\":{\"h\":\"迭代器模式应用实例\",\"t\":[\"应用实例：\",\"在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。\",\"设计思路分析：\",\"image-20220326155107325\",\"代码实现：\",\"专业系类\",\"public class Department { private String name; private String desc; public Department(String name, String desc) { super(); this.name = name; this.desc = desc; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } } \",\"大学接口及其实现类\",\"public interface College { public String getName(); // 增加系的方法 public void addDepartment(String name, String desc); // 返回一个迭代器,遍历 public Iterator createIterator(); } public class ComputerCollege implements College { Department[] departments; int numOfDepartment = 0 ; // 保存当前数组的对象个数 public ComputerCollege() { departments = new Department[5]; addDepartment(\\\"Java专业\\\", \\\" Java专业 \\\"); addDepartment(\\\"PHP专业\\\", \\\" PHP专业 \\\"); addDepartment(\\\"大数据专业\\\", \\\" 大数据专业 \\\"); } @Override public String getName() { return \\\"计算机学院\\\"; } @Override public void addDepartment(String name, String desc) { Department department = new Department(name, desc); departments[numOfDepartment] = department; numOfDepartment += 1; } @Override public Iterator createIterator() { return new ComputerCollegeIterator(departments); } } public class InfoCollege implements College { List<Department> departmentList; public InfoCollege() { departmentList = new ArrayList<Department>(); addDepartment(\\\"信息安全专业\\\", \\\" 信息安全专业 \\\"); addDepartment(\\\"网络安全专业\\\", \\\" 网络安全专业 \\\"); addDepartment(\\\"服务器安全专业\\\", \\\" 服务器安全专业 \\\"); } @Override public String getName() { return \\\"信息工程学院\\\"; } @Override public void addDepartment(String name, String desc) { Department department = new Department(name, desc); departmentList.add(department); } @Override public Iterator createIterator() { return new InfoColleageIterator(departmentList); } } \",\"两个院系的迭代器类\",\"public class ComputerCollegeIterator implements Iterator { // 这里我们需要 Department 是以怎样的方式存放 => 数组 Department[] departments; int position = 0; //遍历的位置 public ComputerCollegeIterator(Department[] departments) { this.departments = departments; } // 判断是否还有下一个元素 @Override public boolean hasNext() { if(position >= departments.length || departments[position] == null) { return false; }else { return true; } } @Override public Object next() { Department department = departments[position]; position += 1; return department; } // 删除的方法，默认空实现 public void remove() { } } public class InfoColleageIterator implements Iterator { List<Department> departmentList; // 信息工程学院是以 List 方式存放系 int index = -1; // 索引 public InfoColleageIterator(List<Department> departmentList) { this.departmentList = departmentList; } // 判断 list 中还有没有下一个元素 @Override public boolean hasNext() { if(index >= departmentList.size() - 1) { return false; } else { index += 1; return true; } } @Override public Object next() { return departmentList.get(index); } // 空实现 remove public void remove() { } } \",\"输出类\",\"public class OutPutImpl { // 学院集合 List<College> collegeList; public OutPutImpl(List<College> collegeList) { this.collegeList = collegeList; } // 遍历所有学院,然后调用printDepartment 输出各个学院的系 public void printCollege() { // 从 collegeList 取出所有学院, Java 中的 List 已经实现 Iterator Iterator<College> iterator = collegeList.iterator(); while(iterator.hasNext()) { //取出一个学院 College college = iterator.next(); System.out.println(\\\"=== \\\"+college.getName() +\\\"=====\\\" ); printDepartment(college.createIterator()); // 得到对应迭代器 } } // 输出 学院输出 系 public void printDepartment(Iterator iterator) { while(iterator.hasNext()) { Department d = (Department)iterator.next(); System.out.println(d.getName()); } } } \",\"测试类\",\"public class Client { public static void main(String[] args) { // 创建学院 List<College> collegeList = new ArrayList<College>(); ComputerCollege computerCollege = new ComputerCollege(); InfoCollege infoCollege = new InfoCollege(); collegeList.add(computerCollege); // collegeList.add(infoCollege); OutPutImpl outPutImpl = new OutPutImpl(collegeList); outPutImpl.printCollege(); } } \"]},\"651\":{\"h\":\"JDK-ArrayList 的迭代器模式剖析\",\"t\":[\"JDK 的 ArrayList 集合中就使用了迭代器模式。\",\"image-20220326155825142\",\"类图：\",\"image-20220326155841174\",\"对类图的角色分析和说明\",\"内部类 Itr 充当具体实现迭代器 Iterator 的类，作为 ArrayList 内部类\",\"List 就是充当了聚合接口，含有一个 iterator() 方法，返回一个迭代器对象\",\"ArrayList 是实现聚合接口 List 的子类，实现了 iterator()\",\"Iterator 接口系统提供\",\"迭代器模式解决了不同集合（ArrayList、LinkedList）统一遍历问题\"]},\"652\":{\"h\":\"迭代器模式的注意事项和细节\",\"t\":[\"迭代器模式提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以遍历对象了。\",\"迭代器模式隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成。\",\"迭代器模式提供了一种 设计思想，就是一个类应该只有一个引起变化的原因（叫做单一责任原则）。在聚合类中，我们把迭代器分开，就是要把 管理对象集合 和 遍历对象集合 的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变的话，只影响到了迭代器。\",\"当要展示一组相似对象，或者遍历一组相同对象时使用, 适合使用迭代器模式，但是每个聚合对象都要一个迭代器，会生成多个迭代器不好管理类。\"]},\"653\":{\"h\":\"迭代器模式的应用场景\",\"t\":[\"前面介绍了关于迭代器模式的结构与特点，下面介绍其应用场景，迭代器模式通常在以下几种情况使用。\",\"当需要为聚合对象提供多种遍历方式时\",\"当需要为遍历不同的聚合结构提供一个统一的接口时\",\"当访问一个聚合对象的内容而无须暴露其内部细节的表示时\",\"由于聚合与迭代器的关系非常密切，所以大多数语言在实现聚合类时都提供了迭代器类，因此大数情况下使用语言中已有的聚合类的迭代器就已经够了。\"]},\"654\":{\"h\":\"行为型中介模式\"},\"655\":{\"h\":\"中介者模式基本介绍\",\"t\":[\"中介者模式（Mediator Pattern）又叫 调停模式，它是迪米特法则的典型应用。用一个 中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其 耦合松散，而且可以独立地改变它们之间的交互。\",\"中介者模式属于行为型模式，使代码易于维护。\",\"在现实生活中，常常会出现好多对象之间存在复杂的交互关系，这种交互关系常常是「网状结构」，它要求每个对象都必须知道它需要交互的对象。例如，每个人必须记住他（她）所有朋友的电话；而且，朋友中如果有人的电话修改了，他（她）必须让其他所有的朋友一起修改，这叫作「牵一发而动全身」，非常复杂。\",\"如果把这种「网状结构」改为「星形结构」的话，将大大降低它们之间的「耦合性」，这时只要找一个「中介者」就可以了。如前面所说的「每个人必须记住所有朋友电话」的问题，只要在网上建立一个每个朋友都可以访问的「通信录」就解决了。这样的例子还有很多，例如，你刚刚参加工作想租房，可以找「房屋中介」；或者，自己刚刚到一个陌生城市找工作，可以找「人才交流中心」帮忙。\",\"比如 MVC 模式，C（Controller 控制器）是 M（Model 模型）和 V（View 视图）的中介者，在前后端交互时起到了中间人的作用。还有大家常用的 QQ 聊天程序的「中介者」是 QQ 服务器。所有这些，都可以采用「中介者模式」来实现，它将大大降低对象之间的耦合性，提高系统的灵活性。\",\"主要优点\",\"类之间各司其职，符合迪米特法则\",\"降低了对象之间的耦合性，使得对象易于独立地被复用\",\"将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展\",\"主要缺点\",\"中介者模式将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护。\"]},\"656\":{\"h\":\"中介者模式的结构与实现\",\"t\":[\"中介者模式包含以下主要角色：\",\"抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法\",\"具体中介者（Concrete Mediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色\",\"抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能\",\"具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互\",\"中介者模式的结构图如下所示：\",\"image-20220326163809453\",\"代码实现：\",\"// 抽象中介者 abstract class Mediator { public abstract void register(Colleague colleague); public abstract void relay(Colleague cl); //转发 } // 具体中介者 class ConcreteMediator extends Mediator { private List<Colleague> colleagues = new ArrayList<Colleague>(); public void register(Colleague colleague) { if (!colleagues.contains(colleague)) { colleagues.add(colleague); colleague.setMedium(this); } } public void relay(Colleague cl) { for (Colleague ob : colleagues) { if (!ob.equals(cl)) { ((Colleague) ob).receive(); } } } } // 抽象同事类 abstract class Colleague { protected Mediator mediator; public void setMedium(Mediator mediator) { this.mediator = mediator; } public abstract void receive(); public abstract void send(); } // 具体同事类 class ConcreteColleague1 extends Colleague { public void receive() { System.out.println(\\\"具体同事类1收到请求。\\\"); } public void send() { System.out.println(\\\"具体同事类1发出请求。\\\"); mediator.relay(this); //请中介者转发 } } // 具体同事类 class ConcreteColleague2 extends Colleague { public void receive() { System.out.println(\\\"具体同事类2收到请求。\\\"); } public void send() { System.out.println(\\\"具体同事类2发出请求。\\\"); mediator.relay(this); //请中介者转发 } } public class MediatorPattern { public static void main(String[] args) { Mediator md = new ConcreteMediator(); Colleague c1, c2; c1 = new ConcreteColleague1(); c2 = new ConcreteColleague2(); md.register(c1); md.register(c2); c1.send(); System.out.println(\\\"-------------\\\"); c2.send(); } } \"]},\"657\":{\"h\":\"智能家具项目\",\"t\":[\"智能家具包括各种设备：闹钟、咖啡机、电视机、窗帘等。\",\"主人要看电视时，各个设备可以协同工作，自动完成看电视的准备工作，比如流程为：闹铃响起 -> 咖啡机开始 -> 做咖啡 -> 窗帘自动落下 -> 电视机开始播放。\"]},\"658\":{\"h\":\"传统方案解决智能家具项目\",\"t\":[\"image-20220326163154437\",\"当各电器对象有多种状态改变时，相互之间的调用关系会比较复杂。\",\"各个电器对象彼此联系，你中有我，我中有你，不利于松耦合。\",\"各个电器对象之间所传递的消息(参数)，容易混乱。\",\"当系统增加一个新的电器对象时，或者执行流程改变时，代码的可维护性、扩展性都不理想 考虑 中介者模式。\"]},\"659\":{\"h\":\"中介者模式解决智能家庭项目\",\"t\":[\"思路分析和类图：\",\"image-20220326163930542\",\"代码实现：\",\"中介者类\",\"// 中介者抽象类 public abstract class Mediator { // 将给中介者对象，加入到集合中 public abstract void Register(String colleagueName, Colleague colleague); // 接收消息, 具体的同事对象发出 public abstract void GetMessage(int stateChange, String colleagueName); public abstract void SendMessage(); } // 具体的中介者类 public class ConcreteMediator extends Mediator { // 集合，放入所有的同事对象 private HashMap<String, Colleague> colleagueMap; private HashMap<String, String> interMap; public ConcreteMediator() { colleagueMap = new HashMap<String, Colleague>(); interMap = new HashMap<String, String>(); } @Override public void Register(String colleagueName, Colleague colleague) { colleagueMap.put(colleagueName, colleague); if (colleague instanceof Alarm) { interMap.put(\\\"Alarm\\\", colleagueName); } else if (colleague instanceof CoffeeMachine) { interMap.put(\\\"CoffeeMachine\\\", colleagueName); } else if (colleague instanceof TV) { interMap.put(\\\"TV\\\", colleagueName); } else if (colleague instanceof Curtains) { interMap.put(\\\"Curtains\\\", colleagueName); } } // 具体中介者的核心方法 // 1. 根据得到消息，完成对应任务 // 2. 中介者在这个方法，协调各个具体的同事对象，完成任务 @Override public void GetMessage(int stateChange, String colleagueName) { //处理闹钟发出的消息 if (colleagueMap.get(colleagueName) instanceof Alarm) { if (stateChange == 0) { ((CoffeeMachine) (colleagueMap.get(interMap .get(\\\"CoffeeMachine\\\")))).StartCoffee(); ((TV) (colleagueMap.get(interMap.get(\\\"TV\\\")))).StartTv(); } else if (stateChange == 1) { ((TV) (colleagueMap.get(interMap.get(\\\"TV\\\")))).StopTv(); } } else if (colleagueMap.get(colleagueName) instanceof CoffeeMachine) { ((Curtains) (colleagueMap.get(interMap.get(\\\"Curtains\\\")))) .UpCurtains(); } else if (colleagueMap.get(colleagueName) instanceof TV) { // 如果 TV 发现消息 } else if (colleagueMap.get(colleagueName) instanceof Curtains) { // 如果是以窗帘发出的消息，这里处理 ... } } @Override public void SendMessage() { } } \",\"智能家具类\",\"// 智能家具抽象类 public abstract class Colleague { private Mediator mediator; public String name; public Colleague(Mediator mediator, String name) { this.mediator = mediator; this.name = name; } public Mediator GetMediator() { return this.mediator; } public abstract void SendMessage(int stateChange); } // 咖啡机 public class CoffeeMachine extends Colleague { public CoffeeMachine(Mediator mediator, String name) { super(mediator, name); mediator.Register(name, this); } @Override public void SendMessage(int stateChange) { this.GetMediator().GetMessage(stateChange, this.name); } public void StartCoffee() { System.out.println(\\\"It's time to startcoffee!\\\"); } public void FinishCoffee() { System.out.println(\\\"After 5 minutes!\\\"); System.out.println(\\\"Coffee is ok!\\\"); SendMessage(0); } } // 电视机 public class TV extends Colleague { public TV(Mediator mediator, String name) { super(mediator, name); mediator.Register(name, this); } @Override public void SendMessage(int stateChange) { this.GetMediator().GetMessage(stateChange, this.name); } public void StartTv() { System.out.println(\\\"It's time to StartTv!\\\"); } public void StopTv() { System.out.println(\\\"StopTv!\\\"); } } // 窗帘 public class Curtains extends Colleague { public Curtains(Mediator mediator, String name) { super(mediator, name); mediator.Register(name, this); } @Override public void SendMessage(int stateChange) { this.GetMediator().GetMessage(stateChange, this.name); } public void UpCurtains() { System.out.println(\\\"I am holding Up Curtains!\\\"); } } // 闹钟 public class Alarm extends Colleague { // 构造器 public Alarm(Mediator mediator, String name) { super(mediator, name); // 在创建 Alarm 同事对象时，将自己放入到 ConcreteMediator 对象中[集合] mediator.Register(name, this); } public void SendAlarm(int stateChange) { SendMessage(stateChange); } @Override public void SendMessage(int stateChange) { // 调用的中介者对象的 getMessage this.GetMediator().GetMessage(stateChange, this.name); } } \",\"测试类\",\"public class ClientTest { public static void main(String[] args) { // 创建一个中介者对象 Mediator mediator = new ConcreteMediator(); // 创建 Alarm 并且加入到 ConcreteMediator 对象的HashMap Alarm alarm = new Alarm(mediator, \\\"alarm\\\"); // 创建了 CoffeeMachine 对象，并 且加入到 ConcreteMediator 对象的 HashMap CoffeeMachine coffeeMachine = new CoffeeMachine(mediator, \\\"coffeeMachine\\\"); // 创建 Curtains，并且加入到 ConcreteMediator 对象的HashMap Curtains curtains = new Curtains(mediator, \\\"curtains\\\"); TV tV = new TV(mediator, \\\"TV\\\"); // 让闹钟发出消息 alarm.SendAlarm(0); coffeeMachine.FinishCoffee(); alarm.SendAlarm(1); } } \"]},\"660\":{\"h\":\"中介者模式的注意事项和细节\",\"t\":[\"传统下多个类相互耦合，会形成网状结构, 使用中介者模式将网状结构分离为星型结构，进行解耦\",\"中介者模式减少类间依赖，降低了耦合，符合迪米特原则\",\"中介者承担了较多的责任，一旦中介者出现了问题，整个系统就会受到影响\",\"如果设计不当，中介者对象本身变得过于复杂，这点在实际使用时，要特别注意\"]},\"661\":{\"h\":\"中介者模式的应用场景\",\"t\":[\"前面分析了中介者模式的结构与特点，下面分析其以下应用场景：\",\"当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时\",\"当想创建一个运行于多个类之间的对象，又不想生成新的子类时\"]},\"662\":{\"h\":\"行为型备忘录模式\"},\"663\":{\"h\":\"备忘录模式基本介绍\",\"t\":[\"备忘录模式（Memento Pattern）又叫 快照模式，在 不破坏封装性的前提下，捕获 一个对象的内部状态，并在该对象之外保存这个状态。这样以后就 可将该对象恢复到原先保存的状态。\",\"备忘录模式属于行为型模式。\",\"可以这里理解备忘录模式：现实生活中的备忘录是用来记录某些要去做的事情，或者是记录已经达成的共同意见的事情，以防忘记了。而在软件层面，备忘录模式有着相同的含义，备忘录对象主要用来记录一个对象的某种状态，或者某些数据，当要做回退时，可以从备忘录对象里获取原来的数据进行恢复操作。\",\"其实很多应用软件都提供了这项功能，如 Word、记事本、Photoshop、Eclipse 等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 IE 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。\",\"主要优点\",\"提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态\",\"实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息\",\"简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则\",\"主要缺点\",\"资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。\"]},\"664\":{\"h\":\"备忘录模式的结构与实现\",\"t\":[\"备忘录模式的核心是设计备忘录类以及用于管理备忘录的管理者类。\",\"备忘录模式的主要角色如下：\",\"发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息\",\"备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。\",\"管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改\",\"备忘录模式的结构图如下图所示：\",\"image-20220326165253607\",\"代码实现：\",\"// 备忘录 class Memento { private String state; public Memento(String state) { this.state = state; } public void setState(String state) { this.state = state; } public String getState() { return state; } } // 发起人 class Originator { private String state; public void setState(String state) { this.state = state; } public String getState() { return state; } public Memento createMemento() { return new Memento(state); } public void restoreMemento(Memento m) { this.setState(m.getState()); } } // 管理者 class Caretaker { private Memento memento; public void setMemento(Memento m) { memento = m; } public Memento getMemento() { return memento; } } public class MementoPattern { public static void main(String[] args) { Originator or = new Originator(); Caretaker cr = new Caretaker(); or.setState(\\\"S0\\\"); System.out.println(\\\"初始状态:\\\" + or.getState()); cr.setMemento(or.createMemento()); //保存状态 or.setState(\\\"S1\\\"); System.out.println(\\\"新的状态:\\\" + or.getState()); or.restoreMemento(cr.getMemento()); //恢复状态 System.out.println(\\\"恢复状态:\\\" + or.getState()); } } \"]},\"665\":{\"h\":\"游戏角色状态恢复问题\",\"t\":[\"游戏角色有攻击力和防御力，在大战 Boss 前保存自身的状态（攻击力和防御力），当大战 Boss 后攻击力和防御力下降，从备忘录对象恢复到大战前的状态。\"]},\"666\":{\"h\":\"传统方案解决游戏角色恢复\",\"t\":[\"image-20220326164847860\",\"一个对象，就对应一个保存对象状态的对象，这样当我们游戏的对象很多时，不利于管理，开销也很大。\",\"传统的方式是简单地做备份，new 出另外一个对象出来，再把需要备份的数据放到这个新对象，但这就暴露了对象内部的细节\",\"解决方案：备忘录模式。\"]},\"667\":{\"h\":\"备忘录模式解决游戏角色恢复\",\"t\":[\"思路分析和类图：\",\"image-20220326165601510\",\"代码实现：\",\"备忘录类\",\"public class Memento { // 攻击力 private int vit; // 防御力 private int def; public Memento(int vit, int def) { super(); this.vit = vit; this.def = def; } public int getVit() { return vit; } public void setVit(int vit) { this.vit = vit; } public int getDef() { return def; } public void setDef(int def) { this.def = def; } } \",\"管理类\",\"// 守护者对象, 保存游戏角色的状态 public class Caretaker { // 如果只保存一次状态 private Memento memento; public Memento getMemento() { return memento; } public void setMemento(Memento memento) { this.memento = memento; } } \",\"发起人类\",\"public class GameRole { private int vit; private int def; // 创建 Memento ,即根据当前的状态得到 Memento public Memento createMemento() { return new Memento(vit, def); } // 从备忘录对象，恢复 GameRole 的状态 public void recoverGameRoleFromMemento(Memento memento) { this.vit = memento.getVit(); this.def = memento.getDef(); } // 显示当前游戏角色的状态 public void display() { System.out.println(\\\"游戏角色当前的攻击力：\\\" + this.vit + \\\" 防御力: \\\" + this.def); } public int getVit() { return vit; } public void setVit(int vit) { this.vit = vit; } public int getDef() { return def; } public void setDef(int def) { this.def = def; } } \",\"测试类\",\"public class Client { public static void main(String[] args) { // 创建游戏角色 GameRole gameRole = new GameRole(); gameRole.setVit(100); gameRole.setDef(100); System.out.println(\\\"和boss大战前的状态\\\"); gameRole.display(); // 把当前状态保存 caretaker Caretaker caretaker = new Caretaker(); caretaker.setMemento(gameRole.createMemento()); System.out.println(\\\"和boss大战~~~\\\"); gameRole.setDef(30); gameRole.setVit(30); gameRole.display(); System.out.println(\\\"大战后，使用备忘录对象恢复到站前\\\"); gameRole.recoverGameRoleFromMemento(caretaker.getMemento()); System.out.println(\\\"恢复后的状态\\\"); gameRole.display(); } } \"]},\"668\":{\"h\":\"备忘录模式的注意事项和细节\",\"t\":[\"备忘录模式给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态\",\"备忘录模式实现了信息的封装，使得用户不需要关心状态的保存细节\",\"如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存，这个需要注意\",\"为了节约内存，备忘录模式可以和原型模式配合使用\"]},\"669\":{\"h\":\"备忘录模式的应用场景\",\"t\":[\"前面学习了备忘录模式的定义与特点、结构与实现，现在来看该模式的以下应用场景：\",\"需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能\",\"需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作\"]},\"670\":{\"h\":\"行为型观察者模式\"},\"671\":{\"h\":\"观察者模式基本介绍\",\"t\":[\"在现实世界中，许多对象并不是独立存在的，其中一个对象的行为发生改变可能会导致一个或者多个其他对象的行为也发生改变。例如，某种商品的物价上涨时会导致部分商家高兴，而消费者伤心；还有，当我们开车到交叉路口时，遇到红灯会停，遇到绿灯会行。这样的例子还有很多，例如，股票价格与股民、微信公众号与微信用户、气象局的天气预报与听众、小偷与警察等。\",\"观察者模式（Observer Pattern）的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。\",\"观察者模式是一种对象行为型模式。\",\"主要优点\",\"降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则\",\"目标与观察者之间建立了一套触发机制\",\"主要缺点\",\"目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用\",\"当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率\"]},\"672\":{\"h\":\"观察者模式的结构与实现\",\"t\":[\"实现观察者模式时要注意具体目标对象和具体观察者对象之间不能直接调用，否则将使两者之间紧密耦合起来，这违反了面向对象的设计原则。\",\"观察者模式的主要角色如下：\",\"抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法\",\"具体主题（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象\",\"抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用\",\"具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态\",\"观察者模式的结构图如下所示：\",\"image-20220326161321893\",\"代码实现：\",\"// 抽象目标 abstract class Subject { protected List<Observer> observers = new ArrayList<Observer>(); // 增加观察者方法 public void add(Observer observer) { observers.add(observer); } // 删除观察者方法 public void remove(Observer observer) { observers.remove(observer); } public abstract void notifyObserver(); // 通知观察者方法 } // 具体目标 class ConcreteSubject extends Subject { public void notifyObserver() { System.out.println(\\\"具体目标发生改变...\\\"); System.out.println(\\\"--------------\\\"); for (Object obs : observers) { ((Observer) obs).response(); } } } // 抽象观察者 interface Observer { void response(); // 反应 } // 具体观察者1 class ConcreteObserver1 implements Observer { public void response() { System.out.println(\\\"具体观察者1作出反应！\\\"); } } // 具体观察者 1 class ConcreteObserver2 implements Observer { public void response() { System.out.println(\\\"具体观察者2作出反应！\\\"); } } public class ObserverPattern { public static void main(String[] args) { Subject subject = new ConcreteSubject(); Observer obs1 = new ConcreteObserver1(); Observer obs2 = new ConcreteObserver2(); subject.add(obs1); subject.add(obs2); subject.notifyObserver(); } } \"]},\"673\":{\"h\":\"天气预报项目需求\",\"t\":[\"气象站可以将每天测量到的温度，湿度，气压等等以公告的形式发布出去（比如发布到自己的网站或第三方）\",\"需要设计开放型 API，便于其他第三方也能接入气象站获取数据\",\"提供温度、气压和湿度的接口\",\"测量数据更新时，要能实时的通知给第三方\"]},\"674\":{\"h\":\"普通方案解决天气预报需求\"},\"675\":{\"h\":\"逻辑分析\",\"t\":[\"传统的设计方案初步设计出一个 WeatherData 类。\",\"image-20220326160526405\",\"说明：\",\"通过 getXxx 方法，可以让第三方接入，并得到相关信息\",\"当数据有更新时，气象站通过调用 dataChange() 去更新数据，当第三方再次获取时，就能得到最新数据，当然也可以推送\",\"image-20220326160613310\",\"CurrentConditions 可以理解成是我们气象局的网站。\"]},\"676\":{\"h\":\"代码实现\",\"t\":[\"public class CurrentConditions { // 温度，气压，湿度 private float temperature; private float pressure; private float humidity; // 更新 天气情况，是由 WeatherData 来调用，我使用推送模式 public void update(float temperature, float pressure, float humidity) { this.temperature = temperature; this.pressure = pressure; this.humidity = humidity; display(); } // 显示 public void display() { System.out.println(\\\"***Today mTemperature: \\\" + temperature + \\\"***\\\"); System.out.println(\\\"***Today mPressure: \\\" + pressure + \\\"***\\\"); System.out.println(\\\"***Today mHumidity: \\\" + humidity + \\\"***\\\"); } } public class WeatherData { private float temperatrue; private float pressure; private float humidity; private CurrentConditions currentConditions; // 加入新的第三方 public WeatherData(CurrentConditions currentConditions) { this.currentConditions = currentConditions; } public float getTemperature() { return temperatrue; } public float getPressure() { return pressure; } public float getHumidity() { return humidity; } public void dataChange() { // 调用接入方的 update currentConditions.update(getTemperature(), getPressure(), getHumidity()); } // 当数据有更新时，就调用 setData public void setData(float temperature, float pressure, float humidity) { this.temperatrue = temperature; this.pressure = pressure; this.humidity = humidity; // 调用 dataChange， 将最新的信息推送给接入方 currentConditions dataChange(); } } \",\"测试类\",\"public class Client { public static void main(String[] args) { // 创建接入方 currentConditions CurrentConditions currentConditions = new CurrentConditions(); // 创建 WeatherData 并将接入方 currentConditions 传递到 WeatherData中 WeatherData weatherData = new WeatherData(currentConditions); // 更新天气情况 weatherData.setData(30, 150, 40); // 天气情况变化 System.out.println(\\\"============天气情况变化=============\\\"); weatherData.setData(40, 160, 20); } } \"]},\"677\":{\"h\":\"问题分析\",\"t\":[\"其他第三方接入气象站获取数据的问题\",\"无法在运行时动态的添加第三方 (如新浪网站）\",\"违反 OCP 原则\",\"在 WeatherData 中，当增加一个第三方，都需要创建一个对应的第三方的公告板对象，并加入到 dataChange, 不利于维护，也不是动态加入\",\"所以我们可以使用 观察者模式，\"]},\"678\":{\"h\":\"观察者模式解决天气预报需求\",\"t\":[\"类图：\",\"image-20220326162333026\",\"代码实现：\",\"观察者类\",\"// 观察者接口，有观察者来实现 public interface Observer { public void update(float temperature, float pressure, float humidity); } public class BaiduSite implements Observer { // 温度，气压，湿度 private float temperature; private float pressure; private float humidity; // 更新 天气情况，是由 WeatherData 来调用，我使用推送模式 public void update(float temperature, float pressure, float humidity) { this.temperature = temperature; this.pressure = pressure; this.humidity = humidity; display(); } // 显示 public void display() { System.out.println(\\\"===百度网站====\\\"); System.out.println(\\\"***百度网站 气温 : \\\" + temperature + \\\"***\\\"); System.out.println(\\\"***百度网站 气压: \\\" + pressure + \\\"***\\\"); System.out.println(\\\"***百度网站 湿度: \\\" + humidity + \\\"***\\\"); } } public class CurrentConditions implements Observer { // 温度，气压，湿度 private float temperature; private float pressure; private float humidity; // 更新 天气情况，是由 WeatherData 来调用，我使用推送模式 public void update(float temperature, float pressure, float humidity) { this.temperature = temperature; this.pressure = pressure; this.humidity = humidity; display(); } // 显示 public void display() { System.out.println(\\\"***Today mTemperature: \\\" + temperature + \\\"***\\\"); System.out.println(\\\"***Today mPressure: \\\" + pressure + \\\"***\\\"); System.out.println(\\\"***Today mHumidity: \\\" + humidity + \\\"***\\\"); } } \",\"数据类\",\"// 接口, 让 WeatherData 来实现 public interface Subject { public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObservers(); } /** * 类是核心 * 1. 包含最新的天气情况信息 * 2. 含有 观察者集合，使用 ArrayList 管理 * 3. 当数据有更新时，就主动的调用 ArrayList，通知所有的（接入方）就看到最新的信息 */ public class WeatherData implements Subject { private float temperatrue; private float pressure; private float humidity; // 观察者集合 private ArrayList<Observer> observers; // 加入新的第三方 public WeatherData() { observers = new ArrayList<Observer>(); } public float getTemperature() { return temperatrue; } public float getPressure() { return pressure; } public float getHumidity() { return humidity; } public void dataChange() { // 调用 接入方的 update notifyObservers(); } // 当数据有更新时，就调用 setData public void setData(float temperature, float pressure, float humidity) { this.temperatrue = temperature; this.pressure = pressure; this.humidity = humidity; // 调用 dataChange， 将最新的信息推送给接入方 currentConditions dataChange(); } // 注册一个观察者 @Override public void registerObserver(Observer o) { observers.add(o); } // 移除一个观察者 @Override public void removeObserver(Observer o) { if(observers.contains(o)) { observers.remove(o); } } // 遍历所有的观察者，并通知 @Override public void notifyObservers() { for(int i = 0; i < observers.size(); i++) { observers.get(i).update(this.temperatrue, this.pressure, this.humidity); } } } \",\"测试类\",\"public class Client { public static void main(String[] args) { // 创建一个 WeatherData WeatherData weatherData = new WeatherData(); // 创建观察者 CurrentConditions currentConditions = new CurrentConditions(); BaiduSite baiduSite = new BaiduSite(); // 注册到 WeatherData weatherData.registerObserver(currentConditions); weatherData.registerObserver(baiduSite); // 测试 System.out.println(\\\"通知各个注册的观察者, 看看信息\\\"); weatherData.setData(10f, 100f, 30.3f); weatherData.removeObserver(currentConditions); // 测试 System.out.println(); System.out.println(\\\"通知各个注册的观察者, 看看信息\\\"); weatherData.setData(10f, 100f, 30.3f); } } \",\"使用了观察者模式设计后，会以集合的方式来管理用户（Observer），包括注册，移除和通知。这样，我们增加观察者（这里可以理解成一个新的公告板），就不需要去修改核心类 WeatherData 不会修改代码，遵守了 OCP 原则。\"]},\"679\":{\"h\":\"JDK 的观察者模式剖析\",\"t\":[\"JDK 的 Observable 类就使用了观察者模式。\",\"image-20220326162754094\",\"Observable 的作用和地位等价于我们前面讲过 Subject\",\"Observable 是类，不是接口，类中已经实现了核心的方法，即管理 Observer 的方法 add、delete、notify\",\"Observer 的作用和地位等价于我们前面讲过的 Observer，有 update\",\"Observable 和 Observer 的使用方法和前面讲过的一样，只是 Observable 是类，通过继承来实现观察者模式\"]},\"680\":{\"h\":\"观察者模式的应用场景\",\"t\":[\"在软件系统中，当系统一方行为依赖另一方行为的变动时，可使用观察者模式松耦合联动双方，使得一方的变动可以通知到感兴趣的另一方对象，从而让另一方对象对此做出响应。\",\"通过前面的分析与应用实例可知观察者模式适合以下几种情形：\",\"对象间存在一对多关系，一个对象的状态发生改变会影响其他对象\",\"当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用\",\"实现类似广播机制的功能，不需要知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收该广播\",\"多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知\"]},\"681\":{\"h\":\"创建型原型模式\"},\"682\":{\"h\":\"原型模式基本介绍\",\"t\":[\"在有些系统中，存在大量相同或相似对象的创建问题，如果用传统的构造函数来创建对象，会比较复杂且耗时耗资源，用原型模式生成对象就很高效，就像孙悟空拔下猴毛轻轻一吹就变出很多孙悟空一样简单。\",\"原型模式（Prototype Pattern）是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。\",\"原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节。\",\"工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()。\",\"主要优点\",\"Java 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良\",\"可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作\",\"主要缺点\",\"需要为每一个类都配置一个 clone 方法\",\"clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则\",\"当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当\"]},\"683\":{\"h\":\"原型模式原理结构图\",\"t\":[\"原型模式包含以下主要角色：\",\"抽象原型类（Prototype）：原型接口，声明一个克隆自己的接口，规定了具体原型对象必须实现的接口\",\"具体原型类（ConcretePrototype）：实现原型接口的原型类，实现一个克隆自己的操作\",\"访问类（Client）：让一个原型对象克隆自己，从而创建一个新的对象（属性一样）\",\"image-20220301174940372\"]},\"684\":{\"h\":\"克隆羊案例\",\"t\":[\"现在有一只羊 tom，姓名为：tom, 年龄为：1，颜色为：白色，请编写程序创建和 tom 羊属性完全相同的 10 只羊。\"]},\"685\":{\"h\":\"传统方式解决克隆羊实例\",\"t\":[\"思路分析（图解）\",\"image-20220301174437773\",\"Sheep 类代码：\",\"public class Sheep { private String name; private int age; private String color; public Sheep(String name, int age, String color) { super(); this.name = name; this.age = age; this.color = color; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } @Override public String toString() { return \\\"Sheep [name=\\\" + name + \\\", age=\\\" + age + \\\", color=\\\" + color + \\\"]\\\"; } } \",\"Client 类代码：\",\"public class Client { public static void main(String[] args) { // 传统的方法 Sheep sheep = new Sheep(\\\"tom\\\", 1, \\\"白色\\\"); Sheep sheep2 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep3 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep4 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep5 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); // ... System.out.println(sheep); System.out.println(sheep2); System.out.println(sheep3); System.out.println(sheep4); System.out.println(sheep5); // ... } } \"]},\"686\":{\"h\":\"传统的方式的优缺点\",\"t\":[\"优点是比较好理解，简单易操作\",\"在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低\",\"总是需要重新初始化对象，而不是动态地获得对象运行时的状态, 不够灵活\",\"改进的思路分析：Java 中 Object 类是所有类的根类，Object 类提供了一个 clone() 方法，该方法可以将一个 Java 对象复制一份，但是需要实现 clone 的 Java 类必须要实现一个接口 Cloneable，该接口表示该类能够复制且具有复制的能力，使用 原型模式。\"]},\"687\":{\"h\":\"原型模式解决克隆羊实例\",\"t\":[\"使用原型模式改进传统方式，让程序具有更高的效率和扩展性。\",\"Sheep 类：\",\"public class Sheep implements Cloneable { private String name; private int age; private String color; private String address = \\\"蒙古羊\\\"; public Sheep friend; // 是对象，克隆是会如何处理 public Sheep(String name, int age, String color) { super(); this.name = name; this.age = age; this.color = color; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } @Override public String toString() { return \\\"Sheep [name=\\\" + name + \\\", age=\\\" + age + \\\", color=\\\" + color + \\\", address=\\\" + address + \\\"]\\\"; } // 克隆该实例，使用默认的 clone 方法来完成 @Override protected Object clone() { Sheep sheep = null; try { sheep = (Sheep) super.clone(); } catch (Exception e) { System.out.println(e.getMessage()); } return sheep; } } \",\"Client 类：\",\"public class Client { public static void main(String[] args) { System.out.println(\\\"原型模式完成对象的创建\\\"); Sheep sheep = new Sheep(\\\"tom\\\", 1, \\\"白色\\\"); sheep.friend = new Sheep(\\\"jack\\\", 2, \\\"黑色\\\"); Sheep sheep2 = (Sheep) sheep.clone(); // 克隆 Sheep sheep3 = (Sheep) sheep.clone(); // 克隆 Sheep sheep4 = (Sheep) sheep.clone(); // 克隆 Sheep sheep5 = (Sheep) sheep.clone(); // 克隆 System.out.println(\\\"sheep2 =\\\" + sheep2 + \\\"sheep2.friend=\\\" + sheep2.friend.hashCode()); System.out.println(\\\"sheep3 =\\\" + sheep3 + \\\"sheep3.friend=\\\" + sheep3.friend.hashCode()); System.out.println(\\\"sheep4 =\\\" + sheep4 + \\\"sheep4.friend=\\\" + sheep4.friend.hashCode()); System.out.println(\\\"sheep5 =\\\" + sheep5 + \\\"sheep5.friend=\\\" + sheep5.friend.hashCode()); } } \"]},\"688\":{\"h\":\"Spring 框架的原型模式\",\"t\":[\"Spring 中原型 bean 的创建，就是原型模式。\",\"image-20220301175359902\"]},\"689\":{\"h\":\"深入讨论：浅拷贝和深拷贝\",\"t\":[\"浅拷贝的介绍\",\"对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象\",\"对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值\",\"前面我们克隆羊案例就是浅拷贝\",\"浅拷贝是使用默认的 clone() 方法来实现：sheep = (Sheep) super.clone();\",\"深拷贝基本介绍\",\"复制对象的所有基本数据类型的成员变量值\",\"为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象 \\\\ 可达的所有对象。也就是说，对象进行深拷贝要对整个对象（包括对象的引用类型）进行拷贝\",\"深拷贝实现方式 1：重写 clone 方法来实现深拷贝\",\"深拷贝实现方式 2：通过 对象序列化 实现深拷贝（推荐）\",\"深拷贝应用实例\",\"使用 重写 clone 方法实现深拷贝\",\"使用序列化来实现深拷贝\",\"DeepCloneableTarget 类\",\"public class DeepCloneableTarget implements Serializable, Cloneable { private static final long serialVersionUID = 1L; private String cloneName; private String cloneClass; // 构造器 public DeepCloneableTarget(String cloneName, String cloneClass) { this.cloneName = cloneName; this.cloneClass = cloneClass; } // 因为该类的属性，都是 String , 因此我们这里使用默认的 clone 完成即可 @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } \",\"DeepProtoType 类\",\"public class DeepProtoType implements Serializable, Cloneable { public String name; // String 属性 public DeepCloneableTarget deepCloneableTarget; // 引用类型 public DeepProtoType() { super(); } // 深拷贝 - 方式 1 使用 clone 方法 @Override protected Object clone() throws CloneNotSupportedException { Object deep = null; // 这里完成对基本数据类型（属性）和 String 的克隆 deep = super.clone(); // 对引用类型的属性，进行单独处理 DeepProtoType deepProtoType = (DeepProtoType) deep; deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone(); return deepProtoType; } // 深拷贝 - 方式 2 通过对象的序列化实现 (推荐) public Object deepClone() { // 创建流对象 ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; ByteArrayInputStream bis = null; ObjectInputStream ois = null; try { // 序列化 bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); oos.writeObject(this); // 当前这个对象以对象流的方式输出 // 反序列化 bis = new ByteArrayInputStream(bos.toByteArray()); ois = new ObjectInputStream(bis); DeepProtoType copyObj = (DeepProtoType) ois.readObject(); return copyObj; } catch (Exception e) { e.printStackTrace(); return null; } finally { // 关闭流 try { bos.close(); oos.close(); bis.close(); ois.close(); } catch (Exception e2) { System.out.println(e2.getMessage()); } } } } \",\"Client 类\",\"public class Client { public static void main(String[] args) throws Exception { DeepProtoType p = new DeepProtoType(); p.name = \\\"宋江\\\"; p.deepCloneableTarget = new DeepCloneableTarget(\\\"大牛\\\", \\\"小牛\\\"); // 方式 1：完成深拷贝 // DeepProtoType p2 = (DeepProtoType) p.clone(); // System.out.println(\\\"p.name=\\\" + p.name + \\\"p.deepCloneableTarget=\\\" + p.deepCloneableTarget.hashCode()); // System.out.println(\\\"p2.name=\\\" + p.name + \\\"p2.deepCloneableTarget=\\\" + p2.deepCloneableTarget.hashCode()); // 方式 2：完成深拷贝 DeepProtoType p2 = (DeepProtoType) p.deepClone(); System.out.println(\\\"p.name=\\\" + p.name + \\\"p.deepCloneableTarget=\\\" + p.deepCloneableTarget.hashCode()); System.out.println(\\\"p2.name=\\\" + p.name + \\\"p2.deepCloneableTarget=\\\" + p2.deepCloneableTarget.hashCode()); } } \",\"DeepProtoType 是引用类型，类似于常写的 Person、Animal 类等。\",\"方式一：如果直接调用引用类型的 clone 方法，则是浅拷贝。那么再创键一个类（成员变量有引用类型），在该类的 clone 方法里返回成员变量（引用类型），返回前，调用引用类型的 clone 方法赋值给成员变量即可\",\"方式二：利用了序列化和反序列化，推荐\"]},\"690\":{\"h\":\"原型模式的注意事项和细节\",\"t\":[\"创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率\",\"不用重新初始化对象，而是动态地获得对象运行时的状态\",\"如果原始对象发生变化（增加或者减少属性），其它克隆对象的也会发生相应的变化，无需修改代码\",\"在实现深克隆的时候可能需要比较复杂的代码\",\"缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了 OCP 原则\"]},\"691\":{\"h\":\"结构型代理模式\"},\"692\":{\"h\":\"代理模式的基本介绍\",\"t\":[\"在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。\",\"在软件设计中，使用代理模式的例子也很多，例如，要访问的远程对象比较大（如视频或大图像等），其下载要花很多时间。还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。\",\"代理模式（Proxy Pattern）：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。\",\"被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象。\",\"代理模式有不同的形式，主要有三种 静态代理、动态代理（JDK 代理、接口代理）和 Cglib 代理（可以在内存动态的创建对象，而不需要实现接口，他是属于动态代理的范畴）。\",\"主要优点\",\"代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用\",\"代理对象可以扩展目标对象的功能\",\"代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性\",\"主要缺点\",\"代理模式会造成系统设计中类的数量增加\",\"在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢\",\"增加了系统的复杂度\",\"代理模式示意图：\",\"image-20220314192143394\"]},\"693\":{\"h\":\"静态代理\"},\"694\":{\"h\":\"静态代理基本介绍\",\"t\":[\"静态代理在使用时，需要定义接口或者父类，被代理对象（即目标对象）与代理对象一起实现相同的接口或者是继承相同父类。\",\"代理模式的主要角色如下：\",\"抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法\",\"真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象\",\"代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能\",\"image-20220316221211102\",\"在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。\"]},\"695\":{\"h\":\"静态代理应用实例\",\"t\":[\"定义一个接口：ITeacherDao\",\"目标对象 TeacherDAO 实现接口 ITeacherDAO\",\"使用静态代理方式，就需要在代理对象 TeacherDAOProxy 中也实现 ITeacherDAO\",\"调用的时候通过调用代理对象的方法来调用目标对象\",\"特别提醒：代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法。\",\"思路分析图解（类图）\",\"image-20220316213701600\",\"代码实现\",\"// 接口 public interface ITeacherDao { void teach(); // 授课的方法 } // 被代理对象，目标对象，实际访问的对象 public class TeacherDao implements ITeacherDao { @Override public void teach() { System.out.println(\\\" 老师授课中\\\"); } } // 代理对象，静态代理 public class TeacherDaoProxy implements ITeacherDao{ private ITeacherDao target; // 目标对象，通过接口来聚合 // 构造器 public TeacherDaoProxy(ITeacherDao target) { this.target = target; } @Override public void teach() { System.out.println(\\\"开始代理，上课前先备课\\\"); // 方法 target.teach(); // 被代理对象的方法 System.out.println(\\\"40 分钟后下课\\\"); // 方法 } } \",\"测试类\",\"public class Client { public static void main(String[] args) { // 创建目标对象（被代理对象） TeacherDao teacherDao = new TeacherDao(); // 创建代理对象, 同时将被代理对象传递给代理对象 TeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDao); // 通过代理对象，调用到被代理对象的方法 // 即：执行的是代理对象的方法，代理对象再去调用目标对象的方法 teacherDaoProxy.teach(); } } \"]},\"696\":{\"h\":\"静态代理优缺点\",\"t\":[\"优点：在不修改目标对象的功能前提下, 能通过代理对象对目标功能扩展\",\"缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类，一旦接口增加方法，目标对象与代理对象都要维护\"]},\"697\":{\"h\":\"动态代理\"},\"698\":{\"h\":\"动态代理基本介绍\",\"t\":[\"代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理。\",\"代理对象的生成，是利用 JDK 的 API，动态的在内存中构建代理对象。\",\"动态代理也叫做：JDK 代理、接口代理。\"]},\"699\":{\"h\":\"JDK 中生成代理对象的 API\",\"t\":[\"代理类所在包：java.lang.reflect.Proxy。\",\"JDK 实现代理只需要使用 newProxyInstance 方法，但是该方法需要接收三个参数，完整的写法是：\",\"static Object newProxyInstance(ClassLoader loader, Class[] interfaces,InvocationHandler h) \",\"人性化解释\",\"我们已经写了一个对象，这个对象已经成型（目标对象，旧对象）\",\"时代变化，新功能出现，但是原来的目标对象成型，很难添加新的东西，于是我们需要重新造出一个对象\",\"要求新的对象有旧的对象的所有功能，同时添加新的功能，于是需要 Proxy 动态代理（母亲）\",\"怎么造出新对象呢，我们首先需要旧对象的基因（类加载器）和该对象的父类基因（类的父接口）\",\"研究旧对象和其父亲的基因，造出新的对象，并且在造出的过程添加新的功能，于是新的对象更加全面\",\"image-20220325225306403\"]},\"700\":{\"h\":\"动态代理应用实例\",\"t\":[\"将前面的静态代理改进成动态代理模式（即：JDK 代理模式）。\",\"类图\",\"image-20220316215716168\",\"代码实现\",\"// 接口 public interface ITeacherDao { void teach(); // 授课方法 void sayHello(String name); } public class TeacherDao implements ITeacherDao { @Override public void teach() { System.out.println(\\\" 老师授课中.... \\\"); } @Override public void sayHello(String name) { System.out.println(\\\"hello \\\" + name); } } \",\"动态代理类\",\"public class ProxyFactory { // 维护一个目标对象，Object private Object target; // 构造器，对 target 进行初始化 public ProxyFactory(Object target) { this.target = target; } // 给目标对象 生成一个代理对象 public Object getProxyInstance() { // 说明 /* * public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h) // 1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定 // 2. Class<?>[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型 // 3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入 */ return Proxy.newProxyInstance( // 需要类加载器 target.getClass().getClassLoader(), // 需要父类接口 target.getClass().getInterfaces(), // 创建新的对象 new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\\\"JDK 代理开始 ~~，开始上课\\\"); // 反射机制调用目标对象的方法 Object returnVal = method.invoke(target, args); System.out.println(\\\"JDK 代理提交，开始下课\\\"); return returnVal; } }); } } \",\"测试类\",\"public class Client { public static void main(String[] args) { // 创建目标对象 ITeacherDao target = new TeacherDao(); // 给目标对象，创建代理对象, 可以转成 ITeacherDao ITeacherDao proxyInstance = (ITeacherDao) new ProxyFactory(target).getProxyInstance(); // proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象 System.out.println(\\\"proxyInstance=\\\" + proxyInstance.getClass()); // 通过代理对象，调用目标对象的方法 //proxyInstance.teach(); proxyInstance.sayHello(\\\" tom \\\"); } } \"]},\"701\":{\"h\":\"Cglib 代理\"},\"702\":{\"h\":\"Cglib 代理基本介绍\",\"t\":[\"静态代理和 JDK 代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个 单独的对象，并没有 实现任何的接口，这个时候可使用目标对象子类来实现代理，这就是 Cglib 代理。\",\"Cglib 代理也叫作子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能扩展，有些书也将 Cglib 代理归属到动态代理。\",\"Cglib 是一个强大的高性能的代码生成包，它可以在运行期扩展 Java 类与实现 Java 接口。它广泛的被许多 AOP 的框架使用，例如 Spring AOP，实现方法拦截。\",\"在 AOP 编程中如何选择代理模式：\",\"目标对象需要实现接口，用 JDK 代理\",\"目标对象不需要实现接口，用 Cglib 代理\",\"Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类。\",\"image-20220325225354561\",\"思路\",\"创建目标对象\",\"创建增强器，相当于JDK动态代理需要的 父接口\",\"设置要生成代理对象的目标对象的类\",\"设置回调方法，里面指定生成目标对象的过程\",\"执行生成目标对象\",\"执行目标对象的方法\",\"人性化解释\",\"我们已经写了一个对象，这个对象已经成型（目标对象）\",\"时代变化，新功能出现，但是原来的对象成型，很难添加新的东西，于是我们需要重新造出一个对象\",\"要求新的对象有旧的对象的所有功能，同时添加新的功能，于是需要 Proxy 动态代理（母亲）\",\"怎么造出新对象呢，我们先造出代理对象的雏形（形状），然后给雏形找个父亲（目标对象的类）\",\"让父亲和母亲造出新的对象，然后放进这个雏形（形状）里，并且在造出的过程添加新的功能，于是新的对象更加全面\"]},\"703\":{\"h\":\"Cglib 代理模式应用实例\",\"t\":[\"将前面的案例用 Cglib 代理模式实现。\",\"image-20220316220549595\",\"代码实现\",\"// Cglib 代理不需要接口 public class TeacherDao { public String teach() { System.out.println(\\\" 老师授课中 ，我是cglib代理，不需要实现接口 \\\"); return \\\"hello\\\"; } } \",\"Cglib 代码类\",\"public class ProxyFactory implements MethodInterceptor { // 维护一个目标对象 private Object target; // 构造器，传入一个被代理的对象 public ProxyFactory(Object target) { this.target = target; } // 返回一个代理对象: 是 target 对象的代理对象 public Object getProxyInstance() { // 1. 创建一个增强器，相当于代理对象的雏形 Enhancer enhancer = new Enhancer(); // 2. 设置父类 enhancer.setSuperclass(target.getClass()); // 3. 设置回调函数 enhancer.setCallback(this); // 4. 创建子类对象，即代理对象 return enhancer.create(); } // 重写 intercept 方法，会调用目标对象的方法 @Override public Object intercept(Object arg0, Method method, Object[] args, MethodProxy arg3) throws Throwable { System.out.println(\\\"Cglib 代理模式 ~~ 开始\\\"); Object returnVal = method.invoke(target, args); System.out.println(\\\"Cglib 代理模式 ~~ 提交\\\"); return returnVal; } // 上面设置回调的 this 和重写 intercept 等价于 enhancer.setCallback(new MethodInterceptor() { @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(\\\"Cglib 代理模式 ~~ 开始\\\"); Object returnVal = method.invoke(target, args); System.out.println(\\\"Cglib 代理模式 ~~ 提交\\\"); return returnVal; } }); // 设置回调 } \",\"测试类\",\"public class Client { public static void main(String[] args) { // 创建目标对象 TeacherDao target = new TeacherDao(); // 获取到代理对象，并且将目标对象传递给代理对象 TeacherDao proxyInstance = (TeacherDao)new ProxyFactory(target).getProxyInstance(); // 执行代理对象的方法，触发 intecept 方法，从而实现对目标对象的调用 String res = proxyInstance.teach(); System.out.println(\\\"res=\\\" + res); } } \",\"在内存中动态构建子类，注意代理的类不能为 final，否则报错 java.lang.IllegalArgumentException。\",\"目标对象的方法如果为 final/static，那么就不会被拦截，即不会执行目标对象额外的业务方法。\"]},\"704\":{\"h\":\"几种常见的代理模式介绍\",\"t\":[\"防火墙代理\",\"内网通过代理穿透防火墙，实现对公网的访问。\",\"缓存代理\",\"比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则 OK，如果取不到资源，再到公网或者数据库取，然后缓存。\",\"远程代理\",\"远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。\",\"同步代理\",\"主要使用在多线程编程中，完成多线程间同步工作。\"]},\"705\":{\"h\":\"代理模式的应用场景\",\"t\":[\"当无法或不想直接引用某个对象或访问某个对象存在困难时，可以通过代理对象来间接访问。使用代理模式主要有两个目的：一是保护目标对象，二是增强目标对象。\",\"前面分析了代理模式的结构与特点，现在来分析以下的应用场景：\",\"远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间\",\"虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉\",\"安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限\",\"智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它\",\"延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载\"]},\"706\":{\"h\":\"行为型职责链模式\"},\"707\":{\"h\":\"职责链模式基本介绍\",\"t\":[\"在现实生活中，一个事件需要经过多个对象处理是很常见的场景。例如，采购审批流程、请假流程等。公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据需要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这无疑增加了难度。\",\"在计算机软硬件中也有相关例子，如总线网中数据报传送，每台计算机根据目标地址是否同自己的地址相同来决定是否接收；还有异常处理中，处理程序根据异常的类型决定自己是否处理该异常；还有 Struts2 的拦截器、JSP 和 Servlet 的 Filter 等，所有这些都可以考虑使用职责链模式来实现。\",\"职责链模式（Chain of Responsibility Pattern）又叫 责任链模式，为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。这种模式对请求的发送者和接收者进行解耦。\",\"在职责链模式中，通常每个接收者都包含对另一个接收者的引用。客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递过程，请求会自动进行传递，如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。所以职责链将请求的发送者和请求的处理者解耦了。\",\"这种类型的设计模式属于行为型模式。\",\"主要优点\",\"降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息\",\"增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则\",\"增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任\",\"职责链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if-else 语句\",\"责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则\",\"主要缺点\",\"不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理\",\"对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响\",\"职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用\"]},\"708\":{\"h\":\"职责链模式的结构与实现\",\"t\":[\"职责链模式主要包含以下角色：\",\"抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接\",\"具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者\",\"客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程\",\"责任链模式的本质是 解耦请求与处理，让请求在处理链中能进行传递与被处理；理解责任链模式应当理解其模式，而不是其具体实现。责任链模式的独到之处是将其节点处理者组合成了链式结构，并允许节点自身决定是否进行请求处理或转发，相当于让请求流动起来。\",\"其结构图如下图所示：\",\"image-20220326184616770\",\"客户端可按下图所示设置职责链：\",\"image-20220326184654465\",\"代码实现\",\"// 抽象处理者角色 abstract class Handler { private Handler next; public void setNext(Handler next) { this.next = next; } public Handler getNext() { return next; } // 处理请求的方法 public abstract void handleRequest(String request); } // 具体处理者角色 1 class ConcreteHandler1 extends Handler { public void handleRequest(String request) { if (request.equals(\\\"one\\\")) { System.out.println(\\\"具体处理者1负责处理该请求！\\\"); } else { if (getNext() != null) { getNext().handleRequest(request); } else { System.out.println(\\\"没有人处理该请求！\\\"); } } } } // 具体处理者角色 2 class ConcreteHandler2 extends Handler { public void handleRequest(String request) { if (request.equals(\\\"two\\\")) { System.out.println(\\\"具体处理者2负责处理该请求！\\\"); } else { if (getNext() != null) { getNext().handleRequest(request); } else { System.out.println(\\\"没有人处理该请求！\\\"); } } } } public class ChainOfResponsibilityPattern { public static void main(String[] args) { //组装责任链 Handler handler1 = new ConcreteHandler1(); Handler handler2 = new ConcreteHandler2(); handler1.setNext(handler2); //提交请求 handler1.handleRequest(\\\"two\\\"); } } \"]},\"709\":{\"h\":\"学校 OA 系统的采购审批项目\",\"t\":[\"采购员采购教学器材\",\"如果金额小于等于 5000，由教学主任审批（0 <= x <= 5000）\",\"如果金额小于等于 10000，由院长审批（5000 < x <= 10000）\",\"如果金额小于等于 30000，由副校长审批（10000 < x <= 30000）\",\"如果金额超过 30000 以上，有校长审批（30000 < x）\",\"传统方案题分析\",\"传统方式是：接收到一个采购请求后，根据采购金额来调用对应的 Approver（审批人）完成审批\",\"传统方式的问题分析：客户端这里会使用到分支判断（比如 Switch）来对不同的采购请求处理，这样就存在如下问题： \",\"如果各个级别的人员审批金额发生变化，在客户端的也需要变化\",\"客户端必须明确的知道有多少个审批级别和访问\",\"这样对一个采购请求进行处理和 Approver（审批人）就存在强耦合关系，不利于代码的扩展和维护\",\"解决方案：职责链模式。\"]},\"710\":{\"h\":\"职责链模式解决采购审批项目\",\"t\":[\"思路分析和类图：\",\"image-20220326183929550\",\"代码实现：\",\"职责链类\",\"public abstract class Approver { Approver approver; // 下一个处理者 String name; // 名字 public Approver(String name) { this.name = name; } // 下一个处理者 public void setApprover(Approver approver) { this.approver = approver; } // 处理审批请求的方法，得到一个请求，处理是子类完成，因此该方法做成抽象 public abstract void processRequest(PurchaseRequest purchaseRequest); } // 学校管理者（权力最大） public class SchoolMasterApprover extends Approver { public SchoolMasterApprover(String name) { super(name); } @Override public void processRequest(PurchaseRequest purchaseRequest) { if(purchaseRequest.getPrice() > 30000) { System.out.println(\\\" 请求编号 id= \\\" + purchaseRequest.getId() + \\\" 被 \\\" + this.name + \\\" 处理\\\"); }else { approver.processRequest(purchaseRequest); } } } // 学校副管理者（权力第二） public class ViceSchoolMasterApprover extends Approver { public ViceSchoolMasterApprover(String name) { super(name); } @Override public void processRequest(PurchaseRequest purchaseRequest) { if(purchaseRequest.getPrice() < 10000 && purchaseRequest.getPrice() <= 30000) { System.out.println(\\\" 请求编号 id= \\\" + purchaseRequest.getId() + \\\" 被 \\\" + this.name + \\\" 处理\\\"); }else { approver.processRequest(purchaseRequest); } } } // 院系管理者（权力第三） public class CollegeApprover extends Approver { public CollegeApprover(String name) { super(name); } @Override public void processRequest(PurchaseRequest purchaseRequest) { if(purchaseRequest.getPrice() < 5000 && purchaseRequest.getPrice() <= 10000) { System.out.println(\\\" 请求编号 id= \\\" + purchaseRequest.getId() + \\\" 被 \\\" + this.name + \\\" 处理\\\"); }else { approver.processRequest(purchaseRequest); } } } // 班级管理者（权力第四） public class DepartmentApprover extends Approver { public DepartmentApprover(String name) { super(name); } @Override public void processRequest(PurchaseRequest purchaseRequest) { if(purchaseRequest.getPrice() <= 5000) { System.out.println(\\\" 请求编号 id= \\\" + purchaseRequest.getId() + \\\" 被 \\\" + this.name + \\\" 处理\\\"); }else { approver.processRequest(purchaseRequest); } } } \",\"请求类\",\"// 请求类 public class PurchaseRequest { private int type = 0; // 请求类型 private float price = 0.0f; // 请求金额 private int id = 0; // 构造器 public PurchaseRequest(int type, float price, int id) { this.type = type; this.price = price; this.id = id; } public int getType() { return type; } public float getPrice() { return price; } public int getId() { return id; } } \",\"测试类\",\"public class Client { public static void main(String[] args) { // 创建一个请求 PurchaseRequest purchaseRequest = new PurchaseRequest(1, 31000, 1); // 创建相关的审批人 DepartmentApprover departmentApprover = new DepartmentApprover(\\\"张主任\\\"); CollegeApprover collegeApprover = new CollegeApprover(\\\"李院长\\\"); ViceSchoolMasterApprover viceSchoolMasterApprover = new ViceSchoolMasterApprover(\\\"王副校\\\"); SchoolMasterApprover schoolMasterApprover = new SchoolMasterApprover(\\\"佟校长\\\"); // 需要将各个审批级别的下一个设置好 (处理人构成环形) departmentApprover.setApprover(collegeApprover); collegeApprover.setApprover(viceSchoolMasterApprover); viceSchoolMasterApprover.setApprover(schoolMasterApprover); schoolMasterApprover.setApprover(departmentApprover); departmentApprover.processRequest(purchaseRequest); } } \",\"SpringMVC 的 HandlerExecutionChain 类就使用到职责链模式。\"]},\"711\":{\"h\":\"职责链模式的注意事项和细节\",\"t\":[\"职责链模式将请求和处理分开，实现解耦，提高系统的灵活性\",\"职责链模式简化了对象，使对象不需要知道链的结构\",\"性能会受到影响，特别是在链比较长的时候，因此需控制链中最大节点数量，一般通过在 Handler 中设置一个最大节点数量，在 setNext() 方法中判断是否已经超过阀值，超过则不允许该链建立，避免出现超长链无意识地破坏系统性能\",\"调试不方便，采用了类似递归的方式，调试时逻辑可能比较复杂\"]},\"712\":{\"h\":\"职责链模式的应用场景\",\"t\":[\"责任链模式通常在以下几种情况使用：\",\"多个对象可以处理一个请求，但具体由哪个对象处理该请求在运行时自动确定\",\"可动态指定一组对象处理请求，或添加新的处理者\",\"需要在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求\"]},\"713\":{\"h\":\"七大原则\"},\"714\":{\"h\":\"设计模式七大原则\",\"t\":[\"设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础（即：设计模式为什么 这样设计的依据）。\",\"设计模式常用的七大原则有：\",\"单一职责原则\",\"接口隔离原则\",\"依赖倒转（倒置）原则\",\"里氏替换原则\",\"开闭原则\",\"迪米特法则\",\"合成复用原则\"]},\"715\":{\"h\":\"单一职责原则（SRP）\"},\"716\":{\"h\":\"基本介绍\",\"t\":[\"单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则，由罗伯特·C.马丁（Robert C. Martin）于《敏捷软件开发：原则、模式和实践》一书中提出的。这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）。\",\"对类来说的，即一个类应该只负责一项职责。如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2。\",\"就像一个 DAO 类负责一个表的增删改查，不能出现其他表的增删改查。\",\"该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：\",\"一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力\",\"当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费\"]},\"717\":{\"h\":\"单一职责原则的优点\",\"t\":[\"单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点：\",\"降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多\",\"提高类的可读性。复杂性降低，自然其可读性会提高\",\"提高系统的可维护性。可读性提高，那自然更容易维护了\",\"变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响\"]},\"718\":{\"h\":\"应用实例\",\"t\":[\"代码示例 1\",\"下方代码 违反了单一职责原则，run 方法不能既负责摩托车、汽车（陆地），又负责飞机（飞机）。\",\"public class SingleResponsibility1 { public static void main(String[] args) { Vehicle vehicle = new Vehicle(); vehicle.run(\\\"摩托车\\\"); vehicle.run(\\\"汽车\\\"); vehicle.run(\\\"飞机\\\"); } } class Vehicle { public void run(String vehicle) { System.out.println(vehicle + \\\" 在公路上运行....\\\"); } } \",\"改进：我们要根据交通工具运行方法不同，分解成不同类即可，看代码示例 2。\",\"代码示例 2\",\"下面代码虽然遵守单一职责原则，但是这样做的改动很大，即将 类分解 成三个，同时修改和新增 main 方法的对象。\",\"public class SingleResponsibility2 { public static void main(String[] args) { RoadVehicle roadVehicle = new RoadVehicle(); roadVehicle.run(\\\"摩托车\\\"); roadVehicle.run(\\\"汽车\\\"); AirVehicle airVehicle = new AirVehicle(); airVehicle.run(\\\"飞机\\\"); } } class RoadVehicle { public void run(String vehicle) { System.out.println(vehicle + \\\"公路运行\\\"); } } class AirVehicle { public void run(String vehicle) { System.out.println(vehicle + \\\"天空运行\\\"); } } class WaterVehicle { public void run(String vehicle) { System.out.println(vehicle + \\\"水中运行\\\"); } } \",\"改进：直接修改 Vehicle 类，改动的代码会比较少。\",\"代码示例 3\",\"下面代码的修改方法没有对原来的类做大的修改，只是增加方法。\",\"这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责。\",\"public class SingleResponsibility3 { public static void main(String[] args) { Vehicle2 vehicle2 = new Vehicle2(); vehicle2.run(\\\"汽车\\\"); vehicle2.runWater(\\\"轮船\\\"); vehicle2.runAir(\\\"飞机\\\"); } } class Vehicle2 { public void run(String vehicle) { // 处理 System.out.println(vehicle + \\\" 在公路上运行....\\\"); } public void runAir(String vehicle) { System.out.println(vehicle + \\\" 在天空上运行....\\\"); } public void runWater(String vehicle) { System.out.println(vehicle + \\\" 在水中行....\\\"); } } \"]},\"719\":{\"h\":\"单一职责原则注意事项和细节\",\"t\":[\"降低类的复杂度，一个类只负责一项职责\",\"提高类的可读性，可维护性\",\"降低变更引起的风险\",\"通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则\"]},\"720\":{\"h\":\"接口隔离原则（ISP）\"},\"721\":{\"h\":\"基本介绍\",\"t\":[\"接口隔离原则（Interface Segregation Principle）：客户端不应该依赖它不需要的接口，即 一个类对另一个类的依赖应该建立在最小的接口上。\",\"最小接口指：接口里的方法不应该囤积许多类需要的不同方法，尽量保证一个接口只能由一个或多个类共同使用的方法。\",\"先看一张图（违反接口隔离原则）：\",\"image-20220224195635097\",\"类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C 来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。\",\"按隔离原则应当这样处理：将接口 Interface1 拆分为独立的几个接口（这里我们拆分成 3 个接口），类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。\",\"接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：\",\"单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离\",\"单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建\"]},\"722\":{\"h\":\"接口隔离原则的优点\",\"t\":[\"接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点：\",\"将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性\",\"接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性\",\"如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险\",\"使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义\",\"能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码\"]},\"723\":{\"h\":\"应用实例\",\"t\":[\"类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，编写代码的应用实例。\",\"没有使用接口隔离原则代码\",\"public class Segregation1 { public static void main(String[] args) { } } // 接口 interface Interface1 { void operation1(); void operation2(); void operation3(); void operation4(); void operation5(); } class B implements Interface1 { public void operation1() { System.out.println(\\\"B 实现了 operation1\\\"); } public void operation2() { System.out.println(\\\"B 实现了 operation2\\\"); } public void operation3() { System.out.println(\\\"B 实现了 operation3\\\"); } public void operation4() { System.out.println(\\\"B 实现了 operation4\\\"); } public void operation5() { System.out.println(\\\"B 实现了 operation5\\\"); } } class D implements Interface1 { public void operation1() { System.out.println(\\\"D 实现了 operation1\\\"); } public void operation2() { System.out.println(\\\"D 实现了 operation2\\\"); } public void operation3() { System.out.println(\\\"D 实现了 operation3\\\"); } public void operation4() { System.out.println(\\\"D 实现了 operation4\\\"); } public void operation5() { System.out.println(\\\"D 实现了 operation5\\\"); } } class A { // A 类通过接口 Interface1 依赖(使用) B 类，但是只会用到 1,2,3 方法 public void depend1(Interface1 i) { i.operation1(); } public void depend2(Interface1 i) { i.operation2(); } public void depend3(Interface1 i) { i.operation3(); } } class C { // C 类通过接口 Interface1 依赖(使用) D 类，但是只会用到 1,4,5 方法 public void depend1(Interface1 i) { i.operation1(); } public void depend4(Interface1 i) { i.operation4(); } public void depend5(Interface1 i) { i.operation5(); } } \",\"类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C 来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。\",\"使用接口隔离原则代码\",\"将接口 Interface1 拆分为独立的几个接口，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。\",\"接口 Interface1 中出现的方法，根据实际情况拆分为三个接口。\",\"image-20220224200505149\",\"public class Segregation1 { public static void main(String[] args) { // 使用一把 A a = new A(); a.depend1(new B()); // A 类通过接口去依赖 B 类 a.depend2(new B()); a.depend3(new B()); C c = new C(); c.depend1(new D()); // C 类通过接口去依赖(使用) D 类 c.depend4(new D()); c.depend5(new D()); } } // 接口 1 interface Interface1 { void operation1(); } // 接口 2 interface Interface2 { void operation2(); void operation3(); } // 接口 3 interface Interface3 { void operation4(); void operation5(); } class B implements Interface1, Interface2 { public void operation1() { System.out.println(\\\"B 实现了 operation1\\\"); } public void operation2() { System.out.println(\\\"B 实现了 operation2\\\"); } public void operation3() { System.out.println(\\\"B 实现了 operation3\\\"); } } class D implements Interface1, Interface3 { public void operation1() { System.out.println(\\\"D 实现了 operation1\\\"); } public void operation4() { System.out.println(\\\"D 实现了 operation4\\\"); } public void operation5() { System.out.println(\\\"D 实现了 operation5\\\"); } } class A { // A 类通过接口 Interface1,Interface2 依赖(使用) B类，但是只会用到 1,2,3 方法 public void depend1(Interface1 i) { i.operation1(); } public void depend2(Interface2 i) { i.operation2(); } public void depend3(Interface2 i) { i.operation3(); } } class C { // C 类通过接口 Interface1,Interface3 依赖(使用) D 类，但是只会用到 1,4,5 方法 public void depend1(Interface1 i) { i.operation1(); } public void depend4(Interface3 i) { i.operation4(); } public void depend5(Interface3 i) { i.operation5(); } } \"]},\"724\":{\"h\":\"依赖倒转原则（DIP）\"},\"725\":{\"h\":\"基本介绍\",\"t\":[\"依赖倒转原则（Dependence Inversion Principle）是指：\",\"高层模块不应该依赖低层模块，二者都应该依赖其抽象\",\"抽象不应该依赖细节，细节应该依赖抽象\",\"依赖倒转（倒置）的中心思想是 面向接口编程\",\"依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 Java 中，抽象指的是接口或抽象类，细节就是具体的实现类\",\"使用 接口或抽象类 的目的是制定好 规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成\",\"类与类之间不建议之间互相引用，而是通过接口来间接引用，这样给接口传入不同的类，就能使用该类的方法。\"]},\"726\":{\"h\":\"依赖倒转原则的作用\",\"t\":[\"依赖倒置原则的主要作用如下：\",\"依赖倒置原则可以降低类间的耦合性\",\"依赖倒置原则可以提高系统的稳定性\",\"依赖倒置原则可以减少并行开发引起的风险\",\"依赖倒置原则可以提高代码的可读性和可维护性\"]},\"727\":{\"h\":\"简单应用实例\",\"t\":[\"需求：Person 接收消息。\",\"方式一：违反依赖倒转原则\",\"简单，比较容易想到，但是 Person 类的 receive 方法竟然直接引用 Email 类，导致双方高耦合，彼此无法分离。\",\"public class DependecyInversion { public static void main(String[] args) { Person person = new Person(); person.receive(new Email()); } } class Email { public String getInfo() { return \\\"电子邮件信息: hello,world\\\"; } } class Person { public void receive(Email email ) { System.out.println(email.getInfo()); } } \",\"如果我们获取的对象是 微信，短信等等，则新增类，同时 Perons 也要增加相应的接收方法。\",\"解决思路：引入一个抽象的接口 IReceiver，表示接收者，这样 Person 类与接口 IReceiver 发生依赖，因为 Email，WeiXin 等等属于接收的范围，他们各自实现 IReceiver 接口就好了，这样我们就符合依赖倒转原则。\",\"方式二\",\"public class DependecyInversion { public static void main(String[] args) { // 客户端无需改变 Person person = new Person(); person.receive(new Email()); person.receive(new WeiXin()); } } // 定义接口 interface IReceiver { public String getInfo(); } class Email implements IReceiver { public String getInfo() { return \\\"电子邮件信息: hello,world\\\"; } } // 增加微信 class WeiXin implements IReceiver { public String getInfo() { return \\\"微信信息: hello,ok\\\"; } } // 方式 2 class Person { // 这里我们是对接口的依赖 public void receive(IReceiver receiver ) { System.out.println(receiver.getInfo()); } } \",\"注意 33 行的参数类型，这样只需要传入继承接口的类，就能实现该类的方法，调用多个类只需要一个接口类。\"]},\"728\":{\"h\":\"依赖关系传递的三种方式和应用案例\",\"t\":[\"上方只是简单介绍依赖倒转原则的基本使用，下面是核心方式使用：\",\"接口传递\",\"构造方法传递\",\"setter 方式传递\",\"public class DependencyPass { public static void main(String[] args) { Kele kele = new Kele(); OpenAndClose1 openAndClose1 = new OpenAndClose1(); openAndClose1.open(kele); // 通过构造器进行依赖传递 BingTang bingTang = new BingTang(); OpenAndClose2 openAndClose2 = new OpenAndClose2(bingTang); openAndClose2.open(); // 通过 setter 方法进行依赖传递 XueLi xueLi = new XueLi(); OpenAndClose3 openAndClose = new OpenAndClose3(); openAndClose.setTv(xueLi); openAndClose.open(); } } // 方式 1：通过接口传递实现依赖 // 开关的接口 interface IOpenAndClose1 { public void open(ITV1 tv); // 抽象方法，接收接口 } interface ITV1 { // ITV 接口 public void play(); } class Kele implements ITV1 { @Override public void play() { System.out.println(\\\"可乐电视机，打开\\\"); } } class OpenAndClose1 implements IOpenAndClose1 { public void open(ITV1 tv){ tv.play(); } } // 方式 2: 通过构造方法依赖传递 interface IOpenAndClose2 { public void open(); // 抽象方法 } interface ITV2 { // ITV 接口 public void play(); } class OpenAndClose2 implements IOpenAndClose2 { public ITV2 tv; // 成员 public OpenAndClose2(ITV2 tv){ // 构造器 this.tv = tv; } public void open(){ this.tv.play(); } } class BingTang implements ITV2 { @Override public void play() { System.out.println(\\\"冰糖电视机，打开\\\"); } } // 方式 3，通过 setter 方法传递 interface IOpenAndClose3 { public void open(); // 抽象方法 public void setTv(ITV3 tv); } interface ITV3 { // ITV接口 public void play(); } class OpenAndClose3 implements IOpenAndClose3 { private ITV3 tv; public void setTv(ITV3 tv) { this.tv = tv; } public void open() { this.tv.play(); } } class XueLi implements ITV3 { @Override public void play() { System.out.println(\\\"雪梨电视机，打开\\\"); } } \",\"输出：\",\"可乐电视机，打开 冰糖电视机，打开 雪梨电视机，打开 \"]},\"729\":{\"h\":\"依赖倒转原则的注意事项和细节\",\"t\":[\"低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好\",\"变量的 声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在 一个缓冲层，利于程序扩展和优化\",\"继承时遵循 里氏替换原则\"]},\"730\":{\"h\":\"里氏替换原则（LSP）\"},\"731\":{\"h\":\"OO 中的继承性的思考和说明\",\"t\":[\"继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。\",\"继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来 侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。\",\"问题：在编程中，如何正确的使用继承？\",\"使用里氏替原则。\"]},\"732\":{\"h\":\"基本介绍\",\"t\":[\"里氏替换原则（Liskov Substitution Principle）由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在 1987 年的「面向对象技术的高峰会议」（OOPSLA）上发表的一篇文章《数据抽象和层次》（Data Abstraction and Hierarchy）里提出来的，她提出：继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）。\",\"如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。\",\"在使用继承时，遵循里氏替换原则，在 子类中尽量不要重写父类的方法。\",\"里氏替换原则 主要阐述了有关继承的一些原则，因为继承实际上让两个类耦合性增强了，所以告诉我们什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。\",\"在适当的情况下，可以通过聚合、组合、依赖来解决问题。\",\"举例\",\"假设 B 类需要 A 类的某些方法（日后基本不会改），则把这些方法放到一个抽象类 C，再让 A、B 类继承抽象类 C，防止 B 直接继承 A 类，提高耦合度。\"]},\"733\":{\"h\":\"里氏替换原则的作用\",\"t\":[\"里氏替换原则的主要作用如下：\",\"里氏替换原则是实现开闭原则的重要方式之一\",\"它克服了继承中重写父类造成的可复用性变差的缺点\",\"它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性\",\"加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险\"]},\"734\":{\"h\":\"应用实例\",\"t\":[\"看下面代码，思考问题和解决思路\",\"public class Liskov { public static void main(String[] args) { A a = new A(); System.out.println(\\\"11-3=\\\" + a.func1(11, 3)); System.out.println(\\\"1-8=\\\" + a.func1(1, 8)); System.out.println(\\\"-----------------------\\\"); B b = new B(); System.out.println(\\\"11-3=\\\" + b.func1(11, 3)); // 这里本意是求出 11-3，但是不小心c System.out.println(\\\"1-8=\\\" + b.func1(1, 8)); // 1-8 System.out.println(\\\"11+3+9=\\\" + b.func2(11, 3)); } } // A 类 class A { // 返回两个数的差 public int func1(int num1, int num2) { return num1 - num2; } } // B 类继承了 A // 增加了一个新功能：完成两个数相加，然后和 9 求和 class B extends A { // 这里，重写了 A 类的方法, 可能是无意识 public int func1(int a, int b) { return a + b; } public int func2(int a, int b) { return func1(a, b) + 9; } } \",\"解决方法\",\"我们发现原来运行正常的相减功能发生了错误。原因就是类 B 无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候。\",\"通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合、组合等 关系代替。\",\"改进方案：\",\"image-20220224203106674\",\"public class Liskov { public static void main(String[] args) { A a = new A(); System.out.println(\\\"11-3=\\\" + a.func1(11, 3)); System.out.println(\\\"1-8=\\\" + a.func1(1, 8)); System.out.println(\\\"-----------------------\\\"); B b = new B(); // 因为 B 类不再继承A类，因此调用者，不会再 func1 是求减法 // 调用完成的功能就会很明确 System.out.println(\\\"11+3=\\\" + b.func1(11, 3)); // 这里本意是求出 11+3 System.out.println(\\\"1+8=\\\" + b.func1(1, 8)); // 1+8 System.out.println(\\\"11+3+9=\\\" + b.func2(11, 3)); // 使用组合仍然可以使用到 A 类相关方法 System.out.println(\\\"11-3=\\\" + b.func3(11, 3));// 这里本意是求出 11-3 } } // 创建一个更加基础的基类 class Base { // 把更加基础的方法和成员写到 Base 类 } // A 类 class A extends Base { // 返回两个数的差 public int func1(int num1, int num2) { return num1 - num2; } } // B 类继承了 A // 增加了一个新功能：完成两个数相加，然后和 9 求和 class B extends Base { // 如果 B 需要使用 A 类的方法，使用组合关系 private A a = new A(); // 这里，重写了 A 类的方法, 可能是无意识 public int func1(int a, int b) { return a + b; } public int func2(int a, int b) { return func1(a, b) + 9; } // 我们仍然想使用 A 的方法 public int func3(int a, int b) { return this.a.func1(a, b); } } \"]},\"735\":{\"h\":\"开闭原则（OCP）\"},\"736\":{\"h\":\"基本介绍\",\"t\":[\"开闭原则（Open Closed Principle，OCP）由勃兰特·梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented Software Construction）中提出：软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。\",\"开闭原则（Open Closed Principle）是编程中 最基础、最重要 的设计原则。\",\"一个软件实体如类，模块和函数应该 对扩展开放（对提供方），对 修改关闭（对使用方）。用抽象构建框架，用实现扩展细节。\",\"当软件需要变化时，尽量 通过扩展软件 实体的行为来实现变化，而不是 通过修改 已有的代码来实现变化。\",\"编程中遵循其它原则，以及使用设计模式的目的就是遵循 开闭原则。\"]},\"737\":{\"h\":\"开闭原则的作用\",\"t\":[\"开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下：\",\"对软件测试的影响\",\"软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。\",\"可以提高代码的可复用性\",\"粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。\",\"可以提高软件的可维护性\",\"遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。\"]},\"738\":{\"h\":\"应用示例\",\"t\":[\"类图设计，如下：\",\"image-20220224203440696\",\"代码演示\",\"public class Ocp { public static void main(String[] args) { // 使用看看存在的问题 GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); } } // 这是一个用于绘图的类 [使用方] class GraphicEditor { // 接收 Shape 对象，然后根据 type，来绘制不同的图形 public void drawShape(Shape s) { if (s.m_type == 1) drawRectangle(s); else if (s.m_type == 2) drawCircle(s); } // 绘制矩形 public void drawRectangle(Shape r) { System.out.println(\\\" 绘制矩形 \\\"); } // 绘制圆形 public void drawCircle(Shape r) { System.out.println(\\\" 绘制圆形 \\\"); } } // Shape 类，基类 class Shape { int m_type; } class Rectangle extends Shape { Rectangle() { super.m_type = 1; } } class Circle extends Shape { Circle() { super.m_type = 2; } } \",\"上方代码优缺点\",\"优点是比较好理解，简单易操作\",\"缺点是违反了设计模式的 OCP 原则，即对扩展开放（提供方），对修改关闭（使用方）。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码\",\"比如我们这时要新增加一个图形种类三角形，我们需要做如下修改，修改的地方较多（四处）\",\"public class Ocp { public static void main(String[] args) { // 使用看看存在的问题 GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); graphicEditor.drawShape(new Triangle()); } } // 这是一个用于绘图的类 [使用方] class GraphicEditor { // 接收 Shape 对象，然后根据 type，来绘制不同的图形 public void drawShape(Shape s) { if (s.m_type == 1) drawRectangle(s); else if (s.m_type == 2) drawCircle(s); } // 绘制矩形 public void drawRectangle(Shape r) { System.out.println(\\\" 绘制矩形 \\\"); } // 绘制圆形 public void drawCircle(Shape r) { System.out.println(\\\" 绘制圆形 \\\"); } // 绘制三角形 public void drawTriangle(Shape r) { System.out.println(\\\" 绘制三角形 \\\"); } } // Shape 类，基类 class Shape { int m_type; } class Rectangle extends Shape { Rectangle() { super.m_type = 1; } } class Circle extends Shape { Circle() { super.m_type = 2; } } // 新增画三角形 class Triangle extends Shape { Triangle() { super.m_type = 3; } } \"]},\"739\":{\"h\":\"应用实例改进\",\"t\":[\"思路：把创建 Shape 类做成抽象类，并提供一个抽象的 draw 方法，让子类去实现即可，这样我们有新的图形种类时，只需要让新的图形类继承 Shape，并实现 draw 方法即可，使用方的代码就不需要修，满足了开闭原则。\",\"public class Ocp { public static void main(String[] args) { // 使用看看存在的问题 GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); graphicEditor.drawShape(new Triangle()); graphicEditor.drawShape(new OtherGraphic()); } } // 这是一个用于绘图的类 [使用方] class GraphicEditor { //接收 Shape 对象，调用 draw 方法 public void drawShape(Shape s) { s.draw(); } } // Shape 类，基类 abstract class Shape { int m_type; public abstract void draw();//抽象方法 } class Rectangle extends Shape { Rectangle() { super.m_type = 1; } @Override public void draw() { System.out.println(\\\" 绘制矩形 \\\"); } } class Circle extends Shape { Circle() { super.m_type = 2; } @Override public void draw() { System.out.println(\\\" 绘制圆形 \\\"); } } // 新增画三角形 class Triangle extends Shape { Triangle() { super.m_type = 3; } @Override public void draw() { System.out.println(\\\" 绘制三角形 \\\"); } } // 新增一个图形 class OtherGraphic extends Shape { OtherGraphic() { super.m_type = 4; } @Override public void draw() { System.out.println(\\\" 绘制其它图形 \\\"); } } \",\"和依赖倒转原则类似，遵循其它原则，以及使用设计模式的目的就是遵循 开闭原则。\"]},\"740\":{\"h\":\"迪米特法则（DP）\"},\"741\":{\"h\":\"基本介绍\",\"t\":[\"一个对象应该对其他对象保持最少的了解，类与类关系越密切，耦合度越大\",\"迪米特法则（Demeter Principle）又叫 最少知道原则，即一个类 对自己依赖的类（引用的其他类）知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息\",\"主要优点\",\"降低了类之间的耦合度，提高了模块的相对独立性\",\"由于亲合度降低，从而提高了类的可复用率和系统的扩展性\",\"迪米特法则还有个更简单的定义：只与直接的朋友通信。\",\"直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部\",\"直接朋友和非直接朋友举例\",\"B 是 A 的直接朋友：\",\"public class A { // 成员变量 B b; // 方法参数 public void method1(B b) { } // 方法返回值 public B method2() { return new B(); } } \",\"非直接朋友：\",\"public class A { public void method() { // 局部变量不是直接朋友 B b = new B(); } } \",\"迪米特法则能够帮我们实现代码的 高内聚、松耦合。\",\"那到底什么是「高内聚」呢？\",\"所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。实际上，我们前面讲过的单一职责原则是实现代码高内聚非常有效的设计原则。\",\"我们再来看一下，什么是「松耦合」？\",\"所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。实际上，我们前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了实现代码的松耦合。\",\"最后，我们来看一下，「内聚」和「耦合」之间的关系\",\"前面也提到，「高内聚」有助于「松耦合」，同理，「低内聚」也会导致「紧耦合」。关于这一点，我画了一张对比图来解释。图中左边部分的代码结构是「高内聚、松耦合」；右边部分正好相反，是「低内聚、紧耦合」\",\"图中左边部分的代码设计中，类的粒度比较小，每个类的职责都比较单一。相近的功能都放到了一个类中，不相近的功能被分割到了多个类中。这样类更加独立，代码的内聚性更好。因为职责单一，所以每个类被依赖的类就会比较少，代码低耦合。一个类的修改，只会影响到一个依赖类的代码改动。我们只需要测试这一个依赖类是否还能正常工作就行了\",\"图中右边部分的代码设计中，类粒度比较大，低内聚，功能大而全，不相近的功能放到了一个类中。这就导致很多其他类都依赖这个类。当我们修改这个类的某一个功能代码的时候，会影响依赖它的多个类。我们需要测试这三个依赖类，是否还能正常工作。这也就是所谓的「牵一发而动全身」\",\"除此之外，从图中我们也可以看出，高内聚、低耦合的代码结构更加简单、清晰，相应地，在可维护性和可读性上确实要好很多\",\"所以，在运用迪米特法则时要注意以下 6 点：\",\"在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标\",\"在类的结构设计上，尽量降低类成员的访问权限\",\"在类的设计上，优先考虑将一个类设置成不变类\",\"在对其他类的引用上，将引用其他对象的次数降到最低\",\"不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）\",\"谨慎使用序列化（Serializable）功能\"]},\"742\":{\"h\":\"应用实例\",\"t\":[\"需求：有一个学校，下属有各个学院和总部，现要求打印出学校总部员工 ID 和学院员工的 id。\",\"违反了 迪米特法则 的内容是 SchoolManager 类的内容（57 - 90 行代码）\",\"// 客户端 public class Demeter1 { public static void main(String[] args) { // 创建了一个 SchoolManager 对象 SchoolManager schoolManager = new SchoolManager(); // 输出学院的员工 id 和 学校总部的员工信息 schoolManager.printAllEmployee(new CollegeManager()); } } // 学校总部员工类 class Employee { private String id; public void setId(String id) { this.id = id; } public String getId() { return id; } } // 学院的员工类 class CollegeEmployee { private String id; public void setId(String id) { this.id = id; } public String getId() { return id; } } // 管理学院员工的管理类 class CollegeManager { // 返回学院的所有员工 public List<CollegeEmployee> getAllEmployee() { List<CollegeEmployee> list = new ArrayList<CollegeEmployee>(); // 这里我们增加了 10 个员工到 list for (int i = 0; i < 10; i++) { CollegeEmployee emp = new CollegeEmployee(); emp.setId(\\\"学院员工id= \\\" + i); list.add(emp); } return list; } } // 学校管理类 // 分析 SchoolManager 类的直接朋友类有哪些：Employee、CollegeManager // CollegeEmployee 不是直接朋友 而是一个陌生类，这样违背了 迪米特法则 class SchoolManager { // 返回学校总部的员工 public List<Employee> getAllEmployee() { List<Employee> list = new ArrayList<Employee>(); // 这里我们增加了 5 个员工到 list for (int i = 0; i < 5; i++) { Employee emp = new Employee(); emp.setId(\\\"学校总部员工id= \\\" + i); list.add(emp); } return list; } // 该方法完成输出学校总部和学院员工信息(id) void printAllEmployee(CollegeManager sub) { // 分析问题 // 1. 这里的 CollegeEmployee 不是 SchoolManager 的直接朋友 // 2. CollegeEmployee 是以局部变量方式出现在 SchoolManager // 3. 违反了 迪米特法则 // 获取到学院员工 List<CollegeEmployee> list1 = sub.getAllEmployee(); System.out.println(\\\"------------学院员工------------\\\"); for (CollegeEmployee e : list1) { System.out.println(e.getId()); } // 获取到学校总部员工 List<Employee> list2 = this.getAllEmployee(); System.out.println(\\\"------------学校总部员工------------\\\"); for (Employee e : list2) { System.out.println(e.getId()); } } } \",\"上方代码违反了 迪米特法则。\"]},\"743\":{\"h\":\"应用实例改进\",\"t\":[\"前面设计的问题在于 SchoolManager 中，CollegeEmployee 类并不是 SchoolManager 类的直接朋友（分析）。\",\"按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。\",\"主要看 SchoolManager 类的内容（65 - 91 行代码）\",\"// 客户端 public class Demeter1 { public static void main(String[] args) { System.out.println(\\\"~~~使用迪米特法则的改进~~~\\\"); // 创建了一个 SchoolManager 对象 SchoolManager schoolManager = new SchoolManager(); // 输出学院的员工 id 和 学校总部的员工信息 schoolManager.printAllEmployee(new CollegeManager()); } } // 学校总部员工类 class Employee { private String id; public void setId(String id) { this.id = id; } public String getId() { return id; } } // 学院的员工类 class CollegeEmployee { private String id; public void setId(String id) { this.id = id; } public String getId() { return id; } } // 管理学院员工的管理类 class CollegeManager { // 返回学院的所有员工 public List<CollegeEmployee> getAllEmployee() { List<CollegeEmployee> list = new ArrayList<CollegeEmployee>(); // 这里我们增加了 10 个员工到 list for (int i = 0; i < 10; i++) { CollegeEmployee emp = new CollegeEmployee(); emp.setId(\\\"学院员工id= \\\" + i); list.add(emp); } return list; } // 输出学院员工的信息 public void printEmployee() { // 获取到学院员工 List<CollegeEmployee> list1 = getAllEmployee(); System.out.println(\\\"------------学院员工------------\\\"); for (CollegeEmployee e : list1) { System.out.println(e.getId()); } } } // 学校管理类 class SchoolManager { // 返回学校总部的员工 public List<Employee> getAllEmployee() { List<Employee> list = new ArrayList<Employee>(); // 这里我们增加了 5 个员工到 list for (int i = 0; i < 5; i++) { Employee emp = new Employee(); emp.setId(\\\"学校总部员工id= \\\" + i); list.add(emp); } return list; } // 该方法完成输出学校总部和学院员工信息(id) void printAllEmployee(CollegeManager sub) { // 分析问题 // 1. 将输出学院的员工方法，封装到 CollegeManager sub.printEmployee(); // 获取到学校总部员工 List<Employee> list2 = this.getAllEmployee(); System.out.println(\\\"------------学校总部员工------------\\\"); for (Employee e : list2) { System.out.println(e.getId()); } } } \"]},\"744\":{\"h\":\"迪米特法则注意事项和细节\",\"t\":[\"迪米特法则的核心是降低类之间的耦合，不建议在方法里 new 其他的类\",\"但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完全没有依赖关系\"]},\"745\":{\"h\":\"合成复用原则（CRP）\",\"t\":[\"合成复用原则（Composite Reuse Principle，CRP）又叫 组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时，要尽量先使用 组合或者聚合 等关联关系来实现，其次才考虑使用继承关系来实现。\",\"如果要使用继承关系，则必须严格遵循里氏替换原则。\",\"继承图\",\"B 直接继承 A。\",\"image-20220226103414310\",\"聚合图\",\"B 需要 A 的三个方法，但不是继承，而是通过方法参数、构造器、setter 传入 A 的对象。\",\"image-20220226103435911\",\"组合图\",\"B 需要 A 的三个方法，直接通过 new A 获得 A 的对象。\",\"image-20220226103439980\"]},\"746\":{\"h\":\"设计原则核心思想\",\"t\":[\"找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起\",\"针对接口编程，而不是针对实现编程\",\"为了交互对象之间的松耦合设计而努力\"]},\"747\":{\"h\":\"合成复用原则的重要性\",\"t\":[\"通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点：\",\"继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为「白箱」复用\",\"子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护\",\"它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化\",\"采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：\",\"它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为「黑箱」复用\",\"新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口\",\"复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象\"]},\"748\":{\"h\":\"总结\",\"t\":[\"单一职责原则：一个类或一个方法只负责一件事情\",\"接口隔离原则：一个接口的所有抽象方法能被一个类全部实现\",\"依赖倒转原则：通过接口、构造器、setter 来降低类与类之间的依赖\",\"里氏替换原则：子类中尽量不要重写父类的方法，应该将父类的方法（以后不会改）放到一个抽象类，由父类和子类共同继承\",\"开闭原则：对扩展开放（对提供方），对修改关闭（对使用方）\",\"迪米特法则：不要在方法里 new 其他的类，而是用过方法参数、全局变量引用其他类\",\"合成复用原则：尽量使用合成/聚合的方式引用其他类，而不是使用继承\",\"设计原则\",\"一句话归纳\",\"目的\",\"开闭原则\",\"对扩展开放，对修改关闭\",\"降低维护带来的新风险\",\"依赖倒置原则\",\"高层不应该依赖低层，要面向接口编程\",\"更利于代码结构的升级扩展\",\"单一职责原则\",\"一个类只干一件事，实现类要单一\",\"便于理解，提高代码的可读性\",\"接口隔离原则\",\"一个接口只干一件事，接口要精简单一\",\"功能解耦，高聚合、低耦合\",\"迪米特法则\",\"不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度\",\"只和朋友交流，不和陌生人说话，减少代码臃肿\",\"里氏替换原则\",\"不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义\",\"防止继承泛滥\",\"合成复用原则\",\"尽量使用组合或者聚合关系实现代码复用，少使用继承\",\"降低代码耦合\",\"实际上，这些原则的目的只有一个：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。\"]},\"749\":{\"h\":\"创建型单例模式\"},\"750\":{\"h\":\"单例设计模式介绍\",\"t\":[\"在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。\",\"所谓类的 单例设计模式，就是 采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。\",\"比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。\",\"单例模式在现实生活中的应用也非常广泛，例如公司 CEO、部门经理等都属于单例模型。J2EE 标准中的 Servlet Context 和 ServletContextConfig、Spring 框架应用中的 ApplicationContext、数据库中的连接池等也都是单例模式。\",\"主要优点\",\"单例模式可以保证内存里只有一个实例，减少了内存的开销\",\"可以避免对资源的多重占用\",\"单例模式设置全局访问点，可以优化和共享资源的访问\",\"主要缺点\",\"单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则\",\"在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象\",\"单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则\"]},\"751\":{\"h\":\"单例设计模式八种方式\",\"t\":[\"单例模式有八种方式：\",\"饿汉式（静态常量）\",\"饿汉式（静态代码块）\",\"懒汉式（线程不安全）\",\"懒汉式（线程安全，同步方法）\",\"懒汉式（线程安全，同步代码块）\",\"双重检查\",\"静态内部类\",\"枚举\"]},\"752\":{\"h\":\"饿汉式（静态常量）\",\"t\":[\"饿汉式（静态常量）步骤如下：\",\"构造器私有化 (防止 new )\",\"类的内部创建对象\",\"向外暴露一个静态的公共方法。如 getInstance()\",\"代码实现\",\"public class SingletonTest01 { public static void main(String[] args) { // 测试 Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true System.out.println(\\\"instance.hashCode=\\\" + instance.hashCode()); // instance.hashCode=968514068 System.out.println(\\\"instance2.hashCode=\\\" + instance2.hashCode()); // instance2.hashCode=968514068 } } // 饿汉式（静态常量） class Singleton { // 1. 构造器私有化，外部能 new private Singleton() { } // 2.本类内部创建对象实例 private final static Singleton instance = new Singleton(); // 3. 提供一个公有的静态方法，返回实例对象 public static Singleton getInstance() { return instance; } } \",\"优缺点说明\",\"优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题\",\"缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则 会造成内存的浪费\",\"这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果\",\"结论：这种单例模式 可用，可能 造成内存浪费。\"]},\"753\":{\"h\":\"饿汉式（静态代码块）\",\"t\":[\"public class SingletonTest02 { public static void main(String[] args) { // 测试 Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true System.out.println(\\\"instance.hashCode=\\\" + instance.hashCode()); System.out.println(\\\"instance2.hashCode=\\\" + instance2.hashCode()); } } // 饿汉式（静态代码块） class Singleton { // 1. 构造器私有化, 外部能new private Singleton() { } // 2.本类内部创建对象实例 private static Singleton instance; static { // 在静态代码块中，创建单例对象 instance = new Singleton(); } // 3. 提供一个公有的静态方法，返回实例对象 public static Singleton getInstance() { return instance; } } \",\"优缺点说明\",\"这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面 是一样的。\",\"结论：这种单例模式可用，但是可能造成内存浪费。\"]},\"754\":{\"h\":\"懒汉式（线程不安全）\",\"t\":[\"public class SingletonTest03 { public static void main(String[] args) { System.out.println(\\\"懒汉式1 ， 线程不安全~\\\"); Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true System.out.println(\\\"instance.hashCode=\\\" + instance.hashCode()); System.out.println(\\\"instance2.hashCode=\\\" + instance2.hashCode()); } } // 懒汉式（线程不安全） class Singleton { private static Singleton instance; private Singleton() {} // 提供一个静态的公有方法，当使用到该方法时，才去创建 instance // 即懒汉式 public static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } \",\"优缺点说明\",\"起到了 Lazy Loading 的效果，但是只能在单线程下使用\",\"如果在多线程下，一个线程进入了 if (singleton == null) 判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式\",\"结论：在实际开发中，不要使用 这种方式。\"]},\"755\":{\"h\":\"懒汉式（线程安全，同步方法）\",\"t\":[\"public class SingletonTest04 { public static void main(String[] args) { System.out.println(\\\"懒汉式2 ， 线程安全~\\\"); Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true System.out.println(\\\"instance.hashCode=\\\" + instance.hashCode()); System.out.println(\\\"instance2.hashCode=\\\" + instance2.hashCode()); } } // 懒汉式（线程安全，同步方法） class Singleton { private static Singleton instance; private Singleton() {} // 提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题 // 即懒汉式 public static synchronized Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } \",\"优缺点说明\",\"解决了 线程安全 问题\",\"但是效率太低了，每个线程在想获得类的实例时候，执行 getInstance() 方法都要进行同步。而其实这个方法只执行 一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低\",\"结论：在实际开发中，不推荐 使用这种方式。\"]},\"756\":{\"h\":\"懒汉式（线程安全，同步代码块）\",\"t\":[\"public class SingletonTest04 { public static void main(String[] args) { System.out.println(\\\"懒汉式2 ， 线程安全~\\\"); Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true System.out.println(\\\"instance.hashCode=\\\" + instance.hashCode()); System.out.println(\\\"instance2.hashCode=\\\" + instance2.hashCode()); } } // 懒汉式（线程安全，同步方法） class Singleton { private static Singleton instance; private Singleton() {} // 提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题 // 即懒汉式 public static Singleton getInstance() { if(instance == null) { synchronized(Singleton.class) { instance = new Singleton(); } } return instance; } } \",\"和懒汉式（线程安全，同步方法）类似，不推荐使用。\"]},\"757\":{\"h\":\"双重检查\",\"t\":[\"public class SingletonTest06 { public static void main(String[] args) { System.out.println(\\\"双重检查\\\"); Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true System.out.println(\\\"instance.hashCode=\\\" + instance.hashCode()); System.out.println(\\\"instance2.hashCode=\\\" + instance2.hashCode()); } } // 懒汉式(线程安全，同步方法) class Singleton { private static volatile Singleton instance; private Singleton() {} // 提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题 // 同时保证了效率, 推荐使用 public static synchronized Singleton getInstance() { if(instance == null) { synchronized (Singleton.class) { if(instance == null) { instance = new Singleton(); } } } return instance; } } \",\"优缺点说明\",\"Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton == null) 检查，这样就可以保证线程安全了\",\"这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)，直接 return 实例化对象，也避免的反复进行方法同步\",\"线程安全；延迟加载；效率较高\",\"结论：在实际开发中，推荐使用这种单例设计模式。\"]},\"758\":{\"h\":\"静态内部类\",\"t\":[\"public class SingletonTest07 { public static void main(String[] args) { System.out.println(\\\"使用静态内部类完成单例模式\\\"); Singleton instance = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); System.out.println(instance == instance2); // true System.out.println(\\\"instance.hashCode=\\\" + instance.hashCode()); System.out.println(\\\"instance2.hashCode=\\\" + instance2.hashCode()); } } // 静态内部类完成，推荐使用 class Singleton { private static volatile Singleton instance; // 构造器私有化 private Singleton() {} // 写一个静态内部类，该类中有一个静态属性 Singleton private static class SingletonInstance { private static final Singleton INSTANCE = new Singleton(); } // 提供一个静态的公有方法，直接返回 SingletonInstance.INSTANCE public static synchronized Singleton getInstance() { return SingletonInstance.INSTANCE; } } \",\"优缺点说明\",\"这种方式采用了类装载的机制来保证初始化实例时只有一个线程\",\"静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化\",\"类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的\",\"优点：避免了线程不安全，利用 静态内部类特点实现延迟加载，效率高\",\"结论：推荐使用。\"]},\"759\":{\"h\":\"枚举\",\"t\":[\"public class SingletonTest08 { public static void main(String[] args) { Singleton instance = Singleton.INSTANCE; Singleton instance2 = Singleton.INSTANCE; System.out.println(instance == instance2); System.out.println(instance.hashCode()); System.out.println(instance2.hashCode()); instance.sayOK(); } } // 使用枚举，可以实现单例, 推荐 enum Singleton { INSTANCE; // 属性，代表 Singleton s public void sayOK() { System.out.println(\\\"ok~\\\"); } } \",\"优缺点说明\",\"这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象\",\"这种方式是 Effective Java 的作者 Josh Bloch 提倡的方式\",\"结论：推荐使用。\"]},\"760\":{\"h\":\"单例模式JDK应用\",\"t\":[\"在 JDK 中，java.lang.Runtime 就是经典的单例模式：饿汉式（静态常量）。\",\"public class Runtime { private static final Runtime currentRuntime = new Runtime(); private static Version version; public static Runtime getRuntime() { return currentRuntime; } private Runtime() {} } \"]},\"761\":{\"h\":\"单例模式注意事项和细节说明\",\"t\":[\"单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。\",\"当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new。\",\"单例模式使用的场景：需要 频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如 数据源、session 工厂 等)。\"]},\"762\":{\"h\":\"单例模式的应用场景\",\"t\":[\"对于 Java 来说，单例模式可以保证在一个 JVM 中只存在单一实例。单例模式的应用场景主要有以下几个方面：\",\"需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC\",\"某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等\",\"某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用\",\"某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等\",\"频繁访问数据库或文件的对象\",\"对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套\",\"当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等\"]},\"763\":{\"h\":\"单例存在哪些问题\",\"t\":[\"尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用。大部分情况下，我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID 生成器类。单例模式书写简洁、使用方便，在代码中，我们不需要创建对象，直接通过类似 IdGenerator.getInstance().getId() 这样的方法来调用就可以了。但是，这种使用方法有点类似硬编码（hard code），会带来诸多问题。接下来，我们就具体看看到底有哪些问题。\"]},\"764\":{\"h\":\"单例对 OOP 特性的支持不友好\",\"t\":[\"我们知道，OOP 的四大特性是封装、抽象、继承、多态。单例这种设计模式对于其中的抽象、继承、多态都支持得不好。为什么这么说呢？我们还是通过 IdGenerator 这个例子来讲解。\",\"public class Order { public void create(...) { //... long id = IdGenerator.getInstance().getId(); //... } } public class User { public void create(...) { // ... long id = IdGenerator.getInstance().getId(); //... } } \",\"IdGenerator 的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的 OOP 的抽象特性。如果未来某一天，我们希望针对不同的业务采用不同的 ID 生成算法。比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，我们需要修改所有用到 IdGenerator 类的地方，这样代码的改动就会比较大。\",\"public class Order { public void create(...) { // ... long id = IdGenerator.getInstance().getId(); // 需要将上面一行代码，替换为下面一行代码 long id = OrderIdGenerator.getIntance().getId(); // ... } } public class User { public void create(...) { // ... long id = IdGenerator.getInstance().getId(); // 需要将上面一行代码，替换为下面一行代码 long id = UserIdGenerator.getIntance().getId(); } } \",\"除此之外，单例对继承、多态特性的支持也不友好。这里之所以会用「不友好」这个词，而非「完全不支持」，是因为从理论上来讲，单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪，会导致代码的可读性变差。不明白设计意图的人，看到这样的设计，会觉得莫名其妙。所以，一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就相当于损失了可以应对未来需求变化的扩展性\"]},\"765\":{\"h\":\"单例会隐藏类之间的依赖关系\",\"t\":[\"我们知道，代码的可读性非常重要。在阅读代码的时候，我们希望一眼就能看出类与类之间的依赖关系，搞清楚这个类依赖了哪些外部类。通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来。但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，我们就需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。\"]},\"766\":{\"h\":\"单例对代码的扩展性不友好\",\"t\":[\"我们知道，单例类只能有一个对象实例。如果未来某一天，我们需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动。你可能会说，会有这样的需求吗？既然单例类大部分情况下都用来表示全局类，怎么会需要两个或者多个实例呢\",\"实际上，这样的需求并不少见。我们拿数据库连接池来举例解释一下\",\"在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据库连接资源的消耗。所以，我们把数据库连接池类设计成了单例类。但之后我们发现，系统中有些 SQL 语句运行得非常慢。这些 SQL 语句在执行的时候，长时间占用数据库连接资源，导致其他 SQL 请求无法响应。为了解决这个问题，我们希望将慢 SQL 与其他 SQL 隔离开来执行。为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢 SQL 独享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到其他 SQL 的执行\",\"如果我们将数据库连接池设计成单例类，显然就无法适应这样的需求变更，也就是说，单例类在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设计成单例类\"]},\"767\":{\"h\":\"单例对代码的可测试性不友好\",\"t\":[\"单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如 DB，我们在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现 mock 替换\",\"除此之外，如果单例类持有成员变量（比如 IdGenerator 中的 id 成员变量），那它实际上相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是说，它的成员变量是可以被修改的，那我们在编写单元测试的时候，还需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题\"]},\"768\":{\"h\":\"单例不支持有参数的构造函数\",\"t\":[\"单例不支持有参数的构造函数，比如我们创建一个连接池的单例对象，我们没法通过参数来指定连接池的大小。针对这个问题，我们来看下都有哪些解决方案。\",\"第一种解决思路是：创建完实例之后，再调用 init() 函数传递参数。需要注意的是，我们在使用这个单例类的时候，要先调用 init() 方法，然后才能调用 getInstance() 方法，否则代码会抛出异常。具体的代码实现如下所示：\",\"public class Singleton { private static Singleton instance = null; private final int paramA; private final int paramB; private Singleton(int paramA, int paramB) { this.paramA = paramA; this.paramB = paramB; } public static Singleton getInstance() { if (instance == null) { throw new RuntimeException(\\\"Run init() first.\\\"); } return instance; } public synchronized static Singleton init(int paramA, int paramB) { if (instance != null){ throw new RuntimeException(\\\"Singleton has been created!\\\"); } instance = new Singleton(paramA, paramB); return instance; } } Singleton.init(10, 50); // 先 init，再使用 Singleton singleton = Singleton.getInstance(); \",\"第二种解决思路是：将参数放到 getIntance() 方法中。具体的代码实现如下所示：\",\"public class Singleton { private static Singleton instance = null; private final int paramA; private final int paramB; private Singleton(int paramA, int paramB) { this.paramA = paramA; this.paramB = paramB; } public synchronized static Singleton getInstance(int paramA, int paramB) { if (instance == null) { instance = new Singleton(paramA, paramB); } return instance; } } Singleton singleton = Singleton.getInstance(10, 50); \",\"不知道你有没有发现，上面的代码实现稍微有点问题。如果我们如下两次执行 getInstance() 方法，那获取到的 singleton1 和 signleton2 的 paramA 和 paramB 都是 10 和 50。也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提示，这样就会误导用户。\",\"Singleton singleton1 = Singleton.getInstance(10, 50); Singleton singleton2 = Singleton.getInstance(20, 30); \",\"第三种解决思路是：将参数放到另外一个全局变量中。具体的代码实现如下。Config 是一个存储了 paramA 和 paramB 值的全局变量。里面的值既可以像下面的代码那样通过静态常量来定义，也可以从配置文件中加载得到。实际上，这种方式是最值得推荐的。\",\"public class Config { public static final int PARAM_A = 123; public static final int PARAM_B = 245; } public class Singleton { private static Singleton instance = null; private final int paramA; private final int paramB; private Singleton() { this.paramA = Config.PARAM_A; this.paramB = Config.PARAM_B; } public synchronized static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } \"]},\"769\":{\"h\":\"有何替代解决方案\",\"t\":[\"刚刚我们提到了单例的很多问题，你可能会说，即便单例有这么多问题，但我不用不行啊。我业务上有表示全局唯一类的需求，如果不用单例，我怎么才能保证这个类的对象全局唯一呢？为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。这也是项目开发中经常用到的一种实现思路。比如， ID 唯一递增生成器的例子，用静态方法实现一下，就是下面这个样子：\",\"// 静态方法实现方式 public class IdGenerator { private static AtomicLong id = new AtomicLong(0); public static long getId() { return id.incrementAndGet(); } } // 使用举例 long id = IdGenerator.getId(); \",\"不过，静态方法这种实现思路，并不能解决我们之前提到的问题。实际上，它比单例更加不灵活，比如，它无法支持延迟加载。我们再来看看有没有其他办法。实际上，单例除了我们之前讲到的使用方法之外，还有另外一种使用方法。具体的代码如下所示：\",\"// 1. 老的使用方式 public demofunction() { //... long id = IdGenerator.getInstance().getId(); //... } // 2. 新的使用方式：依赖注入 public demofunction(IdGenerator idGenerator) { long id = idGenerator.getId(); } // 外部调用demofunction()的时候，传入idGenerator IdGenerator idGenerator = IdGenerator.getInsance(); demofunction(idGenerator); \",\"基于新的使用方式，我们将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其他问题，比如对 OOP 特性、扩展性、可测性不友好等问题，还是无法解决\",\"所以，如果要完全解决这些问题，我们可能要从根上，寻找其他方式来实现全局唯一类。实际上，类对象的全局唯一性可以通过多种不同的方式来保证。我们既可以通过单例模式来强制保证，也可以通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，还可以通过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。这就类似 Java 中内存对象的释放由 JVM 来负责，而 C++ 中由程序员自己负责，道理是一样的\",\"对于替代方案工厂模式、IOC 容器的详细讲解，我们放到后面讲解\"]},\"770\":{\"h\":\"如何理解单例模式中的唯一性\",\"t\":[\"首先，我们重新看一下单例的定义：「一个类只允许创建唯一一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式\",\"定义中提到，「一个类只允许创建唯一一个对象」。那对象的唯一性的作用范围是什么呢？是指线程内只允许创建一个对象，还是指进程内只允许创建一个对象？答案是后者，也就是说，单例模式创建的对象是进程唯一的。这里有点不好理解，我来详细地解释一下\",\"我们编写的代码，通过编译、链接，组织在一起，就构成了一个操作系统可以执行的文件，也就是我们平时所说的「可执行文件」（比如 Windows 下的 exe 文件）。可执行文件实际上就是代码被翻译成操作系统可理解的一组指令，你完全可以简单地理解为就是代码本身\",\"当我们使用命令行或者双击运行这个可执行文件的时候，操作系统会启动一个进程，将这个执行文件从磁盘加载到自己的进程地址空间（可以理解操作系统为进程分配的内存存储区，用来存储代码和数据）。接着，进程就一条一条地执行可执行文件中包含的代码。比如，当进程读到代码中的 User user = new User(); 这条语句的时候，它就在自己的地址空间中创建一个 user 临时变量和一个 User 对象。进程之间是不共享地址空间的，如果我们在一个进程中创建另外一个进程（比如，代码中有一个 fork() 语句，进程执行到这条语句的时候会创建一个新的进程），操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容，重新拷贝一份到新进程的地址空间中，这些内容包括代码、数据（比如 user 临时变量、User 对象）\",\"所以，单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象，这也就说，单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的\"]},\"771\":{\"h\":\"如何实现线程唯一的单例\",\"t\":[\"刚刚我们讲了单例类对象是进程唯一的，一个进程只能有一个单例对象。那如何实现一个线程唯一的单例呢\",\"我们先来看一下，什么是线程唯一的单例，以及「线程唯一」和「进程唯一」的区别\",\"「进程唯一」指的是进程内唯一，进程间不唯一。类比一下，「线程唯一」指的是线程内唯一，线程间可以不唯一。实际上，「进程唯一」还代表了线程内、线程间都唯一，这也是「进程唯一」和「线程唯一」的区别之处。这段话听起来有点像绕口令，我举个例子来解释一下\",\"假设 IdGenerator 是一个线程唯一的单例类。在线程 A 内，我们可以创建一个单例对象 a。因为线程内唯一，在线程 A 内就不能再创建新的 IdGenerator 对象了，而线程间可以不唯一，所以，在另外一个线程 B 内，我们还可以重新创建一个新的单例对象 b\",\"尽管概念理解起来比较复杂，但线程唯一单例的代码实现很简单，如下所示。在代码中，我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 工具类，可以更加轻松地实现线程唯一单例。不过，ThreadLocal 底层实现原理也是基于下面代码中所示的 HashMap\",\"public class IdGenerator { private AtomicLong id = new AtomicLong(0); private static final ConcurrentHashMap<Long, IdGenerator> instances = new ConcurrentHashMap<>(); private IdGenerator() {} public static IdGenerator getInstance() { Long currentThreadId = Thread.currentThread().getId(); instances.putIfAbsent(currentThreadId, new IdGenerator()); return instances.get(currentThreadId); } public long getId() { return id.incrementAndGet(); } } \"]},\"772\":{\"h\":\"如何实现集群环境下的单例？\",\"t\":[\"刚刚我们讲了「进程唯一」的单例和「线程唯一」的单例，现在，我们再来看下，「集群唯一」的单例\",\"首先，我们还是先来解释一下，什么是「集群唯一」的单例\",\"我们还是将它跟「进程唯一」「线程唯一」做个对比。「进程唯一」指的是进程内唯一、进程间不唯一。「线程唯一」指的是线程内唯一、线程间不唯一。集群相当于多个进程构成的一个集合，「集群唯一」就相当于是进程内唯一、进程间也唯一。也就是说，不同的进程间共享同一个对象，不能创建同一个类的多个对象\",\"我们知道，经典的单例模式是进程内唯一的，那如何实现一个进程间也唯一的单例呢？如果严格按照不同的进程间共享同一个对象来实现，那集群唯一的单例实现起来就有点难度了\",\"具体来说，我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区\",\"为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁\",\"我用伪代码实现了一下这个过程，具体如下所示：\",\"public class IdGenerator { private AtomicLong id = new AtomicLong(0); private static IdGenerator instance; private static SharedObjectStorage storage = FileSharedObjectStorage(/*入参省略，比如文件地址*/); private static DistributedLock lock = new DistributedLock(); private IdGenerator() {} public synchronized static IdGenerator getInstance() if (instance == null) { lock.lock(); instance = storage.load(IdGenerator.class); } return instance; } public synchroinzed void freeInstance() { storage.save(this, IdGeneator.class); instance = null; //释放对象 lock.unlock(); } public long getId() { return id.incrementAndGet(); } } // IdGenerator使用举例 IdGenerator idGeneator = IdGenerator.getInstance(); long id = idGenerator.getId(); IdGenerator.freeInstance(); \"]},\"773\":{\"h\":\"如何实现一个多例模式？\",\"t\":[\"跟单例模式概念相对应的还有一个多例模式。那如何实现一个多例模式呢？「单例」指的是，一个类只能创建一个对象。对应地，「多例」指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。如果用代码来简单示例一下的话，就是下面这个样子：\",\"public class BackendServer { private long serverNo; private String serverAddress; private static final int SERVER_COUNT = 3; private static final Map<Long, BackendServer> serverInstances = new HashMap<>(); static { serverInstances.put(1L, new BackendServer(1L, \\\"192.134.22.138:8080\\\")); serverInstances.put(2L, new BackendServer(2L, \\\"192.134.22.139:8080\\\")); serverInstances.put(3L, new BackendServer(3L, \\\"192.134.22.140:8080\\\")); } private BackendServer(long serverNo, String serverAddress) { this.serverNo = serverNo; this.serverAddress = serverAddress; } public BackendServer getInstance(long serverNo) { return serverInstances.get(serverNo); } public BackendServer getRandomInstance() { Random r = new Random(); int no = r.nextInt(SERVER_COUNT)+1; return serverInstances.get(no); } } \",\"实际上，对于多例模式，还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。这里的「类型」如何理解呢？我们还是通过一个例子来解释一下，具体代码如下所示。在代码中，logger name 就是刚刚说的「类型」，同一个 logger name 获取到的对象实例是相同的，不同的 logger name 获取到的对象实例是不同的。\",\"public class Logger { private static final ConcurrentHashMap<String, Logger> instances = new ConcurrentHashMap<>(); private Logger() {} public static Logger getInstance(String loggerName) { instances.putIfAbsent(loggerName, new Logger()); return instances.get(loggerName); } public void log() { //... } } //l1==l2, l1!=l3 Logger l1 = Logger.getInstance(\\\"User.class\\\"); Logger l2 = Logger.getInstance(\\\"User.class\\\"); Logger l3 = Logger.getInstance(\\\"Order.class\\\"); \",\"这种多例模式的理解方式有点类似工厂模式。它跟工厂模式的不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象，关于这一点，后面就会讲到。实际上，它还有点类似享元模式，两者的区别等到我们讲到享元模式的时候再来分析。除此之外，实际上，枚举类型也相当于多例模式，一个类型只能对应一个对象，一个类可以创建多个对象。\"]},\"774\":{\"h\":\"行为型状态模式\"},\"775\":{\"h\":\"状态模式基本介绍\",\"t\":[\"在软件开发过程中，应用程序中的部分对象可能会根据不同的情况做出不同的行为，我们把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态。当有状态的对象与外部事件产生互动时，其内部状态就会发生改变，从而使其行为也发生改变。如人都有高兴和伤心的时候，不同的情绪有不同的行为，当然外界也会影响其情绪变化。\",\"对这种有状态的对象编程，传统的解决方案是：将这些所有可能发生的情况全都考虑到，然后使用 if-else 或 switch-case 语句来做状态判断，再进行不同情况的处理。但是显然这种做法对复杂的状态判断存在天然弊端，条件判断语句会过于臃肿，可读性差，且不具备扩展性，维护难度也大。且增加新的状态时要添加新的 if-else 语句，这违背了「开闭原则」，不利于程序的扩展。\",\"以上问题如果采用 状态模式 就能很好地得到解决。状态模式的解决思想是：当控制一个对象状态转换的条件表达式过于复杂时，把相关「判断逻辑」提取出来，用各个不同的类进行表示，系统处于哪种情况，直接使用相应的状态类对象进行处理，这样能把原来复杂的逻辑判断简单化，消除了 if-else、switch-case 等冗余语句，代码更有层次性，并且具备良好的扩展力。\",\"状态模式（State Pattern）：对有状态的对象，把复杂的「判断逻辑」提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。它主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之间可以相互转换。\",\"当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类。\",\"状态模式是一种对象行为型模式。\",\"主要优点\",\"结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足「单一职责原则」\",\"将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖\",\"状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换\",\"主要缺点\",\"状态模式的使用必然会增加系统的类与对象的个数\",\"状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱\",\"状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码\"]},\"776\":{\"h\":\"状态模式的结构与实现\",\"t\":[\"状态模式把受环境改变的对象行为包装在不同的状态对象里，其意图是让一个对象在其内部状态改变的时候，其行为也随之改变。现在我们来分析其基本结构和实现方法。\",\"状态模式包含以下主要角色。\",\"环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换\",\"抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为\",\"具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换\",\"其结构图如下图所示：\",\"image-20220326173758893\",\"代码实现：\",\"// 环境类 class Context { private State state; // 定义环境类的初始状态 public Context() { this.state = new ConcreteStateA(); } // 设置新状态 public void setState(State state) { this.state = state; } // 读取状态 public State getState() { return (state); } // 对请求做处理 public void Handle() { state.Handle(this); } } // 抽象状态类 abstract class State { public abstract void Handle(Context context); } // 具体状态 A 类 class ConcreteStateA extends State { public void Handle(Context context) { System.out.println(\\\"当前状态是 A.\\\"); context.setState(new ConcreteStateB()); } } // 具体状态 B 类 class ConcreteStateB extends State { public void Handle(Context context) { System.out.println(\\\"当前状态是 B.\\\"); context.setState(new ConcreteStateA()); } } public class StatePatternClient { public static void main(String[] args) { Context context = new Context(); // 创建环境 context.Handle(); // 处理请求 context.Handle(); context.Handle(); context.Handle(); } } \"]},\"777\":{\"h\":\"APP 抽奖活动问题\",\"t\":[\"具体要求如下：\",\"假如每参加一次这个活动要扣除用户 50 积分，中奖概率是 10%\",\"奖品数量固定，抽完就不能抽奖\",\"活动有四个状态: 可以抽奖、不能抽奖、发放奖品和奖品领完\",\"活动的四个状态转换关系图：\",\"image-20220326172739237\"]},\"778\":{\"h\":\"状态模式解决抽奖活动问题\",\"t\":[\"思路分析和类图：\",\"定义出一个接口叫状态接口，每个状态都实现它\",\"接口有扣除积分方法、抽奖方法、发放奖品方法\",\"image-20220326172843488\",\"代码示例：\",\"public class RaffleActivity { // state 表示活动当前的状态，是变化 State state = null; // 奖品数量 int count = 0; // 四个属性，表示四种状态 State noRafflleState = new NoRaffleState(this); State canRaffleState = new CanRaffleState(this); State dispenseState = new DispenseState(this); State dispensOutState = new DispenseOutState(this); // 构造器 // 1. 初始化当前的状态为 noRafflleState（即不能抽奖的状态） // 2. 初始化奖品的数量 public RaffleActivity( int count) { this.state = getNoRafflleState(); this.count = count; } // 扣分，调用当前状态的 deductMoney public void debuctMoney(){ state.deductMoney(); } // 抽奖 public void raffle(){ // 如果当前的状态是抽奖成功 if(state.raffle()){ // 领取奖品 state.dispensePrize(); } } //这里请大家注意，每领取一次奖品，count-- public int getCount() { int curCount = count; count--; return curCount; } // setter 和 getter 方法省略 } \",\"状态类\",\"// 状态抽象类 public abstract class State { // 扣除积分 - 50 public abstract void deductMoney(); // 是否抽中奖品 public abstract boolean raffle(); // 发放奖品 public abstract void dispensePrize(); } // 可以抽奖的状态 public class CanRaffleState extends State { RaffleActivity activity; public CanRaffleState(RaffleActivity activity) { this.activity = activity; } // 已经扣除了积分，不能再扣 @Override public void deductMoney() { System.out.println(\\\"已经扣取过了积分\\\"); } // 可以抽奖, 抽完奖后，根据实际情况，改成新的状态 @Override public boolean raffle() { System.out.println(\\\"正在抽奖，请稍等！\\\"); Random r = new Random(); int num = r.nextInt(10); // 10% 中奖机会 if(num == 0){ // 改变活动状态为发放奖品 context activity.setState(activity.getDispenseState()); return true; }else{ System.out.println(\\\"很遗憾没有抽中奖品！\\\"); // 改变状态为不能抽奖 activity.setState(activity.getNoRafflleState()); return false; } } // 不能发放奖品 @Override public void dispensePrize() { System.out.println(\\\"没中奖，不能发放奖品\\\"); } } // 不能抽奖状态 public class NoRaffleState extends State { // 初始化时传入活动引用，扣除积分后改变其状态 RaffleActivity activity; public NoRaffleState(RaffleActivity activity) { this.activity = activity; } // 当前状态可以扣积分，扣除后，将状态设置成可以抽奖状态 @Override public void deductMoney() { System.out.println(\\\"扣除50积分成功，您可以抽奖了\\\"); activity.setState(activity.getCanRaffleState()); } // 当前状态不能抽奖 @Override public boolean raffle() { System.out.println(\\\"扣了积分才能抽奖喔！\\\"); return false; } // 当前状态不能发奖品 @Override public void dispensePrize() { System.out.println(\\\"不能发放奖品\\\"); } } // 发放奖品的状态 public class DispenseState extends State { // 初始化时传入活动引用，发放奖品后改变其状态 RaffleActivity activity; public DispenseState(RaffleActivity activity) { this.activity = activity; } @Override public void deductMoney() { System.out.println(\\\"不能扣除积分\\\"); } @Override public boolean raffle() { System.out.println(\\\"不能抽奖\\\"); return false; } // 发放奖品 @Override public void dispensePrize() { if(activity.getCount() > 0){ System.out.println(\\\"恭喜中奖了\\\"); // 改变状态为不能抽奖 activity.setState(activity.getNoRafflleState()); }else{ System.out.println(\\\"很遗憾，奖品发送完了\\\"); // 改变状态为奖品发送完毕，后面我们就不可以抽奖 activity.setState(activity.getDispensOutState()); } } } // 奖品发放完毕状态 public class DispenseOutState extends State { // 初始化时传入活动引用，当我们 activity 改变成 DispenseOutState，抽奖活动结束 RaffleActivity activity; public DispenseOutState(RaffleActivity activity) { this.activity = activity; } @Override public void deductMoney() { System.out.println(\\\"奖品发送完了，请下次再参加\\\"); } @Override public boolean raffle() { System.out.println(\\\"奖品发送完了，请下次再参加\\\"); return false; } @Override public void dispensePrize() { System.out.println(\\\"奖品发送完了，请下次再参加\\\"); } } \",\"测试类\",\"// 状态模式测试类 public class ClientTest { public static void main(String[] args) { // 创建活动对象，奖品有 1 个奖品 RaffleActivity activity = new RaffleActivity(1); // 我们连续抽 300 次奖 for (int i = 0; i < 30; i++) { System.out.println(\\\"--------第\\\" + (i + 1) + \\\"次抽奖----------\\\"); // 参加抽奖，第一步点击扣除积分 activity.debuctMoney(); // 第二步抽奖 activity.raffle(); } } } \"]},\"779\":{\"h\":\"状态模式在实际项目源码\",\"t\":[\"借贷平台的订单，有审核、发布、抢单等等步骤，随着操作的不同，会改变订单的状态，项目中的这个模块实现就会使用到状态模式。\",\"通常通过 if/else 判断订单的状态，从而实现不同的逻辑，伪代码如下：\",\"if(审核) { // 审核逻辑 }else if(发布) { // 发布逻辑 }else if(抢单) { // 抢单逻辑 } \",\"问题分析\",\"这类代码难以应对变化，在添加一种状态时，我们需要手动添加 if/else，在添加一种功能时，要对所有的状态进行判断。因此代码会变得越来越臃肿，并且一旦没有处理某个状态，便会发生极其严重的 BUG，难以维护。\",\"使用状态模式完成借贷平台项目的审核模块\",\"状态类\",\"public interface State { // 电审 void checkEvent(Context context); // 电审失败 void checkFailEvent(Context context); // 定价发布 void makePriceEvent(Context context); // 接单 void acceptOrderEvent(Context context); // 无人接单失效 void notPeopleAcceptEvent(Context context); // 付款 void payOrderEvent(Context context); // 接单有人支付失效 void orderFailureEvent(Context context); // 反馈 void feedBackEvent(Context context); // 获取状态 String getCurrentState(); } \",\"各种状态子类\",\"public abstract class AbstractState implements State { protected static final RuntimeException EXCEPTION = new RuntimeException(\\\"操作流程不允许\\\"); // 抽象类，默认实现了 State 接口的所有方法 // 该类的所有方法，其子类（具体的状态类），可以有选择的进行重写 @Override public void checkEvent(Context context) { throw EXCEPTION; } @Override public void checkFailEvent(Context context) { throw EXCEPTION; } @Override public void makePriceEvent(Context context) { throw EXCEPTION; } @Override public void acceptOrderEvent(Context context) { throw EXCEPTION; } @Override public void notPeopleAcceptEvent(Context context) { throw EXCEPTION; } @Override public void payOrderEvent(Context context) { throw EXCEPTION; } @Override public void orderFailureEvent(Context context) { throw EXCEPTION; } @Override public void feedBackEvent(Context context) { throw EXCEPTION; } } // 已完结状态类 class FeedBackState extends AbstractState { @Override public String getCurrentState() { return StateEnum.FEED_BACKED.getValue(); } } // 订单生成状态类 class GenerateState extends AbstractState { @Override public void checkEvent(Context context) { context.setState(new ReviewState()); } @Override public void checkFailEvent(Context context) { context.setState(new FeedBackState()); } @Override public String getCurrentState() { return StateEnum.GENERATE.getValue(); } } // 待付款状态类 class NotPayState extends AbstractState { @Override public void payOrderEvent(Context context) { context.setState(new PaidState()); } @Override public void feedBackEvent(Context context) { context.setState(new FeedBackState()); } @Override public String getCurrentState() { return StateEnum.NOT_PAY.getValue(); } } // 已付款状态类 class PaidState extends AbstractState { @Override public void feedBackEvent(Context context) { context.setState(new FeedBackState()); } @Override public String getCurrentState() { return StateEnum.PAID.getValue(); } } // 已发布状态类 class PublishState extends AbstractState { @Override public void acceptOrderEvent(Context context) { // 把当前状态设置为 NotPayState // 至于应该变成哪个状态，有流程图来决定 context.setState(new NotPayState()); } @Override public void notPeopleAcceptEvent(Context context) { context.setState(new FeedBackState()); } @Override public String getCurrentState() { return StateEnum.PUBLISHED.getValue(); } } // 已审核状态类 class ReviewState extends AbstractState { @Override public void makePriceEvent(Context context) { context.setState(new PublishState()); } @Override public String getCurrentState() { return StateEnum.REVIEWED.getValue(); } } \",\"状态枚举类\",\"public enum StateEnum { // 订单生成 GENERATE(1, \\\"GENERATE\\\"), // 已审核 REVIEWED(2, \\\"REVIEWED\\\"), // 已发布 PUBLISHED(3, \\\"PUBLISHED\\\"), // 待付款 NOT_PAY(4, \\\"NOT_PAY\\\"), // 已付款 PAID(5, \\\"PAID\\\"), // 已完结 FEED_BACKED(6, \\\"FEED_BACKED\\\"); private int key; private String value; StateEnum(int key, String value) { this.key = key; this.value = value; } public int getKey() {return key;} public String getValue() {return value;} } \",\"环境上下文类\",\"// 环境上下文 public class Context extends AbstractState{ // 当前的状态 state，根据我们的业务流程处理，不停的变化 private State state; @Override public void checkEvent(Context context) { state.checkEvent(this); getCurrentState(); } @Override public void checkFailEvent(Context context) { state.checkFailEvent(this); getCurrentState(); } @Override public void makePriceEvent(Context context) { state.makePriceEvent(this); getCurrentState(); } @Override public void acceptOrderEvent(Context context) { state.acceptOrderEvent(this); getCurrentState(); } @Override public void notPeopleAcceptEvent(Context context) { state.notPeopleAcceptEvent(this); getCurrentState(); } @Override public void payOrderEvent(Context context) { state.payOrderEvent(this); getCurrentState(); } @Override public void orderFailureEvent(Context context) { state.orderFailureEvent(this); getCurrentState(); } @Override public void feedBackEvent(Context context) { state.feedBackEvent(this); getCurrentState(); } public State getState() { return state; } public void setState(State state) { this.state = state; } @Override public String getCurrentState() { System.out.println(\\\"当前状态 : \\\" + state.getCurrentState()); return state.getCurrentState(); } } \",\"测试类\",\"public class ClientTest { public static void main(String[] args) { // 创建 context 对象 Context context = new Context(); // 将当前状态设置为 PublishState context.setState(new PublishState()); System.out.println(context.getCurrentState()); context.acceptOrderEvent(context); context.payOrderEvent(context); // 失败, 检测失败时，会抛出异常 try { context.checkFailEvent(context); System.out.println(\\\"流程正常..\\\"); } catch (Exception e) { System.out.println(e.getMessage()); } } } \"]},\"780\":{\"h\":\"状态模式的注意事项和细节\",\"t\":[\"状态模式的代码有很强的可读性。状态模式将每个状态的行为封装到对应的一个类\",\"状态模式方便维护。将容易产生问题的 if-else 语句删除了，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多 if-else 语句，而且容易出错\",\"符合「开闭原则」。容易增删状态\",\"会产生很多类。每个状态都要一个对应的类，当状态过多时会产生很多类，加大维护难度\"]},\"781\":{\"h\":\"状态模式的应用场景\",\"t\":[\"通常在以下情况下可以考虑使用状态模式：\",\"当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式\",\"一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时\"]},\"782\":{\"h\":\"行为型策略模式\"},\"783\":{\"h\":\"策略模式基本介绍\",\"t\":[\"在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，出行旅游可以乘坐飞机、乘坐火车、骑自行车或自己开私家车等，超市促销可以釆用打折、送商品、送积分等方法。\",\"在软件开发中也常常遇到类似的情况，当实现某一个功能存在多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能，如数据排序策略有冒泡排序、选择排序、插入排序、二叉树排序等。\",\"如果使用多重条件转移语句实现（即硬编码），不但使条件语句变得很复杂，而且增加、删除或更换算法要修改原代码，不易维护，违背开闭原则。如果采用策略模式就能很好解决该问题。\",\"策略模式（Strategy Pattern）：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。\",\"策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。即定义 算法族（策略组），并分别封装起来，让他们之间可以互相替换，此模式让 算法的变化 独立于 使用算法的客户。\",\"这算法体现了几个设计原则：\",\"把变化的代码从不变的代码中分离出来\",\"针对接口编程而不是具体类（定义了策略接口）\",\"多用组合/聚合，少用继承（客户通过组合方式使用策略模式）\",\"主要优点\",\"多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句，如 if-else 语句、switch-case 语句\",\"策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码\",\"策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的\",\"策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法\",\"策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离\",\"主要缺点\",\"客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类\",\"策略模式造成很多的策略类，增加维护难度\"]},\"784\":{\"h\":\"策略模式的结构与实现\",\"t\":[\"策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的重心不是如何实现算法，而是如何组织这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展性，现在我们来分析其基本结构和实现方法。\",\"策略模式的主要角色如下：\",\"抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现\",\"具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现\",\"环境（Context）类：持有一个策略类的引用，最终给客户端调用\",\"其结构图如图下所示：\",\"image-20220326181157415\",\"代码实现：\",\"// 抽象策略类 interface Strategy { public void strategyMethod(); // 策略方法 } // 具体策略类 A class ConcreteStrategyA implements Strategy { public void strategyMethod() { System.out.println(\\\"具体策略A的策略方法被访问！\\\"); } } // 具体策略类 B class ConcreteStrategyB implements Strategy { public void strategyMethod() { System.out.println(\\\"具体策略B的策略方法被访问！\\\"); } } // 环境类 class Context { private Strategy strategy; public Strategy getStrategy() { return strategy; } public void setStrategy(Strategy strategy) { this.strategy = strategy; } public void strategyMethod() { strategy.strategyMethod(); } } public class StrategyPattern { public static void main(String[] args) { Context c = new Context(); Strategy s = new ConcreteStrategyA(); c.setStrategy(s); c.strategyMethod(); System.out.println(\\\"-----------------\\\"); s = new ConcreteStrategyB(); c.setStrategy(s); c.strategyMethod(); } } \"]},\"785\":{\"h\":\"鸭子项目\",\"t\":[\"要求：\",\"有各种鸭子（比如野鸭、北京鸭、水鸭等。鸭子有各种行为，比如叫、飞行等）\",\"显示鸭子的信息\"]},\"786\":{\"h\":\"传统方式解决鸭子项目\",\"t\":[\"传统的设计方案（类图）\",\"image-20220326180057205\"]},\"787\":{\"h\":\"传统方式代码实现\",\"t\":[\"public abstract class Duck { public Duck() { } public abstract void display(); // 显示鸭子信息 public void quack() { System.out.println(\\\"鸭子嘎嘎叫~~\\\"); } public void swim() { System.out.println(\\\"鸭子会游泳~~\\\"); } public void fly() { System.out.println(\\\"鸭子会飞翔~~~\\\"); } } public class PekingDuck extends Duck { @Override public void display() { System.out.println(\\\"~~北京鸭~~~\\\"); } // 因为北京鸭不能飞翔，因此需要重写 fly @Override public void fly() { System.out.println(\\\"北京鸭不能飞翔\\\"); } } public class WildDuck extends Duck { @Override public void display() { System.out.println(\\\"这是野鸭\\\"); } } \"]},\"788\":{\"h\":\"传统方式问题分析和解决方案\",\"t\":[\"首先其它鸭子都继承了 Duck 类，所以 fly 让所有子类都会飞了，这其实是继承带来的问题：对类的局部改动，尤其超类的局部改动，会影响其他部分。会有 溢出效应。\",\"所以北京鸭类为了改进不能飞问题，我们通过覆盖重写 fly 方法来解决，即 覆盖解决。\",\"问题又来了，如果我们有一个玩具鸭子 ToyDuck 类，这样就需要 ToyDuck 去覆盖重写 Duck 的所有实现的方法，相当于 ToyDuck 类和 Duck 类的方法完全不兼容，那么继承就影响非常大。代码如下：\",\"public class ToyDuck extends Duck{ @Override public void display() { System.out.println(\\\"玩具鸭\\\"); } // 需要重写父类的所有方法 public void quack() { System.out.println(\\\"玩具鸭不能叫~~\\\"); } public void swim() { System.out.println(\\\"玩具鸭不会游泳~~\\\"); } public void fly() { System.out.println(\\\"玩具鸭不会飞翔~~~\\\"); } } \",\"所以解决思路：使用 策略模式（strategy pattern）。\"]},\"789\":{\"h\":\"策略模式解决鸭子项目\",\"t\":[\"思路分析：\",\"策略模式：分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。原则就是：分离变化部分，封装接口，基于接口编程各种功能。此模式让行为的变化独立于算法的使用者。\",\"类图分析：\",\"image-20220326181409122\",\"代码实现：\",\"飞行策略模式类\",\"public interface FlyBehavior { void fly(); // 给子类具体实现 } public class NoFlyBehavior implements FlyBehavior{ @Override public void fly() { System.out.println(\\\"不会飞翔 ~~~\\\"); } } public class BadFlyBehavior implements FlyBehavior { @Override public void fly() { System.out.println(\\\"飞翔技术一般 ~~~\\\"); } } public class GoodFlyBehavior implements FlyBehavior { @Override public void fly() { System.out.println(\\\"飞翔技术高超 ~~~\\\"); } } \",\"叫声策略模式类（该策略类并没有提供实现类，下面的测试类也没有实际使用到该类，这里只是说明：可以使用多种策略）\",\"public interface QuackBehavior { void quack(); // 子类实现 } \",\"鸭子信息类，可以使用多种策略\",\"public abstract class Duck { // 属性, 飞行策略接口 FlyBehavior flyBehavior; // 其它属性：叫声策略接口 QuackBehavior quackBehavior; public Duck() { } public abstract void display(); // 显示鸭子信息 public void quack() { System.out.println(\\\"鸭子嘎嘎叫~~\\\"); } public void swim() { System.out.println(\\\"鸭子会游泳~~\\\"); } public void fly() { // 改进 if(flyBehavior != null) { flyBehavior.fly(); } } public void setFlyBehavior(FlyBehavior flyBehavior) { this.flyBehavior = flyBehavior; } public void setQuackBehavior(QuackBehavior quackBehavior) { this.quackBehavior = quackBehavior; } } public class PekingDuck extends Duck { // 假如北京鸭可以飞翔，但是飞翔技术一般 public PekingDuck() { flyBehavior = new BadFlyBehavior(); quackBehavior = new QuackBehavior(); } @Override public void display() { System.out.println(\\\"~~北京鸭~~~\\\"); } } public class WildDuck extends Duck { // 构造器，传入 FlyBehavor 的对象 public WildDuck() { flyBehavior = new GoodFlyBehavior(); quackBehavior = new QuackBehavior(); } @Override public void display() { System.out.println(\\\" 这是野鸭 \\\"); } } public class ToyDuck extends Duck{ public ToyDuck() { flyBehavior = new NoFlyBehavior(); quackBehavior = new QuackBehavior(); } @Override public void display() { System.out.println(\\\"玩具鸭\\\"); } // 需要重写父类的所有方法 public void quack() { System.out.println(\\\"玩具鸭不能叫~~\\\"); } public void swim() { System.out.println(\\\"玩具鸭不会游泳~~\\\"); } } \",\"测试类\",\"public class Client { public static void main(String[] args) { WildDuck wildDuck = new WildDuck(); wildDuck.fly();// ToyDuck toyDuck = new ToyDuck(); toyDuck.fly(); PekingDuck pekingDuck = new PekingDuck(); pekingDuck.fly(); // 动态改变某个对象的行为, 北京鸭 不能飞 pekingDuck.setFlyBehavior(new NoFlyBehavior()); System.out.println(\\\"北京鸭的实际飞翔能力\\\"); pekingDuck.fly(); } } \"]},\"790\":{\"h\":\"JDK-Arrays 的策略模式剖析\",\"t\":[\"JDK 的 Arrays 的 Comparator 就使用了策略模式。\",\"image-20220326182515064\",\"代码解释：\",\"public class Strategy { public static void main(String[] args) { // 数组 Integer[] data = { 9, 1, 2, 8, 4, 3 }; // 实现降序排序，返回-1 放左边，1 放右边，0 保持不变 // 说明 // 1. 实现了 Comparator 接口（策略接口） , 匿名类 对象 new Comparator<Integer>(){..} // 2. 对象 new Comparator<Integer>(){..} 就是实现了 策略接口 的对象 // 3. public int compare(Integer o1, Integer o2){} 指定具体的处理方式 Comparator<Integer> comparator = new Comparator<Integer>() { public int compare(Integer o1, Integer o2) { if (o1 > o2) { return -1; } else { return 1; } }; }; /* Arrays 的 sort 类 public static <T> void sort(T[] a, Comparator<? super T> c) { if (c == null) { sort(a); // 默认方法 } else { if (LegacyMergeSort.userRequested) { legacyMergeSort(a, c); // 使用策略对象 c } else{ // 使用策略对象 c TimSort.sort(a, 0, a.length, c, null, 0, 0); } } } */ // 方式 1 Arrays.sort(data, comparator); System.out.println(Arrays.toString(data)); // 降序排序 // 方式 2：同时 lambda 表达式实现 策略模式 Integer[] data2 = { 19, 11, 12, 18, 14, 13 }; Arrays.sort(data2, (var1, var2) -> { if(var1.compareTo(var2) > 0) { return -1; } else { return 1; } }); System.out.println(\\\"data2=\\\" + Arrays.toString(data2)); } } \"]},\"791\":{\"h\":\"策略模式的注意事项和细节\",\"t\":[\"策略模式的关键是：分析项目中变化部分与不变部分\",\"策略模式的核心思想是：多用组合/聚合，少用继承；用行为类组合，而不是行为的继承。这样才会更有弹性\",\"策略模式体现了「对修改关闭，对扩展开放」原则，客户端增加行为不用修改原有代码，只要添加一种策略（或者行为）即可，避免了使用多重转移语句（if-else if-else）\",\"策略模式提供了可以替换继承关系的办法：策略模式将算法封装在独立的 Strategy 类中，使得可以独立于其 Context 并改变它，使它易于切换、易于理解、易于扩展\",\"需要注意的是：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞\"]},\"792\":{\"h\":\"策略模式的应用场景\",\"t\":[\"策略模式在很多地方用到，如 Java SE 中的容器布局管理就是一个典型的实例，Java SE 中的每个容器都存在多种布局供用户选择。\",\"在程序设计中，通常在以下几种情况中使用策略模式较多：\",\"一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中\",\"一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句\",\"系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时\",\"系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构\",\"多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为\"]},\"793\":{\"h\":\"设计模式概述\"},\"794\":{\"h\":\"掌握设计模式的层次\",\"t\":[\"第 1 层：刚开始学编程不久，听说过什么是设计模式\",\"第 2 层：有很长时间的编程经验，自己写了很多代码，其中用到了设计模式，但是自己却不知道\",\"第 3 层：学习过了设计模式，发现自己已经在使用了，并且发现了一些新的模式挺好用的\",\"第 4 层：阅读了很多别人写的源码和框架，在其中看到别人设计模式，并且能够领会设计模式的精妙和带来的 好处\",\"第 5 层：代码写着写着，自己都没有意识到使用了设计模式，并且熟练的写了出来\"]},\"795\":{\"h\":\"设计模式介绍\",\"t\":[\"设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是 某类问题的通用解决方案，设计模式（Design pattern）代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\",\"设计模式的本质提高 软件的维护性，通用性和扩展性，并降低软件的复杂度。\",\"《设计模式》 是经典的书，作者是 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides Design（俗称「四人组 GOF」）。\",\"设计模式并不局限于某种语言，Java，PHP，C++ 都有设计模式。\"]},\"796\":{\"h\":\"设计模式的重要性\",\"t\":[\"软件工程中，设计模式（design pattern）是对软件设计中 普遍存在（反复出现） 的各种问题，所提出的 解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在 1990 年代从建筑设计领域引入到计算机科学的。\",\"拿实际工作经历来说，当一个项目开发完后，如果客户 提出增新功能，怎么办?。（可扩展性，使用设计模式，软件具有很好的扩展性）。\",\"如果项目开发完后，原来程序员离职，你接手维护该项目怎么办? (维护性、可读性、规范性)\",\"目前程序员门槛越来越高，一线 IT 公司(大厂)，都会问你在实际项目中 使用过什么设计模式，怎样使用的，解决了什么问题。\",\"设计模式在软件中哪里？面向对象（oo）=> 功能模块[设计模式 + 算法(数据结构)] => 框架（使用到多种设计模式） => 架构（服务器集群）。\",\"如果想成为合格软件工程师，那就花时间来研究下设计模式是非常必要的。\"]},\"797\":{\"h\":\"设计模式的目的\",\"t\":[\"编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的挑战，设计模式是为了让程序（软件），具有更好的：\",\"代码重用性（即：相同功能的代码，不用多次编写）\",\"可读性（即：编程规范性，便于其他程序员的阅读和理解）\",\"可扩展性（即：当需要增加新的功能时，非常的方便，称为可维护）\",\"可靠性（即：当我们增加新的功能后，对原来的功能没有影响）\",\"可靠性（即：当我们增加新的功能后，对原来的功能没有影响）\",\"设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。正确使用设计模式具有以下优点：\",\"可以提高程序员的思维能力、编程能力和设计能力\",\"使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期\",\"使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强\",\"设计模式解决的是设计不足的问题，但同时也要避免设计过度。一定要牢记简洁原则，要知道设计模式是为了使设计简单，而不是更复杂。如果引入设计模式使得设计变得复杂，只能说我们把简单问题复杂化了，问题本身不需要设计模式。\",\"当然，设计模式只是一个引导。在具体的软件幵发中，必须根据设计的应用系统的特点和要求来恰当选择。对于简单的程序开发，苛能写一个简单的算法要比引入某种设计模式更加容易。但对大项目的开发或者框架设计，用设计模式来组织代码显然更好。\",\"设计模式要活学活用，不要生搬硬套。\",\"需要特别声明的是，在日常应用中，设计模式从来都不是单个设计模式独立使用的。在实际应用中，通常多个设计模式混合使用，你中有我，我中有你。如下图：\",\"分享金句：\",\"设计模式包含了面向对象的精髓，「懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的精要」\",\"Scott Mayers 在其巨著《Effective C++》就曾经说过：C++ 老手和 C++ 新手的区别就是前者手背上有很多伤疤\"]},\"798\":{\"h\":\"设计模式类型\",\"t\":[\"根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种：\",\"创建型模式：用于描述「怎样创建对象」，它的主要特点是「将对象的创建与使用分离」\",\"结构型模式：用于描述如何将类或对象按某种布局组成更大的结构\",\"行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责\",\"共 23 种：\",\"创建型模式（5 种）\",\"单例模式（Singleton Pattern）：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式\",\"工厂方法模式（FactoryMethod Pattern）：定义一个用于创建产品的接口，由子类决定生产什么产品\",\"抽象工厂模式（AbstractFactory Pattern）：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品\",\"原型模式（Prototype Pattern）：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例\",\"建造者模式（Builder Pattern）：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象\",\"以上 5 种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式。\",\"结构型模式（7 种）\",\"适配器模式（Adapter Pattern）：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作\",\"桥接模式（Bridge Pattern）：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度\",\"装饰模式（Decorator Pattern）：动态地给对象增加一些职责，即增加其额外的功能\",\"组合模式（Composite Pattern）：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性\",\"外观模式（Facade Pattern）：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问\",\"享元模式（Flyweight Pattern）：运用共享技术来有效地支持大量细粒度对象的复用\",\"代理模式（Proxy Pattern）：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性\",\"以上 7 种结构型模式，除了适配器模式分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式。\",\"行为型模式（11 种）\",\"模板方法模式（Template Method Pattern）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤\",\"命令模式（Command Pattern）：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开\",\"访问者模式（Visitor Pattern）：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问\",\"迭代器模式（Iterator Pattern）：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示\",\"观察者模式（Observer Pattern）：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为\",\"中介者模式（Mediator Pattern）：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解\",\"备忘录模式（Memento Pattern）：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它\",\"解释器模式（Interpreter Pattern）：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器\",\"状态模式（State Pattern）：允许一个对象在其内部状态发生改变时改变其行为能力\",\"策略模式（Strategy Pattern）：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户\",\"职责链模式（Chain of Responsibility Pattern）：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合\",\"以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。\"]},\"799\":{\"h\":\"行为型模板方法模式\"},\"800\":{\"h\":\"模板方法模式基本介绍\",\"t\":[\"在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。\",\"例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。\",\"这样的例子在生活中还有很多，例如，一个人每天会起床、吃饭、做事、睡觉等，其中「做事」的内容每天可能不同。我们把这些规定了流程或格式的实例定义成模板，允许使用者根据自己的需求去更新它，例如，简历模板、论文模板、Word 中模板文件等。\",\"模板方法模式（Template Method Pattern）又叫 模板模式（Template Pattern），在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。\",\"简单说，模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤。\",\"这种类型的设计模式属于行为型模式。\",\"主要优点\",\"它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展\",\"它在父类中提取了公共的部分代码，便于代码复用\",\"部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则\",\"主要缺点\",\"对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度\",\"父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度\",\"由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍\"]},\"801\":{\"h\":\"模板方法模式结构与实现\",\"t\":[\"模板方法模式包含以下主要角色。\",\"抽象类/抽象模板（Abstract Class）\",\"抽象模板类，负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下：\",\"模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法\",\"基本方法：是整个算法中的一个步骤，包含以下几种类型： \",\"抽象方法：在抽象类中声明，由具体子类实现\",\"具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它\",\"钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种\",\"具体子类/具体实现（Concrete Class）\",\"具体实现类，实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。\",\"模板方法模式的结构图如下：\",\"image-20220326113623976\",\"代码实现：\",\"// 抽象类 abstract class AbstractClass { // 模板方法 public void TemplateMethod() { SpecificMethod(); abstractMethod1(); abstractMethod2(); } // 具体方法 public void SpecificMethod() { System.out.println(\\\"抽象类中的具体方法被调用...\\\"); } // 抽象方法 1 public abstract void abstractMethod1(); // 抽象方法 2 public abstract void abstractMethod2(); } // 具体子类 class ConcreteClass extends AbstractClass { public void abstractMethod1() { System.out.println(\\\"抽象方法1的实现被调用...\\\"); } public void abstractMethod2() { System.out.println(\\\"抽象方法2的实现被调用...\\\"); } } public class TemplateMethodPattern { public static void main(String[] args) { AbstractClass tm = new ConcreteClass(); tm.TemplateMethod(); } } \"]},\"802\":{\"h\":\"模板方法模式解决豆浆制作问题\",\"t\":[\"编写制作豆浆的程序，说明如下：\",\"制作豆浆的流程：选材、添加配料、浸泡、放到豆浆机打碎\",\"通过添加不同的配料，可以制作出不同口味的豆浆\",\"选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的（红豆、花生豆浆）\",\"请使用 模板方法模式 完成\",\"思路分析和类图：\",\"image-20220326114122266\"]},\"803\":{\"h\":\"模板方法模式的钩子方法\",\"t\":[\"在模板方法模式的父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法称为 钩子。\",\"比如，我们还希望制作纯豆浆，不添加任何的配料，则使用钩子方法\",\"代码实现：\",\"抽象类\",\"// 抽象类，表示豆浆 public abstract class SoyaMilk { // 模板方法，make，模板方法可以做成final，不让子类去覆盖. final void make() { select(); if(customerWantCondiments()) { addCondiments(); } soak(); beat(); } // 选材料 void select() { System.out.println(\\\"第一步：选择好的新鲜黄豆 \\\"); } // 添加不同的配料，抽象方法，子类具体实现 abstract void addCondiments(); // 浸泡 void soak() { System.out.println(\\\"第三步， 黄豆和配料开始浸泡， 需要3小时 \\\"); } void beat() { System.out.println(\\\"第四步：黄豆和配料放到豆浆机去打碎 \\\"); } // 钩子方法，决定是否需要添加配料 boolean customerWantCondiments() { return true; } } // 红豆类 public class RedBeanSoyaMilk extends SoyaMilk { @Override void addCondiments() { System.out.println(\\\" 加入上好的红豆 \\\"); } } // 花生类 public class PeanutSoyaMilk extends SoyaMilk { @Override void addCondiments() { System.out.println(\\\" 加入上好的花生 \\\"); } } // 纯豆浆类 public class PureSoyaMilk extends SoyaMilk{ @Override void addCondiments() { // 空实现，纯豆浆不需要配料 } @Override boolean customerWantCondiments() { return false; } } \",\"测试类\",\"public class Client { public static void main(String[] args) { // 制作红豆豆浆 System.out.println(\\\"----制作红豆豆浆----\\\"); SoyaMilk redBeanSoyaMilk = new RedBeanSoyaMilk(); redBeanSoyaMilk.make(); System.out.println(\\\"----制作花生豆浆----\\\"); SoyaMilk peanutSoyaMilk = new PeanutSoyaMilk(); peanutSoyaMilk.make(); System.out.println(\\\"----制作纯豆浆----\\\"); SoyaMilk pureSoyaMilk = new PureSoyaMilk(); pureSoyaMilk.make(); } } \"]},\"804\":{\"h\":\"模板方法模式的注意事项和细节\",\"t\":[\"基本思想是：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改。\",\"实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接使用。既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现。\",\"该模式的不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大。一般模板方法都加上 final 关键字， 防止子类重写模板方法。\"]},\"805\":{\"h\":\"模板方法模式的应用场景\",\"t\":[\"模板方法模式通常适用于以下场景：\",\"算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现\",\"当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码\",\"当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展\"]},\"806\":{\"h\":\"设计思想\"},\"807\":{\"h\":\"基于接口而非实现编程\",\"t\":[\"这个原则非常重要，是一种非常有效的提高代码质量的手段，在平时的开发中特别经常被用到。\"]},\"808\":{\"h\":\"如何解读原则中的「接口」二字\",\"t\":[\"「基于接口而非实现编程」这条原则的英文描述是：「Program to an interface, not an implementation」。我们理解这条原则的时候，千万不要一开始就与具体的编程语言挂钩，局限在编程语言的「接口」语法中（比如 Java 中的 interface 接口语法）。这条原则最早出现于 1994 年 GoF 的《设计模式》这本书，它先于很多编程语言而诞生（比如 Java 语言），是一条比较抽象、泛化的设计思想。\",\"实际上，理解这条原则的关键，就是理解其中的「接口」两个字。从本质上来看，「接口」就是一组「协议」或者「约定」，是功能提供者提供给使用者的一个「功能列表」。「接口」在不同的应用场景下会有不同的解读，比如服务端与客户端之间的「接口」，类库提供的「接口」，甚至是一组通信的协议都可以叫作「接口」。刚刚对「接口」的理解，都比较偏上层、偏抽象，与实际的写代码离得有点远。如果落实到具体的编码，「基于接口而非实现编程」这条原则中的「接口」，可以理解为编程语言中的接口或者抽象类。\",\"前面我们提到，这条原则能非常有效地提高代码质量，之所以这么说，那是因为，应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。\",\"实际上，「基于接口而非实现编程」这条原则的另一个表述方式，是「基于抽象而非实现编程」。后者的表述方式其实更能体现这条原则的设计初衷。在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。\"]},\"809\":{\"h\":\"如何将这条原则应用到实战中\",\"t\":[\"假设我们的系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的 AliyunImageStore 类，供整个系统来使用。具体的代码实现如下所示：\",\"public class AliyunImageStore { // ... 省略属性、构造函数等 ... public void createBucketIfNotExisting(String bucketName) { // ... 创建 bucket 代码逻辑 ... // ... 失败会抛出异常 ... } public String generateAccessToken() { // ...根据 accesskey/secrectkey 等生成 access token } public String uploadToAliyun(Image image, String bucketName, String accessToken) { //... 上传图片到阿里云 ... //... 返回图片存储在阿里云上的地址(url）... } public Image downloadFromAliyun(String url, String accessToken) { //... 从阿里云下载图片 ... } } // AliyunImageStore 类的使用举例 public class ImageProcessingJob { private static final String BUCKET_NAME = \\\"ai_images_bucket\\\"; // ... 省略其他无关代码 ... public void process() { Image image = ...; // 处理图片，并封装为 Image 对象 AliyunImageStore imageStore = new AliyunImageStore(/*省略参数*/); imageStore.createBucketIfNotExisting(BUCKET_NAME); String accessToken = imageStore.generateAccessToken(); imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken); } } \",\"整个上传流程包含三个步骤：创建 bucket（你可以简单理解为存储目录）、生成 access token 访问凭证、携带 access token 上传图片到指定的 bucket 中。代码实现非常简单，类中的几个方法定义得都很干净，用起来也很清晰，乍看起来没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。\",\"不过，软件开发中唯一不变的就是变化。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到自建私有云上。为了满足这样一个需求的变化，我们该如何修改代码呢？\",\"我们需要重新设计实现一个存储图片到私有云的 PrivateImageStore 类，并用它替换掉项目中所有的 AliyunImageStore 类对象。这样的修改听起来并不复杂，只是简单替换而已，对整个代码的改动并不大。不过，我们经常说，「细节是魔鬼」。这句话在软件开发中特别适用。实际上，刚刚的设计实现方式，就隐藏了很多容易出问题的「魔鬼细节」，我们一块来看看都有哪些\",\"新的 PrivateImageStore 类需要设计实现哪些方法，才能在尽量最小化代码修改的情况下，替换掉 AliyunImageStore 类呢？这就要求我们必须将 AliyunImageStore 类中所定义的所有 public 方法，在 PrivateImageStore 类中都逐一定义并重新实现一遍。而这样做就会存在一些问题，我总结了下面两点\",\"首先，AliyunImageStore 类中有些函数命名暴露了实现细节，比如，uploadToAliyun() 和 downloadFromAliyun()。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露实现细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。而我们把这种包含「aliyun」字眼的方法，照抄到 PrivateImageStore 类中，显然是不合适的。如果我们在新类中重新命名 uploadToAliyun()、downloadFromAliyun() 这些方法，那就意味着，我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大\",\"其次，将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的。比如，阿里云的图片上传和下载的过程中，需要生产 access token，而私有云不需要 access token。一方面，AliyunImageStore 中定义的 generateAccessToken() 方法不能照抄到 PrivateImageStore 中；另一方面，我们在使用 AliyunImageStore 上传、下载图片的时候，代码中用到了 generateAccessToken() 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整\",\"那这两个问题该如何解决呢？解决这个问题的根本方法就是，在编写代码的时候，要遵从「基于接口而非实现编程」的原则，具体来讲，我们需要做到下面这 3 点。\",\"函数的命名不能暴露任何实现细节。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()\",\"封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用\",\"为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程\",\"我们按照这个思路，把代码重构一下。重构后的代码如下所示：\",\"public interface ImageStore { String upload(Image image, String bucketName); Image download(String url); } public class AliyunImageStore implements ImageStore { // ... 省略属性、构造函数等 ... public String upload(Image image, String bucketName) { createBucketIfNotExisting(bucketName); String accessToken = generateAccessToken(); // ... 上传图片到阿里云 ... // ... 返回图片在阿里云上的地址(url) ... } public Image download(String url) { String accessToken = generateAccessToken(); // ... 从阿里云下载图片 ... } private void createBucketIfNotExisting(String bucketName) { // ... 创建bucket ... // ... 失败会抛出异常 ... } private String generateAccessToken() { // ... 根据 accesskey/secrectkey 等生成 access token } } // 上传下载流程改变：私有云不需要支持 access token public class PrivateImageStore implements ImageStore { public String upload(Image image, String bucketName) { createBucketIfNotExisting(bucketName); // ... 上传图片到私有云 ... // ... 返回图片的ur l... } public Image download(String url) { //... 从私有云下载图片 ... } private void createBucketIfNotExisting(String bucketName) { // ... 创建bucke t... // ... 失败会抛出异常 ... } } // ImageStore 的使用举例 public class ImageProcessingJob { private static final String BUCKET_NAME = \\\"ai_images_bucket\\\"; // ... 省略其他无关代码 ... public void process() { Image image = ...; // 处理图片，并封装为 Image 对象 ImageStore imageStore = new PrivateImageStore(...); imagestore.upload(image, BUCKET_NAME); } } \",\"除此之外，很多人在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。这样的接口设计就没有意义了。不过，如果你觉得这种思考方式更加顺畅，那也没问题，只是将实现类的方法搬移到接口定义中的时候，要有选择性的搬移，不要将跟具体实现相关的方法搬移到接口中，比如 AliyunImageStore 中的 generateAccessToken() 方法。\",\"总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。\"]},\"810\":{\"h\":\"是否需要为每个类定义接口\",\"t\":[\"看了刚刚的讲解，你可能会有这样的疑问：为了满足这条原则，我是不是需要给每个实现类都定义对应的接口呢？在开发的时候，是不是任何代码都要只依赖接口，完全不依赖实现编程呢\",\"做任何事情都要讲求一个「度」，过度使用这条原则，非得给每个类都定义接口，接口满天飞，也会导致不必要的开发负担。至于什么时候，该为某个类定义接口，实现基于接口的编程，什么时候不需要定义接口，直接使用实现类编程，我们做权衡的根本依据，还是要回归到设计原则诞生的初衷上来。只要搞清楚了这条原则是为了解决什么样的问题而产生的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗\",\"前面我们也提到，这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性\",\"从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了\",\"除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间\"]},\"811\":{\"h\":\"多用组合少用继承\",\"t\":[\"在面向对象编程中，有一条非常经典的设计原则，那就是：组合优于继承，多用组合少用继承。为什么不推荐使用继承？组合相比继承有哪些优势？如何判断该用组合还是继承？今天，我们就围绕着这三个问题，来详细讲解一下这条设计原则。\"]},\"812\":{\"h\":\"为什么不推荐使用继承\",\"t\":[\"继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。所以，对于是否应该在项目中使用继承，网上有很多争议。很多人觉得继承是一种反模式，应该尽量少用，甚至不用。为什么会有这样的争议？我们通过一个例子来解释一下。\",\"假设我们要设计一个关于鸟的类。我们将「鸟类」这样一个抽象的事物概念，定义为一个抽象类 AbstractBird。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。\",\"我们知道，大部分鸟都会飞，那我们可不可以在 AbstractBird 抽象类中，定义一个 fly() 方法呢？答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。鸵鸟继承具有 fly() 方法的父类，那鸵鸟就具有「飞」这样的行为，这显然不符合我们对现实世界中事物的认识。当然，你可能会说，我在鸵鸟这个子类中重写（override）fly() 方法，让它抛出 UnSupportedMethodException 异常不就可以了吗？具体的代码实现如下所示：\",\"public class AbstractBird { // ... 省略其他属性和方法 ... public void fly() { // ... } } public class Ostrich extends AbstractBird { // 鸵鸟 // ... 省略其他属性和方法 ... public void fly() { throw new UnSupportedMethodException(\\\"I can't fly.'\\\"); } } \",\"这种设计思路虽然可以解决问题，但不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写 fly() 方法，抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了我们之后要讲的最小知识原则（Least Knowledge Principle，也叫最少知识原则或者迪米特法则），暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。\",\"你可能又会说，那我们再通过 AbstractBird 类派生出两个更加细分的抽象类：会飞的鸟类 AbstractFlyableBird 和不会飞的鸟类 AbstractUnFlyableBird，让麻雀、乌鸦这些会飞的鸟都继承 AbstractFlyableBird，让鸵鸟、企鹅这些不会飞的鸟，都继承 AbstractUnFlyableBird 类，不就可以了吗？\",\"在刚刚这个场景中，我们只关注「鸟会不会飞」，但如果我们还关注「鸟会不会叫」，那这个时候，我们又该如何设计类之间的继承关系呢？\",\"是否会飞？是否会叫？两个行为搭配起来会产生四种情况：会飞会叫、不会飞会叫、会飞不会叫、不会飞不会叫。如果我们继续沿用刚才的设计思路，那就需要再定义四个抽象类（AbstractFlyableTweetableBird、AbstractFlyableUnTweetableBird、AbstractUnFlyableTweetableBird、AbstractUnFlyableUnTweetableBird）。\",\"如果我们还需要考虑「是否会下蛋」这样一个行为，那估计就要组合爆炸了。类的继承层次会越来越深、继承关系会越来越复杂。而这种层次很深、很复杂的继承关系，一方面，会导致代码的可读性变差。因为我们要搞清楚某个类具有哪些方法、属性，必须阅读父类的代码、父类的父类的代码……一直追溯到最顶层父类的代码。另一方面，这也破坏了类的封装特性，将父类的实现细节暴露给了子类。子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改，就会影响所有子类的逻辑。\",\"总之，继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。这也是为什么我们不推荐使用继承。那刚刚例子中继承存在的问题，我们又该如何来解决呢？你可以先自己思考一下，再听我下面的讲解。\"]},\"813\":{\"h\":\"组合相比继承有哪些优势\",\"t\":[\"实际上，我们可以利用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决刚刚继承存在的问题。\",\"接口表示具有某种行为特性。针对「会飞」这样一个行为特性，我们可以定义一个 Flyable 接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义 Tweetable 接口、EggLayable 接口。我们将这个设计思路翻译成 Java 代码的话，就是下面这个样子：\",\"public interface Flyable { void fly(); } public interface Tweetable { void tweet(); } public interface EggLayable { void layEgg(); } public class Ostrich implements Tweetable, EggLayable {//鸵鸟 // ... 省略其他属性和方法... @Override public void tweet() { // ... } @Override public void layEgg() { // ... } } public class Sparrow impelents Flyable, Tweetable, EggLayable {//麻雀 // ... 省略其他属性和方法 ... @Override public void fly() { // ... } @Override public void tweet() { // ... } @Override public void layEgg() { // ... } } \",\"不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法，并且实现逻辑是一样的，这就会导致代码重复的问题。那这个问题又该如何解决呢？\",\"我们可以针对三个接口再定义三个实现类，它们分别是：实现了 fly() 方法的 FlyAbility 类、实现了 tweet() 方法的 TweetAbility 类、实现了 layEgg() 方法的 EggLayAbility 类。然后，通过组合和委托技术来消除代码重复。具体的代码实现如下所示：\",\"public interface Flyable { void fly()； } public class FlyAbility implements Flyable { @Override public void fly() { //... } } // 省略 Tweetable/TweetAbility/EggLayable/EggLayAbility public class Ostrich implements Tweetable, EggLayable { // 鸵鸟 private TweetAbility tweetAbility = new TweetAbility(); // 组合 private EggLayAbility eggLayAbility = new EggLayAbility(); // 组合 // ... 省略其他属性和方法 ... @Override public void tweet() { tweetAbility.tweet(); // 委托 } @Override public void layEgg() { eggLayAbility.layEgg(); // 委托 } } \",\"我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。\"]},\"814\":{\"h\":\"如何判断该用组合还是继承\",\"t\":[\"尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。从上面的例子来看，继承改写成组合意味着要做更细粒度的类的拆分。这也就意味着，我们要定义更多的类和接口。类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。所以，在实际的项目开发中，我们还是要根据具体的情况，来具体选择该用继承还是组合\",\"如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承\",\"除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系\",\"前面我们讲到继承可以实现代码复用。利用继承特性，我们把相同的属性和方法，抽取出来，定义到父类中。子类复用父类中的属性和方法，达到代码复用的目的。但是，有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系。比如，Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却只是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。这个时候，使用组合就更加合理、更加灵活。具体的代码实现如下所示：\",\"public class Url { // ... 省略属性和方法 } public class Crawler { private Url url; // 组合 public Crawler() { this.url = new Url(); } // ... } public class PageAnalyzer { private Url url; // 组合 public PageAnalyzer() { this.url = new Url(); } // ... } \",\"还有一些特殊的场景要求我们必须使用继承。如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如下面这样一段代码，其中 FeignClient 是一个外部类，我们没有权限去修改这部分代码，但是我们希望能重写这个类在运行时执行的 encode() 函数。这个时候，我们只能采用继承来实现了。\",\"public class FeignClient { // Feign Client 框架代码 // ... 省略其他代码 ... public void encode(String url) { // ... } } public void demofunction(FeignClient feignClient) { // ... feignClient.encode(url); // ... } public class CustomizedFeignClient extends FeignClient { @Override public void encode(String url) { // ... 重写 encode 的实现 ...} } // 调用 FeignClient client = new CustomizedFeignClient(); demofunction(client); \",\"尽管有些人说，要杜绝继承，100% 用组合代替继承，但是我的观点没那么极端！之所以「多用组合少用继承」这个口号喊得这么响，只是因为，长期以来，我们过度使用继承。还是那句话，组合并不完美，继承也不是一无是处。只要我们控制好它们的副作用、发挥它们各自的优势，在不同的场合下，恰当地选择使用继承还是组合，这才是我们所追求的境界。\"]},\"815\":{\"h\":\"通过封装、抽象、模块化、中间层等解耦代码\"},\"816\":{\"h\":\"解耦为何如此重要\",\"t\":[\"软件设计与开发最重要的工作之一就是应对复杂性。人处理复杂性的能力是有限的。过于复杂的代码往往在可读性、可维护性上都不友好。那如何来控制代码的复杂性呢？手段有很多，我个人认为，最关键的就是解耦，保证代码松耦合、高内聚。如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段\",\"后文迪米特法则有介绍，什么是「高内聚、松耦合」。实际上，「高内聚、松耦合」是一个比较通用的设计思想，不仅可以指导细粒度的类和类之间关系的设计，还能指导粗粒度的系统、架构、模块的设计。相对于编码规范，它能够在更高层次上提高代码的可读性和可维护性\",\"不管是阅读代码还是修改代码，「高内聚、松耦合」的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于过于发散，降低了阅读和修改代码的难度。而且，因为依赖关系简单，耦合小，修改代码不至于牵一发而动全身，代码改动比较集中，引入 bug 的风险也就减少了很多。同时，「高内聚、松耦合」的代码可测试性也更加好，容易 mock 或者很少需要 mock 外部依赖的模块或者类\",\"除此之外，代码「高内聚、松耦合」，也就意味着，代码结构清晰、分层和模块化合理、依赖关系简单、模块或类之间的耦合小，那代码整体的质量就不会差。即便某个具体的类或者模块设计得不怎么合理，代码质量不怎么高，影响的范围是非常有限的。我们可以聚焦于这个模块或者类，做相应的小型重构。而相对于代码结构的调整，这种改动范围比较集中的小型重构的难度就容易多了\"]},\"817\":{\"h\":\"代码是否需要解耦\",\"t\":[\"那现在问题来了，我们该怎么判断代码的耦合程度呢？或者说，怎么判断代码是否符合 高内聚、松耦合 呢？再或者说，如何判断系统是否需要解耦重构呢\",\"间接的衡量标准有很多，前面我们讲到了一些，比如，看修改代码会不会牵一发而动全身。除此之外，还有一个直接的衡量标准，也是我在阅读源码的时候经常会用到的，那就是把模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构\",\"如果依赖关系复杂、混乱，那从代码结构上来讲，可读性和可维护性肯定不是太好，那我们就需要考虑是否可以通过解耦的方法，让依赖关系变得清晰、简单。当然，这种判断还是有比较强的主观色彩，但是可以作为一种参考和梳理依赖的手段，配合间接的衡量标准一块来使用\"]},\"818\":{\"h\":\"如何给代码解耦\",\"t\":[\"封装与抽象\",\"封装和抽象作为两个非常通用的设计思想，可以应用在很多设计场景中，比如系统、模块、lib、组件、接口、类等等的设计。封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口。\",\"中间层\",\"引入中间层能简化模块或类之间的依赖关系。下面这张图是引入中间层前后的依赖关系对比图。在引入数据存储中间层之前，A、B、C 三个模块都要依赖内存一级缓存、Redis 二级缓存、DB 持久化存储三个模块。在引入中间层之后，三个模块只需要依赖数据存储一个模块即可。从图上可以看出，中间层的引入明显地简化了依赖关系，让代码结构更加清晰。\",\"除此之外，我们在进行重构的时候，引入中间层可以起到过渡的作用，能够让开发和重构同步进行，不互相干扰。比如，某个接口设计得有问题，我们需要修改它的定义，同时，所有调用这个接口的代码都要做相应的改动。如果新开发的代码也用到这个接口，那开发就跟重构冲突了。为了让重构能小步快跑，我们可以分下面四个阶段来完成接口的修改。\",\"第一阶段：引入一个中间层，包裹老的接口，提供新的接口定义\",\"第二阶段：新开发的代码依赖中间层提供的新接口\",\"第三阶段：将依赖老接口的代码改为调用新接口\",\"第四阶段：确保所有的代码都调用新接口之后，删除掉老的接口\",\"这样，每个阶段的开发工作量都不会很大，都可以在很短的时间内完成。重构跟开发冲突的概率也变小了。\",\"模块化\",\"模块化是构建复杂系统常用的手段。不仅在软件行业，在建筑、机械制造等行业，这个手段也非常有用。对于一个大型复杂系统来说，没有人能掌控所有的细节。之所以我们能搭建出如此复杂的系统，并且能维护得了，最主要的原因就是将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。\",\"其他设计思想和原则\",\"高内聚、松耦合 是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。实际上，我们已经多次听到过这个设计思想。很多设计原则都以实现代码的 高内聚、松耦合 为目的。我们来一块简单了解都有哪些原则。\",\"单一职责原则\",\"我们前面提到，内聚性和耦合性并非独立的。高内聚会让代码更加松耦合，而实现高内聚的重要指导原则就是单一职责原则。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了。\",\"基于接口而非实现编程\",\"基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。这样做的好处是，在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。实际上，这就相当于将一种强依赖关系（强耦合）解耦为了弱依赖关系（弱耦合）。依赖注入。\",\"依赖注入\",\"跟基于接口而非实现编程思想类似，依赖注入也是将代码之间的强耦合变为弱耦合。尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以让耦合关系没那么紧密，容易做到插拔替换。\",\"多用组合少用继承\",\"我们知道，继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。相反，组合关系是一种弱依赖关系，这种关系更加灵活，所以，对于继承结构比较复杂的代码，利用组合来替换继承，也是一种解耦的有效手段。\",\"迪米特法则\",\"迪米特法则讲的是，不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。从定义上，我们明显可以看出，这条原则的目的就是为了实现代码的松耦合。除了上面讲到的这些设计思想和原则之外，还有一些设计模式也是为了解耦依赖，比如观察者模式，有关这一部分的内容，我们留在设计模式模块中慢慢讲解。\",\"下一章会继续讲解七大设计原则。\"]},\"819\":{\"h\":\"代码复用\",\"t\":[\"无论是开发哪种软件产品，成本和时间都是最重要的。较少的开发时间意味着可以比竞争对手更早进入市场。较低的开发成本意味着能够留出更多的营销资金，覆盖更广泛的潜在客户。\",\"其中，代码复用是减少开发成本最常用的方式之一，其目的非常明显，即：与其反复从头开发，不如在新对象中重用已有的代码。\",\"这个想法表面看起来很棒，但实际上要让已有的代码在全新的代码中工作，还是需要付出额外努力的。组件间紧密的耦合、对具体类而非接口的依赖和硬编码的行为都会降低代码的灵活性，使得复用这些代码变得更加困难。\",\"使用设计模式是增加软件组件灵活性并使其易于复用的方式之一。但是，这可能也会让组件变得更加复杂。\",\"一般情况下，复用可以分为三个层次。在最底层，可以复用类、类库、容器，也许还有一些类的「团体（例如容器和迭代器）」。\",\"框架位于最高层。它们能帮助你精简自己的设计，可以明确解决问题所需的抽象概念，然后用类来表示这些概念并定义其关系。例如，JUnit 是一个小型框架，也是框架的 Hello, world，其中定义了 Test、TestCase 和 TestSuite 这几个类及其关系。框架通常比单个类的颗粒度要大。你可以通过在某处构建子类来与框架建立联系。这些子类信奉「别给我们打电话，我们会给你打电话的。」\",\"还有一个中间层次。这是我觉得设计模式所处的位置。设计模式比框架更小且更抽象。它们实际上是对一组类的关系及其互动方式的描述。当你从类转向模式，并最终到达框架的过程中，复用程度会不断增加。\",\"中间层次的优点在于模式提供的复用方式要比框架的风险小。创建框架是一项投入重大且风险很高的工作，模式则能让你独立于具体代码来复用设计思想和理念。\"]},\"820\":{\"h\":\"扩展性\",\"t\":[\"需求变化是程序员生命中唯一不变的事情。比如以下几种场景：\",\"你在 Windows 平台上发布了一款游戏，现在人们想要 Mac OS 的版本\",\"你创建了一个使用方形按钮的 GUI 框架，但几个月后开始流行原型按钮\",\"你设计了一款优秀的电子商务网站，但仅仅几个月后，客户就要求新增电话订单的功能\",\"每个软件开发者都经历过许多相似的故事，导致它们发生的原因也不少。\",\"首先，在完成了第一版的程序后，我们就应该做好了从头开始优化重写代码的准备，因为现在你已经能在很多方面更好的理解问题了，同时在专业水平上也有所提高，所以之前的代码现在看上去可能会显得很糟糕。\",\"其次，可能是在你掌控之外的某些事情发生了变化，这也是导致许多开发团队转变最初想法的原因。比如，每位在网络应用中使用 Flash 的开发者都必须重新开发或移植代码，因为不断地有浏览器停止对 Flash 格式地支持。\",\"最后，可能是需求的改变，之前你的客户对当前版本的程序感到满意，但是现在希望对程序进行 11 个「小小」的改动，使其可完成原始计划阶段中完全没有提到的功能，新增或改变功能。\",\"当然这也有好的一面，如果有人要求你对程序进行修改，至少说明还有人关心它。因此在设计程序架构时，有经验的开发者都会尽量选择支持未来任何可能变更的方式。\"]},\"821\":{\"h\":\"UML类图\"},\"822\":{\"h\":\"UML 基本介绍\",\"t\":[\"997 年 UML 被国际对象管理组织（OMG）采纳为面向对象的建模语言的国际标准。它的特点是 简单、统一、图形化、能表达软件设计中的动态与静态信息。\",\"UML：Unified modeling language UML (统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果。\",\"UML 本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他 们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等，如右图：\",\"画 UML 图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理，UML 图分类：\",\"用例图（use case）\",\"静态结构图：类图、对象图、包图、组件图、部署图\",\"动态行为图：交互图（时序图与协作图）、状态图、活动图\",\"说明：类图是描述类与类之间的关系的，是 UML 图中最核心的。\"]},\"823\":{\"h\":\"应用场景\",\"t\":[\"UML 能为软件开发的所有阶段提供模型化和可视化支持。而且融入了软件工程领域的新思想、新方法和新技术，使软件设计人员沟通更简明，进一步缩短了设计时间，减少开发成本。\",\"UML 具有很宽的应用领域。其中最常用的是建立软件系统的模型，但它同样可以用于描述非软件领域的系统，如机械系统、企业机构或业务过程，以及处理复杂数据的信息系统、具有实时要求的工业系统或工业过程等。总之，UML 可以对任何具有静态结构和动态行为的系统进行建模，而且使用于从需求规格描述直至系统完成后的测试和维护等系统开发的各个阶段。\",\"UML 模型大多以图表的方式表现出来，一份典型的建模图表通常包含几个块或框、连接线和作为模型附加信息的文本。这些虽简单却非常重要，在 UML 规则中相互联系和扩展。\",\"在这里大家可能会疑问，UML 明明是一种图形，为什么说是语言呢？\",\"语言是包括文字和图形的，有很多内容文字是无法表达的。你见过建筑设计图纸吗？里面还不是很多图形，光用文字能表达清楚建筑设计吗？在建筑界，有一套标准来描述设计，同样道理，在软件开发界，我们也需要一套标准来帮助我们做好软件开发的工作。UML 就是其中的一种标准，注意这可不是唯一标准，只是 UML 是大家比较推崇的一种标准而已。UML 并不是强制性标准，没有规定在软件开发中一定要用 UML，但是我们需要包括 UML 在内的各种标准，来提高我们软件开发的水平。\"]},\"824\":{\"h\":\"基本构件\",\"t\":[\"UML 建模的核心是模型，模型是现实的简化、真实系统的抽象。UML 提供了系统的设计蓝图。当给软件系统建模时，需要采用通用的符号语言，这种描述模型所使用的语言被称为建模语言。在 UML 中，所有的描述由事物、关系和图这些构件组成。下图完整地描述了所有构件的关系：\",\"image-20220326235402075\"]},\"825\":{\"h\":\"UML 接口\",\"t\":[\"接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。\",\"如下所示是图形类接口的 UML 表示：\",\"image-20220327001037848\",\"如果在 IDEA，那么是：\",\"image-20220327001011970\"]},\"826\":{\"h\":\"UML 类图\",\"t\":[\"类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。它主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，它是系统分析与设计阶段的重要产物，也是系统编码与测试的重要模型依据。\",\"类图中的类可以通过某种编程语言直接实现。类图在软件系统开发的整个生命周期都是有效的，它是面向对象系统的建模中最常见的图。如下所示是「计算长方形和圆形的周长与面积」的类图，图形接口有计算面积和周长的抽象方法，长方形和圆形实现这两个方法供访问类调用。\",\"类图用于描述系统中的类（对象）本身的组成和类（对象）之间的各种静态关系。\",\"类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合\",\"类图简单举例\",\"public class Person{ private Integer id; private String name; public void setName(String name){ this.name=name; } public String getName(){ return name; } } \",\"对该类右键\",\"image-20220226225439452\",\"image-20220226225625153\",\"如果新建一个类图，快捷键是空格，或者对着空白处右键，点击 Add Class to Diagram...，搜索其他类即可。\",\"类图用 3 个矩形拼接表示，最上面的部分标识类的名称，中间的部分标识类的属性，最下面的部分标识类的方法。\",\"类图中，需注意以下几点：\",\"抽象类或抽象方法用斜体表示\",\"如果是接口，则在类名上方加 <<Interface>>\",\"字段和方法返回值的数据类型非必需\",\"静态类或静态方法加下划线\"]},\"827\":{\"h\":\"类之间的关系\",\"t\":[\"UML 将事物之间的联系归纳为 6 种，并用对应的图形类表示。下面根据类与类之间的耦合度从弱到强排列。UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。\"]},\"828\":{\"h\":\"类图—依赖关系（Dependence）\",\"t\":[\"依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。\",\"只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。\",\"依赖关系使用 带箭头的虚线 来表示，箭头从使用类指向被依赖的类。\",\"public class PersonServiceBean { private PersonDao personDao; // 类 public void save(Person person){} public IDCard getIDCard(Integer personid){return null;} public void modify(){ Department department = new Department(); } } class PersonDao{} class IDCard{} class Person1{} class Department{} \",\"对应的类图：\",\"image-20220226230456728\"]},\"829\":{\"h\":\"小结\",\"t\":[\"什么时候显示依赖关系：\",\"类中用到了对方\",\"如果是类的成员属性\",\"如果是方法的返回类型\",\"是方法接收的参数类型\",\"方法中使用到\"]},\"830\":{\"h\":\"类图—关联关系（Association）\",\"t\":[\"关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。\",\"关联具有 导航性：即双向关系或单向关系。\",\"关联具有多重性：如 1(表示有且仅有一个），「0...」(表示 0 个或者多个），「0，1」(表示 0 个或者一个）,「n.….」(表示 n 到 m 个都可以)，「m.….*」（表示至少 m 个)。\",\"关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用 带两个箭头或者没有箭头的实线 来表示，单向的关联用 带一个箭头的实线 来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。\",\"双向一对一关系\",\"public class Tercher { private String name; private List<Student> stus; } class Student { private String name; private List<Tercher> teas; public void study(){ } } \",\"image-20220327001329079\"]},\"831\":{\"h\":\"类图—聚合关系（Aggregation）\",\"t\":[\"聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系，是 整体和部分的关系，整体与部分可以分开，是 关联关系的特例，所以他具有关联的 导航性与多重性。\",\"聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。\",\"在 UML 类图中，聚合关系可以用 带空心菱形的实线 来表示，菱形指向整体。如下是大学和教师的代码和关系图：\",\"public class University { private Teacher teas; public void setTeacher(Teacher teas) { this.teas = teas; } } class Teacher { private String name; public void teaching(); } \",\"image-20220327001543029\"]},\"832\":{\"h\":\"类图—组合关系（Composition）\",\"t\":[\"组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。\",\"在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。\",\"在 UML 类图中，组合关系用 带实心菱形的实线 来表示，菱形指向整体。\",\"案例：在程序中我们定义实体：Person（人）与 IDCard（身份证）、Head（头），那么 Head 和 Person 就是组合，IDCard 和 Person 就是聚合。\",\"但是如果在程序中 Person 实体中定义了对 IDCard 进行级联删除，即删除 Person 时连同 IDCard 一起删除，那 么 IDCard 和 Person 就是组合了。\",\"案例 1\",\"public class Head{ private IDCard card; private Head head = new Head(); } public class IDCard{} public class Head{} \",\"如下图，可以看到黑色的箭头是组合关系，白色的箭头是聚合。\",\"image-20220226232425687\",\"案例 2\",\"public class Computer { private Mouse mouse = new Mouse(); // 鼠标可以和 Computer 不能分离 private Moniter moniter = new Moniter();// 显示器可以和 Computer 不能分离 public void setMouse(Mouse mouse) { this.mouse = mouse; } public void setMoniter(Moniter moniter) { this.moniter = moniter; } } public class Mouse { } public class Moniter { } \",\"image-20220226232506081\",\"聚合通过方法参数、构造器、setter 传入对象，是组合的弱引用。\",\"组合是直接 new 出对象，依赖性强。\"]},\"833\":{\"h\":\"类图—泛化关系(generalization）\",\"t\":[\"泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。\",\"在 UML 类图中，泛化关系用 带空心三角箭头的实线 来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。\",\"abstract class DaoSupport{ public void save(Object entity){ } public void delete(Object id){ } } class PersonServiceBean2 extends DaoSupport{ } \",\"类图（蓝色是 IDEA 自带，实际是空心的）：\",\"image-20220226231114471\"]},\"834\":{\"h\":\"类图—实现关系（Implementation）\",\"t\":[\"实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。\",\"在 UML 类图中，实现关系使用 带空心三角箭头的虚线 来表示，箭头从实现类指向接口。\",\"实现关系实际上就是 A 类实现 B 接口，他是依赖关系的特例。\",\"public interface PersonService { public void delete(Interger id); } public class PersonServiceBean implements PersonService { public void delete(Interger id){} } \",\"如下图，绿色是 IDEA 自带，实际是空心的虚线：\",\"image-20220226231346103\"]},\"835\":{\"h\":\"类与类箭头技巧\",\"t\":[\"画类图时，要使用正确的箭头。类关系记忆技巧总结如下表所示：\",\"分类\",\"箭头特征\",\"记忆技巧\",\"箭头方向\",\"从子类指向父类\",\"定义子类需要通过 extends 关键字指定父类子类一定是知道父类定义的，但父类并不知道子类的定义只有知道对方信息时才能指向对方箭头的方向是从子类指向父类\",\"继承/实现\",\"用线条连接两个类； 空心三角箭头表示继承或实现\",\"实线表示继承，是is-a的关系，表示扩展，不虚，很结实\",\"虚线表示实现，虚线代表「虚」无实体\",\"关联/依赖\",\"用线条连接两个类； 普通箭头表示关联或依赖\",\"虚线表示依赖关系：临时用一下，若即若离，虚无缥缈，若有若无表示一种使用关系，一个类需要借助另一个类来实现功能一般一个类将另一个类作为参数使用，或作为返回值\",\"实线表示关联关系：关系稳定，实打实的关系，「铁哥们」表示一个类对象和另一个类对象有关联通常一个类中有另一个类对象作为属性\",\"组合/聚合\",\"用菱形表示：像一个盛东西的器皿（如盘子）\",\"聚合：空心菱形，代表空器皿里可以放很多相同的东西，聚集在一起（箭头方向所指的类）整体和局部的关系，两者有独立的生命周期，是 has-a 的关系弱关系，消极的词：弱-空\",\"组合：实心菱形，代表器皿里已经有实体结构的存在，生死与共整体与局部的关系，和聚合关系对比，关系更加强烈，两者具有相同的生命周期，contains-a 的关系强关系，积极的词；强-满\",\"注意：UML 的标准类关系图中，没有实心箭头。有些 Java 编程的 IDE 自带类生成工具可能出现实心箭头，主要目的是降低理解难度。\"]},\"836\":{\"h\":\"行为型访问者模式\"},\"837\":{\"h\":\"访问者模式基本介绍\",\"t\":[\"在现实生活中，有些集合对象存在多种不同的元素，且每种元素也存在多种不同的访问者和处理方式。例如，公园中存在多个景点，也存在多个游客，不同的游客对同一个景点的评价可能不同；医院医生开的处方单中包含多种药元素，査看它的划价员和药房工作人员对它的处理方式也不同，划价员根据处方单上面的药品名和数量进行划价，药房工作人员根据处方单的内容进行抓药。\",\"这样的例子还有很多，例如，电影或电视剧中的人物角色，不同的观众对他们的评价也不同；还有顾客在商场购物时放在「购物车」中的商品，顾客主要关心所选商品的性价比，而收银员关心的是商品的价格和数量。\",\"这些被处理的数据元素相对稳定而访问方式多种多样的数据结构，如果用「访问者模式」来处理比较方便。访问者模式能把处理方法从数据结构中分离出来，并可以根据需要增加新的处理方法，且不用修改原来的程序代码与数据结构，这提高了程序的扩展性和灵活性。\",\"访问者模式（Visitor Pattern），将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。\",\"访问者模式（Visitor）是一种对象行为型模式，基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口。\",\"访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作（这些操作彼此没有关联），同时需要避免让这些操作「污染」这些对象的类，可以选用访问者模式解决。\",\"主要优点\",\"扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能\",\"复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度\",\"灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构\",\"符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一\",\"主要缺点\",\"增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了「开闭原则」\",\"破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性\",\"违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类\"]},\"838\":{\"h\":\"访问者模式的结构与实现\",\"t\":[\"访问者模式包含以下主要角色：\",\"抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit()，该操作中的参数类型标识了被访问的具体元素\",\"具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么\",\"抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数\",\"具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this)，另外具体元素中可能还包含本身业务逻辑的相关操作\",\"对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现\",\"结构图如下：\",\"image-20220326123351242\",\"代码实现：\",\"// 抽象访问者 interface Visitor { void visit(ConcreteElementA element); void visit(ConcreteElementB element); } // 具体访问者 A 类 class ConcreteVisitorA implements Visitor { public void visit(ConcreteElementA element) { System.out.println(\\\"具体访问者A访问-->\\\" + element.operationA()); } public void visit(ConcreteElementB element) { System.out.println(\\\"具体访问者A访问-->\\\" + element.operationB()); } } // 具体访问者 B 类 class ConcreteVisitorB implements Visitor { public void visit(ConcreteElementA element) { System.out.println(\\\"具体访问者B访问-->\\\" + element.operationA()); } public void visit(ConcreteElementB element) { System.out.println(\\\"具体访问者B访问-->\\\" + element.operationB()); } } // 抽象元素类 interface Element { void accept(Visitor visitor); } // 接收者元素 A 类 class ConcreteElementA implements Element { public void accept(Visitor visitor) { visitor.visit(this); } public String operationA() { return \\\"具体元素A的操作。\\\"; } } // 接收者元素 B 类 class ConcreteElementB implements Element { public void accept(Visitor visitor) { visitor.visit(this); } public String operationB() { return \\\"具体元素B的操作。\\\"; } } // 对象结构角色 class ObjectStructure { private List<Element> list = new ArrayList<Element>(); public void accept(Visitor visitor) { Iterator<Element> i = list.iterator(); while (i.hasNext()) { ((Element) i.next()).accept(visitor); } } public void add(Element element) { list.add(element); } public void remove(Element element) { list.remove(element); } } public class VisitorPattern { public static void main(String[] args) { ObjectStructure os = new ObjectStructure(); os.add(new ConcreteElementA()); os.add(new ConcreteElementB()); Visitor visitor = new ConcreteVisitorA(); os.accept(visitor); System.out.println(\\\"------------------------\\\"); visitor = new ConcreteVisitorB(); os.accept(visitor); } } \"]},\"839\":{\"h\":\"访问者模式应用实例\",\"t\":[\"将观众分为男人和女人，对歌手进行测评，当看完某个歌手表演后，得到他们对该歌手不同的评价（评价有不同的种类，比如成功、失败等）\",\"思路分析和类图：\",\"image-20220326123658042\",\"代码实现：\",\"行为类\",\"public abstract class Action { // 得到男性的测评 public abstract void getManResult(Man man); // 得到女性的测评 public abstract void getWomanResult(Woman woman); } public class Success extends Action { @Override public void getManResult(Man man) { System.out.println(\\\" 男人给的评价该歌手很成功 !\\\"); } @Override public void getWomanResult(Woman woman) { System.out.println(\\\" 女人给的评价该歌手很成功 !\\\"); } } public class Fail extends Action { @Override public void getManResult(Man man) { System.out.println(\\\" 男人给的评价该歌手失败 !\\\"); } @Override public void getWomanResult(Woman woman) { System.out.println(\\\" 女人给的评价该歌手失败 !\\\"); } } public class Wait extends Action { @Override public void getManResult(Man man) { System.out.println(\\\" 男人给的评价是该歌手待定 ..\\\"); } @Override public void getWomanResult(Woman woman) { System.out.println(\\\" 女人给的评价是该歌手待定 ..\\\"); } } \",\"访问者类\",\"public abstract class Person { // 提供一个方法，让访问者可以访问 public abstract void accept(Action action); } public class Man extends Person { @Override public void accept(Action action) { action.getManResult(this); } } // 说明 // 1. 这里我们使用到了双分派, 即首先在客户端程序中，将具体状态作为参数传递 Woman 中(第一次分派) // 2. 然后 Woman 类调用作为参数的 \\\"具体方法\\\" 中方法 getWomanResult, 同时将自己(this)作为参数传入，完成第二次的分派 public class Woman extends Person{ @Override public void accept(Action action) { action.getWomanResult(this); } } \",\"管理类\",\"// 数据结构，管理很多人（Man , Woman） public class ObjectStructure { // 维护了一个集合 private List<Person> persons = new LinkedList<>(); // 增加到 list public void attach(Person p) { persons.add(p); } // 移除 public void detach(Person p) { persons.remove(p); } // 显示测评情况 public void display(Action action) { for(Person p: persons) { p.accept(action); } } } \",\"测试类\",\"public class Client { public static void main(String[] args) { // 创建 ObjectStructure ObjectStructure objectStructure = new ObjectStructure(); objectStructure.attach(new Man()); objectStructure.attach(new Woman()); // 成功 Success success = new Success(); objectStructure.display(success); System.out.println(\\\"===============\\\"); Fail fail = new Fail(); objectStructure.display(fail); System.out.println(\\\"=======给的是待定的测评========\\\"); Wait wait = new Wait(); objectStructure.display(wait); } } \",\"上面 Woman 类提到了 双分派，所谓双分派是指不管类怎么变化，我们都能找到期望的方法运行。双分派意味着得到执行的操作取决于请求的种类和两个接收者的类型。\",\"以上述实例为例，假设我们要添加一个 Wait 的状态类，考察 Man 类和 Woman 类的反应，由于使用了 双分派，只需增加一个 Action 子类即可在客户端调用即可，不需要改动任何其他类的代码。\"]},\"840\":{\"h\":\"访问者模式的注意事项和细节\",\"t\":[\"访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常高。访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统。\",\"访问者模式的具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的, 这样造成了具体元素变更比较困难，违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素。\",\"因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么 访问者模式就是比较合适的\"]},\"841\":{\"h\":\"访问者模式的应用场景\",\"t\":[\"当系统中存在类型数量稳定（固定）的一类数据结构时，可以使用访问者模式方便地实现对该类型所有数据结构的不同操作，而又不会对数据产生任何副作用（脏数据）。\",\"简而言之，就是当对集合中的不同类型数据（类型数量稳定）进行多种操作时，使用访问者模式。\",\"通常在以下情况可以考虑使用访问者（Visitor）模式：\",\"对象结构相对稳定，但其操作算法经常变化的程序\",\"对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构\",\"对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。\"]},\"842\":{\"h\":\"阿里巴巴 Java 开发手册\"},\"843\":{\"h\":\"前言\",\"t\":[\"《Java开发手册》是阿里巴巴和开课吧技术团队的集体智慧结晶和经验总结，经历了多次大规模一线实战的检验及不断完善，公开到业界后，众多社区开发者踊跃参与打磨完善，系统化地整理成册，当前的最新版本是黄山版。现代软件行业的高速发展对开发者的综合素质要求越来越高，因为不仅是编程知识点，其它维度的知识点也会影响到软件的最终交付质量。比如：五花八门的错误码会人为地增加排查问题的难度；数据库的表结构和索引设计缺陷带来的系统架构缺陷或性能风险；工程结构混乱导致后续项目维护艰难；没有鉴权的漏洞代码容易被黑客攻击等。所以本手册以Java开发者为中心视角，划分为编程规约、异常日志、单元测试、安全规约、MySQL数据库、工程结构、设计规约七个维度，再根据内容特征，细分成若干二级子目录。此外，依据约束力强弱及故障敏感性，规约依次分为【强制】、【推荐】、【参考】三大类。在延伸的信息中，“说明”对规约做了适当扩展和解释；“正例”提倡什么样的编码和实现方式；“反例”说明需要提防的雷区，以及真实的错误案例。\",\"手册的愿景是码出高效，码出质量。现代软件架构的复杂性需要协同开发完成，如何高效地协同呢？无规矩不成方圆，无规范难以协同，比如，制定交通法规表面上是要限制行车权，实际上是保障公众的人身安全，试想如果没有限速，没有红绿灯，谁还敢上路行驶？对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式一起做事，提升协作效率，降低沟通成本。代码的字里行间流淌的是软件系统的血液，代码质 量的提升是尽可能少踩坑，杜绝踩重复的坑，切实提升系统稳定性，码出质量。2017 年杭州云栖大会上发布了配套的Java开发规约IDE插件，下载量已达到 275 万人次，阿里云效也集成了代码规约扫描引擎。 2018 年 9 月在云栖厅发布 36 万字的配套详解图书《码出高效》，秉持“图胜于表，表胜于言”的理念，深入浅出地将计算机基础、面向对象思想、数据结构与集合、JVM探源与内存分析、并发与多线程、单元测试等知识丰富立体地呈现出来。本书紧扣学以致用、学以精进的目标，结合一线开发的实践经验和故障案例，与底层源码解析融会贯通，娓娓道来。《码出高效》和《Java开发手册（第 2 版）》稿费所得收入均捐赠公益事情，希望用技术情怀帮助到更多的人。\"]},\"844\":{\"h\":\"一、编程规约\"},\"845\":{\"h\":\"(一) 命名风格\",\"t\":[\"【强制】所有编程相关的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。反例：_name / __name / / Object$\",\"【强制】所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。正例：ali / alibaba / taobao / kaikeba / aliyun / youku / hangzhou等国际通用的名称，可视同英文。反例：DaZhePromotion【打折】/ getPingfenByName()【评分】 / String fw【福娃】/ int 变量名 = 3\",\"【强制】代码和注释中都要避免使用任何人类语言中的种族歧视性或侮辱性词语。正例：blockList / allowList / secondary反例：blackList / whiteList / slave / SB / WTF\",\"【强制】类名使用UpperCamelCase风格，以下情形例外：DO / PO / DTO / BO / VO / UID等。正例：ForceCode / UserDO / HtmlDTO / XmlService / TcpUdpDeal / TaPromotion反例：forcecode / UserDo / HTMLDto / XMLService / TCPUDPDeal / TAPromotion\",\"【强制】方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格。正例：localValue / getHttpMessage() / inputUserId\",\"【强制】常量命名应该全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。正例：MAX_STOCK_COUNT / CACHE_EXPIRED_TIME反例：MAX_COUNT / EXPIRED_TIME\",\"【强制】抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾，测试类命名以它要测试的类的名称开始，以Test结尾。\",\"【强制】类型与中括号紧挨相连来定义数组。正例：定义整形数组int[] arrayDemo。反例：在main参数中，使用String args[] 来定义。\",\"【强制】POJO类中的任何布尔类型的变量，都不要加is前缀，否则部分框架解析会引起序列化错误。 说明：本文MySQL规约中的建表约定第 1 条，表达是与否的变量采用is_xxx的命名方式，所以需要在<resultMap>设置从is_xxx到xxx的映射关系。反例：定义为基本数据类型Boolean isDeleted的属性，它的方法也是isDeleted()，框架在反向解析时，“误以为”对应的属性名称是deleted，导致属性获取不到，进而抛出异常。\",\"【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。正例：应用工具类包名为com.alibaba.ei.kunlun.aap.util；类名为MessageUtils（此规则参考spring的框架结构）。\",\"【强制】避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可理解性降低。说明：子类、父类成员变量名相同，即使是public也是能够通过编译，而局部变量在同一方法内的不同代码块中同名也是合法的，但是要避免使用。对于非setter / getter的参数名称也要避免与成员变量名称相同。反例：\",\"public class ConfusingName { protected int stock; protected String alibaba; // 非setter/getter的参数名称，不允许与本类成员变量同名 public void access(String alibaba) { if (condition) { final int money = 666; // ... } for (int i = 0; i < 10; i++) { // 在同一方法体中，不允许与其它代码块中的money命名相同 final int money = 15978; // ... } } } class Son extends ConfusingName { // 不允许与父类的成员变量名称相同 private int stock; } \",\"【强制】杜绝完全不规范的英文缩写，避免望文不知义。反例：AbstractClass“缩写”成AbsClass；condition“缩写”成condi；Function“缩写”成Fu，此类随意缩写严重降低了代码的可阅读性。\",\"【推荐】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用完整的单词组合来表达。正例：在JDK中，对某个对象引用的volatile字段进行原子更新的类名为AtomicReferenceFieldUpdater。反例：常见的方法内变量为int a; 的定义方式。\",\"【推荐】在常量与变量命名时，表示类型的名词放在词尾，以提升辨识度。正例：startTime / workQueue / nameList / TERMINATED_THREAD_COUNT反例：startedAt / QueueOfWork / listName / COUNT_TERMINATED_THREAD\",\"【推荐】如果模块、接口、类、方法使用了设计模式，在命名时要体现出具体模式。 说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。正例：\",\"public class OrderFactory; public class LoginProxy; public class ResourceObserver; \",\"【推荐】接口类中的方法和属性不要加任何修饰符号（public也不要加），保持代码的简洁性，并加上有效的Javadoc注释。尽量不要在接口里定义常量，如果一定要定义，最好确定该常量与接口的方法相关，并且是整个应用的基础常量。正例：接口方法签名void commit(); ​ 接口基础常量String COMPANY = \\\"alibaba\\\";反例：接口方法定义public abstract void commit(); 说明：JDK8中接口允许有默认实现，那么这个default方法，是对所有实现类都有价值的默认实现。\",\"接口和实现类的命名有两套规则： 1 ）【强制】对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口，内部的实现类用Impl的后缀与接口区别。正例：CacheServiceImpl实现CacheService接口。 2 ）【推荐】如果是形容能力的接口名称，取对应的形容词为接口名（通常是 – able结尾的形容词）。正例：AbstractTranslator实现Translatable。\",\"【参考】枚举类名带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。 说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。正例：枚举名字为ProcessStatusEnum的成员名称：SUCCESS / UNKNOWN_REASON\",\"【参考】各层命名规约： A）Service / DAO层方法命名规约： ​ 1 ）获取单个对象的方法用get做前缀。 ​ 2 ）获取多个对象的方法用list做前缀，复数结尾，如：listObjects ​ 3 ）获取统计值的方法用count做前缀。 ​ 4 ）插入的方法用save / insert做前缀。 ​ 5 ）删除的方法用remove / delete做前缀。 ​ 6 ）修改的方法用update做前缀。 ​ 7 ）检查的方法用check做前缀。 B）领域模型命名规约： ​ 1 ）数据对象：xxxDO，xxx即为数据表名。 ​ 2 ）数据传输对象：xxxDTO，xxx为业务领域相关的名称。 ​ 3 ）展示对象：xxxVO，xxx一般为网页名称。 ​ 4 ）POJO是DO / DTO / BO / VO的统称，禁止命名成xxxPOJO。\"]},\"846\":{\"h\":\"(二) 常量定义\",\"t\":[\"【强制】不允许任何魔法值（即未经预先定义的常量）直接出现在代码中。反例： // 开发者A定义了缓存的key。\",\"String key = \\\"Id#taobao_\\\" + tradeId; cache.put(key, value); \",\"// 开发者B使用缓存时直接复制少了下划线，即key是\\\"Id#taobao\\\" + tradeId，导致出现故障。\",\"String key = \\\"Id#taobao\\\" + tradeId; cache.get(key); \",\"【强制】long或Long赋值时，数值后使用大写L，不能是小写l，小写容易跟数字混淆，造成误解。 说明：public static final Long NUM = 2 l; 写的是数字的 21 ，还是Long型的 2 ？\",\"【强制】浮点数类型的数值后缀统一为大写的D或F。正例：\",\"public static final double HEIGHT = 175.5D; public static final float WEIGHT = 150.3F; \",\"【推荐】不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。 说明：大而全的常量类，杂乱无章，使用查找功能才能定位到要修改的常量，不利于理解，也不利于维护。正例：缓存相关常量放在类CacheConsts下；系统配置相关常量放在类SystemConfigConsts下。\",\"【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。 1 ）跨应用共享常量：放置在二方库中，通常是client.jar中的constant目录下。 2 ）应用内共享常量：放置在一方库中，通常是子模块中的constant目录下。反例： 易懂常量也要统一定义成应用内共享常量，两个程序员在两个类中分别定义了表示“是”的常量： ​类A中：public static final String YES = \\\"yes\\\"; ​类B中：public static final String YES = \\\"y\\\"; ​A.YES.equals(B.YES)，预期是true，但实际返回为false，导致线上问题。 3 ）子工程内部共享常量：即在当前子工程的constant目录下。 4 ）包内共享常量：即在当前包下单独的constant目录下。 5 ）类内共享常量：直接在类内部private static final定义。\",\"【推荐】如果变量值仅在一个固定范围内变化用enum类型来定义。 说明：如果存在名称之外的延伸属性应使用enum类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节。正例：\",\"public enum SeasonEnum { SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4); private int seq; SeasonEnum(int seq) { this.seq = seq; } public int getSeq() { return seq; } } \"]},\"847\":{\"h\":\"(三) 代码格式\",\"t\":[\"【强制】如果大括号内为空，简洁地写成{}即可，大括号中间无需换行和空格；如果是非空代码块，则： 1 ）左大括号前不换行。 2 ）左大括号后换行。 3 ）右大括号前换行。 4 ）右大括号后还有else等代码则不换行；表示终止的右大括号后必须换行。\",\"【强制】左小括号和右边相邻字符之间不需要空格；右小括号和左边相邻字符之间也不需要空格；而左大括号前需要加空格。详见第 5 条下方正例提示。反例：if(空格 a == b空格)\",\"【强制】if / for / while / switch / do等保留字与左右括号之间都必须加空格。\",\"【强制】任何二目、三目运算符的左右两边都需要加一个空格。 说明：包括赋值运算符 =、逻辑运算符 &&、加减乘除符号等。\",\"【强制】采用 4 个空格缩进，禁止使用Tab字符。 说明：如使用Tab缩进，必须设置 1 个Tab为 4 个空格。IDEA设置Tab为 4 个空格时，请勿勾选Use tab character；而在Eclipse中，必须勾选insert spaces for tabs。正例：（涉及上述中的 1 - 5 点）\",\"public static void main(String[] args) { // 缩进 4 个空格 String say = \\\"hello\\\"; // 运算符的左右必须有一个空格 int flag = 0; // 关键词if与括号之间必须有一个空格，括号内的f与左括号， 0 与右括号不需要空格 if (flag == 0) { System.out.println(say); } // 左大括号前加空格且不换行；左大括号后换行 if (flag == 1) { System.out.println(\\\"world\\\"); // 右大括号前换行，右大括号后有else，不用换行 } else { System.out.println(\\\"ok\\\"); // 在右大括号后直接结束，则必须换行 } } \",\"【强制】注释的双斜线与注释内容之间有且仅有一个空格。正例： // 这是示例注释，请注意在双斜线之后有一个空格\",\"String commentString = new String(\\\"demo\\\"); \",\"【强制】在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开。正例：\",\"double first = 3.2D; int second = (int)first + 2 ; \",\"【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则： 1 ）第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。 2 ）运算符与下文一起换行。 3 ）方法调用的点符号与下文一起换行。 4 ）方法调用中的多个参数需要换行时，在逗号后进行。 5 ）在括号前不要换行，见反例。正例：\",\"StringBuilder builder = new StringBuilder(); // 超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点号一起换行 builder.append(\\\"yang\\\").append(\\\"hao\\\")... .append(\\\"chen\\\")... .append(\\\"chen\\\")... .append(\\\"chen\\\"); \",\"反例：\",\"// 超过 120 个字符的情况下，不要在括号前换行 builder.append(\\\"you\\\").append(\\\"are\\\")...append (\\\"lucky\\\"); // 参数很多的方法调用可能超过 120 个字符，逗号后才是换行处 method(args1, args2, args3, ... , argsX); \",\"【强制】方法参数在定义和传入时，多个参数逗号后面必须加空格。正例：下例中实参的args1逗号后边必须要有一个空格。 ​ method(args 1 , args 2 , args 3 );\",\"【强制】IDE的text file encoding设置为UTF- 8 ；IDE中文件的换行符使用Unix格式，不要使用Windows格式。\",\"【推荐】单个方法的总行数不超过 80 行。 说明：除注释之外的方法签名、左右大括号、方法内代码、空行、回车及任何不可见字符的总行数不超过 80 行。正例：代码逻辑分清红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码更加晰；共性逻辑抽取 成为共性方法，便于复用和维护。\",\"【推荐】没有必要增加若干空格来使变量的赋值等号与上一行对应位置的等号对齐。正例： int one = 1 ; long two = 2L; float three = 3F; StringBuilder builder = new StringBuilder(); 说明：增加builder这个变量，如果需要对齐，则给one、two、three都要增加几个空格，在变量比较多的情况下，是 非常累赘的事情。\",\"【推荐】不同逻辑、不同语义、不同业务的代码之间插入一个空行，分隔开来以提升可读性。 说明：任何情形，没有必要插入多个空行进行隔开。\"]},\"848\":{\"h\":\"(四) OOP规约\",\"t\":[\"【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。\",\"【强制】所有的覆写方法，必须加 @Override注解。 说明：getObject() 与get0bject() 的问题。一个是字母的O，一个是数字的 0 ，加 @Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。\",\"【强制】相同参数类型，相同业务含义，才可以使用的可变参数，参数类型避免定义为Object。 说明：可变参数必须放置在参数列表的最后。（建议开发者尽量不用可变参数编程）正例：public List<User> listUsers(String type, Long... ids) {...}\",\"【强制】外部正在调用的接口或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加 @Deprecated注解，并清晰地说明采用的新接口或者新服务是什么。\",\"【强制】不能使用过时的类或方法。 说明：java.net.URLDecoder中的方法decode(String encodeStr) 这个方法已经过时，应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。\",\"【强制】Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。正例：\\\"test\\\".equals(param);反例：param.equals(\\\"test\\\"); 说明：推荐使用JDK7引入的工具类java.util.Objects#equals(Object a, Object b)\",\"【强制】所有整型包装类对象之间值的比较，全部使用equals方法比较。 说明：对于Integer var =? 在 - 128 至 127 之间的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用 == 进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。\",\"【强制】任何货币金额，均以最小货币单位且为整型类型进行存储。\",\"【强制】浮点数之间的等值判断，基本数据类型不能使用 == 进行比较，包装数据类型不能使用equals进行判断。 说明：浮点数采用“尾数+阶码”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式。二进制无法精确表示大部分的十进制小数，具体原理参考《码出高效》。反例：\",\"float a = 1.0F - 0.9F; float b = 0.9F - 0.8F; if (a == b) { // 预期进入此代码块，执行其它业务逻辑 // 但事实上a == b的结果为false } Float x = Float.valueOf(a); Float y = Float.valueOf(b); if (x.equals(y)) { // 预期进入此代码块，执行其它业务逻辑 // 但事实上equals的结果为false } \",\"正例： (1)指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的。\",\"float a = 1.0F - 0.9F; float b = 0.9F - 0.8F; float diff = 1e-6F; if (Math.abs(a - b) < diff) { System.out.println(\\\"true\\\"); } \",\"(2)使用BigDecimal来定义值，再进行浮点数的运算操作。\",\"BigDecimal a = new BigDecimal(\\\"1.0\\\"); BigDecimal b = new BigDecimal(\\\"0.9\\\"); BigDecimal c = new BigDecimal(\\\"0.8\\\"); BigDecimal x = a.subtract(b); BigDecimal y = b.subtract(c); if (x.compareTo(y) == 0) { System.out.println(\\\"true\\\"); } \",\"【强制】BigDecimal的等值比较应使用compareTo() 方法，而不是equals() 方法。 说明：equals() 方法会比较值和精度（1.0 与 1.00 返回结果为 false），而compareTo() 则会忽略精度。\",\"【强制】定义数据对象DO类时，属性类型要与数据库字段类型相匹配。正例：数据库字段的bigint必须与类属性的Long类型相对应。反例：某业务的数据库表id字段定义类型为bigint unsigned，实际类对象属性为Integer，随着id越来越大， 超过Integer的表示范围而溢出成为负数，此时数据库id不支持存入负数抛出异常产生线上故障。\",\"【强制】禁止使用构造方法BigDecimal(double) 的方式把double值转化为BigDecimal对象。 说明：BigDecimal(double) 存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。 如：BigDecimal g = new BigDecimal(0.1F)；实际的存储值为：0.正例：优先推荐入参为String的构造方法，或使用BigDecimal的valueOf方法，此方法内部其实执行了Double的toString，而Double的toString按double的实际能表达的精度对尾数进行了截断。\",\"BigDecimal recommend1 = new BigDecimal(\\\"0.1\\\"); BigDecimal recommend2 = BigDecimal.valueOf(0.1); \",\"关于基本数据类型与包装数据类型的使用标准如下： 1 ）【强制】所有的POJO类属性必须使用包装数据类型。 2 ）【强制】RPC方法的返回值和参数必须使用包装数据类型。 3 ）【推荐】所有的局部变量使用基本数据类型。 说明：POJO类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。正例：数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。反例：某业务的交易报表上显示成交总额涨跌情况，即正负x%，x为基本数据类型，调用的RPC服务，调用不成功时，返回的是默认值，页面显示为0%，这是不合理的，应该显示成中划线-。所以包装数据类型的null值，能够表示额外的信息，如：远程调用失败，异常退出。\",\"【强制】定义DO / PO / DTO / VO等POJO类时，不要设定任何属性默认值。反例：某业务的DO的createTime默认值为new Date()；但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。\",\"【强制】序列化类新增属性时，请不要修改serialVersionUID字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改serialVersionUID值。 说明：注意serialVersionUID不一致会抛出序列化运行时异常。\",\"【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中。\",\"【强制】POJO类必须写toString方法。使用IDE中的工具source > generate toString时，如果继承了另一个POJO类，注意在前面加一下super.toString()。 说明：在方法执行抛出异常时，可以直接调用POJO的toString() 方法打印其属性值，便于排查问题。\",\"【强制】禁止在POJO类中，同时存在对应属性xxx的isXxx() 和getXxx() 方法。 说明：框架在调用属性xxx的提取方法时，并不能确定哪个方法一定是被优先调用到，神坑之一。\",\"【推荐】使用索引访问用String的split方法得到的数组时，需做最后一个分隔符后有无内容的检查， 否则会有抛IndexOutOfBoundsException的风险。 说明：\",\"String str = \\\"a,b,c,,\\\"; String[] ary = str.split(\\\",\\\"); // 预期大于 3 ，结果等于 3 System.out.println(ary.length); \",\"【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读， 此条规则优先于下一条。正例：\",\"public int method(int param); protected double method(int param1, int param2); private void method(); \",\"【推荐】类内方法定义的顺序依次是：公有方法或保护方法 > 私有方法 > getter / setter方法。 说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有Service和DAO的getter / setter方法放在类体最后。\",\"【推荐】setter方法中，参数名称与类成员变量名称一致，this.成员名=参数名。在getter / setter方法中，不要增加业务逻辑，增加排查问题的难度。反例：\",\"public Integer getData() { if (condition) { return this.data + 100; } else { return this.data - 100; } } \",\"【推荐】循环体内，字符串的连接方式，使用StringBuilder的append方法进行扩展。反例：\",\"String str = \\\"start\\\"; for (int i = 0; i < 100; i++) { str = str + \\\"hello\\\"; } \",\"说明：反编译出的字节码文件显示每次循环都会new出一个StringBuilder对象，然后进行append操作，最后通过toString() 返回String对象，造成内存资源浪费。\",\"【推荐】final可以声明类、成员变量、方法、以及本地变量，下列情况使用final关键字： 1 ）不允许被继承的类，如：String类。 2 ）不允许修改引用的域对象，如：POJO类的域变量。 3 ）不允许被覆写的方法，如：POJO类的setter方法。 4 ）不允许运行过程中重新赋值的局部变量。 5 ）避免上下文重复使用一个变量，使用final关键字可以强制重新定义一个变量，方便更好地进行重构。\",\"【推荐】慎用Object的clone方法来拷贝对象。 说明：对象clone方法默认是浅拷贝，若想实现深拷贝需覆写clone方法实现域对象的深度遍历式拷贝。\",\"【推荐】类成员与方法访问控制从严： 1 ）如果不允许外部直接通过new来创建对象，那么构造方法必须是private。 2 ）工具类不允许有public或default构造方法。 3 ）类非static成员变量并且与子类共享，必须是protected。 4 ）类非static成员变量并且仅在本类使用，必须是private。 5 ）类static成员变量如果仅在本类使用，必须是private。 6 ）若是static成员变量，考虑是否为final。 7 ）类成员方法只供类内部调用，必须是private。 8 ）类成员方法只对继承类公开，那么限制为protected。 说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。思考：如果是一个private的方法，想删除就删除，可是一个public的service成员方法或成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你会担心的。\"]},\"849\":{\"h\":\"(五) 日期时间\",\"t\":[\"【强制】日期格式化时，传入pattern中表示年份统一使用小写的y。 说明：日期格式化时，yyyy表示当天所在的年，而大写的YYYY代表是week in which year（JDK7之后引入的概念），意思是当天所在的周属于的年份，一周从周日开始，周六结束，只要本周跨年，返回的YYYY就是下一年。正例：表示日期和时间的格式如下所示： ​ new SimpleDateFormat(\\\"yyyy-MM-dd HH:mm:ss\\\")反例：某程序员因使用YYYY/MM/dd进行日期格式化， 2017 /12/31执行结果为2018/12/31，造成线上故障。\",\"【强制】在日期格式中分清楚大写的M和小写的m，大写的H和小写的h分别指代的意义。 说明：日期格式中的这两对字母表意如下： 1 ）表示月份是大写的M 2 ）表示分钟则是小写的m 3 ） 24 小时制的是大写的H 4 ） 12 小时制的则是小写的h\",\"【强制】获取当前毫秒数：System.currentTimeMillis()；而不是new Date().getTime()。 说明：获取纳秒级时间，则使用System.nanoTime的方式。在JDK8中，针对统计时间等场景，推荐使用Instant类。\",\"【强制】不允许在程序任何地方中使用： 1 ）java.sql.Date 2 ）java.sql.Time 3 ）java.sql.Timestamp。 说明：第 1 个不记录时间，getHours() 抛出异常；第 2 个不记录日期，getYear() 抛出异常；第 3 个在构造方法super((time / 1000) * 1000)，在Timestamp属性fastTime和nanos分别存储秒和纳秒信息。反例：java.util.Date.after(Date) 进行时间比较时，当入参是java.sql.Timestamp时，会触发JDK BUG（JDK9已修复），可能导致比较时的意外结果。\",\"【强制】禁止在程序中写死一年为 365 天，避免在公历闰年时出现日期转换错误或程序逻辑错误。正例：\",\"// 获取今年的天数 int daysOfThisYear = LocalDate.now().lengthOfYear(); // 获取指定某年的天数 LocalDate.of( 2011 , 1 , 1 ).lengthOfYear(); \",\"反例：\",\"// 第一种情况：在闰年 366 天时，出现数组越界异常 int[] dayArray = new int[ 365 ]; // 第二种情况：一年有效期的会员制， 2020 年 1 月 26 日注册，硬编码 365 返回的却是 2021 年 1 月 25 日 Calendar calendar = Calendar.getInstance(); calendar.set( 2020 , 1 , 26 ); calendar.add(Calendar.DATE, 365 ); \",\"【推荐】避免公历闰年 2 月问题。闰年的 2 月份有 29 天，一年后的那一天不可能是 2 月 29 日。\",\"【推荐】使用枚举值来指代月份。如果使用数字，注意Date，Calendar等日期相关类的月份month取值范围从 0 到 11 之间。 说明：参考JDK原生注释，Month value is 0-based. e.g., 0 for January.正例：Calendar.JANUARY，Calendar.FEBRUARY，Calendar.MARCH等来指代相应月份来进行传参或比较。\"]},\"850\":{\"h\":\"(六) 集合处理\",\"t\":[\"【强制】关于hashCode和equals的处理，遵循如下规则： 1 ）只要覆写equals，就必须覆写hashCode。 2 ）因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须覆写这两种方法。 3 ）如果自定义对象作为Map的键，那么必须覆写hashCode和equals。 说明：String因为覆写了hashCode和equals方法，所以可以愉快地将String对象作为key来使用。\",\"【强制】判断所有集合内部的元素是否为空，使用isEmpty() 方法，而不是size() == 0 的方式。 说明：在某些集合中，前者的时间复杂度为O(1)，而且可读性更好。正例：\",\"Map<String, Object> map = new HashMap<>(16); if (map.isEmpty()) { System.out.println(\\\"no element in this map.\\\"); } \",\"【强制】在使用java.util.stream.Collectors类的toMap() 方法转为Map集合时，一定要使用参数类型 为BinaryOperator，参数名为mergeFunction的方法，否则当出现相同key时会抛出 IllegalStateException异常。 说明：参数mergeFunction的作用是当出现key重复时，自定义对value的处理策略。正例：\",\"List<Pair<String, Double>> pairArrayList = new ArrayList<>( 3 ); pairArrayList.add(new Pair<>(\\\"version\\\", 12.10)); pairArrayList.add(new Pair<>(\\\"version\\\", 12.19)); pairArrayList.add(new Pair<>(\\\"version\\\", 6.28)); // 生成的map集合中只有一个键值对：{version=6.28} Map<String, Double> map = pairArrayList.stream() .collect(Collectors.toMap(Pair::getKey, Pair::getValue, (v1, v2) - > v2)); \",\"反例：\",\"String[] departments = new String[]{\\\"RDC\\\", \\\"RDC\\\", \\\"KKB\\\"}; // 抛出IllegalStateException异常 Map<Integer, String> map = Arrays.stream(departments) .collect(Collectors.toMap(String::hashCode, str - > str)); \",\"【强制】在使用java.util.stream.Collectors类的toMap() 方法转为Map集合时，一定要注意当value为null时会抛NPE异常。 说明：在java.util.HashMap的merge方法里会进行如下的判断：\",\"if (value == null || remappingFunction == null) throw new NullPointerException(); \",\"反例：\",\"4. List<Pair<String, Double>> pairArrayList = new ArrayList<>( 2 ); pairArrayList.add(new Pair<>(\\\"version1\\\", 8.3)); pairArrayList.add(new Pair<>(\\\"version2\\\", null)); // 抛出NullPointerException异常 Map<String, Double> map = pairArrayList.stream() .collect(Collectors.toMap(Pair::getKey, Pair::getValue, (v1, v2) - > v2)); \",\"【强制】ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException异常： java.util.RandomAccessSubList cannot be cast to java.util.ArrayList。 说明：subList() 返回的是ArrayList的内部类SubList，并不是ArrayList本身，而是ArrayList的一个视图，对于SubList的所有操作最终会反映到原列表上。\",\"【强制】使用Map的方法keySet() / values() / entrySet() 返回集合对象时，不可以对其进行添加元素操作，否则会抛出UnsupportedOperationException异常。\",\"【强制】Collections类返回的对象，如：emptyList() / singletonList() 等都是immutable list，不可对其进行添加或者删除元素的操作。反例：如果查询无结果，返回Collections.emptyList() 空集合对象，调用方一旦在返回的集合中进行了添加元素的操作，就会触发UnsupportedOperationException异常。\",\"【强制】在subList场景中，高度注意对父集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生ConcurrentModificationException异常。 说明：抽查表明， 9 0% 的程序员对此知识点都有错误的认知。\",\"【强制】使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的是类型完全一致、长度为0 的空数组。反例：直接使用toArray无参方法存在问题，此方法返回值只能是Object[]类，若强转其它类型数组将出现ClassCastException错误。正例：\",\"List<String> list = new ArrayList<>( 2 ); list.add(\\\"guan\\\"); list.add(\\\"bao\\\"); String[] array = list.toArray(new String[ 0 ]); \",\"说明：使用toArray带参方法，数组空间大小的length： ​ 1 ）等于 0 ，动态创建与size相同的数组，性能最好。 ​ 2 ）大于 0 但小于size，重新创建大小等于size的数组，增加GC负担。 ​ 3 ）等于size，在高并发情况下，数组创建完成之后，size正在变大的情况下，负面影响与 2 相同。 ​ 4 ）大于size，空间浪费，且在size处插入null值，存在NPE隐患。\",\"【强制】使用Collection接口任何实现类的addAll() 方法时，要对输入的集合参数进行NPE判断。 说明：在ArrayList#addAll方法的第一行代码即Object[] a = c.toArray()；其中c为输入集合参数，如果为null，则直接抛出异常。\",\"【强制】使用工具类Arrays.asList() 把数组转换成集合时，不能使用其修改集合相关的方法，它的add/ remove / clear方法会抛出UnsupportedOperationException异常。 说明：asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。\",\"String[] str = new String[]{ \\\"yang\\\", \\\"guan\\\", \\\"bao\\\" }; List list = Arrays.asList(str); \",\"第一种情况：list.add(\\\"yangguanbao\\\"); 运行时异常。 第二种情况：str[0] = \\\"change\\\"; list中的元素也会随之修改，反之亦然。\",\"【强制】泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用add方法，而<? super T>不能使用get方法，两者在接口调用赋值的场景中容易出错。 说明：扩展说一下PECS(Producer Extends Consumer Super) 原则，即频繁往外读取内容的，适合用<? extends T>，经常往里插入的，适合用<? super T>\",\"【强制】在无泛型限制定义的集合赋值给泛型限制的集合时，在使用集合元素时，需要进行instanceof判断，避免抛出ClassCastException异常。 说明：毕竟泛型是在JDK5后才出现，考虑到向前兼容，编译器是允许非泛型集合与泛型集合互相赋值。反例：\",\"List<String> generics = null; List notGenerics = new ArrayList( 10 ); notGenerics.add(new Object()); notGenerics.add(new Integer( 1 )); generics = notGenerics; // 此处抛出ClassCastException异常 String string = generics.get( 0 ); \",\"【强制】不要在foreach循环里进行元素的remove / add操作。remove元素请使用iterator方式，如果并发操作，需要对iterator对象加锁。正例：\",\"List<String> list = new ArrayList<>(); list.add(\\\"1\\\"); list.add(\\\"2\\\"); Iterator<String> iterator = list.iterator(); while (iterator.hasNext()) { String item = iterator.next(); if (删除元素的条件) { iterator.remove(); } } \",\"反例：\",\"for (String item : list) { if (\\\"1\\\".equals(item)) { list.remove(item); } } \",\"说明：反例中的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”会是同样的结果吗？\",\"【强制】在JDK7版本及以上，Comparator实现类要满足如下三个条件，不然Arrays.sort，Collections.sort会抛IllegalArgumentException异常。 说明：三个条件如下 ​ 1 ）x，y的比较结果和y，x的比较结果相反。 ​ 2 ）x > y，y > z，则x > z。 ​ 3 ）x = y，则x，z比较结果和y，z比较结果相同。反例：下例中没有处理相等的情况，交换两个对象判断结果并不互反，不符合第一个条件，在实际使用中可能会出现异常。\",\"new Comparator<Student>() { @Override public int compare(Student o1, Student o2) { return o1.getId() > o2.getId() ? 1 : -1; } }; \",\"【推荐】泛型集合使用时，在JDK7及以上，使用diamond语法或全省略。 说明：菱形泛型，即diamond，直接使用<>来指代前边已经指定的类型。正例：\",\"// diamond方式，即<> HashMap<String, String> userCache = new HashMap<>( 16 ); // 全省略方式 ArrayList<User> users = new ArrayList( 10 ); \",\"【推荐】集合初始化时，指定集合初始值大小。 说明：HashMap使用构造方法HashMap(int initialCapacity) 进行初始化时，如果暂时无法确定集合大小，那么指定默认值（ 16 ）即可。正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1 。注意负载因子（即loaderfactor）默认为0.75，如果暂时无法确定初始值大小，请设置为 16 （即默认值）。反例：HashMap需要放置 1024 个元素，由于没有设置容量初始大小，随着元素增加而被迫不断扩容，resize() 方法总共会调用 8 次，反复重建哈希表和数据迁移。当放置的集合元素个数达千万级时会影响程序性能。\",\"【推荐】使用entrySet遍历Map类集合KV，而不是keySet方式进行遍历。 说明：keySet其实是遍历了 2 次，一次是转为Iterator对象，另一次是从hashMap中取出key所对应的value。而entrySet只是遍历了一次就把key和value都放到了entry中，效率更高。如果是JDK8，使用Map.forEach方法。正例：values() 返回的是V值集合，是一个list集合对象；keySet() 返回的是K值集合，是一个Set集合对象；entrySet() 返回的是K-V值组合的Set集合。\",\"【推荐】高度注意Map类集合K / V能不能存储null值的情况，如下表格：\",\"集合类\",\"Key\",\"Value\",\"Super\",\"说明\",\"Hashtable\",\"不允许为null\",\"不允许为null\",\"Dictionary\",\"线程安全\",\"TreeMap\",\"不允许为null\",\"允许为null\",\"AbstractMap\",\"线程不安全\",\"ConcurrentHashMap\",\"不允许为null\",\"不允许为null\",\"AbstractMap\",\"锁分段技术（JDK8:CAS）\",\"HashMap\",\"允许为null\",\"允许为null\",\"AbstractMap\",\"线程不安全\",\"反例：由于HashMap的干扰，很多人认为ConcurrentHashMap是可以置入null值，而事实上，存储null值时会抛出NPE异常。\",\"【参考】合理利用好集合的有序性（sort）和稳定性（order），避免集合的无序性（unsort）和不稳定性（unorder）带来的负面影响。 说明：有序性是指遍历的结果是按某种比较规则依次排列的，稳定性指集合每次遍历的元素次序是一定的。如： ​ ArrayList是order / unsort；HashMap是unorder / unsort；TreeSet是order / sort。\",\"【参考】利用Set元素唯一的特性，可以快速对一个集合进行去重操作，避免使用List的contains() 进行遍历去重或者判断包含操作。\"]},\"851\":{\"h\":\"(七) 并发处理\",\"t\":[\"【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。 说明：资源驱动类、工具类、单例工厂类都需要注意。\",\"【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。正例：自定义线程工厂，并且根据外部特征进行分组，比如，来自同一机房的调用，把机房编号赋值给whatFeatureOfGroup：\",\"public class UserThreadFactory implements ThreadFactory { private final String namePrefix; private final AtomicInteger nextId = new AtomicInteger(1); // 定义线程组名称，在利用 jstack 来排查问题时，非常有帮助 UserThreadFactory(String whatFeatureOfGroup) { namePrefix =\\\"FromUserThreadFactory's\\\"+whatFeatureOfGroup +\\\"-Worker-\\\";} @Override public Thread newThread(Runnable task) { String name = namePrefix + nextId.getAndIncrement(); Thread thread = new Thread(null, task, name, 0, false); System.out.println(thread.getName()); return thread; } } \",\"【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 说明：线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。\",\"【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors返回的线程池对象的弊端如下： ​ 1 ）FixedThreadPool和SingleThreadPool： ​ 允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。 ​ 2 ）CachedThreadPool： ​ 允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。 ​ 3 ）ScheduledThreadPool： ​ 允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。\",\"【强制】SimpleDateFormat是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。正例：注意线程安全，使用DateUtils。亦推荐如下处理：\",\"private static final ThreadLocal<DateFormat> dateStyle = new ThreadLocal<DateFormat>() { @Override protected DateFormat initialValue() { return new SimpleDateFormat(\\\"yyyy-MM-dd\\\"); } } \",\"说明：如果是JDK8的应用，可以使用Instant代替Date，LocalDateTime代替Calendar，DateTimeFormatter代替SimpleDateFormat，官方给出的解释：simple beautiful strong immutable thread-safe。\",\"【强制】必须回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的ThreadLocal变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用try-finally块进行回收。正例：\",\"objectThreadLocal.set(userInfo); try { // ... } finally { objectThreadLocal.remove(); } \",\"【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。 说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。\",\"【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。 说明：线程一需要对表A、B、C依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是A、B、C，否则可能出现死锁。\",\"【强制】在使用阻塞等待获取锁的方式中，必须在try代码块之外，并且在加锁方法与try代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在finally中无法解锁。 说明一：在lock方法与try代码块之间的方法调用抛出异常，无法解锁，造成其它线程无法成功获取锁。 说明二：如果lock方法在try代码块之内，可能由于其它方法抛出异常，导致在finally代码块中，unlock对未加锁的对象解锁，它会调用AQS的tryRelease方法（取决于具体实现类），抛出IllegalMonitorStateException异常。 说明三：在Lock对象的lock方法实现中可能抛出unchecked异常，产生的后果与说明二相同。正例：\",\"Lock lock = new XxxLock(); // ... lock.lock(); try { doSomething(); doOthers(); } finally { lock.unlock(); } \",\"反例：\",\"Lock lock = new XxxLock(); // ... try { // 如果此处抛出异常，则直接执行finally代码块 doSomething(); // 无论加锁是否成功，finally代码块都会执行 lock.lock(); doOthers(); } finally { lock.unlock(); } \",\"【强制】在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。 说明：Lock对象的unlock方法在执行时，它会调用AQS的tryRelease方法（取决于具体实现类），如果当前线程不持有锁，则抛出IllegalMonitorStateException异常。正例：\",\"Lock lock = new XxxLock(); // ... boolean isLocked = lock.tryLock(); if (isLocked) { try { doSomething(); doOthers(); } finally { lock.unlock(); } } \",\"【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用version作为更新依据。 说明：如果每次访问冲突概率小于20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。\",\"【强制】多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题。\",\"【推荐】资金相关的金融敏感信息，使用悲观锁策略。 说明：乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，另外，乐观锁对冲突的解决策略有较复杂的要求，处理不当容易造成系统压力或数据异常，所以资金相关的金融敏感信息不建议使用乐观锁更新。正例：悲观锁遵循一锁二判三更新四释放的原则。\",\"【推荐】使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法被执行到，避免主线程无法执行至await方法，直到超时才返回结果。 说明：注意，子线程抛出异常堆栈，不能在主线程try-catch到。\",\"【推荐】避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed导致的性能下降。 说明：Random实例包括java.util.Random的实例或者Math.random() 的方式。正例：在JDK7之后，可以直接使用API ThreadLocalRandom，而在JDK7之前，需要编码保证每个线程持有一个单独的Random实例。\",\"【推荐】通过双重检查锁（double-checked locking），实现延迟初始化需要将目标属性声明为volatile型，（比如修改helper的属性声明为private volatile Helper helper = null;）。正例：\",\"public class LazyInitDemo { private volatile Helper helper = null; public Helper getHelper() { if (helper == null) { synchronized(this) { if (helper == null) { helper = new Helper(); } } } return helper; } // other methods and fields... } \",\"【参考】volatile解决多线程内存不可见问题对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。 说明：如果是count++操作，使用如下类实现： ​ AtomicInteger count = new AtomicInteger(); ​ count.addAndGet(1); ​ 如果是JDK8，推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）。\",\"【参考】HashMap在容量不够进行resize时由于高并发可能出现死链，导致CPU飙升，在开发过程中注意规避此风险。\",\"【参考】ThreadLocal对象使用static修饰，ThreadLocal无法解决共享对象的更新问题。 说明：这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在 类第一次被使用时装载，只分配一块存储空间，所有此类的对象（只要是这个线程内定义的）都可以操控这个变量。\"]},\"852\":{\"h\":\"(八) 控制语句\",\"t\":[\"【强制】在一个switch块内，每个case要么通过continue / break / return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch块内，都必须包含一个default语句并且放在最后，即使它什么代码也没有。 说明：注意break是退出switch语句块，而return是退出方法体。\",\"【强制】当switch括号内的变量类型为String并且此变量为外部参数时，必须先进行null判断。反例：如下的代码输出是什么？\",\"public class SwitchString { public static void main(String[] args) { method(null); } public static void method(String param) { switch (param) { // 肯定不是进入这里 case \\\"sth\\\": System.out.println(\\\"it's sth\\\"); break; // 也不是进入这里 case \\\"null\\\": System.out.println(\\\"it's null\\\"); break; // 也不是进入这里 default: System.out.println(\\\"default\\\"); } } } \",\"【强制】在if / else / for / while / do语句中必须使用大括号。反例： if (condition) statements; 说明：即使只有一行代码，也要采用大括号的编码方式。\",\"【强制】三目运算符condition? 表达式 1 ：表达式 2 中，高度注意表达式 1 和 2 在类型对齐时，可能抛出因自动拆箱导致的NPE异常。 说明：以下两种场景会触发类型对齐的拆箱操作： ​ 1 ）表达式 1 或 表达式 2 的值只要有一个是原始类型。 ​ 2 ）表达式 1 或 表达式 2 的值的类型不一致，会强制拆箱升级成表示范围更大的那个类型。反例：\",\"Integer a = 1 ; Integer b = 2 ; Integer c = null; Boolean flag = false; // a*b的结果是int类型，那么c会强制拆箱成int类型，抛出NPE异常 Integer result = (flag? a * b : c); \",\"【强制】在高并发场景中，避免使用“等于”判断作为中断或退出的条件。 说明：如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件来代替。反例：判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，活动无法终止。\",\"【推荐】当方法的代码总行数超过 10 行时，return / throw等中断逻辑的右大括号后需要加一个空行。 说明：这样做逻辑清晰，有利于代码阅读时重点关注。\",\"【推荐】表达异常的分支时，少用if-else方式，这种方式可以改写成：\",\"if (condition) { ... return obj; } // 接着写else的业务逻辑代码; \",\"说明：如果非使用if()...else if()...else...方式表达逻辑，避免后续代码维护困难，请勿超过 3 层。正例：超过 3 层的if-else的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句示例如下：\",\"public void findBoyfriend(Man man) { if (man.isUgly()) { System.out.println(\\\"本姑娘是外貌协会的资深会员\\\"); return; } if (man.isPoor()) { System.out.println(\\\"贫贱夫妻百事哀\\\"); return; } if (man.isBadTemper()) { System.out.println(\\\"银河有多远，你就给我滚多远\\\"); return; } System.out.println(\\\"可以先交往一段时间看看\\\"); } \",\"【推荐】除常用方法（如getXxx / isXxx）等外不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。 说明：很多if语句内的逻辑表达式相当复杂，与、或、取反混合运算，甚至各种方法纵深调用，理解成本非常高。如果赋值一个非常好理解的布尔变量名字，则是件令人爽心悦目的事情。正例：\",\"// 伪代码如下 final boolean existed = (file.open(fileName, \\\"w\\\") != null) && (...) || (...); if (existed) { ... } \",\"反例：\",\"public final void acquire(long arg) { if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) { selfInterrupt(); } } \",\"【推荐】不要在其它表达式（尤其是条件表达式）中，插入赋值语句。 说明：赋值点类似于人体的穴位，对于代码的理解至关重要，所以赋值语句需要清晰地单独成为一行。反例：\",\"public Lock getLock(boolean fair) { // 算术表达式中出现赋值操作，容易忽略count值已经被改变 threshold = (count = Integer.MAX_VALUE) - 1 ; // 条件表达式中出现赋值操作，容易误认为是sync == fair return (sync = fair)? new FairSync() : new NonfairSync(); } \",\"【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的try-catch操作（这个try-catch是否可以移至循环体外）。\",\"【推荐】避免采用取反逻辑运算符。 说明：取反逻辑不利于快速理解，并且取反逻辑写法一般都存在对应的正向逻辑写法。正例：使用if(x < 628) 来表达x小于 628 。反例：使用if(!(x >= 628)) 来表达x小于 628 。\",\"【推荐】公开接口需要进行入参保护，尤其是批量操作的接口。反例：某业务系统，提供一个用户批量查询的接口，API文档上有说最多查多少个，但接口实现上没做任何保护，导致调用方传了一个 1000 的用户id数组过来后，查询信息后，内存爆了。\",\"【参考】下列情形，需要进行参数校验： 1 ）调用频次低的方法。 2 ）执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。 3 ）需要极高稳定性和可用性的方法。 4 ）对外提供的开放接口，不管是RPC / API / HTTP接口。 5 ）敏感权限入口。\",\"【参考】下列情形，不需要进行参数校验： 1 ）极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查。 2 ）底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般DAO层与Service层都在同一个应用中，部署在同一台服务器中，所以DAO的参数校验，可以省略。 3 ）被声明成private只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。\"]},\"853\":{\"h\":\"(九) 注释规约\",\"t\":[\"【强制】类、类属性、类方法的注释必须使用Javadoc规范，使用 /** 内容 */ 格式，不得使用 // xxx方式。 说明：在IDE编辑窗口中，Javadoc方式会提示相关注释，生成Javadoc可以正确输出相应注释；在IDE中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。\",\"【强制】所有的抽象方法（包括接口中的方法）必须要用Javadoc注释、除了返回值、参数异常说明外，还必须指出该方法做什么事情，实现什么功能。 说明：对子类的实现要求，或者调用注意事项，请一并说明。\",\"【强制】所有的类都必须添加创建者和创建日期。 说明：在设置模板时，注意IDEA的@author为${USER}，而eclipse的@author为${user}，大小写有区别，而日期 的设置统一为yyyy/MM/dd的格式。正例：\",\"/** * * @author yangguanbao * @date 2021/11/26 * **/ \",\"【强制】方法内部单行注释，在被注释语句上方另起一行，使用 // 注释。方法内部多行注释使用 /* */注释，注意与代码对齐。\",\"【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。\",\"【推荐】与其用半吊子英文来注释，不如用中文注释说清楚。专有名词与关键字保持英文原文即可。反例：“TCP连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。\",\"【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等。 说明：代码与注释更新不同步，就像公路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。\",\"【推荐】在类中删除未使用的任何字段和方法、内部类；在方法中删除未使用的参数声明与内部变量。\",\"【参考】谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。 说明：代码被注释掉有两种可能性： 1 ）后续会恢复此段代码逻辑。 2 ）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉即可，假如需要查阅历史代码，登录代码仓库即可。\",\"【参考】对于注释的要求：第一、能够准确反映设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。\",\"【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的另一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释又是相当大的负担。反例：\",\"// put elephant into fridge put(elephant, fridge); \",\"方法名put，加上两个有意义的变量名称elephant和fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。\",\"【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。 1 ）待办事宜（TODO）：（标记人，标记时间，[预计处理时间]）表示需要实现，但目前还未实现的功能。这实际上是一个Javadoc的标签，目前的Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个Javadoc标签）。 2 ）错误，不能工作（FIXME）：（标记人，标记时间，[预计处理时间]）在注释中用FIXME标记某代码是错误的，而且不能工作，需要及时纠正的情况。\"]},\"854\":{\"h\":\"(十) 前后端规约\",\"t\":[\"【强制】前后端交互的API，需要明确协议、域名、路径、请求方法、请求内容、状态码、响应体。 说明： 1 ）协议：生产环境必须使用HTTPS。 2 ）路径：每一个API需对应一个路径，表示API具体的请求地址： a）代表一种资源，只能为名词，推荐使用复数，不能为动词，请求方法已经表达动作意义。 b）URL路径不能使用大写，单词如果需要分隔，统一使用下划线。 c）路径禁止携带表示请求内容类型的后缀，比如\\\".json\\\"，\\\".xml\\\"，通过accept头表达即可。 3 ）请求方法：对具体操作的定义，常见的请求方法如下： a）GET：从服务器取出资源。 b）POST：在服务器新建一个资源。 c）PUT：在服务器更新资源。 d）DELETE：从服务器删除资源。 4 ）请求内容：URL带的参数必须无敏感信息或符合安全要求；body里带参数时必须设置Content-Type。 5 ）响应体：响应体body可放置多种数据类型，由Content-Type头来确定。\",\"【强制】前后端数据列表相关的接口返回，如果为空，则返回空数组[]或空集合{}。 说明：此条约定有利于数据层面上的协作更加高效，减少前端很多琐碎的null判断。\",\"【强制】服务端发生错误时，返回给前端的响应信息必须包含HTTP状态码，errorCode、errorMessage、用户提示信息四个部分。 说明：四个部分的涉众对象分别是浏览器、前端开发、错误排查人员、用户。其中输出给用户的提示信息要求：简短清晰、提示友好，引导用户进行下一步操作或解释错误原因，提示信息可以包括错误原因、上下文环境、推荐操作等。errorCode：参考 。errorMessage：简要描述后端出错原因，便于错误排查人员快速定位问题，注意不要包含敏感数据信息。正例：常见的HTTP状态码如下 1 ） 200 OK：表明该请求被成功地完成，所请求的资源发送到客户端。 2 ） 401 Unauthorized：请求要求身份验证，常见对于需要登录而用户未登录的情况。 3 ） 403 Forbidden：服务器拒绝请求，常见于机密信息或复制其它登录用户链接访问服务器的情况。 4 ） 404 NotFound：服务器无法取得所请求的网页，请求资源不存在。 5 ） 500 InternalServerError：服务器内部错误。\",\"【强制】在前后端交互的JSON格式数据中，所有的key必须为小写字母开始的lowerCamelCase风格，符合英文表达习惯，且表意完整。正例：errorCode / errorMessage / assetStatus / menuList / orderList / configFlag反例：ERRORCODE / ERROR_CODE / error_message / error-message / errormessage\",\"【强制】errorMessage是前后端错误追踪机制的体现，可以在前端输出到type=\\\"hidden\\\" 文字类控件中，或者用户端的日志中，帮助我们快速地定位出问题。\",\"【强制】对于需要使用超大整数的场景，服务端一律使用String字符串类型返回，禁止使用Long类型。 说明：Java服务端如果直接返回Long整型数据给前端，Javascript会自动转换为Number类型（注：此类型为双精度浮点数，表示原理与取值范围等同于Java中的Double）。Long类型能表示的最大值是 263 - 1 ，在取值范围之内，超过 253（ 9007199254740992 ）的数值转化为Javascript的Number时，有些数值会产生精度损失。扩展说明，在Long取值范围内，任何 2 的指数次的整数都是绝对不会存在精度损失的，所以说精度损失是一个概率问题。若浮点数尾数位与指数位空间不限，则可以精确表示任何整数，但很不幸，双精度浮点数的尾数位只有 52 位。反例：通常在订单号或交易号大于等于 16 位，大概率会出现前后端订单数据不一致的情况。 比如，后端传输的 \\\"orderId\\\"： 362909601374617692 ，前端拿到的值却是：362909601374617660\",\"【强制】HTTP请求通过URL传递参数时，不能超过 2048 字节。 说明：不同浏览器对于URL的最大长度限制略有不同，并且对超出最大长度的处理逻辑也有差异， 2048 字节是取所有浏览器的最小值。反例：某业务将退货的商品id列表放在URL中作为参数传递，当一次退货商品数量过多时，URL参数超长，传递到后端的参数被截断，导致部分商品未能正确退货。\",\"【强制】HTTP请求通过body传递内容时，必须控制长度，超出最大长度后，后端解析会出错。 说明：nginx默认限制是1MB，tomcat默认限制为2MB，当确实有业务需要传较大内容时，可以调大服务器端的限制。\",\"【强制】在翻页场景中，用户输入参数的小于 1 ，则前端返回第一页参数给后端；后端发现用户输入的参数大于总页数，直接返回最后一页。\",\"【强制】服务器内部重定向必须使用forward；外部重定向地址必须使用URL统一代理模块生成，否则会因线上采用HTTPS协议而导致浏览器提示“不安全”，并且还会带来URL维护不一致的问题。\",\"【推荐】服务器返回信息必须被标记是否可以缓存，如果缓存，客户端可能会重用之前的请求结果。 说明：缓存有利于减少交互次数，减少交互的平均延迟。正例：http1.1中，s-maxage告诉服务器进行缓存，时间单位为秒，用法如下， response.setHeader(\\\"Cache-Control\\\", \\\"s-maxage=\\\" + cacheSeconds);\",\"【推荐】服务端返回的数据，使用JSON格式而非XML。 说明：尽管HTTP支持使用不同的输出格式，例如纯文本，JSON，CSV，XML，RSS甚至HTML。如果我们使用的面向用户的服务，应该选择JSON作为通信中使用的标准数据交换格式，包括请求和响应。此外，application/JSON是一种通用的MIME类型，具有实用、精简、易读的特点。\",\"【推荐】前后端的时间格式统一为\\\"yyyy-MM-dd HH:mm:ss\\\"，统一为GMT。\",\"【参考】在接口路径中不要加入版本号，版本控制在HTTP头信息中体现，有利于向前兼容。 说明：当用户在低版本与高版本之间反复切换工作时，会导致迁移复杂度升高，存在数据错乱风险。\"]},\"855\":{\"h\":\"(十一) 其他\",\"t\":[\"【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。 说明：不要在方法体内定义：Pattern pattern = Pattern.compile(\\\"规则\\\");\",\"【强制】避免用ApacheBeanutils进行属性的copy。 说明：ApacheBeanUtils性能较差，可以使用其他方案比如SpringBeanUtils，CglibBeanCopier，注意均是浅拷贝。\",\"【强制】velocity调用POJO类的属性时，直接使用属性名取值即可，模板引擎会自动按规范调用POJO的getXxx()，如果是boolean基本数据类型变量（boolean命名不需要加is前缀），会自动调isXxx()方法。 说明：注意如果是Boolean包装类对象，优先调用getXxx() 的方法。\",\"【强制】后台输送给页面的变量必须加 $!{var} ——中间的感叹号。 说明：如果var等于null或者不存在，那么 ${var} 会直接显示在页面上。\",\"【强制】注意Math.random() 这个方法返回是double类型，注意取值的范围 0 ≤ x < 1 （能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将x放大 10 的若干倍然后取整，直接使用Random对象的nextInt或者nextLong方法。\",\"【强制】枚举enum（括号内）的属性字段必须是私有且不可变。\",\"【推荐】不要在视图模板中加入任何复杂的逻辑运算。 说明：根据MVC理论，视图的职责是展示，不要抢模型和控制器的活。\",\"【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。\",\"【推荐】及时清理不再使用的代码段或配置信息。 说明：对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。正例：对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(///)来说明注释掉代码的理由：\",\"public static void hello() { /// 业务方通知活动暂停 // Business business = new Business(); // business.active(); System.out.println(\\\"it's finished\\\"); } \"]},\"856\":{\"h\":\"二、异常日志\"},\"857\":{\"h\":\"(一) 错误码\",\"t\":[\"【强制】错误码的制定原则：快速溯源、沟通标准化。 说明：错误码想得过于完美和复杂，就像康熙字典的生僻字一样，用词似乎精准，但是字典不容易随身携带且简单易懂。正例：错误码回答的问题是谁的错？错在哪？ ​ 1 ）错误码必须能够快速知晓错误来源，可快速判断是谁的问题。 ​ 2 ）错误码必须能够进行清晰地比对（代码中容易equals）。 ​ 3 ）错误码有利于团队快速对错误原因达到一致认知。\",\"【强制】错误码不体现版本号和错误等级信息。 说明：错误码以不断追加的方式进行兼容。错误等级由日志和错误码本身的释义来决定。\",\"【强制】全部正常，但不得不填充错误码时返回五个零： 00000 。\",\"【强制】错误码为字符串类型，共 5 位，分成两个部分：错误产生来源+四位数字编号。 说明：错误产生来源分为A/B/C，A表示错误来源于用户，比如参数错误，用户安装版本过低，用户支付超时等问题；B表示错误来源于当前系统，往往是业务逻辑出错，或程序健壮性差等问题；C表示错误来源于第三方服务，比如CDN服务出错，消息投递超时等问题；四位数字编号从 0001 到 9999 ，大类之间的步长间距预留 100 ，参考文末附表 3 。\",\"【强制】编号不与公司业务架构，更不与组织架构挂钩，以先到先得的原则在统一平台上进行，审批生效，编号即被永久固定。\",\"【强制】错误码使用者避免随意定义新的错误码。 说明：尽可能在原有错误码附表中找到语义相同或者相近的错误码在代码中使用即可。\",\"【强制】错误码不能直接输出给用户作为提示信息使用。 说明：堆栈（stack_trace）、错误信息(error_message) 、错误码（error_code）、提示信息（user_tip）是一个有效关联并互相转义的和谐整体，但是请勿互相越俎代庖。\",\"【推荐】错误码之外的业务信息由error_message来承载，而不是让错误码本身涵盖过多具体业务属性。\",\"【推荐】在获取第三方服务错误码时，向上抛出允许本系统转义，由C转为B，并且在错误信息上带上原有的第三方错误码。\",\"【参考】错误码分为一级宏观错误码、二级宏观错误码、三级宏观错误码。 说明：在无法更加具体确定的错误场景中，可以直接使用一级宏观错误码，分别是：A0001（用户端错误）、B0001（系统执行出错）、C0001（调用第三方服务出错）。正例：调用第三方服务出错是一级，中间件错误是二级，消息服务出错是三级。\",\"【参考】错误码的后三位编号与HTTP状态码没有任何关系。\",\"【参考】错误码有利于不同文化背景的开发者进行交流与代码协作。 说明：英文单词形式的错误码不利于非英语母语国家（如阿拉伯语、希伯来语、俄罗斯语等）之间的开发者互相协作。\",\"【参考】错误码即人性，感性认知+口口相传，使用纯数字来进行错误码编排不利于感性记忆和分类。 说明：数字是一个整体，每位数字的地位和含义是相同的。反例：一个五位数字 12345 ，第 1 位是错误等级，第 2 位是错误来源， 345 是编号，人的大脑不会主动地拆开并分辨每位数字的不同含义。\"]},\"858\":{\"h\":\"(二) 异常处理\",\"t\":[\"【强制】Java类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。 说明：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，可能存在数字格式错误，不得不通过catchNumberFormatException来实现。正例：if (obj != null) {...}反例：try { obj.method(); } catch (NullPointerException e)\",\"【强制】异常捕获后不要用来做流程控制，条件控制。 说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。\",\"【强制】catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。 说明：对大段代码进行try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现。正例：用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户。\",\"【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。\",\"【强制】事务场景中，抛出异常被catch后，如果需要回滚，一定要注意手动回滚事务。\",\"【强制】finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。 说明：如果JDK7，可以使用try-with-resources方式。\",\"【强制】不要在finally块中使用return 说明：try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则会在此直接返回，无情丢弃掉try块中的返回点。反例：\",\"private int x = 0 ; public int checkReturn() { try { // x等于 1 ，此处不返回 return ++x; } finally { // 返回的结果是 2 return ++x; } } \",\"【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。 说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。\",\"【强制】在调用RPC、二方包、或动态生成类的相关方法时，捕捉异常使用Throwable类进行拦截。 说明：通过反射机制来调用方法，如果找不到方法，抛出NoSuchMethodException。什么情况会抛出NoSuchMethodError呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，或者在字节码修改框架（比如：ASM）动态创建或修改类时，修改了相应的方法签名。这些情况，即使代码编译期是正确的，但在代码运行期时，会抛出NoSuchMethodError。反例：足迹服务引入了高版本的spring，导致运行到某段核心逻辑时，抛出NoSuchMethodError错误，catch用的类却是Exception，堆栈向上抛，影响到上层业务。这是一个非核心功能点影响到核心应用的典型反例。\",\"【推荐】方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值。 说明：本规约明确防止NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败，运行时异常等场景返回null的情况。\",\"【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景： 1 ）返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE反例：public int method() { return Integer对象; }，如果为null，自动解箱抛NPE。 2 ）数据库的查询结果可能为null。 3 ）集合里的元素即使isNotEmpty，取出的数据元素也可能为null。 4 ）远程调用返回对象时，一律要求进行空指针判断，防止NPE。 5 ）对于Session中获取的数据，建议进行NPE检查，避免空指针。 6 ）级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。正例：使用JDK8的Optional类来防止NPE问题。\",\"【推荐】定义时区分unchecked / checked异常，避免直接抛出new RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException等。\",\"【参考】对于公司外的http / api开放接口必须使用错误码，而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用Result方式，封装isSuccess() 方法、错误码、错误简短信息；应用内部推荐异常抛出。 说明：关于RPC方法返回方式使用Result方式的理由： 1 ）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。 2 ）如果不加栈信息，只是new自定义异常，加入自己的理解的error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。\"]},\"859\":{\"h\":\"(三) 日志规约\",\"t\":[\"【强制】应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架（SLF4J、JCL—Jakarta Commons Logging）中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。 说明：日志框架（SLF4J、JCL--Jakarta Commons Logging）的使用方式（推荐使用SLF4J） ​ 使用SLF4J：\",\"import org.slf4j.Logger; import org.slf4j.LoggerFactory; private static final Logger logger = LoggerFactory.getLogger(Test.class); \",\"​ 使用JCL：\",\"import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; private static final Log log = LogFactory.getLog(Test.class); \",\"【强制】日志文件至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。对于当天日志，以“应用名.log”来保存，保存在/{统一目录}/{应用名}/logs/目录下，过往日志格式为：{logname}.log.{保存日期}，日期格式：yyyy-MM-dd正例：以mppserver应用为例，日志保存/home/admin/mppserver/logs/mppserver.log，历史日志名称为mppserver.log.20 21 - 11 - 28\",\"【强制】根据国家法律，网络运行状态、网络安全事件、个人敏感信息操作等相关记录，留存的日志不少于六个月，并且进行网络多机备份。\",\"【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式： appName_logType_logName.log。logType：日志类型，如stats / monitor / access等； logName：日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。 说明：推荐对日志进行分类，将错误日志和业务日志分开放，便于开发人员查看，也便于通过日志对系统进行及时监控。正例：mppserver应用中单独监控时区转换异常，如：mppserver_monitor_timeZoneConvert.log\",\"【强制】在日志输出时，字符串变量之间的拼接使用占位符的方式。 说明：因为String字符串的拼接会使用StringBuilder的append() 方式，有一定的性能损耗。使用占位符仅是替换动作，可以有效提升性能。正例：logger.debug(\\\"Processing trade with id : {} and symbol : {}\\\", id, symbol);\",\"【强制】对于trace / debug / info级别的日志输出，必须进行日志级别的开关判断： 说明：虽然在debug(参数) 的方法体内第一行代码isDisabled(Level.DEBUG_INT) 为真时（Slf4j的常见实现Log4j和Logback），就直接return，但是参数可能会进行字符串拼接运算。此外，如果debug(getName()) 这种参数内有getName() 方法调用，无谓浪费方法调用的开销。正例：\",\"// 如果判断为真，那么可以输出trace和debug级别的日志 if (logger.isDebugEnabled()) { logger.debug(\\\"Current ID is: {} and name is: {}\\\", id, getName()); } \",\"【强制】避免重复打印日志，浪费磁盘空间，务必在日志配置文件中设置additivity=false正例：<logger name=\\\"com.taobao.dubbo.config\\\" additivity=\\\"false\\\">\",\"【强制】生产环境禁止使用System.out或System.err输出或使用e.printStackTrace() 打印异常堆栈。 说明：标准日志输出与标准错误输出文件每次Jboss重启时才滚动，如果大量输出送往这两个文件，容易造成文件大小 超过操作系统大小限制。\",\"【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字throws往上抛出。正例：logger.error(\\\"inputParams: {} and errorMessage: {}\\\", 各类参数或者对象toString(), e.getMessage(), e);\",\"【强制】日志打印时禁止直接用JSON工具将对象转换成String。 说明：如果对象里某些get方法被覆写，存在抛出异常的情况，则可能会因为打印日志而影响正常业务流程的执行。正例：打印日志时仅打印出业务相关属性值或者调用其对象的toString() 方法。\",\"【推荐】谨慎地记录日志。生产环境禁止输出debug日志；有选择地输出info日志；如果使用warn来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。 说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？\",\"【推荐】可以使用warn日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出error级别，避免频繁报警。 说明：注意日志输出的级别，error级别只记录系统逻辑出错、异常或者重要的错误信息。\",\"【推荐】尽量用英文来描述日志错误信息，如果日志中的错误信息用英文描述不清楚的话使用中文描述即可，否则容易产生歧义。 说明：国际化团队或海外部署的服务器由于字符集问题，使用全英文来注释和描述日志错误信息。\",\"【推荐】为了保护用户隐私，日志文件中的用户敏感信息需要进行脱敏处理。 说明：日志排查问题时，推荐使用订单号、UUID之类的唯一编号进行查询。\"]},\"860\":{\"h\":\"三、单元测试\",\"t\":[\"【强制】好的单元测试必须遵守AIR原则。 说明：单元测试在线上运行时，感觉像空气（AIR）一样感觉不到，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。\",\"A：Automatic（自动化）\",\"I：Independent（独立性）\",\"R：Repeatable（可重复）\",\"【强制】单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。不准使用System.out来进行人肉验证，单元测试必须使用assert来验证。\",\"【强制】保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。反例：method2需要依赖method1的执行，将执行结果作为method2的输入。\",\"【强制】单元测试是可以重复执行的，不能受到外界环境的影响。 说明：单元测试通常会被放到持续集成中，每次有代码push时单元测试都会被执行。如果单测对外部环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。正例：为了不受外界环境影响，要求设计代码时就把SUT（System under test）的依赖改成注入，在测试时用Spring这样的DI框架注入一个本地（内存）实现或者Mock实现。\",\"【强制】对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。 说明：测试粒度小才能在出错时尽快定位到出错的位置。单元测试不负责检查跨类或者跨系统的交互逻辑，那是集成测试的领域。\",\"【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过。 说明：新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。\",\"【强制】单元测试代码必须写在如下工程目录： src/test/java，不允许写在业务代码目录下。 说明：源码编译时会跳过此目录，而单元测试框架默认是扫描此目录。\",\"【推荐】单测的基本目标：语句覆盖率达到70%；核心模块的语句覆盖率和分支覆盖率都要达到100% 说明：在工程规约的应用分层中提到的DAO层，Manager层，可重用度高的Service，都应该进行单元测试。\",\"【推荐】编写单元测试代码遵守BCDE原则，以保证被测试模块的交付质量。\",\"B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。\",\"C：Correct，正确的输入，并得到预期的结果。\",\"D：Design，与设计文档相结合，来编写单元测试。\",\"E：Error，强制错误信息输入（如：非法数据、异常流程、业务允许外等），并得到预期的结果。\",\"【推荐】对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。反例：删除某一行数据的单元测试，在数据库中，先直接手动增加一行作为删除目标，但是这一行新增数据并不符合业务插入规则，导致测试结果异常。\",\"【推荐】和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。正例：在基础技术部的内部单元测试中，使用FOUNDATION_UNIT_TEST_的前缀来标识单元测试相关代码。\",\"【推荐】对于不可测的代码在适当的时机做必要的重构，使代码变得可测避免为了达到测试要求而书写不规范测试代码。\",\"【推荐】在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好覆盖所有测试用例（UC）。\",\"【推荐】单元测试作为一种质量保障手段，在项目提测前完成单元测试，不建议项目发布后补充单元测试用例。\",\"【参考】为了更方便地进行单元测试，业务代码应避免以下情况：\",\"构造方法中做的事情过多。\",\"存在过多的全局变量和静态方法。\",\"存在过多的外部依赖。\",\"存在过多的条件语句。 说明：多层条件语句建议使用卫语句、策略模式、状态模式等方式重构。\",\"【参考】不要对单元测试存在如下误解：\",\"那是测试同学干的事情。本文是开发手册，凡是本文内容都是与开发同学强相关的。\",\"单元测试代码是多余的。系统的整体功能与各单元部件的测试正常与否是强相关的。\",\"单元测试代码不需要维护。一年半载后，那么单元测试几乎处于废弃状态。\",\"单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障。\"]},\"861\":{\"h\":\"四、安全规约\",\"t\":[\"【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。 说明：防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信内容。\",\"【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。 说明：中国大陆个人手机号码显示：139****1219，隐藏中间 4 位，防止隐私泄露。\",\"【强制】用户输入的SQL参数严格使用参数绑定或者METADATA字段值限定，防止SQL注入，禁止字符串拼接SQL访问数据库。反例：某系统签名大量被恶意修改，即是因为对于危险字符#--没有进行转义，导致数据库更新时，where后边的信息被注释掉，对全库进行更新。\",\"【强制】用户请求传入的任何参数必须做有效性验证。 说明：忽略参数校验可能导致：\",\"页面page size过大导致内存溢出\",\"恶意order by导致数据库慢查询\",\"缓存击穿\",\"SSRF\",\"任意重定向\",\"SQL注入，Shell注入，反序列化注入\",\"正则输入源串拒绝服务ReDoS 扩展：Java代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。\",\"【强制】禁止向HTML页面输出未经安全过滤或未正确转义的用户数据。 说明：XSS跨站脚本攻击。它指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览时，嵌入其中Web里面的html代码会被执行，造成获取用户cookie、钓鱼、获取用户页面数据、蠕虫、挂马等危害。\",\"【强制】表单、AJAX提交必须执行CSRF安全验证。 说明：CSRF (Cross-site request forgery) 跨站请求伪造是一类常见编程漏洞。对于存在CSRF漏洞的应用/网站，攻击者可以事先构造好URL，只要受害者用户一访问，后台便在用户不知情的情况下对数据库中用户参数进行相应修改。\",\"【强制】URL外部重定向传入的目标地址必须执行白名单过滤。 说明：攻击者通过恶意构造跳转的链接，可以向受害者发起钓鱼攻击。\",\"【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。 说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费。\",\"【强制】对于文件上传功能，需要对于文件大小、类型进行严格检查和控制。 说明：攻击者可以利用上传漏洞，上传恶意文件到服务器，并且远程执行，达到控制网站服务器的目的。\",\"【强制】配置文件中的密码需要加密。\",\"【推荐】发贴、评论、发送等即时消息，需要用户输入内容的场景。必须实现防刷、内容违禁词过滤等风控策略。\"]},\"862\":{\"h\":\"五、MySQL数据库\"},\"863\":{\"h\":\"(一) 建表规约\",\"t\":[\"【强制】表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint（ 1 表示是， 0 表示否）。 注意：POJO类中的任何布尔类型的变量，都不要加is前缀，所以，需要在<resultMap>设置从is_xxx到Xxx的映射关系。数据库表示是与否的值，使用tinyint类型，坚持is_xxx的命名方式是为了明确其取值含义与取值范围。 说明：任何字段如果为非负数，必须是unsigned。正例：表达逻辑删除的字段名is_deleted， 1 表示删除， 0 表示未删除。\",\"【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 说明：MySQL在Windows下不区分大小写，但在Linux下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。正例：aliyun_admin，rdc_config，level3_name反例：AliyunAdmin，rdcConfig，level_3_name\",\"【强制】表名不使用复数名词。 说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。\",\"【强制】禁用保留字，如desc、range、match、delayed等，请参考MySQL官方保留字。\",\"【强制】主键索引名为pk_字段名；唯一索引名为uk_字段名；普通索引名则为idx_字段名。 说明：pk_即primary key；uk_即unique key；idx_即index的简称。\",\"【强制】小数类型为decimal，禁止使用float和double。 说明：在存储的时候，float和double都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成整数和小数并分开存储。\",\"【强制】如果存储的字符串长度几乎相等，使用char定长字符串类型。\",\"【强制】varchar是可变长字符串，不预先分配存储空间，长度不要超过 5000 ，如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引率。\",\"【强制】表必备三字段：id，create_time，update_time。 说明：其中id必为主键，类型为bigint unsigned、单表时自增、步长为 1 。create_time，update_time的类型均为datetime类型，前者现在时表示主动式创建，后者过去分词表示被动式更新。\",\"【强制】在数据库中不能使用物理删除操作，要使用逻辑删除。 说明：逻辑删除在数据删除后可以追溯到行为操作。不过会使得一些情况下的唯一主键变得不唯一，需要根据情况来酌情解决。\",\"【推荐】表的命名最好是遵循“业务名称_表的作用”。正例：alipay_task / force_project / trade_config / tes_question\",\"【推荐】库名与应用名称尽量一致。\",\"【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。\",\"【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循： 1 ）不是频繁修改的字段。 2 ）不是唯一索引的字段。 3 ）不是varchar超长字段，更不能是text字段。正例：各业务线经常冗余存储商品名称，避免查询时需要调用IC服务获取。\",\"【推荐】单表行数超过 500 万行或者单表容量超过2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。\",\"【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。正例：无符号值可以避免误存负数，且扩大了表示范围： ​ 对象 年龄区间 类型 字节 表示范围 ​ 人 150 岁之内 tinyint unsigned 1 无符号值： 0 到 255 ​ 龟 数百岁 smallint unsigned 2 无符号值： 0 到 65535 ​ 恐龙化石 数千万年 int unsigned 4 无符号值： 0 到约 43 亿 ​ 太阳 约 50 亿年 bigint unsigned 8 无符号值： 0 到约 10 的 19 次方\"]},\"864\":{\"h\":\"(二) 索引规约\",\"t\":[\"【强制】业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。 说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。\",\"【强制】超过三个表禁止join。需要join的字段，数据类型保持绝对一致；多表关联查询时，保证被关联的字段需要有索引。 说明：即使双表join也要注意表索引、SQL性能。\",\"【强制】在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。 说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达90%以上，可以使用count(distinct left(列名，索引长度)) / count(*) 的区分度来确定。\",\"【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。 说明：索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。\",\"【推荐】如果有order by的场景，请注意利用索引的有序性。order by最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现filesort的情况，影响查询性能。正例：where a =? and b =? order by c；索引：a_b_c反例：索引如果存在范围查询，那么索引有序性无法利用，如：WHERE a > 10 ORDER BY b；索引a_b无法排序。\",\"【推荐】利用覆盖索引来进行查询操作，避免回表。 说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。正例：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用explain的结果，extra列会出现：using index。\",\"【推荐】利用延迟关联或者子查询优化超多分页场景。 说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。正例：先快速定位需要获取的id段，然后再关联： SELECT t1.* FROM表 1 as t1 , (select id from表 1 where条件LIMIT 100000 , 20) as t2 where t1.id = t2.id\",\"【推荐】SQL性能优化的目标：至少要达到range级别，要求是ref级别，如果可以是const最好。 说明： ​ 1 ）consts单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 ​ 2 ）ref指的是使用普通的索引（normal index）。 ​ 3 ）range对索引进行范围检索。反例：explain表的结果，type = index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。\",\"【推荐】建组合索引的时候，区分度最高的在最左边。正例：如果where a =? and b = ?，a列的几乎接近于唯一值，那么只需要单建idx_a索引即可。 说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where c >? and d =? 那么即使c的区分度更高，也必须把d放在索引的最前列，即建立组合索引idx_d_c。\",\"【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。\",\"【参考】创建索引时避免有如下极端误解： 1 ）索引宁滥勿缺。认为一个查询就需要建一个索引。 2 ）吝啬索引的创建。认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度。 3 ）抵制唯一索引。认为唯一索引一律需要在应用层通过“先查后插”方式解决。\"]},\"865\":{\"h\":\"(三) SQL语句\",\"t\":[\"【强制】不要使用count(列名) 或count(常量) 来替代count()，count() 是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关。 说明：count(*) 会统计值为NULL的行，而count(列名) 不会统计此列为NULL值的行。\",\"【强制】count(distinct col) 计算该列除NULL之外的不重复行数，注意count(distinct col1 , col2) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为 0 。\",\"【强制】当某一列的值全是NULL时，count(col) 的返回结果为 0 ；但sum(col) 的返回结果为NULL，因此使用sum() 时需注意NPE问题。正例：可以使用如下方式来避免sum的NPE问题：SELECT IFNULL(SUM(column) , 0) FROM table;\",\"【强制】使用ISNULL() 来判断是否为NULL值。 说明：NULL与任何值的直接比较都为NULL。 ​ 1 ）NULL<>NULL的返回结果是NULL，而不是false。 ​ 2 ）NULL=NULL的返回结果是NULL，而不是true。 ​ 3 ）NULL<>1的返回结果是NULL，而不是true。反例：在SQL语句中，如果在null前换行，影响可读性。 select * from table where column1 is null and column3 is not null；而ISNULL(column) 是一个整体，简洁易懂。 从性能数据上分析，ISNULL(column) 执行效率更快一些。\",\"【强制】代码中写分页查询逻辑时，若count为 0 应直接返回，避免执行后面的分页语句。\",\"【强制】不得使用外键与级联，一切外键概念必须在应用层解决。 说明：（概念解释）学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学生表中的student_id，同时触发成绩表中的student_id更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。\",\"【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。\",\"【强制】数据订正（特别是删除或修改记录操作）时，要先select，避免出现误删除的情况，确认无误才能执行更新语句。\",\"【强制】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或表名）进行限定。 说明：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常。正例：select t1.name from first_table as t1 , second_table as t2 where t1.id = t2.id;反例：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年后，最近在某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出 1052 异常： Column 'name' infield list is ambiguous。\",\"【推荐】SQL语句中表的别名前加as，并且以t1、t2、t3、...的顺序依次命名。 说明： ​ 1 ）别名可以是表的简称，或者是依照表在SQL语句中出现的顺序，以t1、t2、t3的方式命名。 ​ 2 ）别名前加as使别名更容易识别。正例：select t1.name from first_table as t1 , second_table as t2 where t1.id = t2.id;\",\"【推荐】in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000 个之内。\",\"【参考】因国际化需要，所有的字符存储与表示，均采用utf8字符集，那么字符计数方法需要注意。 说明： SELECT LENGTH(\\\"轻松工作\\\")；--返回为 12 SELECT CHARACTER_LENGTH(\\\"轻松工作\\\")；--返回为 4 如果需要存储表情，那么选择utf8mb4来进行存储，注意它与utf8编码的区别。\",\"【参考】TRUNCATE TABLE比DELETE速度快，且使用的系统和事务日志资源少，但TRUNCATE无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句。 说明：TRUNCATE TABLE在功能上与不带WHERE子句的DELETE语句相同。\"]},\"866\":{\"h\":\"(四) ORM映射\",\"t\":[\"【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。 说明： 1 ）增加查询分析器解析成本。 2 ）增减字段容易与resultMap配置不一致。 3 ）无用字段增加网络消耗，尤其是text类型的字段。\",\"【强制】POJO类的布尔属性不能加is，而数据库字段必须加is_，要求在resultMap中进行字段与属 性之间的映射。 说明：参见定义POJO类以及数据库字段定义规定，在sql.xml增加映射，是必须的。\",\"【强制】不要用resultClass当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义<resultMap>；反过来，每一个表也必然有一个<resultMap>与之对应。 说明：配置映射关系，使字段与DO类解耦，方便维护。\",\"【强制】sql.xml配置参数使用：#{}，#param# 不要使用 ${} 此种方式容易出现SQL注入。\",\"【强制】iBATIS自带的queryForList(String statementName，int start，int size) 不推荐使用。 说明：其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList取start，size 的子集合，线上因为这个原因曾经出现过OOM。正例： Map<String, Object> map = new HashMap<>(16); map.put(\\\"start\\\", start); map.put(\\\"size\\\", size);\",\"【强制】不允许直接拿HashMap与Hashtable作为查询结果集的输出。反例：某同学为避免写一个，直接使用Hashtable来接收数据库返回结果，结果出现 日常是把bigint转成Long值，而线上由于数据库版本不一样，解析成BigInteger，导致线上问题。\",\"【强制】更新数据表记录时，必须同时更新记录对应的update_time字段值为当前时间。\",\"【推荐】不要写一个大而全的数据更新接口。传入为POJO类，不管是不是自己的目标更新字段，都进行\",\"update table set c1 = value1 , c2 = value2 , c3 = value3；这是不对的。执行SQL时，不要更新无改 动的字段，一是易出错；二是效率低；三是增加binlog存储。\",\"【参考】@Transactional事务不要滥用。事务会影响数据库的QPS，另外使用事务的地方需要考虑各\",\"方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。\",\"【参考】<isEqual>中的compareValue是与属性值对比的常量，一般是数字，表示相等时带上此条\",\"件；<isNotEmpty>表示不为空且不为null时执行；<isNotNull>表示不为null值时执行。\"]},\"867\":{\"h\":\"六、工程结构\"},\"868\":{\"h\":\"(一) 应用分层\",\"t\":[\"【推荐】根据业务架构实践，结合业界分层规范与流行技术框架分析，推荐分层结构如图所示，默认上层依赖于下层，箭头关系表示可直接依赖，如：开放API层可以依赖于Web层（Controller层），也可以直接依赖于Service层，依此类推：\",\"开放API层：可直接封装Service接口暴露成RPC接口；通过Web封装成http接口；网关控制层等。\",\"终端显示层：各个端的模板渲染并执行显示的层。当前主要是velocity渲染，JS渲染，JSP渲染，移动端展示等。\",\"Web层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。\",\"Service层：相对具体的业务逻辑服务层。\",\"Manager层：通用业务处理层，它有如下特征 1 ）对第三方平台封装的层，预处理返回结果及转化异常信息，适配上层接口。 2 ）对Service层通用能力的下沉，如缓存方案、中间件通用处理。 3 ）与DAO层交互，对多个DAO的组合复用。\",\"DAO层：数据访问层，与底层MySQL、Oracle、Hbase、OceanBase等进行数据交互。\",\"第三方服务：包括其它部门RPC服务接口，基础平台，其它公司的HTTP接口，如淘宝开放平台、支付宝付款服务、高德地图服务等。\",\"外部数据接口：外部（应用）数据存储服务提供的接口，多见于数据迁移场景中。\",\"【参考】（分层异常处理规约）在DAO层，产生的异常类型有很多，无法用细粒度的异常进行catch，使用catch(Exception e) 方式，并throw new DAOException(e)，不需要打印日志，因为日志在Manager或Service层一定需要捕获并打印到日志文件中去，如果同台服务器再打日志，浪费性能和存 储。在Service层出现异常时，必须记录出错日志到磁盘，尽可能带上参数和上下文信息，相当于保护案发现场。Manager层与Service同机部署，日志方式与DAO层处理一致，如果是单独部署，则采用与Service一致的处理方式。Web层绝不应该继续往上抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，尽量加上友好的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。\",\"【参考】分层领域模型规约：\",\"DO（Data Object）：此对象与数据库表结构一一对应，通过DAO层向上传输数据源对象。\",\"DTO（Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。\",\"BO（Business Object）：业务对象，可以由Service层输出的封装业务逻辑的对象。\",\"Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用Map类来传输。\",\"VO（View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。\"]},\"869\":{\"h\":\"(二) 二方库依赖\",\"t\":[\"【强制】定义GAV遵从以下规则： 1 ）GroupId格式：com.{公司/BU}.业务线.[子业务线]，最多 4 级。 说明：{公司/BU}例如：alibaba / taobao / tmall / kaikeba等BU一级；子业务线可选。正例：com.taobao.jstorm或com.alibaba.dubbo.register 2 ）ArtifactId格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。正例：dubbo-client / fastjson-api / jstorm-tool 3 ）Version：详细规定参考下方。\",\"【强制】二方库版本号命名方式：主版本号.次版本号.修订号 1 ）主版本号：产品方向改变，或者大规模API不兼容，或者架构不兼容升级。 2 ）次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的API不兼容修改。 3 ）修订号：保持完全兼容性，修复BUG、新增次要功能特性等。 说明：注意起始版本号必须为：1.0.0，而不是0.0.1。反例：仓库内某二方库版本号从1.0.0.0开始，一直默默“升级”成1.0.0.64，完全失去版本的语义信息。\",\"【强制】线上应用不要依赖SNAPSHOT版本（安全包除外）；正式发布的类库必须先去中央仓库进行查证，使RELEASE版本号有延续性，且版本号不允许覆盖升级。 说明：不依赖SNAPSHOT版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。\",\"【强制】二方库的新增或升级，保持除功能点之外的其它jar包仲裁结果不变。如果有改变，必须明确评估和验证。 说明：在升级时，进行dependency:resolve前后信息比对，如果仲裁结果完全不一致，那么通过dependency:tree命令，找出差异点，进行<exclude>排除jar包。\",\"【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的POJO对象。\",\"【强制】二方库定制包的命名方式，在规定的版本号之后加“-英文说明[序号]”，英文说明可以是部门简称、业务名称，序号直接紧跟在英文说明之后，表示此定制包的顺序号。 说明：fastjson给SCM定制的版本号：1.0.0-SCM1。注：请尽可能在应用端来解决类冲突和加载问题，避免随意发布此类定制包。\",\"【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。 说明：依赖springframework-core，-context，-beans，它们都是同一个版本，可以定义一个变量来保存版本：${spring.version}，定义依赖的时候，引用该版本。\",\"【强制】禁止在子项目的pom依赖中出现相同的GroupId，相同的ArtifactId，但是不同的Version。 说明：在本地调试时会使用各子项目指定的版本号，但是合并成一个war，只能有一个版本号出现在最后的lib目录中。曾经出现过线下调试是正确的，发布到线上却出故障的先例。\",\"【推荐】底层基础技术框架、核心数据管理平台、或近硬件端系统谨慎引入第三方实现。\",\"【推荐】所有pom文件中的依赖声明放在<dependencies>语句块中，所有版本仲裁放在<dependencyManagement>语句块中。\",\"说明：<dependencyManagement>里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖，version和scope都读取自父pom。而<dependencies>所有声明在主pom的<dependencies>里的依赖都会自动引入，并默认被所有的子项目继承。\",\"【推荐】二方库不要有配置项，最低限度不要再增加配置项。\",\"【推荐】不要使用不稳定的工具包或者Utils类。 说明：不稳定指的是提供方无法做到向下兼容，在编译阶段正常，但在运行时产生异常，因此，尽量使用业界稳定的二方工具包。\",\"【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则： 1 ） 。移除一切不必要的API和依赖，只包含Service API、必要的领域模型对象、Utils类、常量、枚举等。如果依赖其它二方库，尽量是provided引入，让二方库使用者去依赖具体版本号；无log具体实现，只依赖日志框架。 2 ） 。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。\"]},\"870\":{\"h\":\"(三) 服务器\",\"t\":[\"【强制】调用远程操作必须有超时设置。 说明：类似于HttpClient的超时设置需要自己明确去设置Timeout。根据经验表明，无数次的故障都是因为没有设置超时时间。\",\"【推荐】客户端设置远程接口方法的具体超时时间（单位 ms），超时设置生效顺序一般为： 1 ）客户端Special Method； 2 ）客户端接口级别； 3 ）服务端Special Method； 4 ）服务端接口级别。\",\"【推荐】高并发服务器建议调小TCP协议的time_wait超时时间。 说明：操作系统默认 240 秒后，才会关闭处于time_wait状态的连接，在高并发访问下，服务器端会因为处于time_wait的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。正例：在linux服务器上请通过变更/etc/sysctl.conf文件去修改该缺省值（秒）：net.ipv4.tcp_fin_timeout=30\",\"【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为fd） 说明：主流操作系统的设计是将TCP / UDP连接采用与文件一样的方式去管理，即一个连接对应于一个fd。主流的linux服务器默认所支持最大fd数量为 1024 ，当并发连接数很大时很容易因为fd不足而出现“open too many files”错误，导致新的连接无法建立。建议将linux服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。\",\"【推荐】给JVM环境参数设置-XX：+HeapDumpOnOutOfMemoryError参数，让JVM碰到OOM场景时输出dump信息。 说明：OOM的发生是有概率的，甚至相隔数月才出现一例，出错时的堆内信息对解决问题非常有帮助。\",\"【推荐】在线上生产环境，JVM的Xms和Xmx设置一样大小的内存容量，避免在GC后调整堆大小带来的压力。\",\"【推荐】了解每个服务大致的平均耗时，可以通过独立配置线程池，将较慢的服务与主线程池隔离开，免得不同服务的线程同归于尽。\",\"【参考】服务器内部重定向必须使用forward；外部部重定向地址必须使用URL Broker生成，否则因线上采用HTTPS协议而导致浏览器提示“不安全”。此外，还会带来URL维护不一致的问题。\"]},\"871\":{\"h\":\"七、设计规约\",\"t\":[\"【强制】存储方案和底层数据结构的设计获得评审一致通过，并沉淀成为文档。 说明：有缺陷的底层数据结构容易导致系统风险上升，可扩展性下降，重构成本也会因历史数据迁移和系统平滑过渡而陡然增加，所以，存储方案和数据结构需要认真地进行设计和评审，生产环境提交执行后，需要进行double check。正例：评审内容包括存储介质选型、表结构设计能否满足技术方案、存取性能和存储空间能否满足业务发展、表或字段之间的辩证关系、字段名称、字段类型、索引等；数据结构变更（如在原有表中新增字段）也需要在评审通过后上线。\",\"【强制】在需求分析阶段，如果与系统交互的User超过一类并且相关的UserCase超过 5 个，使用用例图来表达更加清晰的结构化需求。\",\"【强制】如果某个业务对象的状态超过 3 个，使用状态图来表达并且明确状态变化的各个触发条件。 说明：状态图的核心是对象状态，首先明确对象有多少种状态，然后明确两两状态之间是否存在直接转换关系，再明确触发状态转换的条件是什么。正例：淘宝订单状态有已下单、待付款、已付款、待发货、已发货、已收货等。比如已下单与已收货这两种状态之间是不可能有直接转换关系的。\",\"【强制】如果系统中某个功能的调用链路上的涉及对象超过 3 个，使用时序图来表达并且明确各调用环节的输入与输出。 说明：时序图反映了一系列对象间的交互与协作关系，清晰立体地反映系统的调用纵深链路。\",\"【强制】如果系统中模型类超过 5 个，且存在复杂的依赖关系，使用类图来表达并且明确类之间的关系。 说明：类图像建筑领域的施工图，如果搭平房，可能不需要，但如果建造蚂蚁Z空间大楼，肯定需要详细的施工图。\",\"【强制】如果系统中超过 2 个对象之间存在协作关系，并需要表示复杂的处理流程，使用活动图来表示。 说明：活动图是流程图的扩展，增加了能够体现协作关系的对象泳道，支持表示并发等。\",\"【强制】系统设计时要准确识别出弱依赖，并针对性地设计降级和应急预案，保证核心系统正常可用。 说明：系统依赖的第三方服务被降级或屏蔽后，依然不会影响主干流程继续进行，仅影响信息展示、或消息通知等非关键功能，那么这些服务称为弱依赖。正例：当系统弱依赖于多个外部服务时，如果下游服务耗时过长，则会严重影响当前调用者，必须采取相应降级措施，比如，当调用链路中某个下游服务调用的平均响应时间或错误率超过阈值时，系统自动进行降级或熔断操作，屏蔽弱依赖负面影响，保护当前系统主干功能可用。反例：某个疫情相关的二维码出错：“服务器开了点小差，请稍后重试”，不可用时长持续很久，引起社会高度关注，原因可能为调用的外部依赖服务RT过高而导致系统假死，而在显示端没有做降级预案，只能直接抛错给用户。\",\"【推荐】系统架构设计时明确以下目标：\",\"确定系统边界。确定系统在技术层面上的做与不做。\",\"确定系统内模块之间的关系。确定模块之间的依赖关系及模块的宏观输入与输出。\",\"确定指导后续设计与演化的原则。使后续的子系统或模块设计在一个既定的框架内和技术方向上继续演化。\",\"确定非功能性需求。非功能性需求是指安全性、可用性、可扩展性等。\",\"【推荐】需求分析与系统设计在考虑主干功能的同时，需要充分评估异常流程与业务边界。\",\"【推荐】类在设计与实现时要符合单一原则。 说明：单一原则最易理解却是最难实现的一条规则，随着系统演进，很多时候，忘记了类设计的初衷。\",\"【推荐】谨慎使用继承的方式来进行扩展，优先使用聚合/组合的方式来实现。 说明：不得已使用继承的话，必须符合里氏代换原则，此原则说父类能够出现的地方子类一定能够出现，比如，“把钱交出来”，钱的子类美元、欧元、人民币等都可以出现。\",\"【推荐】系统设计阶段，根据依赖倒置原则，尽量依赖抽象类与接口，有利于扩展与维护。 说明：低层次模块依赖于高层次模块的抽象，方便系统间的解耦。\",\"【推荐】系统设计阶段，注意对扩展开放，对修改闭合。 说明：极端情况下，交付的代码是不可修改的，同一业务域内的需求变化，通过模块或类的扩展来实现。\",\"【推荐】系统设计阶段，共性业务或公共行为抽取出来公共模块、公共配置、公共类、公共方法等，在系统中不出现重复代码的情况，即DRY原则（Don't Repeat Yourself）。 说明：随着代码的重复次数不断增加，维护成本指数级上升。随意复制和粘贴代码，必然会导致代码的重复，在维护代码时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。正例：一个类中有多个public方法，都需要进行数行相同的参数校验操作，这个时候请抽取：\",\"private boolean checkParam(DTO dto) {...} \",\"【推荐】避免如下误解：敏捷开发=讲故事+编码+发布。 说明：敏捷开发是快速交付迭代可用的系统，省略多余的设计方案，摒弃传统的审批流程，但核心关键点上的必要设计和文档沉淀是需要的。反例：某团队为了业务快速发展，敏捷成了产品经理催进度的借口，系统中均是勉强能运行但像面条一样的代码，可维护性和可扩展性极差，一年之后，不得不进行大规模重构，得不偿失。\",\"【参考】设计文档的作用是明确需求、理顺逻辑、后期维护，次要目的用于指导编码。 说明：避免为了设计而设计，系统设计文档有助于后期的系统维护和重构，所以设计结果需要进行分类归档保存。\",\"【参考】可扩展性的本质是找到系统的变化点，并隔离变化点。 说明：世间众多设计模式其实就是一种设计模式即隔离变化点的模式。正例：极致扩展性的标志，就是需求的新增，不会在原有代码交付物上进行任何形式的修改。\",\"【参考】设计的本质就是识别和表达系统难点。 说明：识别和表达完全是两回事，很多人错误地认为识别到系统难点在哪里，表达只是自然而然的事情，但是大家在设计评审中经常出现语焉不详，甚至是词不达意的情况。准确地表达系统难点需要具备如下能力：表达规则和表达工具的熟练性。抽象思维和总结能力的局限性。基础知识体系的完备性。深入浅出的生动表达力。\",\"【参考】代码即文档的观点是错误的，清晰的代码只是文档的某个片断，而不是全部。 说明：代码的深度调用，模块层面上的依赖关系网，业务场景逻辑，非功能性需求等问题要相应的文档来完整地呈现。\",\"【参考】在做无障碍产品设计时，需要考虑到：\",\"所有可交互的控件元素必须能被tab键聚焦，并且焦点顺序需符合自然操作逻辑。\",\"用于登录校验和请求拦截的验证码均需提供图形验证以外的其它方式。\",\"自定义的控件类型需明确交互方式。正例：登录场景中，输入框的按钮都需要考虑tab键聚焦，符合自然逻辑的操作顺序如下，\\\"输入用户名，输入密码，输入验证码，点击登录\\\"，其中验证码实现语音验证方式。如有自定义标签实现的控件设置控件类型可使用role属性。\"]},\"872\":{\"h\":\"附 1 ：版本历史\",\"t\":[\"版本号\",\"版本名\",\"发布日期\",\"备注\",\"2016.12.07\",\"试读版本首次对外发布\",\"1.0.0\",\"正式版\",\"2017.02.09\",\"阿里巴巴集团正式对外发布\",\"1.0.1\",\"2017.02.13\",\"1)修正 String[]的前后矛盾 2)vm 修正成 velocity 3)修正 countdown 描述错误\",\"1.0.2\",\"2017.02.20\",\"1)去除文底水印 2)数据类型中引用太阳系年龄问题 3)修正关于异常和方法签名的部分描述 4)修正 final 描述 5)去除 Comparator 部分描述\",\"1.1.0\",\"2017.02.27\",\"1)增加前言 2)增加<? extends T>描述和说明 3)增加版本历史 4)增加专有名词解释\",\"1.1.1\",\"2017.03.31\",\"修正页码总数和部分示例\",\"1.2.0\",\"完美版\",\"2017.05.20\",\"1)根据云栖社区的“聚能聊”活动反馈，对手册的页码、排版、描述进行修正 2)增加 final 的适用场景描述 3)增加关于锁的粒度的说明 4)增加“指定集合大小”的详细说明以及正反例 5)增加卫语句的示例代码 6)明确数据库表示删除概念的字段名为 is_deleted\",\"1.3.0\",\"终极版\",\"2017.09.25\",\"增加单元测试规约，阿里开源的 IDE 代码规约检测插件\",\"1.3.1\",\"纪念版\",\"2017.11.30\",\"修正部分描述;采用和 P3C 开源 IDE 检测插件相同的 Apache2.0 协议\",\"1.4.0\",\"详尽版\",\"2018.05.20\",\"增加设计规约大类，共 16 条\",\"1.5.0\",\"华山版\",\"2019.06.19\",\"1)鉴于手册是 Java 社区开发者集体智慧的结晶，移除《阿里巴巴 Java 开发手册》 的限定词“阿里巴巴” 2)新增 21 条新规约。比如，switch 的 NPE 问题、浮点数的比较、无泛型限制、锁 的使用方式、判断表达式、日期格式等 3)修改描述 112 处。比如，IFNULL 的判断、集合的 toArray、日志处理等 4)完善若干处示例。比如，卫语句示例、enum 示例、finally 的 return 示例等\",\"1.6.0\",\"泰山版\",\"2020.04.22\",\"1)发布错误码统一解决方案，详细参考附表3。 2)修改描述 90 处。比如，阻塞等待锁、建表的小数类型等。 3)完善若干处示例。比如，ISNULL 的示例等。 4)新增 34 条新规约。比如，日期时间的闰年、闰月问题，三目运算的自动拆箱， SQL 查询的表别名限定，Collectors 类的 toMap() 方法使用注意等。\",\"1.7.0\",\"嵩山版\",\"2020.08.03\",\"1)新增前后端规约 14 条。 2)新增禁止任何歧视性用语的约定。 3)新增涉及敏感操作的情况下日志需要保存六个月的约定。 4)修正 BigDecimal 类中关于 compareTo 和 equals 的等值比较。 5)修正 HashMap 关于 1024 个元素扩容的次数。 6)修正架构分层规范与相关说明。 7)修正泰山版中部分格式错误和描述错误。\",\"1.7.1\",\"黄山版\",\"2022.02.03\",\"1)新增 11 条新规约。比如，浮点数的后缀统一为大写;枚举的属性字段必须是私 有且不可变;配置文件中的密码需要加密等。 2)新增描述中的正反例 2 条。比如，多个构造方法次序、NoSuchMethodError 处 理;新增扩展说明 5 条。比如，父集合元素的增加或删除异常等。3)修改描述 22 处。比如，魔法值的示例代码、ScheduledThreadPool 问题等。 4)修正嵩山版中部分代码格式错误和描述错误。\"]},\"873\":{\"h\":\"附 2 ：专有名词解释\",\"t\":[\"POJO（Plain Ordinary Java Object）：在本规约中，POJO专指只有setter / getter / toString的简单类，包括DO / DTO / BO / VO 等。\",\"DO（Data Object）：阿里巴巴专指数据库表一 一对应的POJO类。 此对象与数据库表结构一 一对应，通过DAO层向上传输数据源对象。\",\"PO（Persistent Object）：也指数据库表一 一对应的POJO类。 此对象与数据库表结构一 一对应，通过DAO层向上传输数据源对象。\",\"DTO（Data Transfer Object ）：数据传输对象，Service或Manager向外传输的对象。\",\"BO（Business Object）：业务对象，可以由Service层输出的封装业务逻辑的对象。\",\"Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用Map类来传输。\",\"VO（View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。\",\"CAS（Compare And Swap） ：解决多线程并行情况下使用锁造成性能损耗的一种机制，这是硬件实现的原子操作。 CAS操作包含三个操作数：内存位置、预期原值和新值。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。\",\"GAV（GroupId、ArtifactId、Version）：Maven坐标，是用来唯一标识jar包。\",\"OOP（Object Oriented Programming）：本文泛指类、对象的编程处理方式。\",\"AQS（AbstractQueuedSynchronizer）：利用先进先出队列实现的底层同步工具类，它是很多上层同步实现类的基础，比如： ReentrantLock、CountDownLatch、 Semaphore等，它们通过继承AQS实现其模版方法，然后将AQS子类作为同步组件的内部类，通常命名为Sync。\",\"ORM（Object Relation Mapping）：对象关系映射，对象领域模型与底层数据之间的转换，本文泛指iBATIS，mybatis 等框架。\",\"NPE（java.lang.NullPointerException）：空指针异常。\",\"OOM（Out Of Memory）：源于java.lang.OutOfMemoryError，当JVM没有足够的内存来为对象分配空间并且垃圾回收器也无法回收空间时，系统出现的严重状况。\",\"GMT（Greenwich Mean Time）：指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。地球每天的自转是有些不规则的，而且正在缓慢减速，现在的标准时间是协调世界时（UTC），它由原子钟提供。\",\"一方库：本工程内部子项目模块依赖的库（jar包）。\",\"二方库：公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar包）。\",\"三方库：公司之外的开源库（jar包）。\"]},\"874\":{\"h\":\"附 3 ：错误码列表\",\"t\":[\"错误码\",\"中文描述\",\"说明\",\"0000\",\"一切 ok\",\"正确执行后的返回\",\"A0001\",\"用户端错误\",\"一级宏观错误码\",\"A0100\",\"用户注册错误\",\"二级宏观错误码\",\"A0101\",\"用户未同意隐私协议\",\"A0102\",\"注册国家或地区受限\",\"A0110\",\"用户名校验失败\",\"A0111\",\"用户名已存在\",\"A0112\",\"用户名包含敏感词\",\"A0113\",\"用户名包含特殊字符\",\"A0120\",\"密码校验失败\",\"A0121\",\"密码长度不够\",\"A0122\",\"密码强度不够\",\"A0130\",\"校验码输入错误\",\"A0131\",\"短信校验码输入错误\",\"A0132\",\"邮件校验码输入错误\",\"A0133\",\"语音校验码输入错误\",\"A0140\",\"用户证件异常\",\"A0141\",\"用户证件类型未选择\",\"A0142\",\"大陆身份证编号校验\",\"A0143\",\"护照编号校验非法\",\"A0144\",\"军官证编号校验非法\",\"A0150\",\"用户基本信息校验失\",\"A0151\",\"手机格式校验失败\",\"A0152\",\"地址格式校验失败\",\"A0153\",\"邮箱格式校验失败\",\"A0200\",\"用户登录异常 二级\",\"A0201\",\"用户账户不存在\",\"A0202\",\"用户账户被冻结\",\"A0203\",\"用户账户已作废\",\"A0210\",\"用户密码错误\",\"A0211\",\"用户输入密码错误次\",\"A0220\",\"用户身份校验失败\",\"A0221\",\"用户指纹识别失败\",\"A0222\",\"用户面容识别失败\",\"A0223\",\"用户未获得第三方登\",\"A0230\",\"用户登录已过期\",\"A0240\",\"用户验证码错误\",\"A0241\",\"用户验证码尝试次数\",\"A0300\",\"访问权限异常\",\"二级宏观错误码\",\"A0301\",\"访问未授权\",\"A0302\",\"正在授权中\",\"A0303\",\"用户授权申请被拒\",\"A0310\",\"因访问对象隐私设\",\"A0311\",\"授权已过期\",\"A0312\",\"无权限使用 API\",\"A0320\",\"用户访问被拦截\",\"A0321\",\"黑名单用户\",\"A0322\",\"账号被冻结\",\"A0323\",\"非法 IP 地址\",\"A0324\",\"网关访问受限\",\"A0325\",\"地域黑名单\",\"A0330\",\"服务已欠费\",\"A0340\",\"用户签名异常\",\"A0341\",\"RSA 签名错误\",\"A0400\",\"用户请求参数错误\",\"二级宏观错误码\",\"A0401\",\"包含非法恶意跳转\",\"A0402\",\"无效的用户输入\",\"A0410\",\"请求必填参数为空\",\"A0411\",\"用户订单号为空\",\"A0412\",\"订购数量为空\",\"A0413\",\"缺少时间戳参数\",\"A0414\",\"非法的时间戳参数\",\"A0420\",\"请求参数值超出允许\",\"A0421\",\"参数格式不匹配\",\"A0422\",\"地址不在服务范围\",\"A0423\",\"时间不在服务范围\",\"A0424\",\"金额超出限制\",\"A0425\",\"数量超出限制\",\"A0426\",\"请求批量处理总个数\",\"A0427\",\"请求 JSON 解析失败\",\"A0430\",\"用户输入内容非法\",\"A0431\",\"包含违禁敏感词\",\"A0432\",\"图片包含违禁信息\",\"A0433\",\"文件侵犯版权\",\"A0440\",\"用户操作异常\",\"A0441\",\"用户支付超时\",\"A0442\",\"确认订单超时\",\"A0443\",\"订单已关闭\",\"A0500\",\"用户请求服务异常\",\"二级宏观错误码\",\"A0501\",\"请求次数超出限制\",\"A0502\",\"请求并发数超出限制\",\"A0503\",\"用户操作请等待\",\"A0504\",\"WebSocket 连接异常\",\"A0505\",\"WebSocket 连接断开\",\"A0506\",\"用户重复请求\",\"A0600\",\"用户资源异常\",\"二级宏观错误码\",\"A0601\",\"账户余额不足\",\"A0602\",\"用户磁盘空间不足\",\"A0603\",\"用户内存空间不足\",\"A0604\",\"用户 OSS 容量不足\",\"A0605\",\"用户配额已用光\",\"蚂蚁森林浇水数或每天抽奖数\",\"A0700\",\"用户上传文件异常\",\"二级宏观错误码\",\"A0701\",\"用户上传文件类型不\",\"A0702\",\"用户上传文件太大\",\"A0703\",\"用户上传图片太大\",\"A0704\",\"用户上传视频太大\",\"A0705\",\"用户上传压缩文件太\",\"A0800\",\"用户当前版本异常\",\"二级宏观错误码\",\"A0801\",\"用户安装版本与系统\",\"A0802\",\"用户安装版本过低\",\"A0803\",\"用户安装版本过高\",\"A0804\",\"用户安装版本已过期\",\"A0805\",\"用户 API 请求版本不\",\"A0806\",\"用户 API 请求版本过\",\"A0807\",\"用户 API 请求版本过\",\"A0900\",\"用户隐私未授权\",\"二级宏观错误码\",\"A0901\",\"用户隐私未签署\",\"A0902\",\"用户摄像头未授权\",\"A0903\",\"用户相机未授权\",\"A0904\",\"用户图片库未授权\",\"A0905\",\"用户文件未授权\",\"A0906\",\"用户位置信息未授权\",\"A0907\",\"用户通讯录未授权\",\"A1000\",\"用户设备异常\",\"二级宏观错误码\",\"A1001\",\"用户相机异常\",\"A1002\",\"用户麦克风异常\",\"A1003\",\"用户听筒异常\",\"A1004\",\"用户扬声器异常\",\"A1005\",\"用户 GPS 定位异常\",\"B0001\",\"系统执行出错\",\"一级宏观错误码\",\"B0100\",\"系统执行超时\",\"二级宏观错误码\",\"B0101\",\"系统订单处理超时\",\"B0200\",\"系统容灾功能被触发\",\"二级宏观错误码\",\"B0210\",\"系统限流\",\"B0220\",\"系统功能降级\",\"B0300\",\"系统资源异常\",\"二级宏观错误码\",\"B0310\",\"系统资源耗尽\",\"B0311\",\"系统磁盘空间耗尽\",\"B0312\",\"系统内存耗尽\",\"B0313\",\"文件句柄耗尽\",\"B0314\",\"系统连接池耗尽\",\"B0315\",\"系统线程池耗尽\",\"B0320\",\"系统资源访问异常\",\"B0321\",\"系统读取磁盘文件\",\"C0001\",\"调用第三方服务出\",\"C0100\",\"中间件服务出错\",\"一级宏观错误码\",\"C0110\",\"RPC 服务出错\",\"二级宏观错误码\",\"C0111\",\"RPC 服务未找到\",\"C0112\",\"RPC 服务未注册\",\"C0113\",\"接口不存在\",\"C0120\",\"消息服务出错\",\"C0121\",\"消息投递出错\",\"C0122\",\"消息消费出错\",\"C0123\",\"消息订阅出错\",\"C0124\",\"消息分组未查到\",\"C0130\",\"缓存服务出错\",\"C0131\",\"key 长度超过限制\",\"C0132\",\"value 长度超过限制\",\"C0133\",\"存储容量已满\",\"C0134\",\"不支持的数据格式\",\"C0140\",\"配置服务出错\",\"C0150\",\"网络资源服务出错\",\"C0151\",\"VPN服务出错\",\"C0152\",\"CDN服务出错\",\"C0153\",\"域名解析服务出错\",\"C0154\",\"网关服务出错\",\"C0200\",\"第三方系统执行超时\",\"二级宏观错误码\",\"C0210\",\"RPC执行超时\",\"C0220\",\"消息投递超时\",\"C0230\",\"缓存服务超时\",\"C0240\",\"配置服务超时\",\"C0250\",\"数据库服务超时\",\"C0300\",\"数据库服务出错\",\"二级宏观错误码\",\"C0311\",\"表不存在\",\"C0312\",\"列不存在\",\"C0321\",\"多表关联中存在多\",\"C0331\",\"数据库死锁\",\"C0341\",\"主键冲突\",\"C0400\",\"第三方容灾系统被\",\"二级宏观错误码\",\"C0401\",\"第三方系统限流\",\"C0402\",\"第三方功能降级\",\"C0500\",\"通知服务出错\",\"二级宏观错误码\",\"C0501\",\"短信提醒服务失败\",\"C0502\",\"语音提醒服务失败\",\"C0503\",\"邮件提醒服务失败\"]},\"875\":{\"h\":\"Google Java 编程风格指南\",\"t\":[\"转载并翻译自 https://google.github.io/styleguide/javaguide.html。个人英语水平有限，应以原文档为标准。\"]},\"876\":{\"h\":\"简介\",\"t\":[\"本文档是 Google Java 语言编程规范的 完整 定义。一个 Java 源文件当且仅当遵守本规范时，才可被描述为 Google 风格。\",\"与其它编程规范指南类似，本文档讨论的不仅涉及代码对齐的美观问题，同时还包含其它类型约定和编码规范。然而，本文档侧重于讨论我们普遍遵循的 硬性规定，也避免提供那些无法明确执行的建议。\"]},\"877\":{\"h\":\"术语说明\",\"t\":[\"在本文档中，除非另有说明：\",\"class 类 表示 ordinary class 普通的类、enum class 枚举类、interface 接口或 annotation 注解类型。\",\"member 成员 表示 nested class 嵌套类、field 字段、method 方法或 constructor 者构造方法，即除初始化方法和注释之外，类的所有最顶层内容。\",\"comment 注释 表示 implementation comments 实现注释。我们不使用术语 documentation comments，而是使用（在 Java 中）更通用的术语 Javadoc。\",\"其它出现在本文档中的术语将另作说明。\"]},\"878\":{\"h\":\"指南说明\",\"t\":[\"本文档中的示例代是 不规范 的。也就是说，虽然示例代码是属于 Google 风格，但并不意味着这是编写优雅代码的唯一方式。示例中代码的风格不应被作为执行的准则。\"]},\"879\":{\"h\":\"源文件准则\"},\"880\":{\"h\":\"文件名\",\"t\":[\"源文件的名称包含了区分大小写的（并且是 唯一 的）顶级类的类名和 .java 扩展名组成。\"]},\"881\":{\"h\":\"文件编码：UTF-8\",\"t\":[\"源文件使用 UTF-8 编码。\"]},\"882\":{\"h\":\"特殊字符\"},\"883\":{\"h\":\"空格字符\",\"t\":[\"除了换行符，ASCII 水平空格字符（0x20） 是源文件中唯一允许出现的空格字符，这意味着：\",\"字符串和字符字面量中的所有非空格字符都要进行转义。\",\"不允许使用制表符缩进。\"]},\"884\":{\"h\":\"特殊转义序列\",\"t\":[\"对于任何含有 特殊转义序列（ \\\\b、\\\\t、\\\\n、\\\\f、\\\\r、\\\\\\\"、\\\\' 和 \\\\\\\\ ）的字符，推荐使用这些转义序列，而不是对应的八进制（例如 \\\\012 ）或者 Unicode（例如 \\\\u000a ）转义字符。\"]},\"885\":{\"h\":\"非 ASCII 字符\",\"t\":[\"对剩余的非 ASCII 字符，取决于 更容易阅读和理解 的方式，选择 Unicode 字符（例如 ∞ ）或等价的 Unicode 转义字符（例如 \\\\u221e ），并且强烈反对在字符串和注释之外使用 Unicode 转义字符。\",\"提示：在使用 Unicode 转义字符的情况下，或者偶尔使用实际的 Unicode 字符时，添加解释性的注释是非常有帮助的。\",\"例如：\",\"Example\",\"Discussion\",\"String unitAbbrev = \\\"μs\\\";\",\"最好：没有注释也十分清晰\",\"String unitAbbrev = \\\"\\\\u03bcs\\\"; // \\\"μs\\\"\",\"允许：但没理由这么做\",\"String unitAbbrev = \\\"\\\\u03bcs\\\"; // Greek letter mu, \\\"s\\\"\",\"允许：但比较笨拙和易出错\",\"String unitAbbrev = \\\"\\\\u03bcs\\\";\",\"较差：可读性太差\",\"return '\\\\ufeff' + content; // byte order mark\",\"很好：转义字符用于非打印字符时，注释是非常有必要的\",\"提示：不要担心因为一些程序可能不能正确地处理非 ASCII 字符，而使你的代码可读性变差。如果真的发生这种情况，那程序会直接 报错，并需要被 修复。\"]},\"886\":{\"h\":\"源文件结构\",\"t\":[\"源文件按以下 顺序 包括：\",\"License 或者 Copyright（如果需要的话）\",\"Package 语句\",\"Import 语句\",\"有且只有一个的顶级 Class\",\"以上每个部分间隔 一个空行。\"]},\"887\":{\"h\":\"License 或者 Copyright 信息\",\"t\":[\"如果文件中包含许可证和版权信息，应当至于此处。\"]},\"888\":{\"h\":\"Package 语句\",\"t\":[\"Package 语句不允许换行。单行字符限制（ 列限制：100 章节）不适用于 Package 语句。\"]},\"889\":{\"h\":\"Import 语句\"},\"890\":{\"h\":\"不允许通配符\",\"t\":[\"不允许 使用静态或者其它形式的 通配符导入。\"]},\"891\":{\"h\":\"不允许换行\",\"t\":[\"Import 语句 不允许 换行。单行字符限制（ 列限制：100 章节）不适用于 Import 语句。\"]},\"892\":{\"h\":\"顺序和间隔\",\"t\":[\"Import 语句应按以下方式排序：\",\"所有静态导入归一组。\",\"所有非静态导入归一组。\",\"如果同时存在静态导入和非静态导入，则应使用空行分隔它们。除此之外，在 Import 语句中不允许使用其它空行。\",\"每组中的 Import 语句以 ASCII 编码顺序先后出现。（注意：因为 . 符号的 ASCII 编码排在 ; 符号之前，所以这与单纯的按 ASCII 编码排序略有不同。）\"]},\"893\":{\"h\":\"不允许类的静态导入\",\"t\":[\"静态内部类以常规方式导入，而不是使用静态导入。\"]},\"894\":{\"h\":\"Class 定义\"},\"895\":{\"h\":\"有且仅有一个顶级类的声明\",\"t\":[\"每个顶级类都定义在它们的源文件中。\"]},\"896\":{\"h\":\"类内容顺序\",\"t\":[\"类的成员和初始化方法的顺序对代码可读性有着很重要的影响。然而，对此并没有一个统一正确的标准：不同的类可能有不同的排序内容的方式。\",\"重要的是，每个类都应该使用该类的维护者可以解释清楚的 逻辑排序。例如，新的方法不是习惯性地添加到类的最后，因为「按时间顺序添加」并不是一种逻辑顺序。\"]},\"897\":{\"h\":\"方法重载：不应被分离\",\"t\":[\"同名的类方法应该在一个单独连续的组中出现，中间没有其它成员。对于多个构造方法（它们始终具有相同的名称），也是如此。即使这些方法之间的修饰符，如 static 或 private 不同，也适用这个规则。\"]},\"898\":{\"h\":\"格式化\",\"t\":[\"术语说明：block-like construct 块状结构 指类或者普通方法或者构造方法的主体。注意，在后续 数组初始化 章节中，任何数组的初始化可以选择被认为是一个块状结构。\"]},\"899\":{\"h\":\"花括号\"},\"900\":{\"h\":\"可选花括号的使用\",\"t\":[\"使用花括号来配对 if、else、for、do 和 while 语句，即使它们的语句主体是空的或者仅包含一条语句。\",\"其它可选的花括号，例如 lambda 表达式中的花括号，仍然是可选的。\"]},\"901\":{\"h\":\"非空语句块：K & R 风格\",\"t\":[\"对于非空语句块和块状结构，花括号的使用方式遵循 Kernighan & Ritchie 风格（Egyptian brackets）：\",\"左花括号之前不能换行，除下面详细说明的情况外。\",\"左花括号之后换行。\",\"右花括号之前换行。\",\"仅在右花括号结束一条语句或者方法 / 构造方法 / 类的主体时，右花括号之后才换行。例如 else 和逗号之后的花括号不能换行。\",\"特殊情况：在这些规则允许以分号 ( ; ) 结尾的单个语句的地方，可以出现一组语句，并且该块的左花括号前面有一个换行符。这样的代码块通常用于限制局部变量的作用域，例如在 switch 语句内部。\",\"例如：\",\"return () -> { while (condition()) { method(); } }; return new MyClass() { @Override public void method() { if (condition()) { try { something(); } catch (ProblemException e) { recover(); } } else if (otherCondition()) { somethingElse(); } else { lastThing(); } { int x = foo(); frob(x); } } }; \",\"关于枚举类的一些特殊情况，将在 枚举类 章节说明。\"]},\"902\":{\"h\":\"空语句块：可以简洁\",\"t\":[\"一个空的语句块或者块状结构可以遵循 K & R 风格（正如在 非空语句块 章节所中描述的）。或者，当它不是 multi-block statement 多块语句（一个包含多块的语句，例如：if / else、try / catch / finally ）一部分的时候，可以在左花括号开始之后立即使用右花括号结束，{} 之中不包含任何字符或者换行符。\",\"例如：\",\"// This is acceptable void doNothing() {} // This is equally acceptable void doNothingElse() { } \",\"// This is not acceptable: No concise empty blocks in a multi-block statement try { doSomething(); } catch (Exception e) {} \"]},\"903\":{\"h\":\"块缩进：+2 个空格\",\"t\":[\"每当新写一个语句块或者块状结构时，增加 2 个空格的缩进。当语句块结束时，返回至上一级别的缩进。语句块的缩进规则适用于所有代码和注释。（代码示例请见 非空语句块：K & R 风格 章节）\"]},\"904\":{\"h\":\"一条语句占一行\",\"t\":[\"每条语句的最后都有换行符。\"]},\"905\":{\"h\":\"列限制：100\",\"t\":[\"Java 代码的列限制为 100 个字符。这儿的「字符」意味着任意的 Unicode 码位。除非另有说明，任何超过此限制的代码行都必须被换行，正如在 换行 章节中所描述的。\",\"每个 Unicode 码位都算作一个字符，不论它显示得更宽或者更窄。例如，如果使用 全角字符 的话，为了遵守这条严格的要求，可以选择提前换行。\",\"特殊情况：\",\"无法遵守列限制的代码行（例如 Javadoc 中的很长的 URL，或者 JSNI 中很长的方法引用）。\",\"Package 语句和 Import 语句（请见 Package 语句 和 Import 语句 章节）。\",\"注释中可以被复制粘贴到 Shell 中执行的命令。\",\"非常长的标识符（在极少数情况下可能需要）允许超过列限制。在这种情况下，周围代码的有效换行方式应与 google-java-format 生成的方式相同。\"]},\"906\":{\"h\":\"换行\",\"t\":[\"术语说明：将原本可以合法写在一行的代码拆分成多行，这种行为称作 line-wrapping 换行。\",\"没有全面和明确的准则，可以准确描述每种场景下该如何进行换行。对于同一段代码，通常会有多种有效可行的换行方法。\",\"注意：换行的典型原因是为了避免代码超出了列数的限制，不过即使符合列限制的一行代码，也可以依据作者的决定而换行。\",\"提示：提取方法或者局部变量或许可以避免换行的问题。\"]},\"907\":{\"h\":\"在何处换行\",\"t\":[\"换行指令的主要内容是：倾向于在 较高语法级别 处中断一行代码。并且：\",\"当一行代码的中断发生在 non-assignment 非赋值运算符时，需要在该运算符之前换行。（注意这与其它语言的 Google 编程风格不同，例如 C++ 和 JavaScript）\",\"这条规则也适用于以下「类似操作符」的符号： \",\"点分隔符（ . ）\",\"方法引用中的两个冒号（ :: ）\",\"类型约束中的 & 符号（ T <extends Foo Foo & Bar> ）\",\"异常捕获中的 | 符号（ catch (FooException | BarException e) ）\",\"当一行代码的中断发生在 assignment 赋值运算符时，需要在该运算符之后换行，但在之前换行也可以接受。\",\"这条规则也适用于 foreach 语句中「类似赋值操作符」的冒号。\",\"方法或者构造方法的名称紧随着与它相连的开括号 (。\",\"逗号 , 紧随着它之前的内容。\",\"在 lambda 语句中，和箭头符号相邻的那行代码永远不会换行，除非 lambda 语句的主体仅是一个不带括号的表达式，并且能紧随着 lambda 语句的箭头立即出现的情况下。例如：\",\"MyLambda<String, Long, Object> lambda = (String label, Long value, Object obj) -> { ... }; Predicate<String> predicate = str -> longExpressionInvolving(str); \",\"注意：换行的主要目的是为了拥有清晰的代码，总代码的行数 不必 是越少越好的。\"]},\"908\":{\"h\":\"换行缩进至少 +4 个空格\",\"t\":[\"进行换行时，第一行（在连续换行的多行代码中）之后的每行代码至少比之前的那行多缩进 +4 个空格。\",\"当进行连续换行时，代码的缩进可以根据实际需要超过 +4 个空格。一般来说，当且仅当两行代码以平级的语法元素开头时，它们才会拥有相同级别的缩进。\",\"在 水平对齐 章节中介绍了不建议使用数量不确定的空格来与上一行代码中的某些单词（token）对齐。\"]},\"909\":{\"h\":\"空格\"},\"910\":{\"h\":\"垂直空格\",\"t\":[\"单个空行总是出现在以下情况中：\",\"类中连续的成员或初始化方法之间，包括：字段、构造方法、方法、内部类、静态初始化代码块、实例初始化代码块。 \",\"特殊情况：两个连续字段（它们之间没有其它代码）之间的空行是可选的。可以根据实际需要，用空行去创建字段之间的 logical groupings 逻辑分组。\",\"特殊情况：枚举常量之间的空行在 枚举类 章节中介绍。\",\"本文档其它章节中所要求的（例如 源文件结构 章节和 Import 语句 章节）\",\"单个空行也可以出现在任何需要提高代码可读性的地方，例如在将代码组织成一小块逻辑的语句之间。不鼓励也不反对将单个空行出现在类的第一个成员或初始化方法的之前，或者最后一个成员或初始化方法的之后。\",\"多个连续的空行是允许的，但这不是本文档所要求的（或者是鼓励的）。\"]},\"911\":{\"h\":\"水平空格\",\"t\":[\"除了编程语言或者编程规范的要求之外，除了在字面量、注释和 Javadoc 之外，单个 ASCII 空格 仅 在以下位置出现：\",\"分隔任何的保留关键字，例如 if、for、catch ，与它们之后的开括号 (。\",\"分隔任何的保留关键字，例如 else、catch，与它之前的右花括号 }。\",\"任何的左花括号 { 之前，除了以下两种特殊情况：\",\"@SomeAnnotation({a, b})（没有使用空格）\",\"String[][] x = {{\\\"foo\\\"}};（ {{ 之间不需要使用空格，请见往下的第 9 条规则）\",\"任何的二元或三元操作符的两侧。这条规则也适用于以下「类似操作符」的符号：\",\"类型约束中的 & 符：<T extends Foo & Bar>\",\"捕获多个异常中的 | 符：catch (FooException | BarException e)\",\"foreach 语句中的冒号（ : ）\",\"lambda 表达式中的箭头：(String str) -> str.length()\",\"但除了：\",\"方法引用中的两个冒号（ :: ），写法类似于 Object::toString\",\"点分隔符（ . ），写法类似于 Object.toString()\",\"在 ,:; 符号或者类型转换的闭括号 ) 之后。\",\"在任何内容与以双斜线 ( // ) 开头的注释之间，允许存在多个空格。\",\"在以双斜线 ( // ) 开头的注释符和注释文本之间，允许存在多个空格。\",\"在类型和变量的定义之间：List<String> list。\",\"在数组初始化的两个花括号的内侧。这条规则不是必须的。\",\"new int[] {5, 6} 和 new int[] { 5, 6 } 都是有效的\",\"在注解和 [] 或 ... 之间。\",\"这条规则不会被解释为要求或者禁止在行首或者行尾使用额外的空格，它只针对于行内的空格。\"]},\"912\":{\"h\":\"水平对齐：从不要求\",\"t\":[\"术语说明：Horizontal alignment 水平对齐 是一种代码的编写方式，其目的是为了使某些单词（token）出现在上一行代码中的另一些单词的正下方，从而在代码中添加若干数量的额外空格的做法。\",\"这种做法是允许的，但在 Google 编程规范中却不是必须的。甚至不要求在已经水平对齐的地方继续保持水平对齐。\",\"如下是一个首先未对齐，然后再对齐的例子：\",\"private int x; // this is fine private Color color; // this too private int x; // permitted, but future edits private Color color; // may leave it unaligned \",\"提示：水平对齐有助于阅读代码，但却难以日后维护。考虑这样一种情况：日后的改动需要调整一行代码，这个改动可能会破坏原本令人愉悦的代码格式，不过这种改动是 允许 的。（IDE）通常会提示编码人员（也许是你自己）调整附近代码行中的空格，但这可能会触发一系列的代码格式化，于是这个一行代码的改动就导致了一个「范围爆炸」。在最坏的情况下，这可能会导致大量毫无意义的工作。在最好的情况下，这依然会混淆代码版本中的历史信息、降低代码评审的速度、加剧代码合并的冲突。\"]},\"913\":{\"h\":\"分组括号：推荐\",\"t\":[\"只有当开发人员和评审人员都同意，没有分组括号时代码的阅读者不会想当然地错误理解，或者分组括号不会更有助于阅读代码的情况下，才可以省略可选的分组括号。不能假定每个阅读者都能熟记整个 Java 运算符的优先级表，这是不合理的。\"]},\"914\":{\"h\":\"特定结构\"},\"915\":{\"h\":\"枚举类\",\"t\":[\"每个枚举常量的逗号之后可以选择性地换行，同时也允许添加额外的空行（通常只有一个）。以下是一种可能的例子：\",\"private enum Answer { YES { @Override public String toString() { return \\\"yes\\\"; } }, NO, MAYBE } \",\"没有方法和注释的枚举常量可以写成数组初始化的方式（请见 数组初始化 章节）。\",\"private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS } \",\"由于枚举类也是类，因此所有对于类的格式化规则也适用于枚举类。\"]},\"916\":{\"h\":\"变量声明\"},\"917\":{\"h\":\"每次声明一个变量\",\"t\":[\"每次变量声明（字段或局部变量）只声明一个变量：例如 int a, b; 形式的变量声明是不允许的。\",\"特殊情况：可以在 for 循环的头部中声明多个变量。\"]},\"918\":{\"h\":\"在需要时声明\",\"t\":[\"局部变量 不是 习惯性地声明在它们所属的代码块或者块状结构的起始位置。相反地，局部变量声明在它们第一次被使用的地方（在合理范围之内），这样做是为了最小化局部变量的作用域。局部变量声明通常具有初始值，或者会在声明之后立即初始化。\"]},\"919\":{\"h\":\"数组\"},\"920\":{\"h\":\"数组初始化：可以写成块状结构\",\"t\":[\"任何数组的初始化可以选择写成「类似块状结构」的格式。例如，以下例子都是合法的（不全）：\",\"new int[] { new int[] { 0, 1, 2, 3 0, } 1, 2, new int[] { 3, 0, 1, } 2, 3 } new int[] {0, 1, 2, 3} \"]},\"921\":{\"h\":\"拒绝使用 C 语言式的声明\",\"t\":[\"方括号是类型而非变量的一部分：String[] args 是合法的，String args[] 是非法的。\"]},\"922\":{\"h\":\"switch 语句\",\"t\":[\"术语说明： switch 语句块的花括号内是一个或多个 statement groups 语句组。每个语句组都包含了一个或多个 switch 标签（ case Foo: 或者 default: ），switch 标签之后跟随着一条或多条语句（或者，对于最后一个语句组，它可以包含零条或多条语句）。\"]},\"923\":{\"h\":\"缩进\",\"t\":[\"和其它任何语句块一样，switch 语句块中的内容缩进 +2 个空格。\",\"switch 标签之后会有一个换行，并增加 +2 个缩进级别，就好像是在开始一段新的代码块。之后的 switch 标签返回到上一个缩进级别，好像是结束了一段代码块。\"]},\"924\":{\"h\":\"Fall-through：需要注释\",\"t\":[\"在 switch 语句块中，每个语句组要么会突然终止（使用 break、continue、return 关键字、或者抛出异常），要么会有注释标记着以指示（程序）将或可能继续执行到下一个语句组。任何可以表达 fall-through 意思的注释都是可行的（例如典型的 // fall through ）。在最后一个语句组中，这个特殊的注释不是必须的。例如：\",\"switch (input) { case 1: case 2: prepareOneOrTwo(); // fall through case 3: handleOneTwoOrThree(); break; default: handleLargeNumber(input); } \",\"注意在 case 1: 之后不需要注释，只有在语句组之后才需要使用注释。\"]},\"925\":{\"h\":\"default 分支：需要存在\",\"t\":[\"每个 switch 语句都包含了一个 default 语句组，即使它不包含任何代码。\",\"特殊情况：如果 enum 类型的 switch 语句明确包含了覆盖所有可能性的枚举值，那么它可以省略 default 语句组。如果遗漏了任何情况，IDE 和静态分析工具可以发出警告。\"]},\"926\":{\"h\":\"注解\"},\"927\":{\"h\":\"用于类型的注解\",\"t\":[\"用于类型的注解出现在被标记的类型之前。当一个注解被元注解 @Target(ElementType.TYPE_USE) 标记时，那么它就是用于类型的注解。例如：\",\"final @Nullable String name; public @Nullable Person getPersonByName(String name); \"]},\"928\":{\"h\":\"用于类的注解\",\"t\":[\"用于类的注解出现在文档之后，并且每个注解都列在自己的一行上（即每行一个注解）。这些注解所占用的行不构成换行（请见 换行 章节），因此缩进级别不会增加。例如：\",\"@Deprecated @Override public String getNameIfPresent() { ... } \"]},\"929\":{\"h\":\"用于方法和构造方法的注解\",\"t\":[\"用于方法和构造方法的注解的使用规则与 前一章节 相同。例如：\",\"@Deprecated @Override public String getNameIfPresent() { ... } \",\"特殊情况：一个单独的没有参数的注解可以和方法签名的第一行一起出现，例如：\",\"@Override public int hashCode() { ... } \"]},\"930\":{\"h\":\"用于字段的注解\",\"t\":[\"用于字段的注解也出现在文档之后，但这种情况下，多个注解（可能会有参数）可以写在同一行上。例如：\",\"@Partial @Mock DataLoader loader; \"]},\"931\":{\"h\":\"用于参数和局部变量的注解\",\"t\":[\"用于参数和局部变量的注解没有特定的格式化规则。（当然，如果注解是用于类型的注解，则除外。）\"]},\"932\":{\"h\":\"注释\",\"t\":[\"本章节介绍 implementation comments 实现注释。Javadoc 将在 Javadoc 章节单独介绍。\",\"任何换行符之前都可以有任意数量的跟随着实现注释的空格。这样的注释使该行成为非空白的。\"]},\"933\":{\"h\":\"注释块样式\",\"t\":[\"注释块与它周围的代码拥有相同的缩进级别。注释块可以是 /* ... */ 样式或 // ... 样式。对于多行注释 /* ... */，后续的行中必须以 * 开头并且与上一行中的 * 保持对齐。\",\"/* * This is // And so /* Or you can * okay. // is this. * even do this. */ */ \",\"注释不会被包含在由星号或者其它字符绘制的框中。\",\"提示：当写多行注释的时候，如果你希望能为了在必要的时候重新包装每行代码而自动格式化（段落样式），那么应使用 /* ... */ 样式。大多数格式化程序不会重新包装 // ... 样式中的注释块。\"]},\"934\":{\"h\":\"修饰符\",\"t\":[\"类和成员如果存在修饰符的话，应以 Java 语言规范建议的顺序出现：\",\"public protected private abstract default static final transient volatile synchronized native strictfp\"]},\"935\":{\"h\":\"数字字面量\",\"t\":[\"long 数值的整数字面量会使用大写的 L 后缀，永远不要使用小写（避免与数字 1 混淆）。例如，使用 3000000000L 而不是 3000000000l。\"]},\"936\":{\"h\":\"命名\"},\"937\":{\"h\":\"适用于所有标识符的通用规则\",\"t\":[\"标识符只允许使用 ASCII 字母和数字，并且在少数情况中可以使用下划线。因此，每个有效的标识符都可以由正则表达式 \\\\w+ 匹配。\",\"在 Google 风格中，不 会使用特殊的前缀或后缀，例如，这些命名不是 Google 风格的：name_、mName、s_name 和 kName。\"]},\"938\":{\"h\":\"各种类型的标识符的规则\"},\"939\":{\"h\":\"包名\",\"t\":[\"包名只使用小写字母和数字（不使用下划线），连续的单词直接拼接在一起。例如，使用 com.example.deepspace，而不是 com.example.deepSpace 或者 com.example.deep_space。\"]},\"940\":{\"h\":\"类名\",\"t\":[\"类名以 大骆峰 方式编写。\",\"类名通常是名词或者名词短语。例如 Character 或者 ImmutableList。接口名可能也是名词或名词短语（例如 List ），但有时候也可能是形容词或形容词短语（例如 Readable ）。\",\"注解类型的命名没有特定的规则或者完善的约定。\",\"测试类的名称以 Test 结尾，例如 HashIntegrationTest。如果它覆盖了一整个类，则它的名称是该类的名称加上 Test，例如 HashImplTest。\"]},\"941\":{\"h\":\"方法名\",\"t\":[\"方法名以 小骆峰 方式编写。\",\"方法名通常是动词或者动词短语。例如 sendMessage 或者 stop。\",\"下划线可以出现在 JUnit 测试方法名中，用于分隔命名上的逻辑组件，每个组件都以 小骆峰 方式编写，例如 transferMoney_deductsFromSource。测试方法的命名没有一种唯一正确的方式。\"]},\"942\":{\"h\":\"常量名\",\"t\":[\"常量使用 UPPER_SNAKE_CASE 的格式命名：全大写，单词之间以下划线分隔。但常量究竟意味着什么？\",\"常量是 static final 修饰的字段，常量的内容是深不可变的（deeply immutable)，并且常量的方法是没有副作用的。以下示例包括了原始类型、字符串、不可变的值类型，和任何可以设置为 null 的内容。如果实例的任何外在状态是可变的，那它就不属于常量。仅仅保证实例引用的不可变属性是不够的。例如：\",\"// Constants static final int NUMBER = 5; static final ImmutableList<String> NAMES = ImmutableList.of(\\\"Ed\\\", \\\"Ann\\\"); static final Map<String, Integer> AGES = ImmutableMap.of(\\\"Ed\\\", 35, \\\"Ann\\\", 32); static final Joiner COMMA_JOINER = Joiner.on(','); // because Joiner is immutable static final SomeMutableType[] EMPTY_ARRAY = {}; // Not constants static String nonFinal = \\\"non-final\\\"; final String nonStatic = \\\"non-static\\\"; static final Set<String> mutableCollection = new HashSet<String>(); static final ImmutableSet<SomeMutableType> mutableElements = ImmutableSet.of(mutable); static final ImmutableMap<String, SomeMutableType> mutableValues = ImmutableMap.of(\\\"Ed\\\", mutableInstance, \\\"Ann\\\", mutableInstance2); static final Logger logger = Logger.getLogger(MyClass.getName()); static final String[] nonEmptyArray = {\\\"these\\\", \\\"can\\\", \\\"change\\\"}; \",\"常量名通常是名词或者名词短语。\"]},\"943\":{\"h\":\"非常量字段名\",\"t\":[\"非常量字段名（静态或者其它形式）以 小骆峰 方式编写。\",\"非常量字段名通常是名词或者名词短语。例如：computedValues 或者 index。\"]},\"944\":{\"h\":\"参数名\",\"t\":[\"参数名以 小骆峰 方式编写。\",\"public 方法中应该避免使用一个字符的参数名。\"]},\"945\":{\"h\":\"局部变量名\",\"t\":[\"局部变量名以 小骆峰 方式编写。\",\"即使是 final 和不可变的，局部变量也不被认为是常量，并且不应该以常量的风格命名。\"]},\"946\":{\"h\":\"类型变量名\",\"t\":[\"类型变量名以如下两者之一方式编写：\",\"一个大写字母，可选地跟随着一个数字（例如 E，T，X，T2 ）。\",\"以类名的方式命名（请见 类名 章节），跟随着大写字母 T（例如：RequestT，FooBarT ）。\"]},\"947\":{\"h\":\"骆驼峰形式：定义\",\"t\":[\"有时候会有多种合理的方式用于将英语短语转换为驼峰形式，例如当英语短语里出现首字母缩略词或者不寻常结构的单词（例如「iOS」和「IPv6」）时。为了提高代码的可预测性， Google 编程风格指定了以下（近乎）明确的方案。\",\"从命名的文字构成开始：\",\"将短语转换为纯 ASCII 编码，并且删除任何的撇号。例如，「Müller's algorithm」可以转换为「Muellers algorithm」。\",\"以空格和任何剩余的标点符号（通常是连字符），将短语划分为单词。 \",\"推荐：如果任何单词在普遍用法中已经具有常规的驼峰形式，那就将它分解成它的组成部分（例如，将「AdWords」变成「ad words」）。注意例如「iOS」之类的单词本身并不是驼峰形式。它违反了一些约定，因此这条规则并不适用。\",\"现在将所有内容转换为小写（包括首字母缩略词），然后只将以下内容的第一个字符转换为大写： \",\"... 每个单词，用于产生大驼峰形式，或者\",\"... 除了第一个以外的每个单词，用于产生小驼峰形式\",\"最后，将所有单词合并为一个标识符。\",\"注意，原始单词的大小写几乎完全被忽略。例如：\",\"Prose form\",\"Correct\",\"Incorrect\",\"\\\"XML HTTP request\\\"\",\"XmlHttpRequest\",\"XMLHTTPRequest\",\"\\\"new customer ID\\\"\",\"newCustomerId\",\"newCustomerID\",\"\\\"inner stopwatch\\\"\",\"innerStopwatch\",\"innerStopWatch\",\"\\\"supports IPv6 on iOS?\\\"\",\"supportsIpv6OnIos\",\"supportsIPv6OnIOS\",\"\\\"YouTube importer\\\"\",\"YouTubeImporterYoutubeImporter*\",\"* 表示可以接受，但不推荐的。\",\"注意：一些带连字符的单词在英语中含糊不清的：例如「nonempty」和「non-empty」都是正确的，所以方法名 checkNonempty 和 checkNonEmpty 也都是正确的。\"]},\"948\":{\"h\":\"编程实践\"},\"949\":{\"h\":\"@Override ：总是使用\",\"t\":[\"只要是合法的，方法总会被标记 @Override 注解。这包括了一个类的方法重写了父类的方法、一个类的方法实现了接口的方法、一个接口的方法重新定义了父接口的方法。\",\"特殊情况：当父类方法是 @Deprecated 的时候，@Override 可以省略。\"]},\"950\":{\"h\":\"捕获异常：不能忽略\",\"t\":[\"除非另有说明，对捕获的异常不做任何响应是很少正确的。（典型的响应是打印日志，或者如果打印日志是「不可能」的，就重新抛出一个作为 AssertionError 的异常。）\",\"当对 catch 语句块中的任何内容不做处理确实是合适的时候，应该在注释中说明正当的理由。\",\"try { int i = Integer.parseInt(response); return handleNumericResponse(i); } catch (NumberFormatException ok) { // it's not numeric; that's fine, just continue } return handleTextResponse(response); \",\"特殊情况：在测试代码中，如果捕获的异常名称是 expected 或者以此为开头，那么它可以不加注释地被忽略。以下是一个很常见的惯用语法，用于确认被测试的代码确实抛出了预期类型的异常，所以此处的注释是不必要的。\",\"try { emptyStack.pop(); fail(); } catch (NoSuchElementException expected) { } \"]},\"951\":{\"h\":\"静态成员：限定使用类\",\"t\":[\"当对静态类的成员的引用必须是有所限定的时候，那它是以该类的名称作为限定，而不是该类的类型的引用或者表达式。\",\"Foo aFoo = ...; Foo.aStaticMethod(); // good aFoo.aStaticMethod(); // bad somethingThatYieldsAFoo().aStaticMethod(); // very bad \"]},\"952\":{\"h\":\"Finalizers：禁用\",\"t\":[\"重写 Object.finalize 方法是 非常罕见 的。\",\"提示：禁止这么做。如果你真的需要，请先仔细阅读和理解 《Effective Java》第七章 —— 避免使用 Finalizer 和 Cleaner，然后禁止这么做。\"]},\"953\":{\"h\":\"Javadoc\"},\"954\":{\"h\":\"格式化\"},\"955\":{\"h\":\"一般形式\",\"t\":[\"Javadoc 语句块的基本格式如这个例子所示：\",\"/** * Multiple lines of Javadoc text are written here, * wrapped normally... */ public int method(String p1) { ... } \",\"... 或者如这个单行例子所示：\",\"/** An especially short bit of Javadoc. */ \",\"基本格式总是可以接受的。当整个 Javadoc 语句块（包括注释标记）可以写在一行的时候，单行格式可以被替换。注意这仅适用于没有类似于 @return 之类块标签的情况。\"]},\"956\":{\"h\":\"段落\",\"t\":[\"一个空行 -- 这意味着，仅包含用于对齐的前导星号（*）的行 -- 会出现在段落之间，和块标签组（如果有的话）之前。除了第一个以外的每个段落，在第一个单词之前有一个 <p> 标签，标签与单词之间没有空格。其它块级元素的 HTML 标签，例如 <ul> 或 <table>，不需要在前面加 <p>。\"]},\"957\":{\"h\":\"块标签\",\"t\":[\"使用到的任何标准「块标签」按以下的顺序出现 @param、@return、@throws、@deprecated，并且这四种类型的块标签不会与空的描述一起出现。当块标签不能写在一行的时候，后续的行从 @ 的位置缩进四个（或者更多）空格。\"]},\"958\":{\"h\":\"摘要片段\",\"t\":[\"每个 Javadoc 语句块以一个简短的 摘要片段 开头。这个片段非常重要：它是在某些情况下唯一可以出现的文本，例如在类和方法的索引中。\",\"这是一个片段 -- 是名词短语或者动词短语，而不是一个完整的句子。它 不 以 A {@code Foo} is a... 或者 This method returns... 开头，也不会形成例如 Save the record. 这样的祈使句。然而，这个片段是用大写字母书写的并且会有标签符号，就好像它是个完整的句子。\",\"提示：一个常见的错误是用以下形式编写简单的 Javadoc /** @return the customer ID */。这是不正确的，并且应该被修正为 /** Returns the customer ID. */。\"]},\"959\":{\"h\":\"在何处使用 Javadoc\",\"t\":[\"至少，Javadoc 应该出现在每个 public 类，和这个类的每个 public 或者 protected 成员，但除了以下提及的几个例外。\",\"额外的 Javadoc 内容也可以出现，正如在 非必需的 Javadoc 章节中所描述的。\"]},\"960\":{\"h\":\"特殊情况：自解释的成员\",\"t\":[\"对于类似 getFoo 之类的「简单、明显」的成员，Javadoc 是可选的，在这种情况下，除了「Returns the foo」也确实真的没什么值得好说了。\",\"重要：引用这个特殊情况来证明省略典型的阅读者可能需要知道的相关信息是不合适的。例如，对于名为 getCanonicalName 的方法，一个典型的阅读者可能不知道术语「canonical name」是什么意思，所以不要省略它的文档（以它只会说 /** Returns the canonical name. */ 的理由）。\"]},\"961\":{\"h\":\"特殊情况：重写\",\"t\":[\"Javadoc 不会总是出现在一个重写了父类方法的方法中。\"]},\"962\":{\"h\":\"非必需的 Javadoc\",\"t\":[\"其它的类和成员根据实际需要或者期望来编写 Javadoc。\",\"每当使用实现注释来定义一个类或者成员的总体目的或者行为的时候，这个注释改为用 Javadoc 来编写（使用 /** ）。\",\"非必需的 Javadoc 内容不是严格要求遵守 一般形式 章节、段落 章节、块标签 章节以及 摘要片段 章节的格式化规则，尽管这当然是推荐的。\"]},\"963\":{\"h\":\"统一命名规范详解\"},\"964\":{\"h\":\"静态样式检查详解\"},\"965\":{\"h\":\"统一代码格式化详解\"},\"966\":{\"h\":\"Sonarlint插件详解\"},\"967\":{\"h\":\"IDEA下单元测试详解\"},\"968\":{\"h\":\"JUnit4 详解\",\"t\":[\"JUint是Java编程语言的单元测试框架，用于编写和运行可重复的自动化测试。本文主要针对Junit4要点进行梳理总结。\"]},\"969\":{\"h\":\"什么是JUnit？\",\"t\":[\"JUint是Java编程语言的单元测试框架，用于编写和运行可重复的自动化测试。\"]},\"970\":{\"h\":\"JUnit特点？\",\"t\":[\"JUnit 是一个开放的资源框架，用于编写和运行测试。\",\"提供注解来识别测试方法。\",\"提供断言来测试预期结果。\",\"JUnit 测试允许你编写代码更快，并能提高质量。\",\"JUnit 优雅简洁。没那么复杂，花费时间较少。\",\"JUnit测试可以自动运行并且检查自身结果并提供即时反馈。所以也没有必要人工梳理测试结果的报告。\",\"JUnit测试可以被组织为测试套件，包含测试用例，甚至其他的测试套件。\",\"JUnit在一个条中显示进度。如果运行良好则是绿色；如果运行失败，则变成红色。\"]},\"971\":{\"h\":\"官方资料\",\"t\":[\"最好的资料依然在Junit官方网站，以下我帮你总结下Junit相关的官方网址。\",\"官网地址\",\"官方入门文档\",\"官方github\"]},\"972\":{\"h\":\"常用注解\",\"t\":[\"@Test\",\"在junit3中，是通过对测试类和测试方法的命名来确定是否是测试，且所有的测试类必须继承junit的测试基类。在junit4中，定义一个测试方法变得简单很多，只需要在方法前加上@Test就行了。\",\"注意：测试方法必须是public void，即公共、无返回数据。可以抛出异常。\",\"@Ignore\",\"有时候我们想暂时不运行某些测试方法\\\\测试类，可以在方法前加上这个注解。在运行结果中，junit会统计忽略的用例数，来提醒你。但是不建议经常这么做，因为这样的坏处时，容易忘记去更新这些测试方法，导致代码不够干净，用例遗漏。使用此标注的时候不能与其它标注一起使用，如：和@Test 标注一起使用，那就没用了\",\"@BeforeClass\",\"当我们运行几个有关联的用例时，可能会在数据准备或其它前期准备中执行一些相同的命令，这个时候为了让代码更清晰，更少冗余，可以将公用的部分提取出来，放在一个方法里，并为这个方法注解@BeforeClass。意思是在测试类里所有用例运行之前，运行一次这个方法。例如创建数据库连接、读取文件等。\",\"注意：方法名可以任意，但必须是public static void，即公开、静态、无返回。这个方法只会运行一次。\",\"@AfterClass\",\"跟@BeforeClass对应，在测试类里所有用例运行之后，运行一次。用于处理一些测试后续工作，例如清理数据，恢复现场。\",\"注意：同样必须是public static void，即公开、静态、无返回。这个方法只会运行一次。\",\"@Before\",\"与@BeforeClass的区别在于，@Before不止运行一次，它会在每个用例运行之前都运行一次。主要用于一些独立于用例之间的准备工作。\",\"比如两个用例都需要读取数据库里的用户A信息，但第一个用例会删除这个用户A，而第二个用例需要修改用户A。那么可以用@BeforeClass创建数据库连接。用@Before来插入一条用户A信息。\",\"注意：必须是public void，不能为static。不止运行一次，根据用例数而定。\",\"@After：与@Before对应。\",\"@Runwith\",\"首先要分清几个概念：测试方法、测试类、测试集、测试运行器。\",\"其中测试方法就是用@Test注解的一些函数。\",\"测试类是包含一个或多个测试方法的一个Test.java文件。\",\"测试集是一个suite，可能包含多个测试类。\",\"测试运行器则决定了用什么方式偏好去运行这些测试集/类/方法。\",\"而@Runwith就是放在测试类名之前，用来确定这个类怎么运行的。也可以不标注，会使用默认运行器。常见的运行器有： \",\"@RunWith(Parameterized.class) 参数化运行器，配合@Parameters使用junit的参数化功能\",\"@RunWith(Suite.class) @SuiteClasses({ATest.class,BTest.class,CTest.class})测试集运行器配合使用测试集功能\",\"@RunWith(JUnit4.class) junit4的默认运行器\",\"@RunWith(JUnit38ClassRunner.class) 用于兼容junit3.8的运行器\",\"一些其它运行器具备更多功能。例如@RunWith(SpringJUnit4ClassRunner.class)集成了spring的一些功能\",\"@Parameters： 用于使用参数化功能。\"]},\"973\":{\"h\":\"编写单元测试\",\"t\":[\"接下来，我们开始学习JUnit4单元测试实例:\"]},\"974\":{\"h\":\"Maven包引入\",\"t\":[\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>org.example</groupId> <artifactId>java-junit4</artifactId> <version>1.0-SNAPSHOT</version> <build> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <configuration> <source>8</source> <target>8</target> </configuration> </plugin> </plugins> </build> <dependencies> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.12</version> <scope>test</scope> </dependency> </dependencies> </project> \"]},\"975\":{\"h\":\"测试:Hello World\",\"t\":[\"package tech.pdai.junit4; import org.junit.Test; import static org.junit.Assert.assertEquals; /** * Hello world test. * * @author pdai */ public class HelloWorldTest { @Test public void firstTest() { assertEquals(2, 1 + 1); } } \",\"执行结果 @Test注解在方法上标记方法为测试方法，以便构建工具和 IDE 能够识别并执行它们。JUnit 4 需要测试方法为public，这和Junit 5 有差别。\"]},\"976\":{\"h\":\"测试:生命周期\",\"t\":[\"@BeforeClass注解修饰的方法(该方法要用static修饰)会在所有方法运行前被执行，且只执行一次，通常用来为后面测试方法的准备工作，如加载配置、进行数据库的连接等。父类的@BeforeClass注解方法会在子类的@BeforeClass注解方法执行前执行。\",\"@Before注解修饰的方法会在每个测试方法执行前执行一次,父类@Before修饰的方法会在子类@Before修饰的方法执行前 执行\",\"@After注解修饰的方法会在每个测试方法执行后执行一次,父类@After修饰的方法会在子类@After修饰的方法执行后执行。\",\"@AfterClass注解修饰的方法(该方法要用static修饰)会在所有方法执行结束后执行一次，且也只执行一次，通常用来对资源进行释放，比如数据库连接的关闭等，无论测试用例里的其他方法有没有抛出异常，该方法最终都会被执行。而且父类中的被@AfterClass注解方法修饰的方法会在子类的@AfterClass注解修饰的方法执行之后才会被执行。\",\"package tech.pdai.junit4; import org.junit.*; /** * Standard Test. */ public class StandardTest { @BeforeClass public static void beforeClass() { System.out.println(\\\"in before class\\\"); } @AfterClass public static void afterClass() { System.out.println(\\\"in after class\\\"); } @Before public void before() { System.out.println(\\\"in before\\\"); } @After public void after() { System.out.println(\\\"in after\\\"); } @Test public void testCase1() { System.out.println(\\\"in test case 1\\\"); } @Test public void testCase2() { System.out.println(\\\"in test case 2\\\"); } } \",\"执行结果\"]},\"977\":{\"h\":\"测试:禁用测试\",\"t\":[\"@Ignore：暂不执行该方法；\",\"package tech.pdai.junit4; import org.junit.Ignore; import org.junit.Test; /** * Ignore Test. */ public class IgnoreTest { /** * ignore. */ @Ignore @Test public void ignoreTest(){ System.out.println(\\\"ignore test\\\"); } } \",\"执行结果\"]},\"978\":{\"h\":\"测试:断言测试\",\"t\":[\"断言测试注解有哪些\",\"断言\",\"描述\",\"void assertEquals([String message],expected value,actual value)\",\"断言两个值相等。值类型可能是int，short，long，byte，char，Object，第一个参数是一个可选字符串消息\",\"void assertTrue([String message],boolean condition)\",\"断言一个条件为真\",\"void assertFalse([String message],boolean condition)\",\"断言一个条件为假\",\"void assertNotNull([String message],java.lang.Object object)\",\"断言一个对象不为空（null）\",\"void assertNull([String message],java.lang.Object object)\",\"断言一个对象为空（null）\",\"void assertSame([String message],java.lang.Object expected,java.lang.Object actual)\",\"断言两个对象引用相同的对象\",\"void assertNotSame([String message],java.lang.Object unexpected,java.lang.Object actual)\",\"断言两个对象不是引用同一个对象\",\"void assertArrayEquals([String message],expectedArray,resultArray)\",\"断言预期数组和结果数组相等，数组类型可能是int，short，long，byte，char，Object\",\"简单测试\",\"package tech.pdai.junit4; import org.junit.Assert; import org.junit.Test; /** * Assertion Test. */ public class AssertionTest { @Test public void test() { String obj1 = \\\"junit\\\"; String obj2 = \\\"junit\\\"; String obj3 = \\\"test\\\"; String obj4 = \\\"test\\\"; String obj5 = null; int var1 = 1; int var2 = 2; int[] array1 = {1, 2, 3}; int[] array2 = {1, 2, 3}; Assert.assertEquals(obj1, obj2); Assert.assertSame(obj3, obj4); Assert.assertNotSame(obj2, obj4); Assert.assertNotNull(obj1); Assert.assertNull(obj5); Assert.assertTrue(var1 < var2); Assert.assertFalse(var1 > var2); Assert.assertArrayEquals(array1, array2); } } \",\"在以上类中我们可以看到，这些断言方法是可以工作的。\",\"assertEquals() 如果比较的两个对象是相等的，此方法将正常返回；否则失败显示在JUnit的窗口测试将中止。\",\"assertSame() 和 assertNotSame() 方法测试两个对象引用指向完全相同的对象。\",\"assertNull() 和 assertNotNull() 方法测试一个变量是否为空或不为空(null)。\",\"assertTrue() 和 assertFalse() 方法测试if条件或变量是true还是false。\",\"assertArrayEquals() 将比较两个数组，如果它们相等，则该方法将继续进行不会发出错误。否则失败将显示在JUnit窗口和中止测试。\",\"更多测试，来自官网https://github.com/junit-team/junit4/wiki/Assertions\",\"package tech.pdai.junit4; import org.hamcrest.core.CombinableMatcher; import org.junit.Test; import java.util.Arrays; import static org.hamcrest.CoreMatchers.*; import static org.junit.Assert.*; /** * More Assertion Test from Junit-Team. */ public class Assertion2Test { @Test public void testAssertArrayEquals() { byte[] expected = \\\"trial\\\".getBytes(); byte[] actual = \\\"trial\\\".getBytes(); assertArrayEquals(\\\"failure - byte arrays not same\\\", expected, actual); } @Test public void testAssertEquals() { assertEquals(\\\"failure - strings are not equal\\\", \\\"text\\\", \\\"text\\\"); } @Test public void testAssertFalse() { assertFalse(\\\"failure - should be false\\\", false); } @Test public void testAssertNotNull() { assertNotNull(\\\"should not be null\\\", new Object()); } @Test public void testAssertNotSame() { assertNotSame(\\\"should not be same Object\\\", new Object(), new Object()); } @Test public void testAssertNull() { assertNull(\\\"should be null\\\", null); } @Test public void testAssertSame() { Integer aNumber = Integer.valueOf(768); assertSame(\\\"should be same\\\", aNumber, aNumber); } // JUnit Matchers assertThat @Test public void testAssertThatBothContainsString() { assertThat(\\\"albumen\\\", both(containsString(\\\"a\\\")).and(containsString(\\\"b\\\"))); } @Test public void testAssertThatHasItems() { assertThat(Arrays.asList(\\\"one\\\", \\\"two\\\", \\\"three\\\"), hasItems(\\\"one\\\", \\\"three\\\")); } @Test public void testAssertThatEveryItemContainsString() { assertThat(Arrays.asList(new String[]{\\\"fun\\\", \\\"ban\\\", \\\"net\\\"}), everyItem(containsString(\\\"n\\\"))); } // Core Hamcrest Matchers with assertThat @Test public void testAssertThatHamcrestCoreMatchers() { assertThat(\\\"good\\\", allOf(equalTo(\\\"good\\\"), startsWith(\\\"good\\\"))); assertThat(\\\"good\\\", not(allOf(equalTo(\\\"bad\\\"), equalTo(\\\"good\\\")))); assertThat(\\\"good\\\", anyOf(equalTo(\\\"bad\\\"), equalTo(\\\"good\\\"))); assertThat(7, not(CombinableMatcher.<Integer>either(equalTo(3)).or(equalTo(4)))); assertThat(new Object(), not(sameInstance(new Object()))); } @Test public void testAssertTrue() { assertTrue(\\\"failure - should be true\\\", true); } } \",\"执行结果\"]},\"979\":{\"h\":\"测试:异常测试\",\"t\":[\"Junit 用代码处理提供了一个追踪异常的选项。你可以测试代码是否它抛出了想要得到的异常。expected 参数和 @Test 注释一起使用。现在让我们看看 @Test(expected):\",\"package tech.pdai.junit4; import org.junit.Test; /** * Exception Test. */ public class ExceptionTest { @Test(expected = ArithmeticException.class) public void exceptionTest() { System.out.println(\\\"in exception success test\\\"); int a = 0; int b = 1 / a; } @Test(expected = NullPointerException.class) public void exceptionFailTest() { System.out.println(\\\"in exception fail test\\\"); int a = 0; int b = 1 / a; } } \",\"执行结果 观察错误的信息：\",\"in exception success test in exception fail test java.lang.Exception: Unexpected exception, expected<java.lang.NullPointerException> but was<java.lang.ArithmeticException> at org.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:28) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230) at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58) Caused by: java.lang.ArithmeticException: / by zero at tech.pdai.junit4.ExceptionTest.exceptionFailTest(ExceptionTest.java:21) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:19) ... 14 more \"]},\"980\":{\"h\":\"测试:时间测试\",\"t\":[\"JUnit提供了一个暂停的方便选项，如果一个测试用例比起指定的毫秒数花费了更多的时间，那么JUnit将自动将它标记为失败，timeout参数和@Test注解一起使用，例如@Test(timeout=1000)。\",\"简单例子\",\"package tech.pdai.junit4; import org.junit.Test; import java.util.concurrent.TimeUnit; /** * Timeout Test. */ public class TimeoutTest { @Test(timeout = 1000) public void testCase1() throws InterruptedException { TimeUnit.SECONDS.sleep(5000); System.out.println(\\\"in timeout exception\\\"); } } \",\"执行结果 观察错误的信息：\",\"org.junit.runners.model.TestTimedOutException: test timed out after 1000 milliseconds at java.lang.Thread.sleep(Native Method) at java.lang.Thread.sleep(Thread.java:340) at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386) at tech.pdai.junit4.TimeoutTest.testCase1(TimeoutTest.java:14) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:298) at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:292) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.lang.Thread.run(Thread.java:748) \",\"超时规则\",\"应用到测试类的所有测试用例\",\"package tech.pdai.junit4; import org.junit.Rule; import org.junit.Test; import org.junit.rules.Timeout; import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit; /** * Timeout Rule. */ public class HasGlobalTimeoutTest { public static String log; private final CountDownLatch latch = new CountDownLatch(1); @Rule public Timeout globalTimeout = Timeout.seconds(10); // 10 seconds max per method tested @Test public void testSleepForTooLong() throws Exception { log += \\\"ran1\\\"; TimeUnit.SECONDS.sleep(100); // sleep for 100 seconds } @Test public void testBlockForever() throws Exception { log += \\\"ran2\\\"; latch.await(); // will block } } \",\"执行结果\"]},\"981\":{\"h\":\"测试:参数化测试\",\"t\":[\"Junit 4 引入了一个新的功能参数化测试。参数化测试允许开发人员使用不同的值反复运行同 一个测试。你将遵循 5 个步骤来创建参数化测试：\",\"为准备使用参数化测试的测试类指定特殊的运行器 org.junit.runners.Parameterized。\",\"为测试类声明几个变量，分别用于存放期望值和测试所用数据。\",\"为测试类声明一个带有参数的公共构造函数，并在其中为第二个环节中声明的几个变量赋值。\",\"为测试类声明一个使用注解 org.junit.runners.Parameterized.Parameters 修饰的，返回值为 java.util.Collection 的公共静态方法，并在此方法中初始化所有需要测试的参数对。\",\"编写测试方法，使用定义的变量作为参数进行测试。\",\"什么是@RunWith?\",\"首先要分清几个概念：测试方法、测试类、测试集、测试运行器。\",\"其中测试方法就是用@Test注解的一些函数。\",\"测试类是包含一个或多个测试方法的一个**Test.java文件，\",\"测试集是一个suite，可能包含多个测试类。\",\"测试运行器则决定了用什么方式偏好去运行这些测试集/类/方法。\",\"而@Runwith就是放在测试类名之前，用来确定这个类怎么运行的。也可以不标注，会使用默认运行器。常见的运行器有：\",\"@RunWith(Parameterized.class) 参数化运行器，配合@Parameters使用JUnit的参数化功能\",\"@RunWith(Suite.class) @SuiteClasses({ATest.class,BTest.class,CTest.class}) 测试集运行器配合使用测试集功能\",\"@RunWith(JUnit4.class)， junit4的默认运行器\",\"@RunWith(JUnit38ClassRunner.class)，用于兼容junit3.8的运行器 一些其它运行器具备更多功能。例如@RunWith(SpringJUnit4ClassRunner.class)集成了spring的一些功能\",\"测试例子\",\"待测试类\",\"package tech.pdai.junit4; /** * PrimeNumberChecker. */ public class PrimeNumberChecker { public Boolean validate(final Integer parimeNumber) { for (int i = 2; i < (parimeNumber / 2); i++) { if (parimeNumber % i == 0) { return false; } } return true; } } \",\"测试类\",\"package tech.pdai.junit4; import org.junit.Assert; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import java.util.Arrays; import java.util.Collection; /** * Parameterized Test. */ @RunWith(Parameterized.class) // 步骤一: 指定定参数运行器 public class PrimeNumberCheckerTest { /** * 步骤二：声明变量 */ private Integer inputNumber; private Boolean expectedResult; private PrimeNumberChecker primeNumberChecker; /** * 步骤三：为测试类声明一个带有参数的公共构造函数，为变量赋值 */ public PrimeNumberCheckerTest(Integer inputNumber, Boolean expectedResult) { this.inputNumber = inputNumber; this.expectedResult = expectedResult; } /** * 步骤四：为测试类声明一个使用注解 org.junit.runners.Parameterized.Parameters 修饰的，返回值为 * java.util.Collection 的公共静态方法，并在此方法中初始化所有需要测试的参数对 * 1）该方法必须由Parameters注解修饰 * 2）该方法必须为public static的 * 3）该方法必须返回Collection类型 * 4）该方法的名字不做要求 * 5）该方法没有参数 */ @Parameterized.Parameters public static Collection primeNumbers() { return Arrays.asList(new Object[][]{ {2, true}, {6, false}, {19, true}, {22, false}, {23, true} }); } @Before public void initialize() { primeNumberChecker = new PrimeNumberChecker(); } /** * 步骤五：编写测试方法，使用自定义变量进行测试 */ @Test public void testPrimeNumberChecker() { System.out.println(\\\"Parameterized Number is : \\\" + inputNumber); Assert.assertEquals(expectedResult, primeNumberChecker.validate(inputNumber)); } } \",\"执行结果\"]},\"982\":{\"h\":\"测试:套件测试\",\"t\":[\"“套件测试”是指捆绑了几个单元测试用例并运行起来。在JUnit中，@RunWith 和 @Suite 这两个注解是用来运行套件测试。先来创建几个测试类 测试类1\",\"package tech.pdai.junit4.testsuite; import org.junit.Test; public class JunitTest1 { @Test public void printMessage(){ System.out.println(\\\"in JunitTest1\\\"); } } \",\"测试类2\",\"package tech.pdai.junit4.testsuite; import org.junit.Test; public class JunitTest2 { @Test public void printMessage(){ System.out.println(\\\"in JunitTest2\\\"); } } \",\"测试套件\",\"package tech.pdai.junit4.testsuite; import org.junit.runner.RunWith; import org.junit.runners.Suite; /** * Test suite. */ @RunWith(Suite.class) @Suite.SuiteClasses({ /** * 此处类的配置顺序会影响执行顺序 */ JunitTest1.class, JunitTest2.class }) public class JunitSuiteTest { } \",\"执行结果\"]},\"983\":{\"h\":\"测试:测试顺序\",\"t\":[\"自定义测试方法的顺序，比如按照方法的名字顺序：\",\"package tech.pdai.junit4; import org.junit.FixMethodOrder; import org.junit.Test; import org.junit.runners.MethodSorters; /** * Order. */ @FixMethodOrder(MethodSorters.NAME_ASCENDING) public class TestMethodOrder { @Test public void testA() { System.out.println(\\\"first\\\"); } @Test public void testC() { System.out.println(\\\"third\\\"); } @Test public void testB() { System.out.println(\\\"second\\\"); } } \",\"执行结果\"]},\"984\":{\"h\":\"参考文章\",\"t\":[\"https://github.com/junit-team/junit4/wiki\",\"https://blog.csdn.net/qq_34264849/article/details/88243278\",\"https://www.cnblogs.com/jingjiren/p/10339039.html\",\"https://blog.csdn.net/weixin_44425934/\"]},\"985\":{\"h\":\"Junit5 详解\"},\"986\":{\"h\":\"Mockito 详解\"},\"987\":{\"h\":\"SpringBoot2+H2+Mockito实战\"},\"988\":{\"h\":\"浅谈单元测试\",\"t\":[\"单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。这是基础，所以围绕着单元测试，我从网上搜集和总结了相关的概念，以助你完善体系。\"]},\"989\":{\"h\":\"什么是单元测试？\",\"t\":[\"来自百度百科。\",\"单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。\"]},\"990\":{\"h\":\"为什么要写单元测试？\",\"t\":[\"使用单元测试可以有效地降低程序出错的机率，提供准确的文档，并帮助我们改进设计方案等等。\",\"以下列举了一些我为什么使用单元测试的好处：\",\"允许你对代码做出任何改变，因为你了解单元测试会在你的预期之中。\",\"单元测试可以有效地降低程序出现BUG的机率；\",\"帮助你更深入地理解代码--因为在写单元测试的时候，你需要明确程序所有的执行流程及对应的执行结果等等;\",\"允许在任何时候代码重构，而不必担心破坏现有的代码。这使得我们编写程序更灵活;\",\"确保你的代码的健壮性，因为所有的测试都是通过了的。\",\"文档记录。单元测试就是一种无价的文档，它是展示函数或类如何使用的最佳文档，这份文档是可编译、可运行的、并且它保持最新，永远与代码同步。\",\"具有回归性。自动化的单元测试避免了代码出现回归，编写完成之后，可以随时随地地快速运行测试，而不是将代码部署到设备之后，然后再手动地覆盖各种执行路径，这样的行为效率低下，浪费时间。\"]},\"991\":{\"h\":\"什么时候写单元测试？\",\"t\":[\"写单元测试的时机不外乎三种情况：\",\"一是在具体实现代码之前，这是测试驱动开发（TDD）所提倡的；\",\"二是与具体实现代码同步进行。先写少量功能代码，紧接着写单元测试（重复这两个过程，直到完成功能代码开发）。其实这种方案跟第一种已经很接近，基本上功能代码开发完，单元测试也差不多完成了。\",\"三是编写完功能代码再写单元测试。我的实践经验告诉我，事后编写的单元测试“粒度”都比较粗。对同样的功能代码，采取前两种方案的结果可能是用10个“小”的单测来覆盖，每个单测比较简单易懂，可读性可维护性都比较好（重构时单测的改动不大）；而第三种方案写的单测，往往是用1个“大”的单测来覆盖，这个单测逻辑就比较复杂，因为它要测的东西很多，可读性可维护性就比较差。\",\"建议：我个人是比较推荐单元测试与具体实现代码同步进行这个方案的。只有对需求有一定的理解后才能知道什么是代码的正确性，才能写出有效的单元测试来验证正确性，而能写出一些功能代码则说明对需求有一定理解了。\"]},\"992\":{\"h\":\"单元测试要写多细？\",\"t\":[\"单元测试不是越多越好，而是越有效越好！进一步解读就是哪些代码需要有单元测试覆盖：\",\"逻辑复杂的\",\"容易出错的\",\"不易理解的，即使是自己过段时间也会遗忘的，看不懂自己的代码，单元测试代码有助于理解代码的功能和需求\",\"公共代码。比如自定义的所有http请求都会经过的拦截器；工具类等。\",\"核心业务代码。一个产品里最核心最有业务价值的代码应该要有较高的单元测试覆盖率。\"]},\"993\":{\"h\":\"有哪些单元测试相关的概念？\",\"t\":[\"这里节选自https://segmentfault.com/a/1190000006731125，作者yongshun 采用署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议.\"]},\"994\":{\"h\":\"被测系统\",\"t\":[\"被测系统(System under test, SUT)表示正在被测试的系统, 目的是测试系统能否正确操作. 根据测试类型的不同, SUT 指代的内容也不同, 例如 SUT 可以是一个类甚至是一整个系统.\"]},\"995\":{\"h\":\"测试依赖组件(DOC)\",\"t\":[\"被测系统所依赖的组件, 例如进程 UserService 的单元测试时, UserService 会依赖 UserDao, 因此 UserDao 就是 DOC.\"]},\"996\":{\"h\":\"测试替身(Test Double)\",\"t\":[\"一个实际的系统会依赖多个外部对象, 但是在进行单元测试时, 我们会用一些功能较为简单的并且其行为和实际对象类似的假对象来作为 SUT 的依赖对象, 以此来降低单元测试的复杂性和可实现性. 在这里, 这些假对象就被称为 测试替身(Test Double). 测试替身有如下 5 种类型:\",\"Test stub\",\"为 SUT 提供数据的假对象，我们举一个例子来展示什么是 Test stub.\",\"假设我们的一个模块需要从 HTTP 接口中获取商品价格数据, 这个获取数据的接口被封装为 getPrice 方法. 在对这个模块进行测试时, 我们显然不太可能专门开一个 HTTP 服务器来提供此接口, 而是提供一个带有 getPrice 方法的假对象, 从这个假对象中获取数据. 在这个例子中, 提供数据的假对象就叫做 Test stub.\",\"Fake object\",\"实现了简单功能的一个假对象. Fake object 和 Test stub 的主要区别就是 Test stub 侧重于用于提供数据的假对象, 而 Fake object 没有这层含义.\",\"使用 Fake object 的最主要的原因就是在测试时某些组件不可用或运行速度太慢, 因而使用 Fake object 来代替它们.\",\"Mock object\",\"用于模拟实际的对象, 并且能够校验对这个 Mock object 的方法调用是否符合预期.\",\"实际上, Mock object 是 Test stub 或 Fake object 一种, 但是 Mock object 有 Test stub/Fake object 没有的特性, Mock object 可以很灵活地配置所调用的方法所产生的行为, 并且它可以追踪方法调用, 例如一个 Mock Object 方法调用时传递了哪些参数, 方法调用了几次等.\",\"Dummy object\",\"在测试中并不使用的, 但是为了测试代码能够正常编译/运行而添加的对象. 例如我们调用一个 Test Double 对象的一个方法, 这个方法需要传递几个参数, 但是其中某个参数无论是什么值都不会影响测试的结果, 那么这个参数就是一个 Dummy object. Dummy object 可以是一个空引用, 一个空对象或者是一个常量等.\",\"简单的说, Dummy object 就是那些没有使用到的, 仅仅是为了填充参数列表的对象.\",\"Test Spy\",\"可以包装一个真实的 Java 对象, 并返回一个包装后的新对象. 若没有特别配置的话, 对这个新对象的所有方法调用, 都会委派给实际的 Java 对象.\",\"mock 和 spy 的区别是: mock 是无中生有地生出一个完全虚拟的对象, 它的所有方法都是虚拟的; 而 spy 是在现有类的基础上包装了一个对象, 即如果我们没有重写 spy 的方法, 那么这些方法的实现其实都是调用的被包装的对象的方法.\"]},\"997\":{\"h\":\"Test fixture\",\"t\":[\"所谓 test fixture, 就是运行测试程序所需要的先决条件(precondition). 即对被测对象进行测试时锁需要的一切东西(The test fixture is everything we need to have in place to exercise the SUT). 这个 东西 不单单指的是数据, 同时包括对被测对象的配置, 被测对象所需要的依赖对象等. JUnit4 之前是通过 setUp, TearDown 方法完成, 在 JUnit4这, 我们可以使用@Before 代替 setUp 方法, @After 代替 tearDown 方法.\",\"注意, @Before 在每个测试方法运行前都会被调用, @After 在每个测试方法运行后都会被调用.\",\"因为 @Before 和 @After 会在每个测试方法前后都会被调用, 而有时我们仅仅需要在测试前进行一次初始化, 这样的情况下, 可以使用@BeforeClass 和@AfterClass 注解.\"]},\"998\":{\"h\":\"测试用例(Test case)\",\"t\":[\"在 JUnit 3中, 测试方法都必须以 test 为前缀, 且必须是 public void 的, JUnit 4之后, 就没有这个限制了, 只要在每个测试方法标注 @Test 注解, 方法签名可以是任意的.\"]},\"999\":{\"h\":\"测试套件\",\"t\":[\"通过 TestSuit 对象将多个测试用例组装成一个测试套件, 测试套件批量运行.通过@RunWith 和@SuteClass 两个注解, 我们可以创建一个测试套件. 通过@RunWith 指定一个特殊的运行器, 几 Suite.class 套件运行器, 并通过@SuiteClasses 注解, 将需要进行测试的类列表作作为参数传入.\"]},\"1000\":{\"h\":\"参考文章\",\"t\":[\"https://coolshell.cn/articles/8209.html\",\"https://segmentfault.com/a/1190000006731125\",\"https://blog.csdn.net/flysqrlboy/article/details/79301241\"]},\"1001\":{\"h\":\"\",\"t\":[\"docker\"]},\"1002\":{\"h\":\"Me\"},\"1003\":{\"h\":\"Basic\"},\"1004\":{\"h\":\"Java\"},\"1005\":{\"h\":\"Collection\"},\"1006\":{\"h\":\"Io\"},\"1007\":{\"h\":\"Javaup\"},\"1008\":{\"h\":\"Jvm\"},\"1009\":{\"h\":\"Others\"},\"1010\":{\"h\":\"Spring\"},\"1011\":{\"h\":\"Thread\"},\"1012\":{\"h\":\"Algorithms Structures\"},\"1013\":{\"h\":\"Develop\"},\"1014\":{\"h\":\"Design\"},\"1015\":{\"h\":\"Quality Assurance\"},\"1016\":{\"h\":\"Docker\"}},\"dirtCount\":0,\"index\":[[\"套件运行器\",{\"1\":{\"999\":1}}],[\"套件测试\",{\"0\":{\"982\":1},\"1\":{\"982\":1}}],[\"几\",{\"1\":{\"999\":1}}],[\"几种常见的代理模式介绍\",{\"0\":{\"704\":1}}],[\"东西\",{\"1\":{\"997\":1}}],[\"侧重于用于提供数据的假对象\",{\"1\":{\"996\":1}}],[\"侧边栏\",{\"1\":{\"6\":1,\"34\":1}}],[\"粒度\",{\"1\":{\"991\":1}}],[\"粒度越小\",{\"1\":{\"737\":1}}],[\"断言预期数组和结果数组相等\",{\"1\":{\"978\":1}}],[\"断言两个对象不是引用同一个对象\",{\"1\":{\"978\":1}}],[\"断言两个对象引用相同的对象\",{\"1\":{\"978\":1}}],[\"断言两个值相等\",{\"1\":{\"978\":1}}],[\"断言一个对象为空\",{\"1\":{\"978\":1}}],[\"断言一个对象不为空\",{\"1\":{\"978\":1}}],[\"断言一个条件为假\",{\"1\":{\"978\":1}}],[\"断言一个条件为真\",{\"1\":{\"978\":1}}],[\"断言\",{\"1\":{\"978\":1}}],[\"断言测试注解有哪些\",{\"1\":{\"978\":1}}],[\"断言测试\",{\"0\":{\"978\":1}}],[\"断电\",{\"1\":{\"197\":1}}],[\"暂不执行该方法\",{\"1\":{\"977\":1}}],[\"额外的\",{\"1\":{\"959\":1}}],[\"摘要片段\",{\"0\":{\"958\":1},\"1\":{\"958\":1,\"962\":1}}],[\"限定使用类\",{\"0\":{\"951\":1}}],[\"近乎\",{\"1\":{\"947\":1}}],[\"骆驼峰形式\",{\"0\":{\"947\":1}}],[\"匹配\",{\"1\":{\"937\":1}}],[\"匹配到一个方法\",{\"1\":{\"311\":1}}],[\"混淆\",{\"1\":{\"935\":1}}],[\"混乱\",{\"1\":{\"817\":1}}],[\"拒绝使用\",{\"0\":{\"921\":1}}],[\"习惯性地声明在它们所属的代码块或者块状结构的起始位置\",{\"1\":{\"918\":1}}],[\"习惯上\",{\"1\":{\"254\":1}}],[\"垂直空格\",{\"0\":{\"910\":1}}],[\"逗号\",{\"1\":{\"907\":1}}],[\"逗号后才是换行处\",{\"1\":{\"847\":1}}],[\"倾向于在\",{\"1\":{\"907\":1}}],[\"码位都算作一个字符\",{\"1\":{\"905\":1}}],[\"码位\",{\"1\":{\"905\":1}}],[\"码出高效\",{\"1\":{\"843\":2,\"848\":1}}],[\"码出质量\",{\"1\":{\"843\":2}}],[\"μs\",{\"1\":{\"885\":2}}],[\"∞\",{\"1\":{\"885\":1}}],[\"顶级类的类名和\",{\"1\":{\"880\":1}}],[\"顶级类型将返回null\",{\"1\":{\"298\":1}}],[\"者构造方法\",{\"1\":{\"877\":1}}],[\"嵌套类\",{\"1\":{\"877\":1}}],[\"嵌入其中web里面的html代码会被执行\",{\"1\":{\"861\":1}}],[\"术语说明\",{\"0\":{\"877\":1},\"1\":{\"898\":1,\"906\":1,\"912\":1,\"922\":1}}],[\"风格的\",{\"1\":{\"937\":1}}],[\"风格中\",{\"1\":{\"937\":1}}],[\"风格\",{\"0\":{\"901\":1},\"1\":{\"876\":1,\"878\":1,\"901\":1,\"902\":1,\"903\":1}}],[\"风扇\",{\"1\":{\"562\":1}}],[\"蚂蚁森林浇水数或每天抽奖数\",{\"1\":{\"874\":1}}],[\"账户余额不足\",{\"1\":{\"874\":1}}],[\"账号被冻结\",{\"1\":{\"874\":1}}],[\"金额超出限制\",{\"1\":{\"874\":1}}],[\"金卡用户\",{\"1\":{\"546\":1}}],[\"缺少时间戳参数\",{\"1\":{\"874\":1}}],[\"缺点是违反了设计模式的\",{\"1\":{\"738\":1}}],[\"缺点是依赖性太强\",{\"1\":{\"609\":1}}],[\"缺点\",{\"1\":{\"610\":1,\"690\":1,\"696\":1,\"752\":1}}],[\"签名错误\",{\"1\":{\"874\":1}}],[\"邮箱格式校验失败\",{\"1\":{\"874\":1}}],[\"邮件提醒服务失败\",{\"1\":{\"874\":1}}],[\"邮件校验码输入错误\",{\"1\":{\"874\":1}}],[\"邮件消息\",{\"1\":{\"546\":1}}],[\"邮件\",{\"1\":{\"432\":1,\"861\":1}}],[\"地域黑名单\",{\"1\":{\"874\":1}}],[\"地址不在服务范围\",{\"1\":{\"874\":1}}],[\"地址\",{\"1\":{\"874\":1}}],[\"地址格式校验失败\",{\"1\":{\"874\":1}}],[\"地球每天的自转是有些不规则的\",{\"1\":{\"873\":1}}],[\"军官证编号校验非法\",{\"1\":{\"874\":1}}],[\"护照编号校验非法\",{\"1\":{\"874\":1}}],[\"短信提醒服务失败\",{\"1\":{\"874\":1}}],[\"短信校验码输入错误\",{\"1\":{\"874\":1}}],[\"短信等等\",{\"1\":{\"727\":1}}],[\"校验码输入错误\",{\"1\":{\"874\":1}}],[\"校验逻辑容易出现漏洞\",{\"1\":{\"851\":1}}],[\"魔法值的示例代码\",{\"1\":{\"872\":1}}],[\"魔鬼细节\",{\"1\":{\"809\":1}}],[\"黄山版\",{\"1\":{\"872\":1}}],[\"黄豆和配料放到豆浆机去打碎\",{\"1\":{\"803\":1}}],[\"黄豆和配料开始浸泡\",{\"1\":{\"803\":1}}],[\"嵩山版\",{\"1\":{\"872\":1}}],[\"闰月问题\",{\"1\":{\"872\":1}}],[\"闰年的\",{\"1\":{\"849\":1}}],[\"阻塞等待锁\",{\"1\":{\"872\":1}}],[\"阻碍同事阅读你代码的有力武器之一\",{\"1\":{\"91\":1}}],[\"泰山版\",{\"1\":{\"872\":1}}],[\"泰国插座用的是两孔的\",{\"1\":{\"521\":1}}],[\"卫语句示例\",{\"1\":{\"872\":1}}],[\"处中断一行代码\",{\"1\":{\"907\":1}}],[\"处\",{\"1\":{\"872\":4}}],[\"处理器不做任何操作\",{\"1\":{\"873\":1}}],[\"处理不当容易造成系统压力或数据异常\",{\"1\":{\"851\":1}}],[\"处理图片\",{\"1\":{\"809\":2}}],[\"处理请求\",{\"1\":{\"776\":1}}],[\"处理请求的方法\",{\"1\":{\"708\":1}}],[\"处理请求的流程回顾\",{\"1\":{\"533\":1}}],[\"处理人构成环形\",{\"1\":{\"710\":1}}],[\"处理\",{\"1\":{\"710\":4,\"718\":1}}],[\"处理是子类完成\",{\"1\":{\"710\":1}}],[\"处理审批请求的方法\",{\"1\":{\"710\":1}}],[\"处理程序根据异常的类型决定自己是否处理该异常\",{\"1\":{\"707\":1}}],[\"处理闹钟发出的消息\",{\"1\":{\"659\":1}}],[\"处理相加\",{\"1\":{\"644\":1}}],[\"处理对象持久化的api\",{\"1\":{\"420\":1}}],[\"处理类似分词等常见任务的工具\",{\"1\":{\"418\":1}}],[\"处理opendocument格式\",{\"1\":{\"402\":1}}],[\"处理office文档的开发库\",{\"1\":{\"402\":1}}],[\"处理时间和日期的开发库\",{\"1\":{\"396\":1}}],[\"处理异常的小例子\",{\"1\":{\"275\":1}}],[\"处理设置注解上的参数\",{\"1\":{\"242\":1}}],[\"处理完请求后执行\",{\"1\":{\"242\":1}}],[\"鉴于手册是\",{\"1\":{\"872\":1}}],[\"纪念版\",{\"1\":{\"872\":1}}],[\"排版\",{\"1\":{\"872\":1}}],[\"排队和对银行工作人员进行评分的业务对每个客户是一样的\",{\"1\":{\"800\":1}}],[\"排队\",{\"1\":{\"800\":1}}],[\"试读版本首次对外发布\",{\"1\":{\"872\":1}}],[\"试想如果没有限速\",{\"1\":{\"843\":1}}],[\"附\",{\"0\":{\"872\":1,\"873\":1,\"874\":1}}],[\"附件等内容也各不相同\",{\"1\":{\"549\":1}}],[\"输入验证码\",{\"1\":{\"871\":1}}],[\"输入密码\",{\"1\":{\"871\":1}}],[\"输入用户名\",{\"1\":{\"871\":1}}],[\"输入框的按钮都需要考虑tab键聚焦\",{\"1\":{\"871\":1}}],[\"输出学院员工的信息\",{\"1\":{\"743\":1}}],[\"输出学院的员工\",{\"1\":{\"742\":1,\"743\":1}}],[\"输出各个学院的系\",{\"1\":{\"650\":1}}],[\"输出类\",{\"1\":{\"650\":1}}],[\"输出被装饰者的信息\",{\"1\":{\"584\":1}}],[\"输出流程\",{\"1\":{\"555\":1}}],[\"输出的电压为=\",{\"1\":{\"528\":1}}],[\"输出结果需要人工检查的测试不是一个好的单元测试\",{\"1\":{\"860\":1}}],[\"输出结果\",{\"1\":{\"305\":1,\"306\":2,\"307\":2,\"308\":2}}],[\"输出\",{\"1\":{\"230\":1,\"285\":1,\"524\":1,\"528\":1,\"650\":1,\"728\":1}}],[\"输出路径\",{\"1\":{\"105\":1}}],[\"识别和表达完全是两回事\",{\"1\":{\"871\":1}}],[\"世间众多设计模式其实就是一种设计模式即隔离变化点的模式\",{\"1\":{\"871\":1}}],[\"世上只有一个我\",{\"1\":{\"589\":1}}],[\"摒弃传统的审批流程\",{\"1\":{\"871\":1}}],[\"极致扩展性的标志\",{\"1\":{\"871\":1}}],[\"极端情况下\",{\"1\":{\"871\":1}}],[\"极有可能被循环调用的方法\",{\"1\":{\"852\":1}}],[\"欧元\",{\"1\":{\"871\":1}}],[\"欧标\",{\"1\":{\"521\":1}}],[\"钱的子类美元\",{\"1\":{\"871\":1}}],[\"忘记了类设计的初衷\",{\"1\":{\"871\":1}}],[\"屏蔽弱依赖负面影响\",{\"1\":{\"871\":1}}],[\"淘宝订单状态有已下单\",{\"1\":{\"871\":1}}],[\"曾经出现过线下调试是正确的\",{\"1\":{\"869\":1}}],[\"序号直接紧跟在英文说明之后\",{\"1\":{\"869\":1}}],[\"序号\",{\"1\":{\"869\":1}}],[\"序列化类新增属性时\",{\"1\":{\"848\":1}}],[\"序列化\",{\"0\":{\"202\":1,\"428\":1},\"1\":{\"689\":1}}],[\"升级\",{\"1\":{\"869\":1}}],[\"升java\",{\"0\":{\"340\":1,\"360\":1}}],[\"仓库内某二方库版本号从1\",{\"1\":{\"869\":1}}],[\"级\",{\"1\":{\"869\":1}}],[\"级联更新是强阻塞\",{\"1\":{\"865\":1}}],[\"级联调用obj\",{\"1\":{\"858\":1}}],[\"储\",{\"1\":{\"868\":1}}],[\"件\",{\"1\":{\"866\":1}}],[\"性之间的映射\",{\"1\":{\"866\":1}}],[\"性能最好\",{\"1\":{\"850\":1}}],[\"性能会受到影响\",{\"1\":{\"711\":1}}],[\"性能以及维护等问题\",{\"1\":{\"646\":1}}],[\"性能良好\",{\"1\":{\"430\":1}}],[\"性能良好且可以实时调用\",{\"1\":{\"409\":1}}],[\"性能剖析及基准测试工具\",{\"1\":{\"422\":1}}],[\"性能分析\",{\"0\":{\"422\":1},\"1\":{\"422\":1}}],[\"性能监测和分析工具\",{\"1\":{\"416\":1}}],[\"性能监测商业工具\",{\"1\":{\"416\":2}}],[\"故不建议在开发代码中使用此语句\",{\"1\":{\"865\":1}}],[\"轻松工作\",{\"1\":{\"865\":2}}],[\"轻量级工作流和业务流程管理框架\",{\"1\":{\"435\":1}}],[\"轻量级\",{\"1\":{\"429\":2}}],[\"轻量级开发包\",{\"1\":{\"420\":1}}],[\"轻量级动态依赖注入框架\",{\"1\":{\"397\":1}}],[\"抵制唯一索引\",{\"1\":{\"864\":1}}],[\"严重拖慢记录的更新以及行的新增速度\",{\"1\":{\"864\":1}}],[\"严控访问范围\",{\"1\":{\"848\":1}}],[\"吝啬索引的创建\",{\"1\":{\"864\":1}}],[\"认为唯一索引一律需要在应用层通过\",{\"1\":{\"864\":1}}],[\"认为索引会消耗空间\",{\"1\":{\"864\":1}}],[\"认为一个查询就需要建一个索引\",{\"1\":{\"864\":1}}],[\"认证\",{\"1\":{\"427\":1}}],[\"速度非常慢\",{\"1\":{\"864\":1}}],[\"速度最快功能最全的csv开发库之一\",{\"1\":{\"393\":1}}],[\"章节的格式化规则\",{\"1\":{\"962\":1}}],[\"章节以及\",{\"1\":{\"962\":1}}],[\"章节单独介绍\",{\"1\":{\"932\":1}}],[\"章节和\",{\"1\":{\"910\":1}}],[\"章节所中描述的\",{\"1\":{\"902\":1}}],[\"章节说明\",{\"1\":{\"901\":1}}],[\"章节中介绍\",{\"1\":{\"910\":1}}],[\"章节中介绍了不建议使用数量不确定的空格来与上一行代码中的某些单词\",{\"1\":{\"908\":1}}],[\"章节中所描述的\",{\"1\":{\"905\":1,\"959\":1}}],[\"章节中\",{\"1\":{\"898\":1}}],[\"章节\",{\"1\":{\"888\":1,\"891\":1,\"903\":1,\"905\":1,\"910\":1,\"915\":1,\"928\":1,\"946\":1,\"962\":2}}],[\"章对应的那一页吗\",{\"1\":{\"864\":1}}],[\"章是什么标题\",{\"1\":{\"864\":1}}],[\"列限制\",{\"0\":{\"905\":1},\"1\":{\"888\":1,\"891\":1}}],[\"列不存在\",{\"1\":{\"874\":1}}],[\"列名\",{\"1\":{\"864\":1,\"865\":2}}],[\"列式数据库\",{\"1\":{\"400\":1}}],[\"区分度最高的在最左边\",{\"1\":{\"864\":1}}],[\"区分度会高达90\",{\"1\":{\"864\":1}}],[\"区别于注解的继承\",{\"1\":{\"237\":1}}],[\"区别2\",{\"1\":{\"191\":1}}],[\"区别1\",{\"1\":{\"191\":1}}],[\"太阳\",{\"1\":{\"863\":1}}],[\"亿年\",{\"1\":{\"863\":1}}],[\"亿\",{\"1\":{\"863\":1}}],[\"恐龙化石\",{\"1\":{\"863\":1}}],[\"龟\",{\"1\":{\"863\":1}}],[\"岁之内\",{\"1\":{\"863\":1}}],[\"冗余字段应遵循\",{\"1\":{\"863\":1}}],[\"疲劳度控制\",{\"1\":{\"861\":1}}],[\"支付宝付款服务\",{\"1\":{\"868\":1}}],[\"支付\",{\"1\":{\"861\":1}}],[\"支持表示并发等\",{\"1\":{\"871\":1}}],[\"支持增加任意产品\",{\"1\":{\"606\":1}}],[\"支持不同平台和不同文件格式的媒体播放器等\",{\"1\":{\"537\":1}}],[\"支持参数化测试\",{\"1\":{\"476\":1}}],[\"支持代码热加载并在浏览器中显示错误\",{\"1\":{\"434\":1}}],[\"支持代理和缓存功能的二进制管理工具\",{\"1\":{\"401\":1}}],[\"支持基本类型\",{\"1\":{\"432\":1}}],[\"支持基于服务器的部署服务\",{\"1\":{\"392\":1}}],[\"支持单元测试和集成测试\",{\"1\":{\"431\":1}}],[\"支持衍生的groovy范的语言\",{\"1\":{\"431\":1}}],[\"支持模拟静态方法\",{\"1\":{\"431\":1}}],[\"支持流式断言提高测试的可读性\",{\"1\":{\"431\":1}}],[\"支持xml文件的工具\",{\"1\":{\"430\":1}}],[\"支持语义扩展\",{\"1\":{\"430\":1}}],[\"支持很多java\",{\"1\":{\"429\":1}}],[\"支持jca提供者\",{\"1\":{\"427\":1}}],[\"支持数学图论对象和算法的图形库\",{\"1\":{\"425\":1}}],[\"支持非阻塞式反向压力\",{\"1\":{\"423\":1}}],[\"支持许多持久化标准\",{\"1\":{\"420\":1}}],[\"支持快速数据访问和编码的orm框架\",{\"1\":{\"420\":1}}],[\"支持pos标签\",{\"1\":{\"418\":1}}],[\"支持对jvm应用程序进行分布式事务追踪的性能监测商业工具\",{\"1\":{\"416\":1}}],[\"支持静态类型和静态编译\",{\"1\":{\"411\":1}}],[\"支持在对象与json之间双向序列化\",{\"1\":{\"409\":1}}],[\"支持硬件加速的图像缩放开发库\",{\"1\":{\"408\":1}}],[\"支持众多jvm语言\",{\"1\":{\"407\":1}}],[\"支持多态特性\",{\"1\":{\"813\":1}}],[\"支持多租户\",{\"1\":{\"426\":1}}],[\"支持多种格式的一维\",{\"1\":{\"408\":1}}],[\"支持多种插件和编程语言\",{\"1\":{\"407\":1}}],[\"支持多重继承\",{\"1\":{\"151\":1}}],[\"支持一元\",{\"1\":{\"403\":1}}],[\"支持ooxml规范\",{\"1\":{\"402\":1}}],[\"支持虚拟角色\",{\"1\":{\"399\":1}}],[\"支持分布式配置\",{\"1\":{\"399\":1}}],[\"支持无限次重定义运行时类与资源\",{\"1\":{\"398\":1}}],[\"支持外部配置的开发库\",{\"1\":{\"390\":1}}],[\"支持自定义标签库的网站通用模板库\",{\"1\":{\"384\":1}}],[\"支持自动垃圾回收\",{\"1\":{\"151\":1}}],[\"支持泛型数组初始化操作就是搬起石头砸自己的脚\",{\"1\":{\"294\":1}}],[\"支持为图片设置颜色模式和大小\",{\"1\":{\"21\":1}}],[\"攻击者可以利用上传漏洞\",{\"1\":{\"861\":1}}],[\"攻击者可以事先构造好url\",{\"1\":{\"861\":1}}],[\"攻击者通过恶意构造跳转的链接\",{\"1\":{\"861\":1}}],[\"攻击力\",{\"1\":{\"667\":1}}],[\"攻击力和防御力\",{\"1\":{\"665\":1}}],[\"挂马等危害\",{\"1\":{\"861\":1}}],[\"蠕虫\",{\"1\":{\"861\":1}}],[\"钓鱼\",{\"1\":{\"861\":1}}],[\"恶意order\",{\"1\":{\"861\":1}}],[\"隐藏中间\",{\"1\":{\"861\":1}}],[\"隐式的将加操作的结果类型强制转换为持有结果的类型\",{\"1\":{\"165\":1}}],[\"隐式类型转换\",{\"0\":{\"129\":1}}],[\"隶属于用户个人的页面或者功能必须进行权限控制校验\",{\"1\":{\"861\":1}}],[\"凡是本文内容都是与开发同学强相关的\",{\"1\":{\"860\":1}}],[\"边界值测试\",{\"1\":{\"860\":1}}],[\"案发现场信息和异常堆栈信息\",{\"1\":{\"859\":1}}],[\"案例\",{\"1\":{\"832\":3}}],[\"案例说明\",{\"1\":{\"532\":1}}],[\"务必在日志配置文件中设置additivity=false正例\",{\"1\":{\"859\":1}}],[\"浪费时间\",{\"1\":{\"990\":1}}],[\"浪费性能和存\",{\"1\":{\"868\":1}}],[\"浪费磁盘空间\",{\"1\":{\"859\":1}}],[\"浪费一周的时间翻遍整个项目的情况\",{\"1\":{\"458\":1}}],[\"留存的日志不少于六个月\",{\"1\":{\"859\":1}}],[\"历史日志名称为mppserver\",{\"1\":{\"859\":1}}],[\"历史上是一个开创新的版本\",{\"1\":{\"187\":1}}],[\"周围代码的有效换行方式应与\",{\"1\":{\"905\":1}}],[\"周\",{\"1\":{\"859\":1}}],[\"周六结束\",{\"1\":{\"849\":1}}],[\"足迹服务引入了高版本的spring\",{\"1\":{\"858\":1}}],[\"仲裁机制可能导致引入非预期的版本使类的方法签名不匹配\",{\"1\":{\"858\":1}}],[\"捕捉异常使用throwable类进行拦截\",{\"1\":{\"858\":1}}],[\"捕获多个异常中的\",{\"1\":{\"911\":1}}],[\"捕获异常\",{\"0\":{\"950\":1}}],[\"捕获异常与抛异常\",{\"1\":{\"858\":1}}],[\"捕获异常是为了处理它\",{\"1\":{\"858\":1}}],[\"捕获异常并处理\",{\"1\":{\"257\":1}}],[\"捕获\",{\"1\":{\"663\":1}}],[\"捕获标准异常并包装为自定义异常是一个很常见的做法\",{\"1\":{\"271\":1}}],[\"感性认知+口口相传\",{\"1\":{\"857\":1}}],[\"感觉像空气\",{\"1\":{\"860\":1}}],[\"感觉只是和目标接口交互\",{\"1\":{\"520\":1}}],[\"感觉和原来的方式并没有太大区别\",{\"1\":{\"450\":1}}],[\"俄罗斯语等\",{\"1\":{\"857\":1}}],[\"英文说明可以是部门简称\",{\"1\":{\"869\":1}}],[\"英文说明\",{\"1\":{\"869\":1}}],[\"英文单词形式的错误码不利于非英语母语国家\",{\"1\":{\"857\":1}}],[\"英文站点\",{\"0\":{\"442\":1}}],[\"堆栈向上抛\",{\"1\":{\"858\":1}}],[\"堆栈\",{\"1\":{\"857\":1}}],[\"往往是用1个\",{\"1\":{\"991\":1}}],[\"往往是业务逻辑出错\",{\"1\":{\"857\":1}}],[\"往往有多处\",{\"1\":{\"609\":1}}],[\"错在哪\",{\"1\":{\"857\":1}}],[\"错误简短信息\",{\"1\":{\"858\":1}}],[\"错误信息\",{\"1\":{\"857\":1}}],[\"错误产生来源分为a\",{\"1\":{\"857\":1}}],[\"错误产生来源+四位数字编号\",{\"1\":{\"857\":1}}],[\"错误等级由日志和错误码本身的释义来决定\",{\"1\":{\"857\":1}}],[\"错误码列表\",{\"0\":{\"874\":1}}],[\"错误码即人性\",{\"1\":{\"857\":1}}],[\"错误码有利于不同文化背景的开发者进行交流与代码协作\",{\"1\":{\"857\":1}}],[\"错误码有利于团队快速对错误原因达到一致认知\",{\"1\":{\"857\":1}}],[\"错误码的后三位编号与http状态码没有任何关系\",{\"1\":{\"857\":1}}],[\"错误码的制定原则\",{\"1\":{\"857\":1}}],[\"错误码分为一级宏观错误码\",{\"1\":{\"857\":1}}],[\"错误码之外的业务信息由error\",{\"1\":{\"857\":1}}],[\"错误码不能直接输出给用户作为提示信息使用\",{\"1\":{\"857\":1}}],[\"错误码不体现版本号和错误等级信息\",{\"1\":{\"857\":1}}],[\"错误码使用者避免随意定义新的错误码\",{\"1\":{\"857\":1}}],[\"错误码为字符串类型\",{\"1\":{\"857\":1}}],[\"错误码以不断追加的方式进行兼容\",{\"1\":{\"857\":1}}],[\"错误码必须能够进行清晰地比对\",{\"1\":{\"857\":1}}],[\"错误码必须能够快速知晓错误来源\",{\"1\":{\"857\":1}}],[\"错误码回答的问题是谁的错\",{\"1\":{\"857\":1}}],[\"错误码想得过于完美和复杂\",{\"1\":{\"857\":1}}],[\"错误码\",{\"0\":{\"857\":1},\"1\":{\"857\":1,\"858\":1,\"874\":1}}],[\"错误排查人员\",{\"1\":{\"854\":1}}],[\"错误的严重程度等\",{\"1\":{\"266\":1}}],[\"错误示例\",{\"1\":{\"264\":1}}],[\"错误\",{\"0\":{\"247\":1},\"1\":{\"246\":1,\"853\":1,\"870\":1}}],[\"错误将引发异常\",{\"1\":{\"245\":1}}],[\"错误条件\",{\"1\":{\"245\":1}}],[\"沟通标准化\",{\"1\":{\"857\":1}}],[\"坚决清理干净\",{\"1\":{\"855\":1}}],[\"坚持is\",{\"1\":{\"863\":1}}],[\"坚持读书\",{\"1\":{\"36\":1}}],[\"坚持运动\",{\"1\":{\"36\":1}}],[\"括号内\",{\"1\":{\"855\":1}}],[\"括号内的f与左括号\",{\"1\":{\"847\":1}}],[\"≤\",{\"1\":{\"855\":1}}],[\"精简\",{\"1\":{\"854\":1}}],[\"响应体body可放置多种数据类型\",{\"1\":{\"854\":1}}],[\"响应体\",{\"1\":{\"854\":2}}],[\"响应式开发库\",{\"0\":{\"423\":1}}],[\"域名解析服务出错\",{\"1\":{\"874\":1}}],[\"域名\",{\"1\":{\"854\":1}}],[\"十一\",{\"0\":{\"855\":1}}],[\"十\",{\"0\":{\"854\":1}}],[\"预处理返回结果及转化异常信息\",{\"1\":{\"868\":1}}],[\"预计处理时间\",{\"1\":{\"853\":2}}],[\"预期原值和新值\",{\"1\":{\"873\":1}}],[\"预期大于\",{\"1\":{\"848\":1}}],[\"预期进入此代码块\",{\"1\":{\"848\":2}}],[\"预期是true\",{\"1\":{\"846\":1}}],[\"线上应用不要依赖snapshot版本\",{\"1\":{\"869\":1}}],[\"线上因为这个原因曾经出现过oom\",{\"1\":{\"866\":1}}],[\"线上查询语句出现出\",{\"1\":{\"865\":1}}],[\"线上故障有时候就是来源于这些标记处的代码\",{\"1\":{\"853\":1}}],[\"线程执行代码注意catch异常\",{\"1\":{\"851\":1}}],[\"线程一需要对表a\",{\"1\":{\"851\":1}}],[\"线程经常会被复用\",{\"1\":{\"851\":1}}],[\"线程资源必须通过线程池提供\",{\"1\":{\"851\":1}}],[\"线程间不唯一\",{\"1\":{\"772\":1}}],[\"线程间都唯一\",{\"1\":{\"771\":1}}],[\"线程间可以不唯一\",{\"1\":{\"771\":1}}],[\"线程间消息传递开发库\",{\"1\":{\"406\":1}}],[\"线程唯一\",{\"1\":{\"771\":3,\"772\":3}}],[\"线程池不允许使用executors去创建\",{\"1\":{\"851\":1}}],[\"线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销\",{\"1\":{\"851\":1}}],[\"线程池也确实没有设计成单例类\",{\"1\":{\"766\":1}}],[\"线程池这类的资源池\",{\"1\":{\"766\":1}}],[\"线程不安全~\",{\"1\":{\"754\":1}}],[\"线程不安全\",{\"0\":{\"754\":1},\"1\":{\"751\":1,\"754\":1,\"850\":2}}],[\"线程基础\",{\"0\":{\"515\":1}}],[\"线程分析之线程dump分析\",{\"0\":{\"380\":1}}],[\"线程安全~\",{\"1\":{\"755\":1,\"756\":1}}],[\"线程安全\",{\"0\":{\"755\":1,\"756\":1},\"1\":{\"123\":1,\"124\":1,\"192\":1,\"751\":2,\"755\":2,\"756\":2,\"757\":2,\"850\":1}}],[\"登录场景中\",{\"1\":{\"871\":1}}],[\"登录代码仓库即可\",{\"1\":{\"853\":1}}],[\"登录认证\",{\"1\":{\"427\":1}}],[\"难以知晓注释动机\",{\"1\":{\"853\":1}}],[\"难以维护\",{\"1\":{\"779\":1}}],[\"谨慎使用继承的方式来进行扩展\",{\"1\":{\"871\":1}}],[\"谨慎使用序列化\",{\"1\":{\"741\":1}}],[\"谨慎地记录日志\",{\"1\":{\"859\":1}}],[\"谨慎注释掉代码\",{\"1\":{\"853\":1}}],[\"九\",{\"0\":{\"853\":1}}],[\"底层基础技术框架\",{\"1\":{\"869\":1}}],[\"底层调用频度比较高的方法\",{\"1\":{\"852\":1}}],[\"底层实现原理也是基于下面代码中所示的\",{\"1\":{\"771\":1}}],[\"敏捷成了产品经理催进度的借口\",{\"1\":{\"871\":1}}],[\"敏捷开发是快速交付迭代可用的系统\",{\"1\":{\"871\":1}}],[\"敏捷开发=讲故事+编码+发布\",{\"1\":{\"871\":1}}],[\"敏捷软件开发\",{\"1\":{\"219\":1,\"716\":1}}],[\"敏感权限入口\",{\"1\":{\"852\":1}}],[\"赋值运算符时\",{\"1\":{\"907\":1}}],[\"赋值点类似于人体的穴位\",{\"1\":{\"852\":1}}],[\"赋值为\",{\"1\":{\"294\":1}}],[\"贫贱夫妻百事哀\",{\"1\":{\"852\":1}}],[\"击穿\",{\"1\":{\"852\":1}}],[\"八\",{\"0\":{\"852\":1}}],[\"八个基本类型\",{\"1\":{\"119\":1}}],[\"悲观锁遵循一锁二判三更新四释放的原则\",{\"1\":{\"851\":1}}],[\"资金相关的金融敏感信息\",{\"1\":{\"851\":1}}],[\"资源驱动类\",{\"1\":{\"851\":1}}],[\"资源消耗大\",{\"1\":{\"663\":1}}],[\"资源\",{\"0\":{\"436\":1}}],[\"资源和jvm打包成windows\",{\"1\":{\"401\":1}}],[\"资源会在\",{\"1\":{\"264\":1}}],[\"资源导航\",{\"0\":{\"37\":1}}],[\"乐观锁对冲突的解决策略有较复杂的要求\",{\"1\":{\"851\":1}}],[\"乐观锁在获得锁的同时已经完成了更新操作\",{\"1\":{\"851\":1}}],[\"乐观锁的重试次数不得小于\",{\"1\":{\"851\":1}}],[\"乐器类\",{\"1\":{\"211\":1}}],[\"亦推荐如下处理\",{\"1\":{\"851\":1}}],[\"七\",{\"0\":{\"851\":1,\"871\":1}}],[\"七大原则\",{\"0\":{\"713\":1}}],[\"稳定代码指的是无论如何不会出错的代码\",{\"1\":{\"858\":1}}],[\"稳定性指集合每次遍历的元素次序是一定的\",{\"1\":{\"850\":1}}],[\"稳定数据结构\",{\"1\":{\"591\":1}}],[\"锁\",{\"1\":{\"872\":1}}],[\"锁的释放规则与锁的阻塞等待方式相同\",{\"1\":{\"851\":1}}],[\"锁分段技术\",{\"1\":{\"850\":1}}],[\"锁核心类aqs详解\",{\"0\":{\"508\":1}}],[\"毕竟是像纯净水过滤的最后一道\",{\"1\":{\"852\":1}}],[\"毕竟泛型是在jdk5后才出现\",{\"1\":{\"850\":1}}],[\"毕竟最初我们只考虑将图片存储在阿里云上\",{\"1\":{\"809\":1}}],[\"均采用utf8字符集\",{\"1\":{\"865\":1}}],[\"均会导致子列表的遍历\",{\"1\":{\"850\":1}}],[\"均以最小货币单位且为整型类型进行存储\",{\"1\":{\"848\":1}}],[\"六\",{\"0\":{\"850\":1,\"867\":1}}],[\"硬性规定\",{\"1\":{\"876\":1}}],[\"硬编码\",{\"1\":{\"849\":1}}],[\"硬盘\",{\"1\":{\"549\":1}}],[\"慎用object的clone方法来拷贝对象\",{\"1\":{\"848\":1}}],[\"循环的头部中声明多个变量\",{\"1\":{\"917\":1}}],[\"循环体中的语句要考量性能\",{\"1\":{\"852\":1}}],[\"循环体内\",{\"1\":{\"848\":1}}],[\"循序渐进\",{\"1\":{\"36\":1}}],[\"首屏展示最好\",{\"1\":{\"848\":1}}],[\"首先要分清几个概念\",{\"1\":{\"972\":1,\"981\":1}}],[\"首先要找到其无参构造器\",{\"1\":{\"310\":1}}],[\"首先明确对象有多少种状态\",{\"1\":{\"871\":1}}],[\"首先其它鸭子都继承了\",{\"1\":{\"788\":1}}],[\"首先创建手机和路由器的接口类\",{\"1\":{\"617\":1}}],[\"首先肯定是\",{\"1\":{\"310\":1}}],[\"首先调用了\",{\"1\":{\"310\":1}}],[\"首先调用driversiterator\",{\"1\":{\"103\":1}}],[\"首先来看看异常慢在哪里\",{\"1\":{\"276\":1}}],[\"首先会将它们提升到\",{\"1\":{\"165\":1}}],[\"首先把\",{\"1\":{\"125\":1}}],[\"首先去掉注释校验\",{\"1\":{\"114\":1}}],[\"首先看第二步\",{\"1\":{\"103\":1}}],[\"首先在java中定义了接口java\",{\"1\":{\"99\":1}}],[\"首先通过allocatememory方法申请4字节的内存空间后\",{\"1\":{\"93\":1}}],[\"首先通过反射拿到boolean类中定义的true这个变量\",{\"1\":{\"91\":1}}],[\"首先\",{\"1\":{\"91\":1,\"104\":2,\"114\":1,\"285\":1,\"291\":1,\"622\":1,\"770\":1,\"772\":1,\"805\":1,\"809\":1,\"820\":1}}],[\"神坑之一\",{\"1\":{\"848\":1}}],[\"尾数+阶码\",{\"1\":{\"848\":1}}],[\"浮点数的后缀统一为大写\",{\"1\":{\"872\":1}}],[\"浮点数的比较\",{\"1\":{\"872\":1}}],[\"浮点数采用\",{\"1\":{\"848\":1}}],[\"浮点数之间的等值判断\",{\"1\":{\"848\":1}}],[\"浮点数类型的数值后缀统一为大写的d或f\",{\"1\":{\"846\":1}}],[\"绿叶逻辑单独出来成为额外方法\",{\"1\":{\"847\":1}}],[\"绿色是\",{\"1\":{\"834\":1}}],[\"回车及任何不可见字符的总行数不超过\",{\"1\":{\"847\":1}}],[\"回忆一下当天发生的事\",{\"1\":{\"36\":1}}],[\"见反例\",{\"1\":{\"847\":1}}],[\"见过的人\",{\"1\":{\"36\":1}}],[\"涉及上述中的\",{\"1\":{\"847\":1}}],[\"右花括号之后才换行\",{\"1\":{\"901\":1}}],[\"右花括号之前换行\",{\"1\":{\"901\":1}}],[\"右括号与强制转换值之间不需要任何空格隔开\",{\"1\":{\"847\":1}}],[\"右小括号和左边相邻字符之间也不需要空格\",{\"1\":{\"847\":1}}],[\"右大括号后有else\",{\"1\":{\"847\":1}}],[\"右大括号后还有else等代码则不换行\",{\"1\":{\"847\":1}}],[\"右大括号前换行\",{\"1\":{\"847\":2}}],[\"右边部分正好相反\",{\"1\":{\"741\":1}}],[\"左花括号之后换行\",{\"1\":{\"901\":1}}],[\"左花括号之前不能换行\",{\"1\":{\"901\":1}}],[\"左右大括号\",{\"1\":{\"847\":1}}],[\"左小括号和右边相邻字符之间不需要空格\",{\"1\":{\"847\":1}}],[\"左大括号前加空格且不换行\",{\"1\":{\"847\":1}}],[\"左大括号前不换行\",{\"1\":{\"847\":1}}],[\"左大括号后换行\",{\"1\":{\"847\":2}}],[\"左移运算符\",{\"1\":{\"203\":1}}],[\"杂乱无章\",{\"1\":{\"846\":1}}],[\"杂项\",{\"0\":{\"415\":1}}],[\"​a\",{\"1\":{\"846\":1}}],[\"​类b中\",{\"1\":{\"846\":1}}],[\"​类a中\",{\"1\":{\"846\":1}}],[\"​\",{\"1\":{\"845\":12,\"847\":1,\"849\":1,\"850\":8,\"851\":9,\"852\":2,\"857\":3,\"859\":2,\"863\":5,\"864\":3,\"865\":5}}],[\"杜绝完全不规范的英文缩写\",{\"1\":{\"845\":1}}],[\"杜绝踩重复的坑\",{\"1\":{\"843\":1}}],[\"误以为\",{\"1\":{\"845\":1}}],[\"力求语义表达完整清楚\",{\"1\":{\"845\":1}}],[\"福娃\",{\"1\":{\"845\":1}}],[\"稿费所得收入均捐赠公益事情\",{\"1\":{\"843\":1}}],[\"娓娓道来\",{\"1\":{\"843\":1}}],[\"秉持\",{\"1\":{\"843\":1}}],[\"万行或者单表容量超过2gb\",{\"1\":{\"863\":1}}],[\"万字的配套详解图书\",{\"1\":{\"843\":1}}],[\"万人次\",{\"1\":{\"843\":1}}],[\"万能充电器\",{\"1\":{\"590\":1}}],[\"切实提升系统稳定性\",{\"1\":{\"843\":1}}],[\"切点\",{\"1\":{\"242\":2}}],[\"量的提升是尽可能少踩坑\",{\"1\":{\"843\":1}}],[\"量大\",{\"1\":{\"205\":1}}],[\"制定交通法规表面上是要限制行车权\",{\"1\":{\"843\":1}}],[\"制作纯豆浆\",{\"1\":{\"803\":1}}],[\"制作花生豆浆\",{\"1\":{\"803\":1}}],[\"制作红豆豆浆\",{\"1\":{\"803\":2}}],[\"制作豆浆的流程\",{\"1\":{\"802\":1}}],[\"众多社区开发者踊跃参与打磨完善\",{\"1\":{\"843\":1}}],[\"脏数据\",{\"1\":{\"841\":1}}],[\"固定\",{\"1\":{\"841\":1}}],[\"考察\",{\"1\":{\"839\":1}}],[\"考虑这样一种情况\",{\"1\":{\"912\":1}}],[\"考虑到向前兼容\",{\"1\":{\"850\":1}}],[\"考虑到用户可以添加多份调料时\",{\"1\":{\"583\":1}}],[\"考虑是否为final\",{\"1\":{\"848\":1}}],[\"考虑\",{\"1\":{\"658\":1}}],[\"考虑使用\",{\"1\":{\"583\":1}}],[\"考虑纸牌对象的情形\",{\"1\":{\"265\":1}}],[\"男人给的评价是该歌手待定\",{\"1\":{\"839\":1}}],[\"男人给的评价该歌手失败\",{\"1\":{\"839\":1}}],[\"男人给的评价该歌手很成功\",{\"1\":{\"839\":1}}],[\"女人给的评价是该歌手待定\",{\"1\":{\"839\":1}}],[\"女人给的评价该歌手失败\",{\"1\":{\"839\":1}}],[\"女人给的评价该歌手很成功\",{\"1\":{\"839\":1}}],[\"女士在\",{\"1\":{\"732\":1}}],[\"破坏封装\",{\"1\":{\"837\":1}}],[\"污染\",{\"1\":{\"837\":1}}],[\"顾客主要关心所选商品的性价比\",{\"1\":{\"837\":1}}],[\"顾问\",{\"1\":{\"440\":1}}],[\"购物车\",{\"1\":{\"837\":1}}],[\"购买火车票不一定要去火车站买\",{\"1\":{\"692\":1}}],[\"药房工作人员根据处方单的内容进行抓药\",{\"1\":{\"837\":1}}],[\"划分为编程规约\",{\"1\":{\"843\":1}}],[\"划分访问的层次\",{\"1\":{\"603\":1}}],[\"划价员根据处方单上面的药品名和数量进行划价\",{\"1\":{\"837\":1}}],[\"査看它的划价员和药房工作人员对它的处理方式也不同\",{\"1\":{\"837\":1}}],[\"医院医生开的处方单中包含多种药元素\",{\"1\":{\"837\":1}}],[\"满\",{\"1\":{\"835\":1}}],[\"满足开闭原则\",{\"1\":{\"616\":1,\"707\":1}}],[\"满足了开闭原则\",{\"1\":{\"739\":1}}],[\"满足了\",{\"1\":{\"613\":1}}],[\"满足迪米特法则\",{\"1\":{\"612\":1}}],[\"满足\",{\"1\":{\"567\":1,\"775\":1}}],[\"积极的词\",{\"1\":{\"835\":1}}],[\"积分\",{\"1\":{\"777\":1}}],[\"铁哥们\",{\"1\":{\"835\":1}}],[\"临时监控\",{\"1\":{\"859\":1}}],[\"临时用一下\",{\"1\":{\"835\":1}}],[\"临时变量\",{\"1\":{\"770\":1}}],[\"临时变量和一个\",{\"1\":{\"770\":1}}],[\"虚无缥缈\",{\"1\":{\"835\":1}}],[\"虚\",{\"1\":{\"835\":1}}],[\"虚线表示依赖关系\",{\"1\":{\"835\":1}}],[\"虚线表示实现\",{\"1\":{\"835\":1}}],[\"虚线代表\",{\"1\":{\"835\":1}}],[\"虚拟代理\",{\"1\":{\"705\":1}}],[\"虚拟java用户组\",{\"1\":{\"437\":1}}],[\"虚拟构造器\",{\"1\":{\"305\":1}}],[\"虚拟机巧妙的使用了桥方法\",{\"1\":{\"291\":1}}],[\"虚拟机并不能将泛型类型变为date\",{\"1\":{\"291\":1}}],[\"虚拟机运行错误\",{\"1\":{\"247\":1}}],[\"虚拟机错误\",{\"1\":{\"198\":1}}],[\"箭头关系表示可直接依赖\",{\"1\":{\"868\":1}}],[\"箭头方向所指的类\",{\"1\":{\"835\":1}}],[\"箭头方向\",{\"1\":{\"835\":1}}],[\"箭头特征\",{\"1\":{\"835\":1}}],[\"箭头从实现类指向接口\",{\"1\":{\"834\":1}}],[\"箭头从子类指向父类\",{\"1\":{\"833\":1}}],[\"箭头从使用类指向被关联的类\",{\"1\":{\"830\":1}}],[\"箭头从使用类指向被依赖的类\",{\"1\":{\"828\":1}}],[\"蓝色是\",{\"1\":{\"833\":1}}],[\"鼠标可以和\",{\"1\":{\"832\":1}}],[\"鼠标等部件组装而成的\",{\"1\":{\"549\":1}}],[\"头\",{\"1\":{\"832\":1}}],[\"头和嘴的关系\",{\"1\":{\"832\":1}}],[\"身份证\",{\"1\":{\"832\":1}}],[\"嘴也就不存在了\",{\"1\":{\"832\":1}}],[\"菱形泛型\",{\"1\":{\"850\":1}}],[\"菱形指向整体\",{\"1\":{\"831\":1,\"832\":1}}],[\"菱形操作符\",{\"1\":{\"186\":1}}],[\"丈夫和妻子等\",{\"1\":{\"830\":1}}],[\"师傅和徒弟\",{\"1\":{\"830\":1}}],[\"连续的单词直接拼接在一起\",{\"1\":{\"939\":1}}],[\"连编绎都通过不了\",{\"1\":{\"828\":1}}],[\"连接断开\",{\"1\":{\"874\":1}}],[\"连接异常\",{\"1\":{\"874\":1}}],[\"连接线和作为模型附加信息的文本\",{\"1\":{\"823\":1}}],[\"连接池类\",{\"1\":{\"763\":1}}],[\"连接池中的连接对象\",{\"1\":{\"631\":1}}],[\"连接\",{\"1\":{\"631\":1}}],[\"连接华为路由器\",{\"1\":{\"617\":1}}],[\"连接小米路由器\",{\"1\":{\"617\":1}}],[\"连接将军和士兵\",{\"1\":{\"560\":1}}],[\"真实系统的抽象\",{\"1\":{\"824\":1}}],[\"真实主题\",{\"1\":{\"694\":1}}],[\"光用文字能表达清楚建筑设计吗\",{\"1\":{\"823\":1}}],[\"明显\",{\"1\":{\"960\":1}}],[\"明确的方案\",{\"1\":{\"947\":1}}],[\"明确数据库表示删除概念的字段名为\",{\"1\":{\"872\":1}}],[\"明确各类的责任范围\",{\"1\":{\"707\":1}}],[\"明明是一种图形\",{\"1\":{\"823\":1}}],[\"企业机构或业务过程\",{\"1\":{\"823\":1}}],[\"企鹅这些不会飞的鸟\",{\"1\":{\"812\":1}}],[\"画类图时\",{\"1\":{\"835\":1}}],[\"画\",{\"1\":{\"822\":1}}],[\"们之间的关系\",{\"1\":{\"822\":1}}],[\"平台上发布了一款游戏\",{\"1\":{\"820\":1}}],[\"团体\",{\"1\":{\"819\":1}}],[\"团队成员才能理解这些通用概念\",{\"1\":{\"262\":1}}],[\"弱\",{\"1\":{\"835\":1}}],[\"弱耦合\",{\"1\":{\"818\":1}}],[\"弱点\",{\"1\":{\"36\":1}}],[\"配合\",{\"1\":{\"972\":1,\"981\":1}}],[\"配合间接的衡量标准一块来使用\",{\"1\":{\"817\":1}}],[\"配置服务超时\",{\"1\":{\"874\":1}}],[\"配置服务出错\",{\"1\":{\"874\":1}}],[\"配置映射关系\",{\"1\":{\"866\":1}}],[\"配置解析\",{\"1\":{\"622\":1}}],[\"配置文件解析主要包含\",{\"1\":{\"626\":1}}],[\"配置文件解析\",{\"0\":{\"626\":1},\"1\":{\"623\":1}}],[\"配置文件\",{\"1\":{\"622\":1,\"624\":1}}],[\"配置文件中的密码需要加密等\",{\"1\":{\"872\":1}}],[\"配置文件中的密码需要加密\",{\"1\":{\"861\":1}}],[\"配置文件中绝对不应该有逻辑或者控制结构\",{\"1\":{\"449\":1}}],[\"配置文件中有接口的具体实现类名\",{\"1\":{\"95\":1}}],[\"配置文件的解析比较繁琐\",{\"1\":{\"626\":1}}],[\"配置文件的格式\",{\"1\":{\"449\":2}}],[\"配置文件的方式\",{\"1\":{\"449\":1}}],[\"配置文件的两种连接方式\",{\"1\":{\"449\":1}}],[\"配置织入点\",{\"1\":{\"242\":1}}],[\"配置化到注解化的转变\",{\"1\":{\"240\":1}}],[\"配置化到注解化\",{\"0\":{\"240\":1}}],[\"配置的功能\",{\"1\":{\"148\":1}}],[\"配置\",{\"0\":{\"10\":1}}],[\"配置项的相关说明详见\",{\"1\":{\"0\":1}}],[\"间接的衡量标准有很多\",{\"1\":{\"817\":1}}],[\"间接地增加了系统实现的复杂度\",{\"1\":{\"800\":1}}],[\"恰当地选择使用继承还是组合\",{\"1\":{\"814\":1}}],[\"恰当使用继承可以把算法族的公共代码转移到父类里面\",{\"1\":{\"783\":1}}],[\"长度超过限制\",{\"1\":{\"874\":2}}],[\"长度为\",{\"1\":{\"864\":1}}],[\"长度为0\",{\"1\":{\"850\":1}}],[\"长度不要超过\",{\"1\":{\"863\":1}}],[\"长方形和圆形实现这两个方法供访问类调用\",{\"1\":{\"826\":1}}],[\"长期以来\",{\"1\":{\"814\":1}}],[\"长时间占用数据库连接资源\",{\"1\":{\"766\":1}}],[\"拼接和分割的功能\",{\"1\":{\"814\":1}}],[\"达到控制网站服务器的目的\",{\"1\":{\"861\":1}}],[\"达到代码复用的目的\",{\"1\":{\"814\":1}}],[\"达到和主项目的依赖关系的解耦\",{\"1\":{\"619\":1}}],[\"麻雀\",{\"1\":{\"813\":1}}],[\"委托三个技术手段\",{\"1\":{\"813\":1}}],[\"委托\",{\"1\":{\"813\":3}}],[\"委派模式\",{\"1\":{\"591\":1}}],[\"鸟会不会叫\",{\"1\":{\"812\":1}}],[\"鸟会不会飞\",{\"1\":{\"812\":1}}],[\"鸟类\",{\"1\":{\"812\":1}}],[\"乌鸦这些会飞的鸟都继承\",{\"1\":{\"812\":1}}],[\"乌鸦等\",{\"1\":{\"812\":1}}],[\"暴露出来的服务一定是接口\",{\"1\":{\"845\":1}}],[\"暴露不该暴露的接口给外部\",{\"1\":{\"812\":1}}],[\"暴露稳定的接口\",{\"1\":{\"808\":1,\"810\":1}}],[\"徒增了编码的工作量\",{\"1\":{\"812\":1}}],[\"鸵鸟\",{\"1\":{\"812\":1,\"813\":2}}],[\"鸵鸟继承具有\",{\"1\":{\"812\":1}}],[\"鸽子\",{\"1\":{\"812\":1}}],[\"投入不必要的开发时间\",{\"1\":{\"810\":1}}],[\"投影仪\",{\"1\":{\"597\":1,\"601\":2}}],[\"度\",{\"1\":{\"810\":1}}],[\"阿里开源的\",{\"1\":{\"872\":1}}],[\"阿里云效也集成了代码规约扫描引擎\",{\"1\":{\"843\":1}}],[\"阿里云的图片上传和下载的过程中\",{\"1\":{\"809\":1}}],[\"阿里巴巴专指数据库表一\",{\"1\":{\"873\":1}}],[\"阿里巴巴集团正式对外发布\",{\"1\":{\"872\":1}}],[\"阿里巴巴\",{\"0\":{\"842\":1},\"1\":{\"872\":2}}],[\"阿里手册\",{\"1\":{\"263\":1}}],[\"照抄到接口定义中\",{\"1\":{\"809\":1}}],[\"照抄到\",{\"1\":{\"809\":1}}],[\"乍看起来没有太大问题\",{\"1\":{\"809\":1}}],[\"乍一看这些工具类似乎很不错\",{\"1\":{\"452\":1}}],[\"携带\",{\"1\":{\"809\":1}}],[\"越能应对未来的需求变化\",{\"1\":{\"808\":1}}],[\"越能提高代码的灵活性\",{\"1\":{\"808\":1}}],[\"越脱离具体某一实现的设计\",{\"1\":{\"808\":1}}],[\"越顶层\",{\"1\":{\"808\":1}}],[\"越抽象\",{\"1\":{\"808\":1}}],[\"越是不稳定的系统\",{\"1\":{\"810\":1}}],[\"越是具体的异常要先处理\",{\"1\":{\"275\":1}}],[\"越是要勇于攀爬\",{\"1\":{\"36\":1}}],[\"越是艰难\",{\"1\":{\"36\":1}}],[\"偏抽象\",{\"1\":{\"808\":1}}],[\"偏向于自己使用的web框架\",{\"1\":{\"424\":1}}],[\"协作以及它们之间的静态结构和关系的一种静态模型\",{\"1\":{\"826\":1}}],[\"协议\",{\"1\":{\"808\":1,\"854\":1,\"872\":1}}],[\"协调各个具体的同事对象\",{\"1\":{\"659\":1}}],[\"协调各个同事角色之间的交互关系\",{\"1\":{\"656\":1}}],[\"千万不要一开始就与具体的编程语言挂钩\",{\"1\":{\"808\":1}}],[\"千万不要吝啬\",{\"1\":{\"462\":1}}],[\"供整个系统来使用\",{\"1\":{\"809\":1}}],[\"供子类实现\",{\"1\":{\"805\":1}}],[\"供扩展抽象化角色调用\",{\"1\":{\"538\":1}}],[\"纯豆浆不需要配料\",{\"1\":{\"803\":1}}],[\"纯豆浆类\",{\"1\":{\"803\":1}}],[\"纯java\",{\"1\":{\"408\":1}}],[\"纯java的3d引擎\",{\"1\":{\"404\":1}}],[\"决定是否需要添加配料\",{\"1\":{\"803\":1}}],[\"决胜千里之外\",{\"1\":{\"591\":1}}],[\"钩子\",{\"1\":{\"803\":1}}],[\"钩子方法\",{\"1\":{\"801\":1,\"803\":1}}],[\"花费时间较少\",{\"1\":{\"970\":1}}],[\"花费的代码比较高\",{\"1\":{\"613\":1}}],[\"花括号的使用方式遵循\",{\"1\":{\"901\":1}}],[\"花括号\",{\"0\":{\"899\":1}}],[\"花生类\",{\"1\":{\"803\":1}}],[\"花生豆浆\",{\"1\":{\"802\":1}}],[\"红豆类\",{\"1\":{\"803\":1}}],[\"红豆\",{\"1\":{\"802\":1}}],[\"浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆都是一样的\",{\"1\":{\"802\":1}}],[\"浸泡\",{\"1\":{\"802\":1,\"803\":1}}],[\"论文模板\",{\"1\":{\"800\":1}}],[\"论坛\",{\"1\":{\"420\":1}}],[\"睡觉等\",{\"1\":{\"800\":1}}],[\"睡前15分钟\",{\"1\":{\"36\":1}}],[\"吃饭\",{\"1\":{\"800\":1}}],[\"办理具体业务\",{\"1\":{\"800\":1}}],[\"懂了设计模式\",{\"1\":{\"797\":1}}],[\"苛能写一个简单的算法要比引入某种设计模式更加容易\",{\"1\":{\"797\":1}}],[\"称为可维护\",{\"1\":{\"797\":1}}],[\"架构\",{\"1\":{\"796\":1,\"816\":1}}],[\"架构类似python的scrapy\",{\"1\":{\"433\":1}}],[\"拿实际工作经历来说\",{\"1\":{\"796\":1}}],[\"伽玛\",{\"1\":{\"796\":1}}],[\"普遍存在\",{\"1\":{\"796\":1}}],[\"普通的类\",{\"1\":{\"877\":1}}],[\"普通索引三种\",{\"1\":{\"864\":1}}],[\"普通索引名则为idx\",{\"1\":{\"863\":1}}],[\"普通箭头表示关联或依赖\",{\"1\":{\"835\":1}}],[\"普通方案解决天气预报需求\",{\"0\":{\"674\":1}}],[\"普通房子\",{\"1\":{\"555\":1}}],[\"普通房子屋顶\",{\"1\":{\"555\":1}}],[\"普通房子封顶\",{\"1\":{\"553\":1}}],[\"普通房子砌墙\",{\"1\":{\"553\":1,\"555\":1}}],[\"普通房子打地基\",{\"1\":{\"553\":1,\"555\":1}}],[\"普通用户\",{\"1\":{\"546\":1}}],[\"普通类\",{\"1\":{\"305\":1}}],[\"普通语句块\",{\"1\":{\"144\":3}}],[\"俗称\",{\"1\":{\"795\":1}}],[\"听说过什么是设计模式\",{\"1\":{\"794\":1}}],[\"刚开始学编程不久\",{\"1\":{\"794\":1}}],[\"刚刚的设计实现方式\",{\"1\":{\"809\":1}}],[\"刚刚对\",{\"1\":{\"808\":1}}],[\"刚刚我们讲了\",{\"1\":{\"772\":1}}],[\"刚刚我们讲了单例类对象是进程唯一的\",{\"1\":{\"771\":1}}],[\"刚刚我们提到了单例的很多问题\",{\"1\":{\"769\":1}}],[\"刚刚调用该方法的调用处\",{\"1\":{\"275\":1}}],[\"层的if\",{\"1\":{\"852\":1}}],[\"层\",{\"1\":{\"794\":5,\"852\":1}}],[\"掌握设计模式的层次\",{\"0\":{\"794\":1}}],[\"降序排序\",{\"1\":{\"790\":1}}],[\"降低沟通成本\",{\"1\":{\"843\":1}}],[\"降低系统中对象间的耦合度\",{\"1\":{\"798\":1}}],[\"降低系统的耦合度\",{\"1\":{\"560\":1}}],[\"降低系统的管理和维护成本\",{\"1\":{\"544\":1}}],[\"降低对象之间的耦合\",{\"1\":{\"748\":1}}],[\"降低代码评审的速度\",{\"1\":{\"912\":1}}],[\"降低代码耦合\",{\"1\":{\"748\":1}}],[\"降低代码可读性\",{\"1\":{\"518\":1}}],[\"降低维护带来的新风险\",{\"1\":{\"748\":1}}],[\"降低需求变更时引入的风险\",{\"1\":{\"733\":1}}],[\"降低类对接口的依赖性\",{\"1\":{\"722\":1}}],[\"降低类的复杂度\",{\"1\":{\"717\":1,\"719\":1}}],[\"降低它们之间的耦合性\",{\"1\":{\"721\":1}}],[\"降低变更引起的风险\",{\"1\":{\"719\":1}}],[\"降低大量内存空间的消耗\",{\"1\":{\"639\":1}}],[\"降低内存消耗\",{\"1\":{\"631\":1}}],[\"降低了阅读和修改代码的难度\",{\"1\":{\"816\":1}}],[\"降低了类之间的耦合度\",{\"1\":{\"741\":1}}],[\"降低了代码出错的可能性\",{\"1\":{\"733\":1}}],[\"降低了系统的耦合性\",{\"1\":{\"722\":1}}],[\"降低了对象之间的耦合度\",{\"1\":{\"707\":1}}],[\"降低了对象之间的耦合性\",{\"1\":{\"655\":1}}],[\"降低了目标与观察者之间的耦合关系\",{\"1\":{\"671\":1}}],[\"降低了耦合\",{\"1\":{\"660\":1}}],[\"降低了程序内存的占用\",{\"1\":{\"638\":1}}],[\"降低了大型软件系统中的编译依赖性\",{\"1\":{\"593\":1}}],[\"降低了子系统与客户端之间的耦合度\",{\"1\":{\"593\":1}}],[\"降低了构建大型系统的风险\",{\"1\":{\"209\":1}}],[\"降低耦合度\",{\"1\":{\"241\":1,\"748\":1}}],[\"匿名类\",{\"1\":{\"790\":1}}],[\"叫声策略接口\",{\"1\":{\"789\":1}}],[\"叫声策略模式类\",{\"1\":{\"789\":1}}],[\"叫做单一责任原则\",{\"1\":{\"652\":1}}],[\"玩具鸭不会飞翔~~~\",{\"1\":{\"788\":1}}],[\"玩具鸭不会游泳~~\",{\"1\":{\"788\":1,\"789\":1}}],[\"玩具鸭不能叫~~\",{\"1\":{\"788\":1,\"789\":1}}],[\"玩具鸭\",{\"1\":{\"788\":1,\"789\":1}}],[\"玩游戏时的中间结果存档功能\",{\"1\":{\"663\":1}}],[\"溢出效应\",{\"1\":{\"788\":1}}],[\"尤其在线程池场景下\",{\"1\":{\"851\":1}}],[\"尤其超类的局部改动\",{\"1\":{\"788\":1}}],[\"尤其是text类型的字段\",{\"1\":{\"866\":1}}],[\"尤其是参数\",{\"1\":{\"853\":1}}],[\"尤其是批量操作的接口\",{\"1\":{\"852\":1}}],[\"尤其是条件表达式\",{\"1\":{\"852\":1}}],[\"尤其是现阶段各种第三方sdk\",{\"1\":{\"593\":1}}],[\"尤其是一些看起来\",{\"1\":{\"287\":1}}],[\"飞\",{\"1\":{\"812\":1}}],[\"飞翔技术高超\",{\"1\":{\"789\":1}}],[\"飞翔技术一般\",{\"1\":{\"789\":1}}],[\"飞行策略接口\",{\"1\":{\"789\":1}}],[\"飞行策略模式类\",{\"1\":{\"789\":1}}],[\"飞行等\",{\"1\":{\"785\":1}}],[\"飞机\",{\"1\":{\"718\":4}}],[\"鸭子信息类\",{\"1\":{\"789\":1}}],[\"鸭子会飞翔~~~\",{\"1\":{\"787\":1}}],[\"鸭子会游泳~~\",{\"1\":{\"787\":1,\"789\":1}}],[\"鸭子嘎嘎叫~~\",{\"1\":{\"787\":1,\"789\":1}}],[\"鸭子有各种行为\",{\"1\":{\"785\":1}}],[\"鸭子项目\",{\"0\":{\"785\":1}}],[\"水平空格\",{\"0\":{\"911\":1}}],[\"水平空格字符\",{\"1\":{\"883\":1}}],[\"水平对齐有助于阅读代码\",{\"1\":{\"912\":1}}],[\"水平对齐\",{\"0\":{\"912\":1},\"1\":{\"908\":1,\"912\":1}}],[\"水鸭等\",{\"1\":{\"785\":1}}],[\"水中运行\",{\"1\":{\"718\":1}}],[\"北京鸭的实际飞翔能力\",{\"1\":{\"789\":1}}],[\"北京鸭不能飞翔\",{\"1\":{\"787\":1}}],[\"北京鸭\",{\"1\":{\"785\":1,\"789\":1}}],[\"北京的奶酪\",{\"1\":{\"613\":2}}],[\"北京的胡椒\",{\"1\":{\"613\":3}}],[\"少用if\",{\"1\":{\"852\":1}}],[\"少用继承\",{\"1\":{\"783\":1,\"791\":1}}],[\"少使用继承\",{\"1\":{\"748\":1}}],[\"策略接口\",{\"1\":{\"790\":2}}],[\"策略方法\",{\"1\":{\"784\":1}}],[\"策略组\",{\"1\":{\"783\":1}}],[\"策略模式在很多地方用到\",{\"1\":{\"792\":1}}],[\"策略模式将算法封装在独立的\",{\"1\":{\"791\":1}}],[\"策略模式体现了\",{\"1\":{\"791\":1}}],[\"策略模式解决鸭子项目\",{\"0\":{\"789\":1}}],[\"策略模式的应用场景\",{\"0\":{\"792\":1}}],[\"策略模式的核心思想是\",{\"1\":{\"791\":1}}],[\"策略模式的关键是\",{\"1\":{\"791\":1}}],[\"策略模式的注意事项和细节\",{\"0\":{\"791\":1}}],[\"策略模式的主要角色如下\",{\"1\":{\"784\":1}}],[\"策略模式的重心不是如何实现算法\",{\"1\":{\"784\":1}}],[\"策略模式的结构与实现\",{\"0\":{\"784\":1}}],[\"策略模式是准备一组算法\",{\"1\":{\"784\":1}}],[\"策略模式造成很多的策略类\",{\"1\":{\"783\":1}}],[\"策略模式把算法的使用放到环境类中\",{\"1\":{\"783\":1}}],[\"策略模式提供了可以替换继承关系的办法\",{\"1\":{\"791\":1}}],[\"策略模式提供了对开闭原则的完美支持\",{\"1\":{\"783\":1}}],[\"策略模式提供了一系列的可供重用的算法族\",{\"1\":{\"783\":1}}],[\"策略模式可以提供相同行为的不同实现\",{\"1\":{\"783\":1}}],[\"策略模式属于对象行为模式\",{\"1\":{\"783\":1}}],[\"策略模式基本介绍\",{\"0\":{\"783\":1}}],[\"策略模式\",{\"1\":{\"591\":1,\"783\":1,\"788\":1,\"789\":1,\"790\":1,\"798\":1,\"814\":1,\"852\":1,\"860\":1}}],[\"送积分等方法\",{\"1\":{\"783\":1}}],[\"送商品\",{\"1\":{\"783\":1}}],[\"超时规则\",{\"1\":{\"980\":1}}],[\"超时设置生效顺序一般为\",{\"1\":{\"870\":1}}],[\"超出最大长度后\",{\"1\":{\"854\":1}}],[\"超出需要换行\",{\"1\":{\"847\":1}}],[\"超类里放行为接口对象\",{\"1\":{\"789\":1}}],[\"超市促销可以釆用打折\",{\"1\":{\"783\":1}}],[\"超过三个表禁止join\",{\"1\":{\"864\":1}}],[\"超过操作系统大小限制\",{\"1\":{\"859\":1}}],[\"超过integer的表示范围而溢出成为负数\",{\"1\":{\"848\":1}}],[\"超过\",{\"1\":{\"847\":2,\"852\":1,\"854\":1}}],[\"超过则不允许该链建立\",{\"1\":{\"711\":1}}],[\"超过当前流行的模板引擎\",{\"1\":{\"430\":1}}],[\"骑自行车或自己开私家车等\",{\"1\":{\"783\":1}}],[\"乘坐火车\",{\"1\":{\"783\":1}}],[\"检测插件相同的\",{\"1\":{\"872\":1}}],[\"检测失败时\",{\"1\":{\"779\":1}}],[\"检查的方法用check做前缀\",{\"1\":{\"845\":1}}],[\"检查\",{\"1\":{\"757\":1}}],[\"检查规则在一个\",{\"1\":{\"484\":1}}],[\"检查是否是同一个类型\",{\"1\":{\"138\":1}}],[\"检查是否为同一个对象的引用\",{\"1\":{\"138\":1}}],[\"待测试类\",{\"1\":{\"981\":1}}],[\"待发货\",{\"1\":{\"871\":1}}],[\"待办事宜\",{\"1\":{\"853\":1}}],[\"待付款\",{\"1\":{\"779\":1,\"871\":1}}],[\"待付款状态类\",{\"1\":{\"779\":1}}],[\"待会讲到\",{\"1\":{\"622\":1}}],[\"付款\",{\"1\":{\"779\":1}}],[\"抢单逻辑\",{\"1\":{\"779\":1}}],[\"抢单\",{\"1\":{\"779\":1}}],[\"抢单等等步骤\",{\"1\":{\"779\":1}}],[\"审批生效\",{\"1\":{\"857\":1}}],[\"审批人\",{\"1\":{\"709\":2}}],[\"审核逻辑\",{\"1\":{\"779\":1}}],[\"审核\",{\"1\":{\"779\":1}}],[\"伪代码如下\",{\"1\":{\"779\":1,\"852\":1}}],[\"伪泛型\",{\"1\":{\"278\":1,\"287\":1}}],[\"随意复制和粘贴代码\",{\"1\":{\"871\":1}}],[\"随着代码的重复次数不断增加\",{\"1\":{\"871\":1}}],[\"随着系统演进\",{\"1\":{\"871\":1}}],[\"随着元素增加而被迫不断扩容\",{\"1\":{\"850\":1}}],[\"随着id越来越大\",{\"1\":{\"848\":1}}],[\"随着操作的不同\",{\"1\":{\"779\":1}}],[\"随环境的改变而改变\",{\"1\":{\"631\":1}}],[\"借贷平台的订单\",{\"1\":{\"779\":1}}],[\"次要目的用于指导编码\",{\"1\":{\"871\":1}}],[\"次版本号\",{\"1\":{\"869\":2}}],[\"次方\",{\"1\":{\"863\":1}}],[\"次\",{\"1\":{\"850\":2,\"851\":1}}],[\"次抽奖\",{\"1\":{\"778\":1}}],[\"次奖\",{\"1\":{\"778\":1}}],[\"次或者多次\",{\"1\":{\"477\":1}}],[\"奖品有\",{\"1\":{\"778\":1}}],[\"奖品发放完毕状态\",{\"1\":{\"778\":1}}],[\"奖品发送完了\",{\"1\":{\"778\":4}}],[\"奖品数量\",{\"1\":{\"778\":1}}],[\"奖品数量固定\",{\"1\":{\"777\":1}}],[\"恭喜中奖了\",{\"1\":{\"778\":1}}],[\"恭喜你\",{\"1\":{\"284\":1}}],[\"您可以抽奖了\",{\"1\":{\"778\":1}}],[\"您的车票打八折\",{\"1\":{\"284\":1}}],[\"扣了积分才能抽奖喔\",{\"1\":{\"778\":1}}],[\"扣除50积分成功\",{\"1\":{\"778\":1}}],[\"扣除后\",{\"1\":{\"778\":1}}],[\"扣除积分后改变其状态\",{\"1\":{\"778\":1}}],[\"扣除积分\",{\"1\":{\"778\":1}}],[\"扣分\",{\"1\":{\"778\":1}}],[\"领取奖品\",{\"1\":{\"778\":1}}],[\"领域模型命名规约\",{\"1\":{\"845\":1}}],[\"领域\",{\"1\":{\"449\":1}}],[\"活动反馈\",{\"1\":{\"872\":1}}],[\"活动无法终止\",{\"1\":{\"852\":1}}],[\"活动图是流程图的扩展\",{\"1\":{\"871\":1}}],[\"活动图\",{\"1\":{\"822\":1}}],[\"活动的四个状态转换关系图\",{\"1\":{\"777\":1}}],[\"活动有四个状态\",{\"1\":{\"777\":1}}],[\"活跃讲师和作者\",{\"1\":{\"440\":1}}],[\"抽查表明\",{\"1\":{\"850\":1}}],[\"抽取出来\",{\"1\":{\"814\":1}}],[\"抽完奖后\",{\"1\":{\"778\":1}}],[\"抽完就不能抽奖\",{\"1\":{\"777\":1}}],[\"抽奖活动结束\",{\"1\":{\"778\":1}}],[\"抽奖活动问题\",{\"0\":{\"777\":1}}],[\"抽奖\",{\"1\":{\"778\":1}}],[\"抽奖方法\",{\"1\":{\"778\":1}}],[\"抽象元素类\",{\"1\":{\"838\":1}}],[\"抽象元素\",{\"1\":{\"838\":1}}],[\"抽象访问者\",{\"1\":{\"838\":2}}],[\"抽象思维和总结能力的局限性\",{\"1\":{\"871\":1}}],[\"抽象思维\",{\"1\":{\"809\":1}}],[\"抽象模板类\",{\"1\":{\"801\":1}}],[\"抽象模板\",{\"1\":{\"801\":1}}],[\"抽象策略类\",{\"1\":{\"784\":1}}],[\"抽象策略\",{\"1\":{\"784\":1}}],[\"抽象状态类\",{\"1\":{\"776\":1}}],[\"抽象状态\",{\"1\":{\"776\":1}}],[\"抽象指的是接口或抽象类\",{\"1\":{\"725\":1}}],[\"抽象的东西要稳定的多\",{\"1\":{\"725\":1}}],[\"抽象的方法\",{\"1\":{\"555\":1}}],[\"抽象不应该依赖细节\",{\"1\":{\"725\":1}}],[\"抽象处理者角色\",{\"1\":{\"708\":1}}],[\"抽象处理者\",{\"1\":{\"708\":1}}],[\"抽象原型类\",{\"1\":{\"683\":1}}],[\"抽象目标\",{\"1\":{\"672\":1}}],[\"抽象观察者\",{\"1\":{\"672\":2}}],[\"抽象主题\",{\"1\":{\"672\":1,\"694\":1}}],[\"抽象同事类\",{\"1\":{\"656\":2}}],[\"抽象中介者\",{\"1\":{\"656\":2}}],[\"抽象迭代器\",{\"1\":{\"649\":2}}],[\"抽象聚合\",{\"1\":{\"649\":2}}],[\"抽象成迭代器类来实现的\",{\"1\":{\"649\":1}}],[\"抽象运算符号解析器\",{\"1\":{\"644\":1}}],[\"抽象表达式类\",{\"1\":{\"642\":1}}],[\"抽象表达式\",{\"1\":{\"642\":1}}],[\"抽象享元角色\",{\"1\":{\"632\":2}}],[\"抽象工厂结构图\",{\"1\":{\"616\":1}}],[\"抽象工厂增强了程序的可扩展性\",{\"1\":{\"616\":1}}],[\"抽象工厂可以保证客户端始终只使用同一个产品的产品组\",{\"1\":{\"616\":1}}],[\"抽象工厂\",{\"0\":{\"615\":1},\"1\":{\"612\":1,\"616\":2,\"617\":1}}],[\"抽象工厂模式应用实例\",{\"0\":{\"617\":1}}],[\"抽象工厂模式有多个抽象产品\",{\"1\":{\"616\":1}}],[\"抽象工厂模式就是对简单工厂模式的改进\",{\"1\":{\"616\":1}}],[\"抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合\",{\"1\":{\"616\":1}}],[\"抽象工厂模式实现对产品家族的创建\",{\"1\":{\"557\":1}}],[\"抽象工厂模式\",{\"1\":{\"557\":1,\"606\":1,\"612\":1,\"616\":1,\"619\":1,\"798\":1}}],[\"抽象产品只能生产一种产品\",{\"1\":{\"612\":1}}],[\"抽象产品\",{\"1\":{\"608\":1,\"612\":1,\"616\":1}}],[\"抽象装饰角色\",{\"1\":{\"580\":1}}],[\"抽象装饰\",{\"1\":{\"580\":1}}],[\"抽象构件角色\",{\"1\":{\"580\":1}}],[\"抽象构件和树叶构件没有对子对象的管理方法\",{\"1\":{\"570\":1}}],[\"抽象构件\",{\"1\":{\"568\":1,\"571\":2,\"580\":1}}],[\"抽象命令\",{\"1\":{\"561\":1}}],[\"抽象命令类\",{\"1\":{\"561\":1}}],[\"抽象必然会额外增加类的数量\",{\"1\":{\"560\":1}}],[\"抽象接口\",{\"1\":{\"560\":1}}],[\"抽象建造者\",{\"1\":{\"550\":1,\"551\":1}}],[\"抽象\",{\"0\":{\"815\":1},\"1\":{\"544\":1,\"545\":1,\"764\":1}}],[\"抽象化角色\",{\"1\":{\"538\":1}}],[\"抽象化\",{\"1\":{\"538\":1}}],[\"抽象与实现分离\",{\"1\":{\"537\":1}}],[\"抽象方法2的实现被调用\",{\"1\":{\"801\":1}}],[\"抽象方法1的实现被调用\",{\"1\":{\"801\":1}}],[\"抽象方法\",{\"1\":{\"556\":1,\"613\":1,\"636\":1,\"728\":3,\"739\":1,\"801\":3,\"803\":1}}],[\"抽象方法的返回值就是泛型类型\",{\"1\":{\"282\":1}}],[\"抽象方法一定位于抽象类中\",{\"1\":{\"133\":1}}],[\"抽象以及更高级的一些概念\",{\"1\":{\"187\":1}}],[\"抽象类命名使用abstract或base开头\",{\"1\":{\"845\":1}}],[\"抽象类或抽象方法用斜体表示\",{\"1\":{\"826\":1}}],[\"抽象类表达式\",{\"1\":{\"644\":1}}],[\"抽象类别\",{\"1\":{\"549\":1}}],[\"抽象类与oop三大特征\",{\"1\":{\"219\":1}}],[\"抽象类与接口之间有什么不同\",{\"0\":{\"189\":1}}],[\"抽象类与接口\",{\"0\":{\"133\":1}}],[\"抽象类中\",{\"1\":{\"812\":1}}],[\"抽象类中的具体方法被调用\",{\"1\":{\"801\":1}}],[\"抽象类中的方法可以是public\",{\"1\":{\"194\":1}}],[\"抽象类中静态成员变量访问类型任意\",{\"1\":{\"194\":1}}],[\"抽象类可以没有抽象方法\",{\"1\":{\"194\":1,\"195\":1}}],[\"抽象类可以有静态方法\",{\"1\":{\"194\":1}}],[\"抽象类可以有普通方法\",{\"1\":{\"194\":1}}],[\"抽象类可以有普通成员变量\",{\"1\":{\"194\":1}}],[\"抽象类可以有构造方法\",{\"1\":{\"194\":1}}],[\"抽象类可以很好的定义一个家族类的默认行为\",{\"1\":{\"189\":1}}],[\"抽象类提供了一种\",{\"1\":{\"133\":1}}],[\"抽象类不能被实例化\",{\"1\":{\"133\":1}}],[\"抽象类和最终类\",{\"0\":{\"195\":1}}],[\"抽象类和接口都可有静态成员变量\",{\"1\":{\"194\":1}}],[\"抽象类和接口有很多不同之处\",{\"1\":{\"189\":1}}],[\"抽象类和普通类最大的区别是\",{\"1\":{\"133\":1}}],[\"抽象类和抽象方法都使用\",{\"1\":{\"133\":1}}],[\"抽象类一般会包含抽象方法\",{\"1\":{\"133\":1}}],[\"抽象类\",{\"1\":{\"133\":1,\"542\":1,\"550\":1,\"779\":1,\"801\":2,\"803\":2}}],[\"抽象类logfactory加载具体实现的步骤如下\",{\"1\":{\"104\":1}}],[\"跟\",{\"1\":{\"972\":1}}],[\"跟随着大写字母\",{\"1\":{\"946\":1}}],[\"跟null和非null无关\",{\"1\":{\"865\":1}}],[\"跟数据库无关\",{\"1\":{\"865\":1}}],[\"跟基于接口而非实现编程思想类似\",{\"1\":{\"818\":1}}],[\"跟阿里云相关的特殊上传\",{\"1\":{\"809\":1}}],[\"跟存储到私有云的流程\",{\"1\":{\"809\":1}}],[\"跟单例模式概念相对应的还有一个多例模式\",{\"1\":{\"773\":1}}],[\"跟踪到drivermanager中之后\",{\"1\":{\"103\":1}}],[\"释放对象\",{\"1\":{\"772\":1}}],[\"入参省略\",{\"1\":{\"772\":1}}],[\"道理是一样的\",{\"1\":{\"769\":1}}],[\"寻找其他方式来实现全局唯一类\",{\"1\":{\"769\":1}}],[\"唯一\",{\"1\":{\"880\":1}}],[\"唯一索引\",{\"1\":{\"864\":1}}],[\"唯一索引名为uk\",{\"1\":{\"863\":1}}],[\"唯一递增生成器的例子\",{\"1\":{\"769\":1}}],[\"唯一不好的是标准库对\",{\"1\":{\"450\":1}}],[\"独立出来一张表\",{\"1\":{\"863\":1}}],[\"独立性\",{\"1\":{\"860\":2}}],[\"独立于\",{\"1\":{\"783\":1}}],[\"独立为函数或者类\",{\"1\":{\"614\":1}}],[\"独享另外一个数据库连接池\",{\"1\":{\"766\":1}}],[\"独享一个数据库连接池\",{\"1\":{\"766\":1}}],[\"慢\",{\"1\":{\"766\":1}}],[\"慢慢提升专注力\",{\"1\":{\"36\":1}}],[\"频繁访问数据库或文件的对象\",{\"1\":{\"761\":1,\"762\":1}}],[\"频繁的进行创建和销毁的对象\",{\"1\":{\"761\":1}}],[\"节约索引存储\",{\"1\":{\"863\":1}}],[\"节省了系统资源\",{\"1\":{\"761\":1}}],[\"节点和叶子有很多差异性的话\",{\"1\":{\"576\":1}}],[\"双精度浮点数的尾数位只有\",{\"1\":{\"854\":1}}],[\"双分派意味着得到执行的操作取决于请求的种类和两个接收者的类型\",{\"1\":{\"839\":1}}],[\"双分派\",{\"1\":{\"839\":2}}],[\"双向一对一关系\",{\"1\":{\"830\":1}}],[\"双向的关联可以用\",{\"1\":{\"830\":1}}],[\"双重检查\",{\"0\":{\"757\":1},\"1\":{\"751\":1,\"757\":1}}],[\"双亲委托加载\",{\"1\":{\"310\":1}}],[\"懒汉式2\",{\"1\":{\"755\":1,\"756\":1}}],[\"懒汉式1\",{\"1\":{\"754\":1}}],[\"懒汉式\",{\"0\":{\"754\":1,\"755\":1,\"756\":1},\"1\":{\"751\":3,\"754\":1,\"755\":1,\"756\":1,\"757\":1}}],[\"懒加载的实现是\",{\"1\":{\"114\":1}}],[\"饿汉式\",{\"0\":{\"752\":1,\"753\":1},\"1\":{\"751\":2,\"752\":2,\"753\":1,\"760\":1}}],[\"黑名单用户\",{\"1\":{\"874\":1}}],[\"黑箱\",{\"1\":{\"747\":1}}],[\"黑色\",{\"1\":{\"687\":1}}],[\"白箱\",{\"1\":{\"747\":1}}],[\"白色的箭头是聚合\",{\"1\":{\"832\":1}}],[\"白色\",{\"1\":{\"684\":1,\"685\":1,\"687\":1}}],[\"点分隔符\",{\"1\":{\"907\":1,\"911\":1}}],[\"点分隔符之间有且仅有一个自然语义的英语单词\",{\"1\":{\"845\":1}}],[\"点击登录\",{\"1\":{\"871\":1}}],[\"点击\",{\"1\":{\"826\":1}}],[\"点\",{\"1\":{\"741\":1,\"809\":1,\"847\":1}}],[\"点一份\",{\"1\":{\"584\":1}}],[\"紧接着写单元测试\",{\"1\":{\"991\":1}}],[\"紧随着它之前的内容\",{\"1\":{\"907\":1}}],[\"紧耦合\",{\"1\":{\"741\":2}}],[\"紧密集成的元组功能\",{\"1\":{\"469\":1}}],[\"松耦合\",{\"1\":{\"741\":4,\"816\":5,\"817\":1,\"818\":2}}],[\"陌生的类最好不要以局部变量的形式出现在类的内部\",{\"1\":{\"741\":1}}],[\"已收货等\",{\"1\":{\"871\":1}}],[\"已发货\",{\"1\":{\"871\":1}}],[\"已发布\",{\"1\":{\"779\":1}}],[\"已发布状态类\",{\"1\":{\"779\":1}}],[\"已完结\",{\"1\":{\"779\":1}}],[\"已完结状态类\",{\"1\":{\"779\":1}}],[\"已付款\",{\"1\":{\"779\":1,\"871\":1}}],[\"已付款状态类\",{\"1\":{\"779\":1}}],[\"已审核\",{\"1\":{\"779\":1}}],[\"已审核状态类\",{\"1\":{\"779\":1}}],[\"已有的代码来实现变化\",{\"1\":{\"736\":1}}],[\"已经说明了这是在干什么\",{\"1\":{\"853\":1}}],[\"已经扣取过了积分\",{\"1\":{\"778\":1}}],[\"已经扣除了积分\",{\"1\":{\"778\":1}}],[\"已经实现\",{\"1\":{\"650\":1}}],[\"已经存在\",{\"1\":{\"632\":1}}],[\"已经是建造者\",{\"1\":{\"556\":1}}],[\"已经有了自己的新的\",{\"1\":{\"470\":1}}],[\"梅耶\",{\"1\":{\"736\":1}}],[\"求和\",{\"1\":{\"734\":2}}],[\"求出left\",{\"1\":{\"644\":1}}],[\"思考\",{\"1\":{\"848\":1}}],[\"思考问题和解决思路\",{\"1\":{\"734\":1}}],[\"思路\",{\"1\":{\"609\":1,\"613\":2,\"702\":1,\"739\":1}}],[\"思路分析和图解\",{\"1\":{\"574\":1}}],[\"思路分析和类图\",{\"1\":{\"562\":1,\"644\":1,\"659\":1,\"667\":1,\"710\":1,\"778\":1,\"802\":1,\"839\":1}}],[\"思路分析图解\",{\"1\":{\"555\":1,\"613\":1,\"695\":1}}],[\"思路分析\",{\"1\":{\"524\":1,\"528\":1,\"553\":1,\"609\":1,\"685\":1,\"789\":1}}],[\"换成\",{\"1\":{\"850\":1}}],[\"换行的主要目的是为了拥有清晰的代码\",{\"1\":{\"907\":1}}],[\"换行的典型原因是为了避免代码超出了列数的限制\",{\"1\":{\"906\":1}}],[\"换行指令的主要内容是\",{\"1\":{\"907\":1}}],[\"换行\",{\"0\":{\"906\":1},\"1\":{\"891\":1,\"905\":1,\"906\":1,\"928\":1}}],[\"换行缩进至少\",{\"0\":{\"908\":1}}],[\"换行缩进\",{\"1\":{\"847\":1}}],[\"换行时遵循如下原则\",{\"1\":{\"847\":1}}],[\"换句话说\",{\"1\":{\"732\":1}}],[\"换个案例\",{\"1\":{\"617\":1}}],[\"侵入性\",{\"1\":{\"731\":1}}],[\"雪梨电视机\",{\"1\":{\"728\":2}}],[\"冰糖电视机\",{\"1\":{\"728\":2}}],[\"冰箱\",{\"1\":{\"562\":1}}],[\"行时\",{\"1\":{\"852\":1}}],[\"行\",{\"1\":{\"847\":2}}],[\"行代码\",{\"1\":{\"742\":1,\"743\":1}}],[\"行的参数类型\",{\"1\":{\"727\":1}}],[\"行为类\",{\"1\":{\"839\":1}}],[\"行为决定状态\",{\"1\":{\"591\":1}}],[\"行为型访问者模式\",{\"0\":{\"836\":1}}],[\"行为型模板方法模式\",{\"0\":{\"799\":1}}],[\"行为型模式\",{\"1\":{\"798\":2}}],[\"行为型策略模式\",{\"0\":{\"782\":1}}],[\"行为型状态模式\",{\"0\":{\"774\":1}}],[\"行为型职责链模式\",{\"0\":{\"706\":1}}],[\"行为型观察者模式\",{\"0\":{\"670\":1}}],[\"行为型备忘录模式\",{\"0\":{\"662\":1}}],[\"行为型中介模式\",{\"0\":{\"654\":1}}],[\"行为型迭代器模式\",{\"0\":{\"647\":1}}],[\"行为型解释器模式\",{\"0\":{\"640\":1}}],[\"行为型设计模式\",{\"0\":{\"591\":1}}],[\"行为型命令模式\",{\"0\":{\"559\":1}}],[\"彼此无法分离\",{\"1\":{\"727\":1}}],[\"细分成若干二级子目录\",{\"1\":{\"843\":1}}],[\"细节的方法\",{\"1\":{\"809\":1}}],[\"细节是魔鬼\",{\"1\":{\"809\":1}}],[\"细节就是具体的实现类\",{\"1\":{\"725\":1}}],[\"细节应该依赖抽象\",{\"1\":{\"725\":1}}],[\"细粒度和共享对象\",{\"1\":{\"631\":1}}],[\"遵从一致的上传功能协议\",{\"1\":{\"809\":1}}],[\"遵守开闭原则的软件\",{\"1\":{\"737\":1}}],[\"遵守了\",{\"1\":{\"678\":1}}],[\"遵循如下规则\",{\"1\":{\"850\":1}}],[\"遵循其它原则\",{\"1\":{\"739\":1}}],[\"遵循里氏替换原则\",{\"1\":{\"732\":1}}],[\"遵循接口隔离原则有以下\",{\"1\":{\"722\":1}}],[\"拆分为独立的几个接口\",{\"1\":{\"721\":1,\"723\":1}}],[\"拆箱操作时候的警告\",{\"1\":{\"225\":1}}],[\"拆箱\",{\"1\":{\"119\":1}}],[\"轮船\",{\"1\":{\"718\":1}}],[\"轮胎等部件也多种多样\",{\"1\":{\"549\":1}}],[\"天时\",{\"1\":{\"849\":1}}],[\"天\",{\"1\":{\"849\":2,\"859\":1}}],[\"天空运行\",{\"1\":{\"718\":1}}],[\"天气情况变化\",{\"1\":{\"676\":1}}],[\"天气情况\",{\"1\":{\"676\":1,\"678\":2}}],[\"天气预报项目需求\",{\"0\":{\"673\":1}}],[\"摩托车\",{\"1\":{\"718\":2}}],[\"摩斯密码\",{\"1\":{\"591\":1}}],[\"陆地\",{\"1\":{\"718\":1}}],[\"汽车\",{\"1\":{\"718\":4}}],[\"至\",{\"1\":{\"848\":1}}],[\"至少\",{\"1\":{\"959\":1}}],[\"至少要达到range级别\",{\"1\":{\"864\":1}}],[\"至少说明还有人关心它\",{\"1\":{\"820\":1}}],[\"至少存在以下两个缺点\",{\"1\":{\"716\":1}}],[\"至于什么时候\",{\"1\":{\"810\":1}}],[\"至于应该变成哪个状态\",{\"1\":{\"779\":1}}],[\"至于都要加载哪些类\",{\"1\":{\"627\":1}}],[\"至于该异常被捕获还是继续抛出都与它无关\",{\"1\":{\"260\":1}}],[\"至于c语言中的内存复制\",{\"1\":{\"93\":1}}],[\"至于这么写有什么好处\",{\"1\":{\"89\":1}}],[\"至于为啥要写出同事看不懂的代码\",{\"1\":{\"88\":1}}],[\"于\",{\"1\":{\"716\":1}}],[\"于是这个一行代码的改动就导致了一个\",{\"1\":{\"912\":1}}],[\"于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链\",{\"1\":{\"707\":1}}],[\"于是新的对象更加全面\",{\"1\":{\"699\":1,\"702\":1}}],[\"于是需要\",{\"1\":{\"699\":1,\"702\":1}}],[\"于是我们需要重新造出一个对象\",{\"1\":{\"699\":1,\"702\":1}}],[\"于是很多人为了多睡一会\",{\"1\":{\"579\":1}}],[\"于是jvm采用了一个特殊的方法\",{\"1\":{\"291\":1}}],[\"马丁\",{\"1\":{\"716\":1}}],[\"倒置\",{\"1\":{\"714\":1,\"725\":1}}],[\"佟校长\",{\"1\":{\"710\":1}}],[\"王副校\",{\"1\":{\"710\":1}}],[\"李院长\",{\"1\":{\"710\":1}}],[\"李兴华\",{\"1\":{\"280\":1}}],[\"张主任\",{\"1\":{\"710\":1}}],[\"班级管理者\",{\"1\":{\"710\":1}}],[\"权力第四\",{\"1\":{\"710\":1}}],[\"权力第三\",{\"1\":{\"710\":1}}],[\"权力第二\",{\"1\":{\"710\":1}}],[\"权力最大\",{\"1\":{\"710\":1}}],[\"权限认证\",{\"1\":{\"427\":1}}],[\"权限认证框架\",{\"1\":{\"427\":1}}],[\"权限检测\",{\"1\":{\"310\":1}}],[\"责任分担\",{\"1\":{\"707\":1}}],[\"责任链模式通常在以下几种情况使用\",{\"1\":{\"712\":1}}],[\"责任链模式的独到之处是将其节点处理者组合成了链式结构\",{\"1\":{\"708\":1}}],[\"责任链模式的本质是\",{\"1\":{\"708\":1}}],[\"责任链模式\",{\"1\":{\"591\":1,\"707\":1}}],[\"依然不会影响主干流程继续进行\",{\"1\":{\"871\":1}}],[\"依据hashcode和equals进行判断\",{\"1\":{\"850\":1}}],[\"依据约束力强弱及故障敏感性\",{\"1\":{\"843\":1}}],[\"依此类推\",{\"1\":{\"707\":1,\"868\":1}}],[\"依赖springframework\",{\"1\":{\"869\":1}}],[\"依赖于一个二方库群时\",{\"1\":{\"869\":1}}],[\"依赖于特定的平台\",{\"1\":{\"151\":1}}],[\"依赖性强\",{\"1\":{\"832\":1}}],[\"依赖具体的实现\",{\"1\":{\"809\":1}}],[\"依赖来解决问题\",{\"1\":{\"732\":1}}],[\"依赖类\",{\"1\":{\"721\":2,\"723\":4}}],[\"依赖倒置原则\",{\"1\":{\"748\":1}}],[\"依赖倒置原则可以提高代码的可读性和可维护性\",{\"1\":{\"726\":1}}],[\"依赖倒置原则可以提高系统的稳定性\",{\"1\":{\"726\":1}}],[\"依赖倒置原则可以减少并行开发引起的风险\",{\"1\":{\"726\":1}}],[\"依赖倒置原则可以降低类间的耦合性\",{\"1\":{\"726\":1}}],[\"依赖倒置原则的主要作用如下\",{\"1\":{\"726\":1}}],[\"依赖倒置原则和里氏替换原则\",{\"1\":{\"612\":1}}],[\"依赖倒转原则的注意事项和细节\",{\"0\":{\"729\":1}}],[\"依赖倒转原则的作用\",{\"0\":{\"726\":1}}],[\"依赖倒转原则是基于这样的设计理念\",{\"1\":{\"725\":1}}],[\"依赖倒转原则\",{\"0\":{\"724\":1},\"1\":{\"725\":1,\"748\":1}}],[\"依赖倒转\",{\"1\":{\"714\":1,\"725\":1}}],[\"依赖\",{\"1\":{\"622\":1,\"723\":4,\"741\":1,\"822\":1,\"826\":1,\"828\":1,\"835\":1}}],[\"依赖趋同插件构建时将会报错\",{\"1\":{\"459\":1}}],[\"依赖注入也是将代码之间的强耦合变为弱耦合\",{\"1\":{\"818\":1}}],[\"依赖注入框架\",{\"1\":{\"620\":1}}],[\"依赖注入\",{\"0\":{\"397\":1},\"1\":{\"769\":1,\"818\":2}}],[\"依赖关系使用\",{\"1\":{\"828\":1}}],[\"依赖关系简单\",{\"1\":{\"816\":1}}],[\"依赖关系传递的三种方式和应用案例\",{\"0\":{\"728\":1}}],[\"依赖关系是在运行过程中起作用的\",{\"1\":{\"218\":1}}],[\"依赖关系\",{\"0\":{\"218\":1,\"828\":1},\"1\":{\"827\":1}}],[\"员工必须根据需要请假的天数去找不同的领导签名\",{\"1\":{\"707\":1}}],[\"副总经理\",{\"1\":{\"707\":1}}],[\"职责\",{\"1\":{\"716\":2}}],[\"职责链类\",{\"1\":{\"710\":1}}],[\"职责链建立的合理性要靠客户端来保证\",{\"1\":{\"707\":1}}],[\"职责链简化了对象之间的连接\",{\"1\":{\"707\":1}}],[\"职责链模式简化了对象\",{\"1\":{\"711\":1}}],[\"职责链模式将请求和处理分开\",{\"1\":{\"711\":1}}],[\"职责链模式的应用场景\",{\"0\":{\"712\":1}}],[\"职责链模式的注意事项和细节\",{\"0\":{\"711\":1}}],[\"职责链模式的结构与实现\",{\"0\":{\"708\":1}}],[\"职责链模式解决采购审批项目\",{\"0\":{\"710\":1}}],[\"职责链模式主要包含以下角色\",{\"1\":{\"708\":1}}],[\"职责链模式\",{\"1\":{\"707\":1,\"709\":1,\"798\":1}}],[\"职责链模式基本介绍\",{\"0\":{\"707\":1}}],[\"职责过重\",{\"1\":{\"608\":1}}],[\"延迟对目标的加载\",{\"1\":{\"705\":1}}],[\"延迟加载\",{\"1\":{\"705\":1,\"757\":1}}],[\"延时消息\",{\"1\":{\"546\":1}}],[\"智能指引\",{\"1\":{\"705\":1}}],[\"智能家具抽象类\",{\"1\":{\"659\":1}}],[\"智能家具类\",{\"1\":{\"659\":1}}],[\"智能家具包括各种设备\",{\"1\":{\"657\":1}}],[\"智能家具项目\",{\"0\":{\"657\":1}}],[\"远程调用返回对象时\",{\"1\":{\"858\":1}}],[\"远程调用失败\",{\"1\":{\"848\":1}}],[\"远程对象的本地代表\",{\"1\":{\"704\":1}}],[\"远程代理通过网络和真正的远程对象沟通信息\",{\"1\":{\"704\":1}}],[\"远程代理\",{\"1\":{\"704\":1,\"705\":1}}],[\"远近高低各不同\",{\"1\":{\"591\":1}}],[\"触发\",{\"1\":{\"703\":1}}],[\"父集合元素的增加或删除异常等\",{\"1\":{\"872\":1}}],[\"父接口\",{\"1\":{\"702\":1}}],[\"父类成员变量名相同\",{\"1\":{\"845\":1}}],[\"父类与子类高度耦合\",{\"1\":{\"818\":1}}],[\"父类中的抽象方法由子类实现\",{\"1\":{\"800\":1}}],[\"父类中凡是已经实现好的方法\",{\"1\":{\"731\":1}}],[\"父类对子类是透明的\",{\"1\":{\"747\":1}}],[\"父类代码侵入子类\",{\"1\":{\"545\":1}}],[\"父类封装共性\",{\"1\":{\"545\":1}}],[\"父类没有加载到时\",{\"1\":{\"310\":1}}],[\"父类在后面\",{\"1\":{\"297\":1}}],[\"父类的\",{\"1\":{\"976\":1}}],[\"父类的每一次改动都会影响所有的子类\",{\"1\":{\"818\":1}}],[\"父类的父类的代码\",{\"1\":{\"812\":1}}],[\"父类的父类的公共字段也打印出来了\",{\"1\":{\"305\":1}}],[\"父类的模板方法确保了算法的结构保持不变\",{\"1\":{\"804\":1}}],[\"父类的模板方法和已实现的某些步骤会被子类继承而直接使用\",{\"1\":{\"804\":1}}],[\"父类的实现的任何改变都会导致子类的实现发生变化\",{\"1\":{\"747\":1}}],[\"父类的类型是object\",{\"1\":{\"291\":1}}],[\"父类的的泛型类型全部变为了原始类型object\",{\"1\":{\"291\":1}}],[\"父类引用指向子类对象称为\",{\"1\":{\"210\":1}}],[\"父类\",{\"1\":{\"144\":3,\"305\":1,\"976\":2}}],[\"~~~\",{\"1\":{\"789\":3}}],[\"~~~使用迪米特法则的改进~~~\",{\"1\":{\"743\":1}}],[\"~~北京鸭~~~\",{\"1\":{\"787\":1,\"789\":1}}],[\"~~\",{\"1\":{\"700\":1,\"703\":4}}],[\"~modifier\",{\"1\":{\"91\":1}}],[\"造出新的对象\",{\"1\":{\"699\":1}}],[\"造成获取用户cookie\",{\"1\":{\"861\":1}}],[\"造成其它线程无法成功获取锁\",{\"1\":{\"851\":1}}],[\"造成线上故障\",{\"1\":{\"849\":1}}],[\"造成内存资源浪费\",{\"1\":{\"848\":1}}],[\"造成内存浪费\",{\"1\":{\"752\":1}}],[\"造成误解\",{\"1\":{\"846\":1}}],[\"造成原有功能出现错误\",{\"1\":{\"734\":1}}],[\"造成服务器的资源浪费\",{\"1\":{\"635\":1}}],[\"造成工厂角色无法形成基于继承的等级结构\",{\"1\":{\"608\":1}}],[\"研究旧对象和其父亲的基因\",{\"1\":{\"699\":1}}],[\"母亲\",{\"1\":{\"699\":1,\"702\":1}}],[\"旧对象\",{\"1\":{\"699\":1}}],[\"授课方法\",{\"1\":{\"700\":1}}],[\"授课的方法\",{\"1\":{\"695\":1}}],[\"授权已过期\",{\"1\":{\"874\":1}}],[\"授权委托书\",{\"1\":{\"591\":1}}],[\"授权\",{\"1\":{\"427\":1}}],[\"授权或会话管理的函数库\",{\"1\":{\"427\":1}}],[\"特定结构\",{\"0\":{\"914\":1}}],[\"特殊情况\",{\"0\":{\"960\":1,\"961\":1},\"1\":{\"901\":1,\"905\":1,\"910\":2,\"917\":1,\"925\":1,\"929\":1,\"949\":1,\"950\":1}}],[\"特殊转义序列\",{\"0\":{\"884\":1},\"1\":{\"884\":1}}],[\"特殊字符\",{\"0\":{\"882\":1}}],[\"特殊时间点\",{\"1\":{\"860\":1}}],[\"特殊取值\",{\"1\":{\"860\":1}}],[\"特殊注释标记\",{\"1\":{\"853\":1}}],[\"特别是删除或修改记录操作\",{\"1\":{\"865\":1}}],[\"特别是一些复杂的继承关系\",{\"1\":{\"813\":1}}],[\"特别是运行多态比较频繁的时候\",{\"1\":{\"734\":1}}],[\"特别是在链比较长的时候\",{\"1\":{\"711\":1}}],[\"特别提醒\",{\"1\":{\"695\":1}}],[\"特性的支持不友好\",{\"0\":{\"764\":1}}],[\"特性在新窗口打开\",{\"1\":{\"150\":1}}],[\"特性\",{\"0\":{\"149\":1},\"1\":{\"264\":1,\"769\":1}}],[\"宋江\",{\"1\":{\"689\":1}}],[\"推荐分层结构如图所示\",{\"1\":{\"868\":1}}],[\"推荐对日志进行分类\",{\"1\":{\"859\":1}}],[\"推荐业界已定义过的自定义异常\",{\"1\":{\"858\":1}}],[\"推荐操作等\",{\"1\":{\"854\":1}}],[\"推荐使用这些转义序列\",{\"1\":{\"884\":1}}],[\"推荐使用这种单例设计模式\",{\"1\":{\"757\":1}}],[\"推荐使用订单号\",{\"1\":{\"859\":1}}],[\"推荐使用slf4j\",{\"1\":{\"859\":1}}],[\"推荐使用复数\",{\"1\":{\"854\":1}}],[\"推荐使用longadder对象\",{\"1\":{\"851\":1}}],[\"推荐使用乐观锁\",{\"1\":{\"851\":1}}],[\"推荐使用instant类\",{\"1\":{\"849\":1}}],[\"推荐使用equals方法进行判断\",{\"1\":{\"848\":1}}],[\"推荐使用jdk7引入的工具类java\",{\"1\":{\"848\":1}}],[\"推荐使用\",{\"1\":{\"757\":1,\"758\":2,\"759\":1}}],[\"推荐\",{\"0\":{\"913\":1},\"1\":{\"689\":3,\"759\":1,\"843\":1,\"845\":5,\"846\":3,\"847\":3,\"848\":9,\"849\":2,\"850\":4,\"851\":4,\"852\":7,\"853\":3,\"854\":3,\"855\":3,\"857\":2,\"858\":3,\"859\":4,\"860\":7,\"861\":1,\"863\":5,\"864\":6,\"865\":2,\"866\":1,\"868\":1,\"869\":4,\"870\":6,\"871\":8,\"947\":1}}],[\"蒙古羊\",{\"1\":{\"687\":1}}],[\"效率就非常的低下\",{\"1\":{\"864\":1}}],[\"效率更高\",{\"1\":{\"850\":1}}],[\"效率高\",{\"1\":{\"758\":1}}],[\"效率较高\",{\"1\":{\"757\":1}}],[\"效率较低\",{\"1\":{\"686\":1}}],[\"效率可能降低\",{\"1\":{\"645\":1}}],[\"羊属性完全相同的\",{\"1\":{\"684\":1}}],[\"颜色为\",{\"1\":{\"684\":1}}],[\"浅谈单元测试\",{\"0\":{\"988\":1}}],[\"浅克隆需要运用得当\",{\"1\":{\"682\":1}}],[\"浅拷贝是使用默认的\",{\"1\":{\"689\":1}}],[\"浅拷贝会直接进行值传递\",{\"1\":{\"689\":1}}],[\"浅拷贝的介绍\",{\"1\":{\"689\":1}}],[\"浅拷贝和深拷贝\",{\"0\":{\"689\":1}}],[\"浅拷贝\",{\"1\":{\"141\":1}}],[\"跨站请求伪造是一类常见编程漏洞\",{\"1\":{\"861\":1}}],[\"跨应用间rpc调用优先考虑使用result方式\",{\"1\":{\"858\":1}}],[\"跨应用共享常量\",{\"1\":{\"846\":2}}],[\"跨越两种观察者类型\",{\"1\":{\"680\":1}}],[\"跨平台im客户端\",{\"1\":{\"414\":1}}],[\"跨平台xmpp客户端函数库\",{\"1\":{\"414\":1}}],[\"含有\",{\"1\":{\"678\":1}}],[\"含有一个\",{\"1\":{\"651\":1}}],[\"百度网站\",{\"1\":{\"678\":3}}],[\"温度\",{\"1\":{\"676\":1,\"678\":2}}],[\"气温\",{\"1\":{\"678\":1}}],[\"气压\",{\"1\":{\"676\":1,\"678\":3}}],[\"气压和湿度的接口\",{\"1\":{\"673\":1}}],[\"气压等等以公告的形式发布出去\",{\"1\":{\"673\":1}}],[\"气象站通过调用\",{\"1\":{\"675\":1}}],[\"气象站可以将每天测量到的温度\",{\"1\":{\"673\":1}}],[\"气象局的天气预报与听众\",{\"1\":{\"671\":1}}],[\"湿度\",{\"1\":{\"673\":1,\"676\":1,\"678\":3}}],[\"影响范围极小的api不兼容修改\",{\"1\":{\"869\":1}}],[\"影响可读性\",{\"1\":{\"865\":1}}],[\"影响查询性能\",{\"1\":{\"864\":1}}],[\"影响到上层业务\",{\"1\":{\"858\":1}}],[\"影响到其他\",{\"1\":{\"766\":1}}],[\"影响的范围是非常有限的\",{\"1\":{\"816\":1}}],[\"影响程序的效率\",{\"1\":{\"671\":1}}],[\"影院的\",{\"1\":{\"601\":1}}],[\"影院管理项目类图\",{\"1\":{\"601\":1}}],[\"影院管理项目\",{\"0\":{\"597\":1}}],[\"订购数量为空\",{\"1\":{\"874\":1}}],[\"订阅模式\",{\"1\":{\"671\":1}}],[\"订单已关闭\",{\"1\":{\"874\":1}}],[\"订单生成\",{\"1\":{\"779\":1}}],[\"订单生成状态类\",{\"1\":{\"779\":1}}],[\"订单\",{\"1\":{\"764\":1}}],[\"订单状态跟踪\",{\"1\":{\"591\":1}}],[\"订单分析图\",{\"1\":{\"584\":1}}],[\"股票价格与股民\",{\"1\":{\"671\":1}}],[\"遇到绿灯会行\",{\"1\":{\"671\":1}}],[\"遇到红灯会停\",{\"1\":{\"671\":1}}],[\"遇到困难时\",{\"1\":{\"36\":1}}],[\"遇到困难\",{\"1\":{\"36\":1}}],[\"势必会占用比较大的资源\",{\"1\":{\"668\":1}}],[\"恢复现场\",{\"1\":{\"972\":1}}],[\"恢复后的状态\",{\"1\":{\"667\":1}}],[\"恢复\",{\"1\":{\"667\":1}}],[\"恢复状态\",{\"1\":{\"664\":2}}],[\"守护者对象\",{\"1\":{\"667\":1}}],[\"防火墙代理\",{\"1\":{\"704\":1}}],[\"防御力\",{\"1\":{\"667\":2}}],[\"防止因字段类型不同造成的隐式转换\",{\"1\":{\"864\":1}}],[\"防止sql注入\",{\"1\":{\"861\":1}}],[\"防止隐私泄露\",{\"1\":{\"861\":1}}],[\"防止没有做水平权限校验就可随意访问\",{\"1\":{\"861\":1}}],[\"防止npe\",{\"1\":{\"858\":2}}],[\"防止子类重写模板方法\",{\"1\":{\"804\":1}}],[\"防止继承泛滥\",{\"1\":{\"748\":1}}],[\"防止\",{\"1\":{\"732\":1,\"752\":1}}],[\"防止动态运行时不匹配问题的出现\",{\"1\":{\"206\":1}}],[\"防止程序员在管理内存时容易产生的错误\",{\"1\":{\"206\":1}}],[\"游戏角色当前的攻击力\",{\"1\":{\"667\":1}}],[\"游戏角色有攻击力和防御力\",{\"1\":{\"665\":1}}],[\"游戏角色状态恢复问题\",{\"0\":{\"665\":1}}],[\"游戏开发框架\",{\"1\":{\"404\":1}}],[\"游戏开发\",{\"0\":{\"404\":1}}],[\"棋类游戏中的悔棋功能等都属于这类\",{\"1\":{\"663\":1}}],[\"记忆技巧\",{\"1\":{\"835\":1}}],[\"记事本\",{\"1\":{\"663\":1,\"669\":1}}],[\"记录日志时请思考\",{\"1\":{\"859\":1}}],[\"记录日志并再次抛出的逻辑\",{\"1\":{\"270\":1}}],[\"记录当前时刻的内部状态信息\",{\"1\":{\"664\":1}}],[\"记录遍历的当前位置\",{\"1\":{\"649\":1}}],[\"记录这次的操作\",{\"1\":{\"562\":2}}],[\"记录\",{\"1\":{\"560\":1}}],[\"记录应用程序行为日志的开发库\",{\"1\":{\"412\":1}}],[\"记录本地异常日志\",{\"1\":{\"242\":1}}],[\"闹铃响起\",{\"1\":{\"657\":1}}],[\"闹钟\",{\"1\":{\"591\":1,\"657\":1,\"659\":1}}],[\"窗帘\",{\"1\":{\"659\":1}}],[\"窗帘自动落下\",{\"1\":{\"657\":1}}],[\"窗帘等\",{\"1\":{\"657\":1}}],[\"窗体程序中的简单控件与容器控件等\",{\"1\":{\"567\":1}}],[\"聊天程序的\",{\"1\":{\"655\":1}}],[\"视图的职责是展示\",{\"1\":{\"855\":1}}],[\"视图模式\",{\"1\":{\"671\":1}}],[\"视图\",{\"1\":{\"655\":1}}],[\"房屋中介\",{\"1\":{\"655\":1}}],[\"房子\",{\"1\":{\"554\":1,\"555\":2}}],[\"房子有各种各样的\",{\"1\":{\"552\":1}}],[\"星形结构\",{\"1\":{\"655\":1}}],[\"星巴克咖啡订单项目\",{\"0\":{\"581\":1}}],[\"牵一发而动全身\",{\"1\":{\"655\":1,\"741\":1,\"818\":1}}],[\"朋友中如果有人的电话修改了\",{\"1\":{\"655\":1}}],[\"朋友圈\",{\"1\":{\"591\":1}}],[\"她提出\",{\"1\":{\"732\":1}}],[\"她\",{\"1\":{\"655\":2}}],[\"索引等\",{\"1\":{\"871\":1}}],[\"索引宁滥勿缺\",{\"1\":{\"864\":1}}],[\"索引物理文件全扫描\",{\"1\":{\"864\":1}}],[\"索引a\",{\"1\":{\"864\":1}}],[\"索引如果存在范围查询\",{\"1\":{\"864\":1}}],[\"索引文件具有b\",{\"1\":{\"864\":1}}],[\"索引长度\",{\"1\":{\"864\":1}}],[\"索引的长度与区分度是一对矛盾体\",{\"1\":{\"864\":1}}],[\"索引规约\",{\"0\":{\"864\":1}}],[\"索引\",{\"1\":{\"650\":1,\"864\":1}}],[\"韶关学院\",{\"1\":{\"649\":1}}],[\"华山版\",{\"1\":{\"872\":1}}],[\"华南理工\",{\"1\":{\"649\":1}}],[\"华为系列工厂\",{\"1\":{\"617\":1}}],[\"华为工厂\",{\"1\":{\"617\":2}}],[\"华为路由器\",{\"1\":{\"617\":2}}],[\"华为手机打电话\",{\"1\":{\"617\":1}}],[\"华为手机发送消息\",{\"1\":{\"617\":1}}],[\"华为手机\",{\"1\":{\"617\":2}}],[\"物流系统中的传送带\",{\"1\":{\"648\":1}}],[\"键值对\",{\"1\":{\"644\":1}}],[\"键盘\",{\"1\":{\"549\":1}}],[\"环境角色使用这个接口调用不同的算法\",{\"1\":{\"784\":1}}],[\"环境上下文\",{\"1\":{\"779\":1}}],[\"环境上下文类\",{\"1\":{\"779\":1}}],[\"环境类\",{\"1\":{\"642\":1,\"776\":2,\"784\":1}}],[\"环境\",{\"1\":{\"642\":1,\"784\":1}}],[\"环绕立体声\",{\"1\":{\"597\":1,\"601\":2}}],[\"终极版\",{\"1\":{\"872\":1}}],[\"终端显示层\",{\"1\":{\"868\":1}}],[\"终止发放奖品\",{\"1\":{\"852\":1}}],[\"终止程序\",{\"1\":{\"260\":1}}],[\"终结符表达式类\",{\"1\":{\"642\":1}}],[\"终结符表达式\",{\"1\":{\"642\":1}}],[\"汉语中的句子有很多\",{\"1\":{\"641\":1}}],[\"句子\",{\"1\":{\"641\":1}}],[\"元\",{\"1\":{\"638\":1}}],[\"元注解和获取注解的反射接口后\",{\"1\":{\"234\":1}}],[\"元注解是用于定义注解的注解\",{\"1\":{\"221\":1}}],[\"元注解\",{\"0\":{\"226\":1,\"227\":1,\"228\":1,\"229\":1,\"230\":1,\"231\":1,\"232\":1},\"1\":{\"221\":1}}],[\"享\",{\"1\":{\"638\":1}}],[\"享元工厂角色\",{\"1\":{\"632\":1}}],[\"享元工厂检査系统中是否存在符合要求的享元对象\",{\"1\":{\"632\":1}}],[\"享元工厂\",{\"1\":{\"632\":1}}],[\"享元模式是通过减少内存中对象的数量来节省内存空间的\",{\"1\":{\"639\":1}}],[\"享元模式是池技术的重要实现方式\",{\"1\":{\"629\":1}}],[\"享元模式同样要求创建一个或一组对象\",{\"1\":{\"639\":1}}],[\"享元模式其实是\",{\"1\":{\"639\":1}}],[\"享元模式经典的应用场景是需要缓冲池的场景\",{\"1\":{\"638\":1}}],[\"享元模式经典的应用场景就是池技术了\",{\"1\":{\"629\":1}}],[\"享元模式提高了系统的复杂度\",{\"1\":{\"638\":1}}],[\"享元模式大大减少了对象的创建\",{\"1\":{\"638\":1}}],[\"享元模式解决网站展现项目\",{\"0\":{\"636\":1}}],[\"享元模式的应用场景\",{\"0\":{\"639\":1}}],[\"享元模式的注意事项和细节\",{\"0\":{\"638\":1}}],[\"享元模式的主要角色有如下\",{\"1\":{\"632\":1}}],[\"享元模式的本质是缓存共享对象\",{\"1\":{\"631\":1}}],[\"享元模式的定义提出了两个要求\",{\"1\":{\"631\":1}}],[\"享元模式的结构与实现\",{\"0\":{\"630\":1}}],[\"享元模式能够解决重复对象的内存浪费的问题\",{\"1\":{\"629\":1}}],[\"享元模式基本介绍\",{\"0\":{\"629\":1}}],[\"享元模式\",{\"1\":{\"590\":1,\"629\":1,\"635\":1,\"798\":1}}],[\"范围爆炸\",{\"1\":{\"912\":1}}],[\"范围在\",{\"1\":{\"637\":1}}],[\"范围类\",{\"1\":{\"637\":1}}],[\"博客\",{\"1\":{\"636\":3}}],[\"池中有多少个网站类型\",{\"1\":{\"636\":1}}],[\"池某种程度上实现\",{\"1\":{\"186\":1}}],[\"初始状态\",{\"1\":{\"664\":1}}],[\"初始\",{\"1\":{\"632\":2}}],[\"初始化时传入活动引用\",{\"1\":{\"778\":3}}],[\"初始化奖品的数量\",{\"1\":{\"778\":1}}],[\"初始化当前的状态为\",{\"1\":{\"778\":1}}],[\"初始化类的实例\",{\"1\":{\"753\":1}}],[\"初始化一个对象特别复杂\",{\"1\":{\"558\":1}}],[\"初始化是通过override父类方法来进行\",{\"1\":{\"241\":1}}],[\"初始化顺序为\",{\"1\":{\"144\":1}}],[\"初始化顺序\",{\"1\":{\"144\":1}}],[\"密码强度不够\",{\"1\":{\"874\":1}}],[\"密码长度不够\",{\"1\":{\"874\":1}}],[\"密码校验失败\",{\"1\":{\"874\":1}}],[\"密码\",{\"1\":{\"631\":1}}],[\"密码加密的文章\",{\"0\":{\"7\":1}}],[\"落子颜色是定的\",{\"1\":{\"631\":1}}],[\"跳棋颜色多一点\",{\"1\":{\"631\":1}}],[\"跳棋\",{\"1\":{\"631\":1}}],[\"缓冲池等等都是享元模式的应用\",{\"1\":{\"629\":1}}],[\"缓存服务超时\",{\"1\":{\"874\":1}}],[\"缓存服务出错\",{\"1\":{\"874\":1}}],[\"缓存击穿\",{\"1\":{\"861\":1}}],[\"缓存有利于减少交互次数\",{\"1\":{\"854\":1}}],[\"缓存相关常量放在类cacheconsts下\",{\"1\":{\"846\":1}}],[\"缓存代理\",{\"1\":{\"704\":1}}],[\"缓存到内存当中\",{\"1\":{\"466\":1}}],[\"缓存函数或者其他任何你想要缓存的内容\",{\"1\":{\"466\":1}}],[\"缓存\",{\"1\":{\"432\":2}}],[\"缓存使用软引用进行保存\",{\"1\":{\"310\":1}}],[\"缓存池的大小默认为\",{\"1\":{\"120\":1}}],[\"缓存池\",{\"0\":{\"120\":1}}],[\"缓存已经被实例化的服务提供者\",{\"1\":{\"114\":1}}],[\"蝇量模式\",{\"1\":{\"629\":1}}],[\"教室里的桌子和凳子等\",{\"1\":{\"629\":1}}],[\"局限在编程语言的\",{\"1\":{\"808\":1}}],[\"局域网中的路由器\",{\"1\":{\"629\":1}}],[\"局部变量也不被认为是常量\",{\"1\":{\"945\":1}}],[\"局部变量名以\",{\"1\":{\"945\":1}}],[\"局部变量名\",{\"0\":{\"945\":1}}],[\"局部变量声明通常具有初始值\",{\"1\":{\"918\":1}}],[\"局部变量声明在它们第一次被使用的地方\",{\"1\":{\"918\":1}}],[\"局部变量都统一使用lowercamelcase风格\",{\"1\":{\"845\":1}}],[\"局部变量不是直接朋友\",{\"1\":{\"741\":1}}],[\"局部变量等进行注解\",{\"1\":{\"220\":1,\"221\":1}}],[\"局部变量\",{\"1\":{\"218\":1,\"224\":1,\"225\":1,\"227\":1,\"918\":1}}],[\"局部变量运行时被分配在栈中\",{\"1\":{\"205\":1}}],[\"局部变量是指类方法中的变量\",{\"1\":{\"205\":1}}],[\"局部变量为什么要初始化\",{\"0\":{\"205\":1}}],[\"围棋理论上有\",{\"1\":{\"631\":1}}],[\"围棋和五子棋只有黑白两色\",{\"1\":{\"631\":1}}],[\"围棋和五子棋中的黑白棋子\",{\"1\":{\"629\":1}}],[\"围绕一个超级工厂创建其他工厂\",{\"1\":{\"606\":1}}],[\"搞清楚这个类依赖了哪些外部类\",{\"1\":{\"765\":1}}],[\"搞清楚了反射的原理\",{\"1\":{\"627\":1}}],[\"搞混了\",{\"1\":{\"284\":1}}],[\"格式化\",{\"0\":{\"898\":1,\"954\":1}}],[\"格式化代码对大多数程序员来说并没有它应有的那么重要\",{\"1\":{\"453\":1}}],[\"格式地支持\",{\"1\":{\"820\":1}}],[\"格式\",{\"1\":{\"625\":1,\"853\":1}}],[\"格式的配置文件\",{\"1\":{\"625\":1}}],[\"串联执行流程\",{\"1\":{\"625\":1}}],[\"示例中代码的风格不应被作为执行的准则\",{\"1\":{\"878\":1}}],[\"示例等\",{\"1\":{\"872\":1}}],[\"示例\",{\"1\":{\"872\":1}}],[\"示例代码如下所示\",{\"1\":{\"624\":1}}],[\"示意图\",{\"1\":{\"601\":1}}],[\"核心数据管理平台\",{\"1\":{\"869\":1}}],[\"核心模块的语句覆盖率和分支覆盖率都要达到100\",{\"1\":{\"860\":1}}],[\"核心模块的增量代码确保单元测试通过\",{\"1\":{\"860\":1}}],[\"核心应用\",{\"1\":{\"860\":1}}],[\"核心业务代码\",{\"1\":{\"992\":1}}],[\"核心业务\",{\"1\":{\"860\":1}}],[\"核心逻辑等\",{\"1\":{\"853\":1}}],[\"核心逻辑只需要包括这样两个部分\",{\"1\":{\"623\":1}}],[\"核心工厂类设计\",{\"0\":{\"627\":1}}],[\"核心思路\",{\"1\":{\"531\":1}}],[\"事后编写的单元测试\",{\"1\":{\"991\":1}}],[\"事务会影响数据库的qps\",{\"1\":{\"866\":1}}],[\"事务场景中\",{\"1\":{\"858\":1}}],[\"事情处理\",{\"1\":{\"700\":1}}],[\"事先创建好对象\",{\"1\":{\"621\":1}}],[\"事实上在设置值的方法上\",{\"1\":{\"307\":1}}],[\"事实上\",{\"1\":{\"297\":1}}],[\"呢\",{\"1\":{\"620\":1,\"622\":1,\"741\":1,\"817\":1}}],[\"秒后\",{\"1\":{\"870\":1}}],[\"秒\",{\"1\":{\"618\":1,\"870\":1}}],[\"路径禁止携带表示请求内容类型的后缀\",{\"1\":{\"854\":1}}],[\"路径\",{\"1\":{\"854\":2}}],[\"路径导航\",{\"1\":{\"6\":1,\"34\":1}}],[\"路由器接口\",{\"1\":{\"617\":1}}],[\"海信电视工厂等\",{\"1\":{\"614\":1}}],[\"剥离之后能让代码更加清晰\",{\"1\":{\"614\":1}}],[\"伦敦的奶酪\",{\"1\":{\"613\":4}}],[\"伦敦的胡椒\",{\"1\":{\"613\":1}}],[\"披萨类代码\",{\"1\":{\"613\":1}}],[\"披萨项目新的需求\",{\"1\":{\"613\":1}}],[\"披萨的制作有\",{\"1\":{\"609\":1}}],[\"披萨的种类很多\",{\"1\":{\"609\":1}}],[\"典型的响应是打印日志\",{\"1\":{\"950\":1}}],[\"典型的解耦框架\",{\"1\":{\"612\":1}}],[\"典型的例子是\",{\"1\":{\"268\":1}}],[\"灵活增加新算法\",{\"1\":{\"783\":1}}],[\"灵活性非常高\",{\"1\":{\"840\":1}}],[\"灵活性好\",{\"1\":{\"797\":1,\"837\":1}}],[\"灵活性\",{\"1\":{\"766\":1,\"797\":1,\"808\":1}}],[\"灵活性降低\",{\"1\":{\"722\":1}}],[\"灵活性增强\",{\"1\":{\"612\":1}}],[\"灵活扩展\",{\"1\":{\"590\":1}}],[\"奶酪披萨\",{\"1\":{\"610\":3}}],[\"希伯来语\",{\"1\":{\"857\":1}}],[\"希望用技术情怀帮助到更多的人\",{\"1\":{\"843\":1}}],[\"希望对这些对象实施一些依赖于其具体类型的操作\",{\"1\":{\"841\":1}}],[\"希望通过实现类来反推接口的定义\",{\"1\":{\"809\":1}}],[\"希望能通过\",{\"1\":{\"767\":1}}],[\"希望可以提升你对java中反射的认知效率\",{\"1\":{\"300\":1}}],[\"希望可以提升你对java中泛型的认知效率\",{\"1\":{\"278\":1}}],[\"希望可以提升你对java中异常的认知效率\",{\"1\":{\"244\":1}}],[\"希腊披萨工厂类\",{\"1\":{\"613\":1}}],[\"希腊披萨类\",{\"1\":{\"613\":1}}],[\"希腊披萨\",{\"1\":{\"610\":3}}],[\"利于程序扩展和优化\",{\"1\":{\"729\":1}}],[\"利于维护为目的\",{\"1\":{\"603\":1}}],[\"利用先进先出队列实现的底层同步工具类\",{\"1\":{\"873\":1}}],[\"利用延迟关联或者子查询优化超多分页场景\",{\"1\":{\"864\":1}}],[\"利用覆盖索引来进行查询操作\",{\"1\":{\"864\":1}}],[\"利用好其预编译功能\",{\"1\":{\"855\":1}}],[\"利用set元素唯一的特性\",{\"1\":{\"850\":1}}],[\"利用组合来替换继承\",{\"1\":{\"818\":1}}],[\"利用继承特性\",{\"1\":{\"814\":1}}],[\"利用\",{\"1\":{\"758\":1}}],[\"利用了序列化和反序列化\",{\"1\":{\"689\":1}}],[\"利用反射创建对象\",{\"1\":{\"627\":1}}],[\"利用反射技术可以对一个类进行解剖\",{\"1\":{\"301\":1}}],[\"利用方法代替\",{\"1\":{\"610\":1}}],[\"利用程序维护\",{\"1\":{\"542\":1}}],[\"利用它可以在运行时动态创建对象\",{\"1\":{\"304\":1}}],[\"利用抽象数据类型将数据和基于数据的操作封装在一起\",{\"1\":{\"209\":1}}],[\"步骤五\",{\"1\":{\"981\":1}}],[\"步骤四\",{\"1\":{\"981\":1}}],[\"步骤三\",{\"1\":{\"981\":1}}],[\"步骤二\",{\"1\":{\"981\":1}}],[\"步骤一\",{\"1\":{\"981\":1}}],[\"步骤如下\",{\"1\":{\"752\":1}}],[\"步长为\",{\"1\":{\"863\":1}}],[\"步\",{\"1\":{\"601\":1}}],[\"起到了\",{\"1\":{\"754\":1}}],[\"起到简化用户操作的作用\",{\"1\":{\"601\":1}}],[\"起到说明\",{\"1\":{\"148\":1}}],[\"省略多余的设计方案\",{\"1\":{\"871\":1}}],[\"省略其他代码\",{\"1\":{\"814\":1}}],[\"省略其他属性和方法\",{\"1\":{\"812\":2,\"813\":3}}],[\"省略其他无关代码\",{\"1\":{\"809\":2}}],[\"省略参数\",{\"1\":{\"809\":1}}],[\"省略属性和方法\",{\"1\":{\"814\":1}}],[\"省略属性\",{\"1\":{\"809\":2}}],[\"省略必要的\",{\"1\":{\"626\":2}}],[\"省略\",{\"1\":{\"609\":1,\"613\":1,\"813\":1}}],[\"省略set和get方法\",{\"1\":{\"307\":2}}],[\"省去选择安装目录\",{\"1\":{\"601\":1}}],[\"观察错误的信息\",{\"1\":{\"979\":1,\"980\":1}}],[\"观察者集合\",{\"1\":{\"678\":2}}],[\"观察者接口\",{\"1\":{\"678\":1}}],[\"观察者类\",{\"1\":{\"678\":1}}],[\"观察者模式解决天气预报需求\",{\"0\":{\"678\":1}}],[\"观察者模式的应用场景\",{\"0\":{\"680\":1}}],[\"观察者模式的结构图如下所示\",{\"1\":{\"672\":1}}],[\"观察者模式的结构与实现\",{\"0\":{\"672\":1}}],[\"观察者模式的主要角色如下\",{\"1\":{\"672\":1}}],[\"观察者模式是一种对象行为型模式\",{\"1\":{\"671\":1}}],[\"观察者模式基本介绍\",{\"0\":{\"671\":1}}],[\"观察者模式\",{\"1\":{\"591\":1,\"671\":1,\"677\":1,\"798\":1}}],[\"观影结束后\",{\"1\":{\"597\":1}}],[\"灯光类\",{\"1\":{\"601\":1}}],[\"灯光\",{\"1\":{\"597\":1,\"601\":1}}],[\"灯的遥控器\",{\"1\":{\"562\":1}}],[\"灯的关闭类\",{\"1\":{\"562\":1}}],[\"灯的开启类\",{\"1\":{\"562\":1}}],[\"爆米花机\",{\"1\":{\"597\":1,\"601\":2}}],[\"播放\",{\"1\":{\"597\":1}}],[\"播放器\",{\"1\":{\"597\":1,\"601\":2}}],[\"播客\",{\"0\":{\"439\":1}}],[\"门面模式\",{\"1\":{\"593\":1}}],[\"迪米特法则讲的是\",{\"1\":{\"818\":1}}],[\"迪米特法则的核心是降低类之间的耦合\",{\"1\":{\"744\":1}}],[\"迪米特法则注意事项和细节\",{\"0\":{\"744\":1}}],[\"迪米特法则能够帮我们实现代码的\",{\"1\":{\"741\":1}}],[\"迪米特法则还有个更简单的定义\",{\"1\":{\"741\":1}}],[\"迪米特法则\",{\"0\":{\"740\":1},\"1\":{\"593\":2,\"714\":1,\"741\":1,\"742\":4,\"748\":2,\"818\":1}}],[\"横看成岭侧成峰\",{\"1\":{\"591\":1}}],[\"联系方式我给你\",{\"1\":{\"591\":1}}],[\"联合使用\",{\"1\":{\"547\":1}}],[\"草稿箱\",{\"1\":{\"591\":1}}],[\"备注\",{\"1\":{\"872\":1}}],[\"备忘录类\",{\"1\":{\"667\":1}}],[\"备忘录\",{\"1\":{\"664\":2}}],[\"备忘录对象主要用来记录一个对象的某种状态\",{\"1\":{\"663\":1}}],[\"备忘录模式可以和原型模式配合使用\",{\"1\":{\"668\":1}}],[\"备忘录模式实现了信息的封装\",{\"1\":{\"668\":1}}],[\"备忘录模式给用户提供了一种可以恢复状态的机制\",{\"1\":{\"668\":1}}],[\"备忘录模式解决游戏角色恢复\",{\"0\":{\"667\":1}}],[\"备忘录模式的应用场景\",{\"0\":{\"669\":1}}],[\"备忘录模式的注意事项和细节\",{\"0\":{\"668\":1}}],[\"备忘录模式的结构图如下图所示\",{\"1\":{\"664\":1}}],[\"备忘录模式的结构与实现\",{\"0\":{\"664\":1}}],[\"备忘录模式的主要角色如下\",{\"1\":{\"664\":1}}],[\"备忘录模式的核心是设计备忘录类以及用于管理备忘录的管理者类\",{\"1\":{\"664\":1}}],[\"备忘录模式有着相同的含义\",{\"1\":{\"663\":1}}],[\"备忘录模式属于行为型模式\",{\"1\":{\"663\":1}}],[\"备忘录模式基本介绍\",{\"0\":{\"663\":1}}],[\"备忘录模式\",{\"1\":{\"560\":1,\"591\":1,\"663\":1,\"666\":1,\"798\":1}}],[\"备份\",{\"1\":{\"591\":1}}],[\"绑定状态和行为\",{\"1\":{\"591\":1}}],[\"状态码\",{\"1\":{\"854\":1}}],[\"状态图的核心是对象状态\",{\"1\":{\"871\":1}}],[\"状态图\",{\"1\":{\"822\":1}}],[\"状态枚举类\",{\"1\":{\"779\":1}}],[\"状态抽象类\",{\"1\":{\"778\":1}}],[\"状态类\",{\"1\":{\"778\":1,\"779\":1}}],[\"状态类职责明确\",{\"1\":{\"775\":1}}],[\"状态之间可以相互转换\",{\"1\":{\"775\":1}}],[\"状态和行为是一一对应的\",{\"1\":{\"775\":1}}],[\"状态发生改变时通知观察者\",{\"1\":{\"591\":1}}],[\"状态驱动行为\",{\"1\":{\"591\":1}}],[\"状态模式等方式重构\",{\"1\":{\"860\":1}}],[\"状态模式等来实现\",{\"1\":{\"852\":1}}],[\"状态模式方便维护\",{\"1\":{\"780\":1}}],[\"状态模式将每个状态的行为封装到对应的一个类\",{\"1\":{\"780\":1}}],[\"状态模式将与特定状态相关的行为局部化到一个状态中\",{\"1\":{\"775\":1}}],[\"状态模式在实际项目源码\",{\"0\":{\"779\":1}}],[\"状态模式测试类\",{\"1\":{\"778\":1}}],[\"状态模式解决抽奖活动问题\",{\"0\":{\"778\":1}}],[\"状态模式包含以下主要角色\",{\"1\":{\"776\":1}}],[\"状态模式把受环境改变的对象行为包装在不同的状态对象里\",{\"1\":{\"776\":1}}],[\"状态模式对开闭原则的支持并不太好\",{\"1\":{\"775\":1}}],[\"状态模式的应用场景\",{\"0\":{\"781\":1}}],[\"状态模式的代码有很强的可读性\",{\"1\":{\"780\":1}}],[\"状态模式的注意事项和细节\",{\"0\":{\"780\":1}}],[\"状态模式的结构与实现\",{\"0\":{\"776\":1}}],[\"状态模式的结构与实现都较为复杂\",{\"1\":{\"775\":1}}],[\"状态模式的使用必然会增加系统的类与对象的个数\",{\"1\":{\"775\":1}}],[\"状态模式的解决思想是\",{\"1\":{\"775\":1}}],[\"状态模式是一种对象行为型模式\",{\"1\":{\"775\":1}}],[\"状态模式基本介绍\",{\"0\":{\"775\":1}}],[\"状态模式\",{\"1\":{\"591\":1,\"775\":2,\"798\":1}}],[\"状态就不能再改变\",{\"1\":{\"173\":1}}],[\"遥控器\",{\"1\":{\"591\":1}}],[\"逐个检票进站\",{\"1\":{\"591\":1}}],[\"流对象进行关闭\",{\"1\":{\"858\":1}}],[\"流水线上坐一天\",{\"1\":{\"591\":1}}],[\"流程进行封装\",{\"1\":{\"809\":1}}],[\"流程不应该暴露给调用者\",{\"1\":{\"809\":1}}],[\"流程正常\",{\"1\":{\"779\":1}}],[\"流程全部标准化\",{\"1\":{\"591\":2}}],[\"流程驱动的软件系统构建\",{\"1\":{\"435\":1}}],[\"流程图\",{\"0\":{\"24\":1,\"40\":1}}],[\"踢皮球\",{\"1\":{\"591\":1}}],[\"莫管他们瓦上霜\",{\"1\":{\"591\":1}}],[\"拦截器与过滤器\",{\"1\":{\"840\":1}}],[\"拦截的类都实现统一接口\",{\"1\":{\"591\":1}}],[\"拦截异常操作\",{\"1\":{\"242\":1}}],[\"条规则\",{\"1\":{\"911\":1}}],[\"条新规约\",{\"1\":{\"872\":3}}],[\"条件控制\",{\"1\":{\"858\":1}}],[\"条件表达式中出现赋值操作\",{\"1\":{\"852\":1}}],[\"条件判断语句会过于臃肿\",{\"1\":{\"775\":1}}],[\"条件判断语句中使用\",{\"1\":{\"130\":1}}],[\"条下方正例提示\",{\"1\":{\"847\":1}}],[\"条\",{\"1\":{\"845\":1,\"872\":4}}],[\"条条大道通罗马\",{\"1\":{\"591\":1}}],[\"算术表达式中出现赋值操作\",{\"1\":{\"852\":1}}],[\"算术条件异常\",{\"1\":{\"261\":1}}],[\"算法的整体步骤很固定\",{\"1\":{\"805\":1}}],[\"算法的变化\",{\"1\":{\"783\":1}}],[\"算法只存在于一个地方\",{\"1\":{\"804\":1}}],[\"算法\",{\"1\":{\"796\":1}}],[\"算法族\",{\"1\":{\"783\":1}}],[\"算法之间能互相替换\",{\"1\":{\"591\":1}}],[\"桥\",{\"1\":{\"590\":1}}],[\"桥接\",{\"1\":{\"538\":1}}],[\"桥接模式模式的扩展\",{\"0\":{\"547\":1}}],[\"桥接模式通常适用于以下场景\",{\"1\":{\"545\":1}}],[\"桥接模式尤为适用\",{\"1\":{\"545\":1}}],[\"桥接模式要求正确识别出系统中两个独立变化的维度\",{\"1\":{\"544\":1}}],[\"桥接模式替代多层继承方案\",{\"1\":{\"544\":1}}],[\"桥接模式的一个常见使用场景就是\",{\"1\":{\"545\":1}}],[\"桥接模式的应用场景\",{\"0\":{\"545\":1}}],[\"桥接模式的引入增加了系统的理解和设计难度\",{\"1\":{\"544\":1}}],[\"桥接模式的注意事项和细节\",{\"0\":{\"544\":1}}],[\"桥接模式的结构与实现\",{\"0\":{\"538\":1}}],[\"桥接模式解决手机操作问题\",{\"0\":{\"542\":1}}],[\"桥接模式\",{\"1\":{\"537\":2,\"590\":1,\"798\":1}}],[\"桥接模式基本介绍\",{\"0\":{\"537\":1}}],[\"桥接方法\",{\"1\":{\"287\":1}}],[\"约\",{\"1\":{\"863\":1}}],[\"约定\",{\"1\":{\"808\":1}}],[\"约定解释器的解释操作\",{\"1\":{\"642\":1}}],[\"约定优于配置\",{\"1\":{\"590\":1}}],[\"约束满足问题求解程序\",{\"0\":{\"391\":1}}],[\"兼容转换\",{\"1\":{\"590\":1}}],[\"心在一起叫团队\",{\"1\":{\"590\":1}}],[\"人民币等都可以出现\",{\"1\":{\"871\":1}}],[\"人的大脑不会主动地拆开并分辨每位数字的不同含义\",{\"1\":{\"857\":1}}],[\"人\",{\"1\":{\"832\":1,\"863\":1}}],[\"人处理复杂性的能力是有限的\",{\"1\":{\"816\":1}}],[\"人性化解释\",{\"1\":{\"699\":1,\"702\":1}}],[\"人才交流中心\",{\"1\":{\"655\":1}}],[\"人在一起叫团伙\",{\"1\":{\"590\":1}}],[\"人生就是起起伏伏\",{\"1\":{\"36\":1}}],[\"煎饼\",{\"1\":{\"590\":1}}],[\"煎饼中可以加鸡蛋\",{\"1\":{\"579\":1}}],[\"媒婆\",{\"1\":{\"590\":1}}],[\"增减字段容易与resultmap配置不一致\",{\"1\":{\"866\":1}}],[\"增强或修改该对象的一些特性\",{\"1\":{\"798\":1}}],[\"增强了给对象指派职责的灵活性\",{\"1\":{\"707\":1}}],[\"增强了系统的可扩展性\",{\"1\":{\"707\":1}}],[\"增强额外的功能操作\",{\"1\":{\"692\":1}}],[\"增强职责\",{\"1\":{\"590\":1}}],[\"增加设计规约大类\",{\"1\":{\"872\":1}}],[\"增加单元测试规约\",{\"1\":{\"872\":1}}],[\"增加卫语句的示例代码\",{\"1\":{\"872\":1}}],[\"增加关于锁的粒度的说明\",{\"1\":{\"872\":1}}],[\"增加专有名词解释\",{\"1\":{\"872\":1}}],[\"增加版本历史\",{\"1\":{\"872\":1}}],[\"增加<\",{\"1\":{\"872\":1}}],[\"增加前言\",{\"1\":{\"872\":1}}],[\"增加主要功能特性\",{\"1\":{\"869\":1}}],[\"增加查询分析器解析成本\",{\"1\":{\"866\":1}}],[\"增加gc负担\",{\"1\":{\"850\":1}}],[\"增加排查问题的难度\",{\"1\":{\"848\":1}}],[\"增加builder这个变量\",{\"1\":{\"847\":1}}],[\"增加到\",{\"1\":{\"839\":1}}],[\"增加维护难度\",{\"1\":{\"783\":1}}],[\"增加程序的可复用性\",{\"1\":{\"748\":1}}],[\"增加对象间的耦合性\",{\"1\":{\"731\":1}}],[\"增加微信\",{\"1\":{\"727\":1}}],[\"增加计算真实对象的引用次数的功能\",{\"1\":{\"705\":1}}],[\"增加或者减少属性\",{\"1\":{\"690\":1}}],[\"增加或删除命令非常方便\",{\"1\":{\"560\":1}}],[\"增加观察者方法\",{\"1\":{\"672\":1}}],[\"增加系的方法\",{\"1\":{\"650\":1}}],[\"增加系统的复杂度和理解难度\",{\"1\":{\"608\":1}}],[\"增加复杂度\",{\"1\":{\"612\":1}}],[\"增加新的元素类很困难\",{\"1\":{\"837\":1}}],[\"增加新的状态类需要修改那些负责状态转换的源码\",{\"1\":{\"775\":1}}],[\"增加新的聚合类和迭代器类都很方便\",{\"1\":{\"648\":1}}],[\"增加新的子系统可能需要修改外观类或客户端的源代码\",{\"1\":{\"593\":1}}],[\"增加新的具体建造者无须修改原有类库的代码\",{\"1\":{\"557\":1}}],[\"增加了能够体现协作关系的对象泳道\",{\"1\":{\"871\":1}}],[\"增加了类使用过程中被误用的概率\",{\"1\":{\"812\":1}}],[\"增加了类的个数\",{\"1\":{\"648\":1}}],[\"增加了一个新功能\",{\"1\":{\"734\":2}}],[\"增加了客户端的复杂性\",{\"1\":{\"707\":1}}],[\"增加了程序的可扩展性\",{\"1\":{\"692\":1}}],[\"增加了系统的抽象性和理解难度\",{\"1\":{\"612\":1,\"616\":1}}],[\"增加了系统的复杂度\",{\"1\":{\"564\":1,\"692\":1}}],[\"增加了理解上的困难\",{\"1\":{\"560\":1}}],[\"增加额外功能\",{\"1\":{\"560\":1}}],[\"增加代码阅读难度\",{\"1\":{\"518\":1}}],[\"增加安全机制\",{\"1\":{\"185\":1}}],[\"增加\",{\"1\":{\"164\":1,\"850\":1,\"872\":2,\"903\":1}}],[\"得不偿失\",{\"1\":{\"871\":1}}],[\"得找别人来帮忙\",{\"1\":{\"590\":2}}],[\"得到不正确的结果\",{\"1\":{\"863\":1}}],[\"得到女性的测评\",{\"1\":{\"839\":1}}],[\"得到男性的测评\",{\"1\":{\"839\":1}}],[\"得到他们对该歌手不同的评价\",{\"1\":{\"839\":1}}],[\"得到一个请求\",{\"1\":{\"710\":1}}],[\"得到对应迭代器\",{\"1\":{\"650\":1}}],[\"得到对应的一组\",{\"1\":{\"106\":1}}],[\"得到\",{\"1\":{\"637\":2}}],[\"得到以下实现\",{\"1\":{\"141\":1}}],[\"得到的还是原数值\",{\"1\":{\"90\":1}}],[\"克隆该实例\",{\"1\":{\"687\":1}}],[\"克隆是会如何处理\",{\"1\":{\"687\":1}}],[\"克隆羊案例\",{\"0\":{\"684\":1}}],[\"克隆\",{\"1\":{\"589\":1,\"687\":4}}],[\"吹出千万个\",{\"1\":{\"589\":1}}],[\"拔一根猴毛\",{\"1\":{\"589\":1}}],[\"体现了封装的思想\",{\"1\":{\"721\":1}}],[\"体系中\",{\"1\":{\"585\":1}}],[\"体型\",{\"1\":{\"549\":1}}],[\"费用\",{\"1\":{\"584\":5}}],[\"费用1=\",{\"1\":{\"584\":1}}],[\"份巧克力\",{\"1\":{\"584\":1}}],[\"牛奶\",{\"1\":{\"584\":1}}],[\"巧克力\",{\"1\":{\"584\":1}}],[\"咖啡机开始\",{\"1\":{\"657\":1}}],[\"咖啡机\",{\"1\":{\"657\":1,\"659\":1}}],[\"咖啡代码\",{\"1\":{\"584\":1}}],[\"咖啡种类\",{\"1\":{\"581\":1}}],[\"较高语法级别\",{\"1\":{\"907\":1}}],[\"较低的开发成本意味着能够留出更多的营销资金\",{\"1\":{\"819\":1}}],[\"较少的开发时间意味着可以比竞争对手更早进入市场\",{\"1\":{\"819\":1}}],[\"较好\",{\"0\":{\"583\":1}}],[\"较差\",{\"0\":{\"582\":1},\"1\":{\"885\":1}}],[\"维护成本指数级上升\",{\"1\":{\"871\":1}}],[\"维护了一个集合\",{\"1\":{\"839\":1}}],[\"维护性上下功夫\",{\"1\":{\"810\":1}}],[\"维护性\",{\"1\":{\"796\":1}}],[\"维护难度也大\",{\"1\":{\"775\":1}}],[\"维护一个目标对象\",{\"1\":{\"700\":1,\"703\":1}}],[\"维护和扩展都更加容易\",{\"1\":{\"635\":1}}],[\"维护方便\",{\"1\":{\"581\":1}}],[\"维护相对困难\",{\"1\":{\"385\":1}}],[\"改成新的状态\",{\"1\":{\"778\":1}}],[\"改动的代码会比较少\",{\"1\":{\"718\":1}}],[\"改动方便\",{\"1\":{\"581\":1}}],[\"改进方案\",{\"1\":{\"734\":1}}],[\"改进\",{\"1\":{\"718\":2,\"789\":1}}],[\"改进的思路分析\",{\"1\":{\"609\":1,\"686\":1}}],[\"改为更加抽象的命名方式\",{\"1\":{\"809\":1}}],[\"改为\",{\"1\":{\"655\":1}}],[\"改变成\",{\"1\":{\"778\":1}}],[\"改变状态为奖品发送完毕\",{\"1\":{\"778\":1}}],[\"改变状态为不能抽奖\",{\"1\":{\"778\":2}}],[\"改变活动状态为发放奖品\",{\"1\":{\"778\":1}}],[\"改变\",{\"1\":{\"123\":1}}],[\"豆浆\",{\"1\":{\"581\":1,\"584\":1}}],[\"美式咖啡\",{\"1\":{\"581\":1}}],[\"耦合小\",{\"1\":{\"816\":1}}],[\"耦合关系\",{\"1\":{\"744\":1}}],[\"耦合\",{\"1\":{\"741\":1}}],[\"耦合的方式很多\",{\"1\":{\"741\":1}}],[\"耦合度越大\",{\"1\":{\"741\":1}}],[\"耦合度高\",{\"1\":{\"580\":1}}],[\"耦合性\",{\"1\":{\"655\":1,\"797\":1}}],[\"耦合性增强了\",{\"1\":{\"554\":1}}],[\"耦合松散\",{\"1\":{\"655\":1}}],[\"软件的独立单元将在与程序的其他部分相隔离的情况下进行测试\",{\"1\":{\"989\":1}}],[\"软件的维护性\",{\"1\":{\"795\":1}}],[\"软件设计与开发最重要的工作之一就是应对复杂性\",{\"1\":{\"816\":1}}],[\"软件设计也是这样\",{\"1\":{\"593\":1}}],[\"软件开发中唯一不变的就是变化\",{\"1\":{\"809\":1}}],[\"软件\",{\"1\":{\"797\":1}}],[\"软件具有很好的扩展性\",{\"1\":{\"796\":1}}],[\"软件测试时只需要对扩展的代码进行测试就可以了\",{\"1\":{\"737\":1}}],[\"软件遵守开闭原则的话\",{\"1\":{\"737\":1}}],[\"软件实体应当对扩展开放\",{\"1\":{\"736\":1}}],[\"软件工程中\",{\"1\":{\"796\":1}}],[\"软件工程不错\",{\"1\":{\"574\":1}}],[\"软件工程\",{\"1\":{\"574\":1}}],[\"软件是具备现实场景的\",{\"1\":{\"545\":1}}],[\"专有名词解释\",{\"0\":{\"873\":1}}],[\"专有名词与关键字保持英文原文即可\",{\"1\":{\"853\":1}}],[\"专业系类\",{\"1\":{\"650\":1}}],[\"专业\",{\"1\":{\"574\":1}}],[\"专业类\",{\"1\":{\"574\":1}}],[\"专注协同过滤\",{\"1\":{\"413\":1}}],[\"名字\",{\"1\":{\"574\":1,\"609\":1,\"613\":1,\"710\":1}}],[\"名称\",{\"1\":{\"105\":1}}],[\"公共代码\",{\"1\":{\"992\":1}}],[\"公共方法等\",{\"1\":{\"871\":1}}],[\"公共类\",{\"1\":{\"871\":1}}],[\"公共配置\",{\"1\":{\"871\":1}}],[\"公共抽象组件\",{\"1\":{\"574\":1}}],[\"公开接口需要进行入参保护\",{\"1\":{\"852\":1}}],[\"公开到业界后\",{\"1\":{\"843\":1}}],[\"公有方法是类的调用者和维护者最关心的方法\",{\"1\":{\"848\":1}}],[\"公有方法或保护方法\",{\"1\":{\"848\":1}}],[\"公园中存在多个景点\",{\"1\":{\"837\":1}}],[\"公路运行\",{\"1\":{\"718\":1}}],[\"公司之外的开源库\",{\"1\":{\"873\":1}}],[\"公司内部发布到中央仓库\",{\"1\":{\"873\":1}}],[\"公司\",{\"1\":{\"796\":1,\"869\":2}}],[\"公司员工请假\",{\"1\":{\"707\":1}}],[\"公司没了部门就不存在了\",{\"1\":{\"216\":1}}],[\"院系管理者\",{\"1\":{\"710\":1}}],[\"院\",{\"1\":{\"573\":1}}],[\"需做最后一个分隔符后有无内容的检查\",{\"1\":{\"848\":1}}],[\"需注意以下几点\",{\"1\":{\"826\":1}}],[\"需求分析与系统设计在考虑主干功能的同时\",{\"1\":{\"871\":1}}],[\"需求变化是程序员生命中唯一不变的事情\",{\"1\":{\"820\":1}}],[\"需求变更而改变\",{\"1\":{\"716\":1}}],[\"需求\",{\"1\":{\"727\":1,\"742\":1}}],[\"需求是这样\",{\"1\":{\"572\":1}}],[\"需要测试方法为public\",{\"1\":{\"975\":1}}],[\"需要存在\",{\"0\":{\"925\":1}}],[\"需要存储的元素个数\",{\"1\":{\"850\":1}}],[\"需要存储对象的元数据\",{\"1\":{\"168\":1}}],[\"需要注释\",{\"0\":{\"924\":1}}],[\"需要注意的点是要使用的正确的编码\",{\"1\":{\"159\":1}}],[\"需要注意的是\",{\"1\":{\"106\":1,\"768\":1,\"791\":1}}],[\"需要考虑到\",{\"1\":{\"871\":1}}],[\"需要充分评估异常流程与业务边界\",{\"1\":{\"871\":1}}],[\"需要哪些字段必须明确写明\",{\"1\":{\"866\":1}}],[\"需要仔细评估in后边的集合元素数量\",{\"1\":{\"865\":1}}],[\"需要join的字段\",{\"1\":{\"864\":1}}],[\"需要及时更新字段注释\",{\"1\":{\"863\":1}}],[\"需要及时纠正的情况\",{\"1\":{\"853\":1}}],[\"需要根据情况来酌情解决\",{\"1\":{\"863\":1}}],[\"需要明确协议\",{\"1\":{\"854\":1}}],[\"需要极高稳定性和可用性的方法\",{\"1\":{\"852\":1}}],[\"需要编码保证每个线程持有一个单独的random实例\",{\"1\":{\"851\":1}}],[\"需要编写较为复杂的代码\",{\"1\":{\"682\":1}}],[\"需要加锁\",{\"1\":{\"851\":1}}],[\"需要加锁的代码\",{\"1\":{\"258\":1}}],[\"需要保持一致的加锁顺序\",{\"1\":{\"851\":1}}],[\"需要保存与恢复数据的场景\",{\"1\":{\"669\":1}}],[\"需要进行double\",{\"1\":{\"871\":1}}],[\"需要进行参数校验\",{\"1\":{\"852\":1}}],[\"需要进行instanceof判断\",{\"1\":{\"850\":1}}],[\"需要进行处理\",{\"1\":{\"252\":1}}],[\"需要采用通用的符号语言\",{\"1\":{\"824\":1}}],[\"需要生产\",{\"1\":{\"809\":1}}],[\"需要3小时\",{\"1\":{\"803\":1}}],[\"需要特别声明的是\",{\"1\":{\"797\":1}}],[\"需要特别注意的是被final关键字修饰的field字段是安全的\",{\"1\":{\"307\":1}}],[\"需要重写父类的所有方法\",{\"1\":{\"788\":1,\"789\":1}}],[\"需要对于文件大小\",{\"1\":{\"861\":1}}],[\"需要对iterator对象加锁\",{\"1\":{\"850\":1}}],[\"需要对一个对象结构中的对象进行很多不同操作\",{\"1\":{\"837\":1}}],[\"需要对外输出不同的行为的问题\",{\"1\":{\"775\":1}}],[\"需要对对象加锁\",{\"1\":{\"772\":1}}],[\"需要先从外部共享存储区中将它读取到内存\",{\"1\":{\"772\":1}}],[\"需要先使用javac编译\",{\"1\":{\"275\":1}}],[\"需要频繁创建的一些类\",{\"1\":{\"762\":1}}],[\"需要父类接口\",{\"1\":{\"700\":1}}],[\"需要类加载器\",{\"1\":{\"700\":1}}],[\"需要定义接口或者父类\",{\"1\":{\"694\":1}}],[\"需要定义语言文法的应用实例非常少\",{\"1\":{\"641\":1}}],[\"需要修改所有的副本\",{\"1\":{\"871\":1}}],[\"需要修改算法时\",{\"1\":{\"804\":1}}],[\"需要修改其源代码\",{\"1\":{\"690\":1}}],[\"需要修改代码\",{\"1\":{\"682\":1}}],[\"需要为每一个类配备一个克隆方法\",{\"1\":{\"690\":1}}],[\"需要为每一个类都配置一个\",{\"1\":{\"682\":1}}],[\"需要设计开放型\",{\"1\":{\"673\":1}}],[\"需要提供一个可回滚操作的场景\",{\"1\":{\"669\":1}}],[\"需要分离出内部状态和外部状态\",{\"1\":{\"638\":1}}],[\"需要的网站结构相似度很高\",{\"1\":{\"635\":1}}],[\"需要将上面一行代码\",{\"1\":{\"764\":2}}],[\"需要将各个审批级别的下一个设置好\",{\"1\":{\"710\":1}}],[\"需要将一些不能共享的状态外部化\",{\"1\":{\"629\":1}}],[\"需要将插排的\",{\"1\":{\"524\":1,\"528\":1}}],[\"需要缓冲池时\",{\"1\":{\"629\":1}}],[\"需要什么类型的披萨\",{\"1\":{\"609\":1}}],[\"需要覆盖已有代码\",{\"1\":{\"606\":1}}],[\"需要微调请覆盖\",{\"1\":{\"591\":2}}],[\"需要\",{\"1\":{\"576\":1,\"745\":2,\"761\":1}}],[\"需要一个遥控器\",{\"1\":{\"562\":1}}],[\"需要建房子\",{\"1\":{\"552\":1,\"555\":1}}],[\"需要调用的时候就得不断是使用\",{\"1\":{\"533\":1}}],[\"需要开发的具有某种业务功能的组件在现有的组件库中已经存在\",{\"1\":{\"518\":1}}],[\"需要与具体的实现配合使用\",{\"1\":{\"412\":1}}],[\"需要时查api文档即可\",{\"1\":{\"307\":1}}],[\"需要深入理解\",{\"1\":{\"300\":1}}],[\"需要强转类型\",{\"1\":{\"285\":1,\"294\":1}}],[\"需要是可比较的类\",{\"1\":{\"284\":1}}],[\"需要尽可能精确地描述问题和相关信息\",{\"1\":{\"266\":1}}],[\"需要程序员自己分析代码决定是否捕获和处理\",{\"1\":{\"198\":1}}],[\"需要转换为其对应的包装类型\",{\"1\":{\"191\":1}}],[\"需要使用\",{\"1\":{\"532\":1,\"734\":1}}],[\"需要使用顶级类的名称来引用嵌套静态类\",{\"1\":{\"184\":1}}],[\"需要使用多重继承\",{\"1\":{\"133\":1}}],[\"需要遵循以下几个原则\",{\"1\":{\"173\":1}}],[\"需要手动回收\",{\"1\":{\"151\":1}}],[\"需要用户输入内容的场景\",{\"1\":{\"861\":1}}],[\"需要用\",{\"1\":{\"146\":1}}],[\"需要继承非静态和非常量字段\",{\"1\":{\"133\":1}}],[\"需要继承抽象类才能实例化其子类\",{\"1\":{\"133\":1}}],[\"需要能控制继承来的成员的访问权限\",{\"1\":{\"133\":1}}],[\"需要在该运算符之后换行\",{\"1\":{\"907\":1}}],[\"需要在该运算符之前换行\",{\"1\":{\"907\":1}}],[\"需要在<resultmap>设置从is\",{\"1\":{\"863\":1}}],[\"需要在不明确指定请求处理者的情况下\",{\"1\":{\"712\":1}}],[\"需要在几个相关的类中共享代码\",{\"1\":{\"133\":1}}],[\"需要在classpath下的meta\",{\"1\":{\"95\":1}}],[\"需要让不相关的类都实现一个方法\",{\"1\":{\"133\":1}}],[\"需要遍历所有的实现\",{\"1\":{\"115\":1}}],[\"需要通过反射获取\",{\"1\":{\"93\":1}}],[\"假如需要查阅历史代码\",{\"1\":{\"853\":1}}],[\"假如北京鸭可以飞翔\",{\"1\":{\"789\":1}}],[\"假如每参加一次这个活动要扣除用户\",{\"1\":{\"777\":1}}],[\"假如要访问集合\",{\"1\":{\"571\":1}}],[\"假设我们的一个模块需要从\",{\"1\":{\"996\":1}}],[\"假设我们的系统中有很多涉及图片处理和存储的业务逻辑\",{\"1\":{\"809\":1}}],[\"假设我们要添加一个\",{\"1\":{\"839\":1}}],[\"假设我们要设计一个关于鸟的类\",{\"1\":{\"812\":1}}],[\"假设\",{\"1\":{\"732\":1,\"771\":1}}],[\"假设上面的编译可行\",{\"1\":{\"297\":1}}],[\"假设调用者在这个参数中传递的值大于整副牌的剩余张数\",{\"1\":{\"265\":1}}],[\"假设有一个用于发牌操作的方法\",{\"1\":{\"265\":1}}],[\"及时清理不再使用的代码段或配置信息\",{\"1\":{\"855\":1}}],[\"及\",{\"1\":{\"569\":1}}],[\"透明方式\",{\"0\":{\"569\":1}}],[\"树形结构\",{\"1\":{\"576\":1,\"590\":1}}],[\"树叶\",{\"1\":{\"571\":2}}],[\"树叶构件本来没有\",{\"1\":{\"569\":1}}],[\"树叶构件\",{\"1\":{\"568\":1,\"571\":2}}],[\"树枝构件\",{\"1\":{\"568\":1,\"571\":2}}],[\"属于行为型模式\",{\"1\":{\"648\":1}}],[\"属于结构型模式\",{\"1\":{\"567\":1}}],[\"属性类型要与数据库字段类型相匹配\",{\"1\":{\"848\":1}}],[\"属性一样\",{\"1\":{\"683\":1}}],[\"属性是\",{\"1\":{\"627\":3}}],[\"属性指定的方法来做一些清理工作\",{\"1\":{\"622\":1}}],[\"属性指定的方法来初始化对象\",{\"1\":{\"622\":1}}],[\"属性去记录了classpolicy\",{\"1\":{\"228\":1}}],[\"属性使用的数据类型时\",{\"1\":{\"209\":1}}],[\"属性使用\",{\"1\":{\"209\":1}}],[\"属性可以供\",{\"1\":{\"209\":1}}],[\"属性\",{\"1\":{\"209\":2,\"224\":1,\"225\":1,\"549\":1,\"622\":1,\"689\":2,\"759\":1,\"789\":1,\"812\":1}}],[\"属性和\",{\"1\":{\"209\":1}}],[\"学生表中的student\",{\"1\":{\"865\":1}}],[\"学以精进的目标\",{\"1\":{\"843\":1}}],[\"学习过了设计模式\",{\"1\":{\"794\":1}}],[\"学习用品中的书与书包\",{\"1\":{\"567\":1}}],[\"学院员工\",{\"1\":{\"742\":1,\"743\":1}}],[\"学院员工id=\",{\"1\":{\"742\":1,\"743\":1}}],[\"学院的员工类\",{\"1\":{\"742\":1,\"743\":1}}],[\"学院输出\",{\"1\":{\"650\":1}}],[\"学院集合\",{\"1\":{\"650\":1}}],[\"学院\",{\"1\":{\"574\":1}}],[\"学院类\",{\"1\":{\"574\":1}}],[\"学校包含老师\",{\"1\":{\"831\":1}}],[\"学校与老师的关系\",{\"1\":{\"831\":1}}],[\"学校管理类\",{\"1\":{\"742\":1,\"743\":1}}],[\"学校管理者\",{\"1\":{\"710\":1}}],[\"学校总部员工\",{\"1\":{\"742\":1,\"743\":1}}],[\"学校总部员工id=\",{\"1\":{\"742\":1,\"743\":1}}],[\"学校总部员工类\",{\"1\":{\"742\":1,\"743\":1}}],[\"学校总部的员工信息\",{\"1\":{\"742\":1,\"743\":1}}],[\"学校副管理者\",{\"1\":{\"710\":1}}],[\"学校\",{\"0\":{\"709\":1},\"1\":{\"574\":2}}],[\"学校院系展示需求\",{\"0\":{\"572\":1}}],[\"学会用欣赏的眼光看他人\",{\"1\":{\"36\":1}}],[\"按以下的顺序出现\",{\"1\":{\"957\":1}}],[\"按时间顺序添加\",{\"1\":{\"896\":1}}],[\"按某种顺序调用其包含的基本方法\",{\"1\":{\"801\":1}}],[\"按隔离原则应当这样处理\",{\"1\":{\"721\":1}}],[\"按下电视机的关按钮\",{\"1\":{\"562\":1}}],[\"按下电视机的开按钮\",{\"1\":{\"562\":1}}],[\"按下灯的关按钮\",{\"1\":{\"562\":1}}],[\"按下灯的开按钮\",{\"1\":{\"562\":1}}],[\"按下撤销按钮\",{\"1\":{\"562\":3}}],[\"按下开按钮\",{\"1\":{\"562\":2}}],[\"按照迪米特法则\",{\"1\":{\"743\":1}}],[\"按照声明顺序返回\",{\"1\":{\"308\":2}}],[\"按照声明顺序返回一组\",{\"1\":{\"306\":2}}],[\"按照java惯例\",{\"1\":{\"247\":1}}],[\"按照实例化顺序返回已经缓存的服务提供者实例\",{\"1\":{\"114\":1}}],[\"按照实例化的顺序存储\",{\"1\":{\"114\":1}}],[\"控制在1000\",{\"1\":{\"865\":1}}],[\"控制语句\",{\"0\":{\"852\":1}}],[\"控制或扩展真实主题的功能\",{\"1\":{\"694\":1}}],[\"控制器\",{\"1\":{\"655\":1}}],[\"控制器类\",{\"1\":{\"562\":1}}],[\"控制所有智能家电的需要\",{\"1\":{\"562\":1}}],[\"动的字段\",{\"1\":{\"866\":1}}],[\"动作的执行者是每个厂商的一个家电产品\",{\"1\":{\"562\":1}}],[\"动作的执行者\",{\"1\":{\"562\":1}}],[\"动作的请求者是手机\",{\"1\":{\"562\":1}}],[\"动作的请求者\",{\"1\":{\"562\":1}}],[\"动态创建或修改类时\",{\"1\":{\"858\":1}}],[\"动态创建与size相同的数组\",{\"1\":{\"850\":1}}],[\"动态行为图\",{\"1\":{\"822\":1}}],[\"动态改变某个对象的行为\",{\"1\":{\"789\":1}}],[\"动态的在内存中构建代理对象\",{\"1\":{\"698\":1}}],[\"动态的给一个对象扩展功能\",{\"1\":{\"579\":1}}],[\"动态代理类\",{\"1\":{\"700\":1}}],[\"动态代理应用实例\",{\"0\":{\"700\":1}}],[\"动态代理也叫做\",{\"1\":{\"698\":1}}],[\"动态代理基本介绍\",{\"0\":{\"698\":1}}],[\"动态代理\",{\"0\":{\"697\":1},\"1\":{\"692\":1,\"699\":1,\"702\":1}}],[\"动态地给对象增加一些职责\",{\"1\":{\"798\":1}}],[\"动态地给该对象增加一些职责\",{\"1\":{\"579\":1}}],[\"动态地根据配置文件来加载类\",{\"1\":{\"627\":1}}],[\"动态地加载类\",{\"1\":{\"622\":1}}],[\"动态链接失败等\",{\"1\":{\"198\":1}}],[\"动态添加新插件和停止现有插件\",{\"1\":{\"105\":1}}],[\"洗衣机\",{\"1\":{\"562\":1}}],[\"餐厅提供的菜单就相当于把请求和处理进行了解耦\",{\"1\":{\"560\":1}}],[\"客户就要求新增电话订单的功能\",{\"1\":{\"820\":1}}],[\"客户通过组合方式使用策略模式\",{\"1\":{\"783\":1}}],[\"客户类\",{\"1\":{\"708\":1}}],[\"客户不用再考虑聚合的类型\",{\"1\":{\"652\":1}}],[\"客户不关心创建产品的细节\",{\"1\":{\"614\":1}}],[\"客户要一个以博客形式发布的网站\",{\"1\":{\"636\":3}}],[\"客户要一个以新闻形式发布的网站\",{\"1\":{\"636\":1}}],[\"客户只需要将请求发送到职责链上即可\",{\"1\":{\"707\":1}}],[\"客户只知道创建产品的工厂名\",{\"1\":{\"614\":1}}],[\"客户只要调用一个接口\",{\"1\":{\"601\":1}}],[\"客户在点披萨时\",{\"1\":{\"613\":1}}],[\"客户角色通过享元工厂获取具体享元\",{\"1\":{\"632\":1}}],[\"客户角色\",{\"1\":{\"596\":1}}],[\"客户\",{\"1\":{\"595\":1,\"633\":1}}],[\"客户可以根据不同时间或空间要求选择不同的\",{\"1\":{\"783\":1}}],[\"客户可以通过外观角色访问它\",{\"1\":{\"595\":1}}],[\"客户可以点单品咖啡\",{\"1\":{\"581\":1}}],[\"客户对系统的访问也变得越来越复杂\",{\"1\":{\"593\":1}}],[\"客户访问调用者的call\",{\"1\":{\"561\":1}}],[\"客户端接口级别\",{\"1\":{\"870\":1}}],[\"客户端special\",{\"1\":{\"870\":1}}],[\"客户端设置远程接口方法的具体超时时间\",{\"1\":{\"870\":1}}],[\"客户端增加行为不用修改原有代码\",{\"1\":{\"791\":1}}],[\"客户端必须理解所有策略算法的区别\",{\"1\":{\"783\":1}}],[\"客户端必须明确的知道有多少个审批级别和访问\",{\"1\":{\"709\":1}}],[\"客户端无需改变\",{\"1\":{\"727\":1}}],[\"客户端无需知道所创建具体产品的类名\",{\"1\":{\"608\":1}}],[\"客户端这里会使用到分支判断\",{\"1\":{\"709\":1}}],[\"客户端可能会重用之前的请求结果\",{\"1\":{\"854\":1}}],[\"客户端可按下图所示设置职责链\",{\"1\":{\"708\":1}}],[\"客户端可以免除直接创建产品对象的职责\",{\"1\":{\"608\":1}}],[\"客户端可以通过它访问各个子系统的功能\",{\"1\":{\"594\":1}}],[\"客户端可以对其随意修改\",{\"1\":{\"132\":1}}],[\"客户端要遍历聚合的时候只能取到迭代器\",{\"1\":{\"652\":1}}],[\"客户端也要跟着改变\",{\"1\":{\"593\":1}}],[\"客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题\",{\"1\":{\"576\":1}}],[\"客户端在调用时要知道树叶对象和树枝对象的存在\",{\"1\":{\"570\":1}}],[\"客户端需要花更多时间理清类之间的层次关系\",{\"1\":{\"567\":1}}],[\"客户端不应该依赖它不需要的接口\",{\"1\":{\"721\":1}}],[\"客户端不用理会组合里面的组成细节\",{\"1\":{\"576\":1}}],[\"客户端不用做出任何改动\",{\"1\":{\"576\":1}}],[\"客户端不会因为加入了新的对象而更改源代码\",{\"1\":{\"567\":1}}],[\"客户端不必知道产品内部组成的细节\",{\"1\":{\"549\":1}}],[\"客户端\",{\"1\":{\"557\":1,\"642\":1,\"742\":1,\"743\":1}}],[\"客户端通过适配器可以透明地调用目标接口\",{\"1\":{\"518\":1}}],[\"客户端使用ajax\",{\"1\":{\"434\":1}}],[\"客人来了就只需要点菜\",{\"1\":{\"560\":1}}],[\"菜单不是等到客人来了之后才定制的\",{\"1\":{\"560\":1}}],[\"士兵\",{\"1\":{\"560\":2}}],[\"士兵去执行\",{\"1\":{\"560\":1}}],[\"撤销动作\",{\"1\":{\"562\":1}}],[\"撤销\",{\"1\":{\"560\":1}}],[\"之类的\",{\"1\":{\"960\":1}}],[\"之类的单词本身并不是驼峰形式\",{\"1\":{\"947\":1}}],[\"之类块标签的情况\",{\"1\":{\"955\":1}}],[\"之后不需要注释\",{\"1\":{\"924\":1}}],[\"之后的\",{\"1\":{\"923\":1}}],[\"之后的每行代码至少比之前的那行多缩进\",{\"1\":{\"908\":1}}],[\"之后\",{\"1\":{\"911\":1}}],[\"之外\",{\"1\":{\"911\":1}}],[\"之中不包含任何字符或者换行符\",{\"1\":{\"902\":1}}],[\"之所以我们能搭建出如此复杂的系统\",{\"1\":{\"818\":1}}],[\"之所以\",{\"1\":{\"814\":1}}],[\"之所以这么说\",{\"1\":{\"808\":1}}],[\"之所以将某个代码块剥离出来\",{\"1\":{\"614\":1}}],[\"之间不需要使用空格\",{\"1\":{\"911\":1}}],[\"之间\",{\"1\":{\"849\":1,\"911\":1}}],[\"之间的空行是可选的\",{\"1\":{\"910\":1}}],[\"之间的开发者互相协作\",{\"1\":{\"857\":1}}],[\"之间的赋值\",{\"1\":{\"848\":1}}],[\"之间的各种静态关系\",{\"1\":{\"826\":1}}],[\"之间的关系\",{\"1\":{\"741\":1}}],[\"之间的解耦是通过命令对象实现的\",{\"1\":{\"564\":1}}],[\"之间经常存在紧密的耦合关系\",{\"1\":{\"560\":1}}],[\"之前是通过\",{\"1\":{\"997\":1}}],[\"之前你的客户对当前版本的程序感到满意\",{\"1\":{\"820\":1}}],[\"之前被称作jboss\",{\"1\":{\"429\":1}}],[\"之前\",{\"1\":{\"133\":2,\"911\":1,\"956\":1}}],[\"产生的异常类型有很多\",{\"1\":{\"868\":1}}],[\"产生的后果与说明二相同\",{\"1\":{\"851\":1}}],[\"产生不同的结果\",{\"1\":{\"558\":1}}],[\"产品方向改变\",{\"1\":{\"869\":1}}],[\"产品簇\",{\"1\":{\"617\":1}}],[\"产品线名\",{\"1\":{\"869\":1}}],[\"产品线\",{\"1\":{\"617\":1}}],[\"产品标准化\",{\"1\":{\"589\":1}}],[\"产品类非常复杂\",{\"1\":{\"558\":1}}],[\"产品角色\",{\"1\":{\"550\":1,\"551\":1}}],[\"产品的组成部分必须相同\",{\"1\":{\"549\":1}}],[\"产品运行时错误监测及调试商业工具\",{\"1\":{\"416\":1}}],[\"准备原材料\",{\"1\":{\"609\":3,\"613\":5}}],[\"准备创建房子的指挥者\",{\"1\":{\"555\":1}}],[\"准确地表达系统难点需要具备如下能力\",{\"1\":{\"871\":1}}],[\"准确\",{\"1\":{\"414\":1}}],[\"盖高楼\",{\"1\":{\"555\":1}}],[\"盖普通房子\",{\"1\":{\"555\":1}}],[\"盖房案例\",{\"0\":{\"552\":1}}],[\"交付的代码是不可修改的\",{\"1\":{\"871\":1}}],[\"交换两个对象判断结果并不互反\",{\"1\":{\"850\":1}}],[\"交换机和集线器\",{\"1\":{\"629\":1}}],[\"交互图\",{\"1\":{\"822\":1}}],[\"交给指挥者\",{\"1\":{\"555\":1}}],[\"交流电相当于\",{\"1\":{\"524\":1,\"528\":1}}],[\"米\",{\"1\":{\"555\":2}}],[\"封顶\",{\"1\":{\"552\":1,\"553\":1,\"555\":1}}],[\"封装issuccess\",{\"1\":{\"858\":1}}],[\"封装和抽象可以有效地隐藏实现的复杂性\",{\"1\":{\"818\":1}}],[\"封装和抽象作为两个非常通用的设计思想\",{\"1\":{\"818\":1}}],[\"封装与抽象\",{\"1\":{\"818\":1}}],[\"封装意识\",{\"1\":{\"809\":1}}],[\"封装具体的实现细节\",{\"1\":{\"809\":1}}],[\"封装不稳定的实现\",{\"1\":{\"808\":1,\"810\":1}}],[\"封装不同的算法\",{\"1\":{\"591\":1}}],[\"封装接口\",{\"1\":{\"789\":1}}],[\"封装接收方具体命令的实现细节\",{\"1\":{\"565\":1}}],[\"封装到\",{\"1\":{\"743\":1}}],[\"封装性良好\",{\"1\":{\"648\":1}}],[\"封装性好\",{\"1\":{\"549\":1}}],[\"封装创建对象的代码\",{\"1\":{\"610\":1}}],[\"封装创建细节\",{\"1\":{\"589\":1}}],[\"封装在一起\",{\"1\":{\"554\":1}}],[\"封装使得用户注意不到这种实现细节\",{\"1\":{\"209\":1}}],[\"封装\",{\"0\":{\"209\":1},\"1\":{\"187\":1,\"219\":1,\"545\":2}}],[\"砌墙\",{\"1\":{\"552\":1,\"553\":1,\"555\":1}}],[\"负载因子\",{\"1\":{\"850\":1}}],[\"负面影响与\",{\"1\":{\"850\":1}}],[\"负责给出一个算法的轮廓和骨架\",{\"1\":{\"801\":1}}],[\"负责两个不同职责\",{\"1\":{\"716\":1}}],[\"负责存储发起人的内部状态\",{\"1\":{\"664\":1}}],[\"负责创建和管理享元角色\",{\"1\":{\"632\":1}}],[\"负责将配置文件解析为\",{\"1\":{\"626\":1}}],[\"负责组装\",{\"1\":{\"625\":1}}],[\"负责在程序启动的时候\",{\"1\":{\"621\":1}}],[\"负责描述所有实例共有的公共接口\",{\"1\":{\"608\":1}}],[\"负责实现创建所有实例的内部逻辑\",{\"1\":{\"608\":1}}],[\"负责所有产品的创建\",{\"1\":{\"608\":1}}],[\"负责任务的调用和分配\",{\"1\":{\"591\":2}}],[\"负责控制产品对象的生产过程\",{\"1\":{\"550\":1}}],[\"负数高位补1\",{\"1\":{\"203\":1}}],[\"隔离变化和具体的实现\",{\"1\":{\"818\":1}}],[\"隔离实现的易变性\",{\"1\":{\"818\":1}}],[\"隔离开来执行\",{\"1\":{\"766\":1}}],[\"隔离了客户与对象的生产过程\",{\"1\":{\"550\":1}}],[\"隔开\",{\"1\":{\"256\":1}}],[\"便会发生极其严重的\",{\"1\":{\"779\":1}}],[\"便于开发人员查看\",{\"1\":{\"859\":1}}],[\"便于错误排查人员快速定位问题\",{\"1\":{\"854\":1}}],[\"便于阅读\",{\"1\":{\"848\":1}}],[\"便于排查问题\",{\"1\":{\"848\":1}}],[\"便于复用和维护\",{\"1\":{\"847\":1}}],[\"便于代码复用\",{\"1\":{\"800\":1}}],[\"便于子类继续扩展\",{\"1\":{\"800\":1}}],[\"便于其他程序员的阅读和理解\",{\"1\":{\"797\":1}}],[\"便于其他第三方也能接入气象站获取数据\",{\"1\":{\"673\":1}}],[\"便于理解\",{\"1\":{\"748\":1}}],[\"便于控制细节风险\",{\"1\":{\"549\":1}}],[\"便捷的jdbc抽象\",{\"1\":{\"394\":1}}],[\"收件人\",{\"1\":{\"549\":1}}],[\"车架\",{\"1\":{\"549\":1}}],[\"服装\",{\"1\":{\"549\":1}}],[\"服务未注册\",{\"1\":{\"874\":1}}],[\"服务未找到\",{\"1\":{\"874\":1}}],[\"服务出错\",{\"1\":{\"874\":1}}],[\"服务已欠费\",{\"1\":{\"874\":1}}],[\"服务\",{\"1\":{\"860\":1}}],[\"服务端接口级别\",{\"1\":{\"870\":1}}],[\"服务端special\",{\"1\":{\"870\":1}}],[\"服务端返回的数据\",{\"1\":{\"854\":1}}],[\"服务端一律使用string字符串类型返回\",{\"1\":{\"854\":1}}],[\"服务端发生错误时\",{\"1\":{\"854\":1}}],[\"服务的框架\",{\"1\":{\"424\":1}}],[\"服务器来提供此接口\",{\"1\":{\"996\":1}}],[\"服务器开了点小差\",{\"1\":{\"871\":1}}],[\"服务器端会因为处于time\",{\"1\":{\"870\":1}}],[\"服务器返回信息必须被标记是否可以缓存\",{\"1\":{\"854\":1}}],[\"服务器内部重定向必须使用forward\",{\"1\":{\"854\":1,\"870\":1}}],[\"服务器内部错误\",{\"1\":{\"854\":1}}],[\"服务器无法取得所请求的网页\",{\"1\":{\"854\":1}}],[\"服务器拒绝请求\",{\"1\":{\"854\":1}}],[\"服务器集群\",{\"1\":{\"796\":1}}],[\"服务器安全专业\",{\"1\":{\"650\":2}}],[\"服务器交互\",{\"1\":{\"477\":1}}],[\"服务器编程交流平台是一个老牌的it信息网站\",{\"1\":{\"442\":1}}],[\"服务器\",{\"0\":{\"870\":1},\"1\":{\"414\":1,\"655\":1}}],[\"服务提供者也只会被实例化一次\",{\"1\":{\"114\":1}}],[\"服务提供者接口\",{\"1\":{\"114\":1}}],[\"服务提供者查找的迭代器\",{\"1\":{\"114\":1}}],[\"服务提供发现机制\",{\"1\":{\"95\":2}}],[\"脸型\",{\"1\":{\"549\":1}}],[\"采取前两种方案的结果可能是用10个\",{\"1\":{\"991\":1}}],[\"采取一定的方法保证在整个的软件系统中\",{\"1\":{\"750\":1}}],[\"采纳为面向对象的建模语言的国际标准\",{\"1\":{\"822\":1}}],[\"采购员采购教学器材\",{\"1\":{\"709\":1}}],[\"采购员不可能自己去组装计算机\",{\"1\":{\"549\":1}}],[\"采购审批流程\",{\"1\":{\"707\":1}}],[\"采用署名\",{\"1\":{\"993\":1}}],[\"采用和\",{\"1\":{\"872\":1}}],[\"采用不同的\",{\"1\":{\"764\":1}}],[\"采用组合或聚合复用时\",{\"1\":{\"747\":1}}],[\"采用依赖\",{\"1\":{\"734\":1}}],[\"采用了类似递归的方式\",{\"1\":{\"711\":1}}],[\"采用继承关系很难实现\",{\"1\":{\"586\":1}}],[\"采用备忘录模式来实现\",{\"1\":{\"565\":1}}],[\"采用命令模式增加与删除命令不会影响其他类\",{\"1\":{\"560\":1}}],[\"采用抽象工厂模式不需要关心构建过程\",{\"1\":{\"557\":1}}],[\"采用java编程语言开发的实时协作服务器\",{\"1\":{\"414\":1}}],[\"采用约定优于配置方式进行管理\",{\"1\":{\"385\":1}}],[\"采用\",{\"1\":{\"125\":1,\"847\":1}}],[\"显然是不合适的\",{\"1\":{\"809\":1}}],[\"显然就无法适应这样的需求变更\",{\"1\":{\"766\":1}}],[\"显示层对象\",{\"1\":{\"868\":1,\"873\":1}}],[\"显示测评情况\",{\"1\":{\"839\":1}}],[\"显示鸭子信息\",{\"1\":{\"787\":1,\"789\":1}}],[\"显示鸭子的信息\",{\"1\":{\"785\":1}}],[\"显示\",{\"1\":{\"676\":1,\"678\":2}}],[\"显示当前游戏角色的状态\",{\"1\":{\"667\":1}}],[\"显示器可以和\",{\"1\":{\"832\":1}}],[\"显示器\",{\"1\":{\"549\":1}}],[\"显卡的驱动程序对象\",{\"1\":{\"750\":1}}],[\"显卡\",{\"1\":{\"549\":1}}],[\"建表的小数类型等\",{\"1\":{\"872\":1}}],[\"建表规约\",{\"0\":{\"863\":1}}],[\"建组合索引的时候\",{\"1\":{\"864\":1}}],[\"建议\",{\"1\":{\"991\":1}}],[\"建议将linux服务器所支持的最大句柄数调高数倍\",{\"1\":{\"870\":1}}],[\"建议将数据拆成整数和小数并分开存储\",{\"1\":{\"863\":1}}],[\"建议进行npe检查\",{\"1\":{\"858\":1}}],[\"建议开发者尽量不用可变参数编程\",{\"1\":{\"848\":1}}],[\"建模的核心是模型\",{\"1\":{\"824\":1}}],[\"建造方法的实现是由\",{\"1\":{\"556\":1}}],[\"建造房子好\",{\"1\":{\"555\":1}}],[\"建造者类以及子类\",{\"1\":{\"555\":1}}],[\"建造者\",{\"1\":{\"549\":1,\"551\":1,\"557\":1}}],[\"建造者可以对创建过程逐步细化\",{\"1\":{\"549\":1}}],[\"建造者模式主要适用于以下应用场景\",{\"1\":{\"558\":1}}],[\"建造者模式唯一区别于工厂模式的是针对复杂对象的创建\",{\"1\":{\"558\":1}}],[\"建造者模式所创建的产品一般具有较多的共同点\",{\"1\":{\"557\":1}}],[\"建造者模式的应用场景\",{\"0\":{\"558\":1}}],[\"建造者模式的注意事项和细节\",{\"0\":{\"557\":1}}],[\"建造者模式的\",{\"0\":{\"556\":1}}],[\"建造者模式的四个角色\",{\"0\":{\"550\":1}}],[\"建造者模式解决盖房案例\",{\"0\":{\"555\":1}}],[\"建造者模式结构图\",{\"0\":{\"551\":1}}],[\"建造者模式注重零部件的组装过程\",{\"1\":{\"549\":1}}],[\"建造者模式\",{\"1\":{\"549\":2,\"554\":1,\"589\":1,\"798\":1}}],[\"建造者模式基本介绍\",{\"0\":{\"549\":1}}],[\"建房子流程\",{\"1\":{\"554\":1}}],[\"建立了一个\",{\"1\":{\"477\":1}}],[\"建立一个异常对象\",{\"1\":{\"276\":1}}],[\"建立\",{\"1\":{\"276\":2}}],[\"建立对象\",{\"1\":{\"276\":2}}],[\"建立异常对象\",{\"1\":{\"276\":3}}],[\"银河有多远\",{\"1\":{\"852\":1}}],[\"银卡用户\",{\"1\":{\"546\":1}}],[\"银行转账系统\",{\"1\":{\"546\":1}}],[\"柜台转账\",{\"1\":{\"546\":1}}],[\"驱动程序\",{\"1\":{\"546\":1}}],[\"品牌\",{\"1\":{\"542\":1}}],[\"样式中的注释块\",{\"1\":{\"933\":1}}],[\"样式或\",{\"1\":{\"933\":1}}],[\"样式\",{\"1\":{\"542\":1,\"933\":2}}],[\"样式化\",{\"0\":{\"29\":1}}],[\"折叠样式手机\",{\"1\":{\"542\":3}}],[\"折叠式手机类\",{\"1\":{\"542\":1}}],[\"违反依赖倒转原则\",{\"1\":{\"727\":1}}],[\"违反接口隔离原则\",{\"1\":{\"721\":1}}],[\"违反\",{\"1\":{\"677\":1}}],[\"违反了依赖倒置原则\",{\"1\":{\"837\":1}}],[\"违反了\",{\"1\":{\"610\":1,\"742\":2}}],[\"违反了单一职责原则\",{\"1\":{\"541\":1,\"718\":1}}],[\"违背开闭原则\",{\"1\":{\"750\":1,\"783\":1}}],[\"违背高聚合原则\",{\"1\":{\"608\":1}}],[\"违背了依赖倒转原则\",{\"1\":{\"840\":1}}],[\"违背了开闭原则\",{\"1\":{\"682\":1}}],[\"违背了\",{\"1\":{\"593\":1,\"690\":1}}],[\"违背了异常捕获的原则\",{\"1\":{\"297\":1}}],[\"违背了泛型设计的初衷\",{\"1\":{\"290\":1}}],[\"旋转式\",{\"1\":{\"541\":1}}],[\"打印日志时仅打印出业务相关属性值或者调用其对象的tostring\",{\"1\":{\"859\":1}}],[\"打印异常堆栈\",{\"1\":{\"859\":1}}],[\"打印机的后台处理服务\",{\"1\":{\"750\":1}}],[\"打折\",{\"1\":{\"845\":1}}],[\"打开\",{\"1\":{\"728\":6}}],[\"打开华为路由器\",{\"1\":{\"617\":1}}],[\"打开华为手机\",{\"1\":{\"617\":1}}],[\"打开小米路由器\",{\"1\":{\"617\":1}}],[\"打开小米手机\",{\"1\":{\"617\":1}}],[\"打开一扇门\",{\"1\":{\"590\":1}}],[\"打地基\",{\"1\":{\"553\":1}}],[\"打电话等\",{\"1\":{\"539\":1}}],[\"打包和测试的标准\",{\"1\":{\"458\":1}}],[\"打包github仓库的便捷工具\",{\"1\":{\"401\":1}}],[\"给jvm环境参数设置\",{\"1\":{\"870\":1}}],[\"给依赖的模块提供稳定且易用的抽象接口\",{\"1\":{\"818\":1}}],[\"给调用者使用\",{\"1\":{\"809\":1}}],[\"给子类具体实现\",{\"1\":{\"789\":1}}],[\"给子系统中的一组接口提供一个一致的界面\",{\"1\":{\"600\":1}}],[\"给整体项目带来无法预料的风险\",{\"1\":{\"722\":1}}],[\"给目标对象\",{\"1\":{\"700\":2}}],[\"给每个网站租用一个空间\",{\"1\":{\"634\":1}}],[\"给客户\",{\"1\":{\"633\":1}}],[\"给希腊披萨\",{\"1\":{\"609\":1}}],[\"给制作奶酪披萨\",{\"1\":{\"609\":1}}],[\"给定一个语言\",{\"1\":{\"591\":1}}],[\"给我们的遥控器设置命令\",{\"1\":{\"562\":2}}],[\"给我们的按钮设置你需要的命令\",{\"1\":{\"562\":1}}],[\"给出实现化角色接口的具体实现\",{\"1\":{\"538\":1}}],[\"给你展示下如何通过注解实现解耦的\",{\"1\":{\"242\":1}}],[\"角色被访问\",{\"1\":{\"538\":2}}],[\"角色\",{\"1\":{\"538\":4,\"561\":4,\"568\":3,\"580\":4,\"595\":3,\"632\":3,\"642\":4,\"649\":4,\"656\":4,\"664\":3,\"672\":4,\"708\":3,\"776\":3,\"838\":5}}],[\"种类型\",{\"1\":{\"996\":1}}],[\"种类时\",{\"1\":{\"609\":1}}],[\"种行为型模式\",{\"1\":{\"798\":1}}],[\"种结构型模式\",{\"1\":{\"798\":1}}],[\"种创建型模式\",{\"1\":{\"798\":1}}],[\"种设计模式表格总结\",{\"1\":{\"588\":1}}],[\"种\",{\"1\":{\"537\":1,\"798\":5,\"827\":1}}],[\"种颜色的图形就有\",{\"1\":{\"537\":1}}],[\"种形状和\",{\"1\":{\"537\":1}}],[\"某团队为了业务快速发展\",{\"1\":{\"871\":1}}],[\"某同学为避免写一个\",{\"1\":{\"866\":1}}],[\"某系统签名大量被恶意修改\",{\"1\":{\"861\":1}}],[\"某业务将退货的商品id列表放在url中作为参数传递\",{\"1\":{\"854\":1}}],[\"某业务系统\",{\"1\":{\"852\":1}}],[\"某业务的do的createtime默认值为new\",{\"1\":{\"848\":1}}],[\"某业务的交易报表上显示成交总额涨跌情况\",{\"1\":{\"848\":1}}],[\"某业务的数据库表id字段定义类型为bigint\",{\"1\":{\"848\":1}}],[\"某程序员因使用yyyy\",{\"1\":{\"849\":1}}],[\"某个疫情相关的二维码出错\",{\"1\":{\"871\":1}}],[\"某个接口设计得有问题\",{\"1\":{\"818\":1}}],[\"某个功能只有一种实现方式\",{\"1\":{\"810\":1}}],[\"某个类的方法通过局部变量\",{\"1\":{\"828\":1}}],[\"某个类的对象等\",{\"1\":{\"689\":1}}],[\"某个类只能生成一个实例\",{\"1\":{\"798\":1}}],[\"某些类创建实例时占用资源较多\",{\"1\":{\"762\":1}}],[\"某些类具有两个或多个维度的变化\",{\"1\":{\"537\":1}}],[\"某类问题的通用解决方案\",{\"1\":{\"795\":1}}],[\"某类需要频繁实例化\",{\"1\":{\"762\":1}}],[\"某类只要求生成一个对象的时候\",{\"1\":{\"762\":1}}],[\"某类或者某批对象时\",{\"1\":{\"608\":1}}],[\"某种商品的物价上涨时会导致部分商家高兴\",{\"1\":{\"671\":1}}],[\"某中方法的\",{\"1\":{\"218\":1}}],[\"合适的字符存储长度\",{\"1\":{\"863\":1}}],[\"合成复用原则的重要性\",{\"0\":{\"747\":1}}],[\"合成复用原则\",{\"0\":{\"745\":1},\"1\":{\"527\":1,\"714\":1,\"745\":1,\"748\":2}}],[\"合理利用好集合的有序性\",{\"1\":{\"850\":1}}],[\"合理使用\",{\"1\":{\"285\":1}}],[\"合理的做法是至少要记录异常的信息\",{\"1\":{\"269\":1}}],[\"手册的愿景是码出高效\",{\"1\":{\"843\":1}}],[\"手段有很多\",{\"1\":{\"816\":1}}],[\"手机格式校验失败\",{\"1\":{\"874\":1}}],[\"手机接口\",{\"1\":{\"617\":1}}],[\"手机短信\",{\"1\":{\"546\":1}}],[\"手机代码\",{\"1\":{\"542\":1}}],[\"手机品牌代码\",{\"1\":{\"542\":1}}],[\"手机操作问题\",{\"0\":{\"539\":1}}],[\"手机类和测试类\",{\"1\":{\"524\":1,\"528\":1}}],[\"手动编写的类被编译后会产生一个class对象\",{\"1\":{\"302\":1}}],[\"伏\",{\"1\":{\"524\":1,\"528\":1}}],[\"电影或电视剧中的人物角色\",{\"1\":{\"837\":1}}],[\"电审失败\",{\"1\":{\"779\":1}}],[\"电审\",{\"1\":{\"779\":1}}],[\"电子邮件信息\",{\"1\":{\"727\":2}}],[\"电话\",{\"1\":{\"861\":1}}],[\"电话和地址等信息\",{\"1\":{\"707\":1}}],[\"电话集成和强大安全性能\",{\"1\":{\"414\":1}}],[\"电源适配\",{\"1\":{\"590\":1}}],[\"电视工厂\",{\"1\":{\"614\":1}}],[\"电视机开始播放\",{\"1\":{\"657\":1}}],[\"电视机\",{\"1\":{\"657\":1,\"659\":1}}],[\"电视机关闭了\",{\"1\":{\"562\":1}}],[\"电视机打开了\",{\"1\":{\"562\":1}}],[\"电视的遥控器\",{\"1\":{\"562\":1}}],[\"电视的关机类\",{\"1\":{\"562\":1}}],[\"电视的开机类\",{\"1\":{\"562\":1}}],[\"电灯关闭了\",{\"1\":{\"562\":1}}],[\"电灯打开了\",{\"1\":{\"562\":1}}],[\"电压大于5v\",{\"1\":{\"524\":1,\"528\":1}}],[\"电压为5v\",{\"1\":{\"524\":1,\"528\":1}}],[\"电压\",{\"1\":{\"524\":1,\"528\":1}}],[\"电压=\",{\"1\":{\"524\":1,\"528\":1}}],[\"插入赋值语句\",{\"1\":{\"852\":1}}],[\"插入的方法用save\",{\"1\":{\"845\":1}}],[\"插入排序\",{\"1\":{\"783\":1}}],[\"插排的\",{\"1\":{\"524\":1,\"528\":1}}],[\"插件实现\",{\"1\":{\"481\":1}}],[\"插件a\",{\"1\":{\"460\":1}}],[\"插件\",{\"1\":{\"458\":1}}],[\"插件模式的插件\",{\"1\":{\"113\":1}}],[\"插件开发者遵循这些规则去开发自己的插件\",{\"1\":{\"105\":1}}],[\"插件的操作配置信息\",{\"1\":{\"105\":1}}],[\"插件的文件结构必须在指定目录下包含以下三个文件\",{\"1\":{\"105\":1}}],[\"插件的所有功能\",{\"1\":{\"13\":1}}],[\"插件体系\",{\"0\":{\"105\":1}}],[\"插件来实现\",{\"1\":{\"11\":1}}],[\"充当具体实现迭代器\",{\"1\":{\"651\":1}}],[\"充当池的作用\",{\"1\":{\"636\":1}}],[\"充电\",{\"1\":{\"524\":1,\"528\":1}}],[\"充电器\",{\"1\":{\"524\":1,\"528\":1}}],[\"充电器需要\",{\"1\":{\"524\":1,\"528\":1}}],[\"充电器本身相当于\",{\"1\":{\"524\":1,\"528\":1}}],[\"充分利用现代多核\",{\"1\":{\"187\":1}}],[\"完整\",{\"1\":{\"876\":1}}],[\"完整的写法是\",{\"1\":{\"699\":1}}],[\"完善若干处示例\",{\"1\":{\"872\":2}}],[\"完美版\",{\"1\":{\"872\":1}}],[\"完全失去版本的语义信息\",{\"1\":{\"869\":1}}],[\"完全没有注释的大段代码对于阅读者形同天书\",{\"1\":{\"853\":1}}],[\"完全不依赖实现编程呢\",{\"1\":{\"810\":1}}],[\"完全不支持\",{\"1\":{\"764\":1}}],[\"完全能满足我们将图片存储在阿里云的业务需求\",{\"1\":{\"809\":1}}],[\"完全的实例和详解\",{\"1\":{\"442\":1}}],[\"完成第二次的分派\",{\"1\":{\"839\":1}}],[\"完成两个数相加\",{\"1\":{\"734\":2}}],[\"完成审批\",{\"1\":{\"709\":1}}],[\"完成多线程间同步工作\",{\"1\":{\"704\":1}}],[\"完成深拷贝\",{\"1\":{\"689\":2}}],[\"完成即可\",{\"1\":{\"689\":1}}],[\"完成任务\",{\"1\":{\"659\":1}}],[\"完成对应任务\",{\"1\":{\"659\":1}}],[\"完成对聚合对象的遍历\",{\"1\":{\"649\":1}}],[\"完成对按钮初始化\",{\"1\":{\"562\":1}}],[\"完成具体产品的创建\",{\"1\":{\"612\":1,\"616\":1}}],[\"完成披萨店订购功能\",{\"1\":{\"609\":1}}],[\"完成通过遥控器\",{\"1\":{\"562\":1}}],[\"完成盖房子\",{\"1\":{\"555\":2}}],[\"完成复杂产品的各个部件的具体创建方法\",{\"1\":{\"551\":1}}],[\"完成\",{\"1\":{\"527\":1,\"556\":1,\"802\":1}}],[\"完成被适配类到适配接口的适配\",{\"1\":{\"523\":1}}],[\"过往日志格式为\",{\"1\":{\"859\":1}}],[\"过多过滥的注释\",{\"1\":{\"853\":1}}],[\"过多使用适配器会使系统代码变得凌乱\",{\"1\":{\"518\":1}}],[\"过度切换\",{\"1\":{\"851\":1}}],[\"过度使用这条原则\",{\"1\":{\"810\":1}}],[\"过度使用会增加程序得复杂性\",{\"1\":{\"579\":1}}],[\"过于宽泛的访问范围\",{\"1\":{\"848\":1}}],[\"过于复杂的代码往往在可读性\",{\"1\":{\"816\":1}}],[\"过于简单\",{\"1\":{\"554\":1}}],[\"过复杂\",{\"1\":{\"812\":1}}],[\"过了一段时间后\",{\"1\":{\"809\":1}}],[\"过大的大接口里面通常放置许多不用的方法\",{\"1\":{\"722\":1}}],[\"过程\",{\"1\":{\"597\":1}}],[\"过程模式\",{\"1\":{\"593\":1}}],[\"过api中throwable类的众多子类描述各种不同的异常\",{\"1\":{\"245\":1}}],[\"适合用<\",{\"1\":{\"850\":2}}],[\"适合使用迭代器模式\",{\"1\":{\"652\":1}}],[\"适合使用组合模式\",{\"1\":{\"576\":1}}],[\"适当的规范和标准绝不是消灭代码内容的创造性\",{\"1\":{\"843\":1}}],[\"适用于所有标识符的通用规则\",{\"0\":{\"937\":1}}],[\"适用于数据结构相对稳定的系统\",{\"1\":{\"840\":1}}],[\"适用于一个接口不想使用其所有的方法的情况\",{\"1\":{\"531\":1}}],[\"适用于多种数据类型执行相同的代码\",{\"1\":{\"279\":1}}],[\"适配上层接口\",{\"1\":{\"868\":1}}],[\"适配完成\",{\"1\":{\"528\":1}}],[\"适配接口\",{\"1\":{\"523\":1,\"524\":1,\"525\":1,\"528\":1}}],[\"适配者\",{\"1\":{\"519\":1}}],[\"适配器类\",{\"1\":{\"524\":1,\"528\":1}}],[\"适配器再调用被适配者的相关接口方法\",{\"1\":{\"520\":1}}],[\"适配器\",{\"1\":{\"519\":1,\"521\":1}}],[\"适配器编写过程需要结合业务场景全面考虑\",{\"1\":{\"518\":1}}],[\"适配器模式的应用场景\",{\"0\":{\"535\":1}}],[\"适配器模式的注意事项和细节\",{\"0\":{\"534\":1}}],[\"适配器模式属于结构型模式\",{\"1\":{\"518\":1}}],[\"适配器模式\",{\"1\":{\"518\":1,\"519\":1,\"520\":1,\"531\":1,\"535\":1,\"547\":1,\"590\":1,\"798\":1}}],[\"讲中文的人同讲英文的人对话时需要一个翻译\",{\"1\":{\"518\":1}}],[\"快捷键是空格\",{\"1\":{\"826\":1}}],[\"快照模式\",{\"1\":{\"663\":1}}],[\"快\",{\"1\":{\"637\":1}}],[\"快看看到底是怎么回事\",{\"1\":{\"485\":1}}],[\"快速溯源\",{\"1\":{\"857\":1}}],[\"快速和高效\",{\"1\":{\"434\":1}}],[\"快速\",{\"1\":{\"409\":1,\"413\":1,\"414\":1,\"428\":1}}],[\"快速紧凑的特定类型集合\",{\"1\":{\"406\":1}}],[\"$proxy0\",{\"1\":{\"700\":1}}],[\"$\",{\"1\":{\"485\":1,\"855\":2,\"866\":1,\"869\":1}}],[\"潜在的\",{\"1\":{\"484\":1}}],[\"界面类\",{\"1\":{\"600\":1}}],[\"界面\",{\"1\":{\"484\":1}}],[\"着力于发现你代码中的错误和整理的你的代码\",{\"1\":{\"484\":1}}],[\"诸如海森堡类的\",{\"1\":{\"481\":1}}],[\"免得不同服务的线程同归于尽\",{\"1\":{\"870\":1}}],[\"免费的社区版对我来说已经足够好了\",{\"1\":{\"480\":1}}],[\"免除了其它orm产品中的复杂性和开销\",{\"1\":{\"420\":1}}],[\"肯定需要详细的施工图\",{\"1\":{\"871\":1}}],[\"肯定不是进入这里\",{\"1\":{\"852\":1}}],[\"肯定不为\",{\"1\":{\"450\":1}}],[\"肯定会很熟悉\",{\"1\":{\"472\":1}}],[\"稍有不足\",{\"1\":{\"472\":1}}],[\"夫复何求\",{\"1\":{\"470\":1}}],[\"饥汉式和懒汉式的数据类型\",{\"1\":{\"469\":1}}],[\"幸运的是\",{\"1\":{\"468\":1,\"485\":1}}],[\"令我比较烦恼的问题之一\",{\"1\":{\"468\":1}}],[\"磁盘访问\",{\"1\":{\"466\":1}}],[\"库名与应用名称尽量一致\",{\"1\":{\"863\":1}}],[\"库依赖于原始的\",{\"1\":{\"469\":1}}],[\"库宕机而使你的构建崩溃了\",{\"1\":{\"461\":1}}],[\"库本身依赖特定版本的其他的库\",{\"1\":{\"459\":1}}],[\"库是一个简单快速的\",{\"1\":{\"467\":1}}],[\"库是\",{\"1\":{\"449\":1}}],[\"然而\",{\"1\":{\"457\":1,\"876\":1,\"896\":1,\"958\":1}}],[\"然后禁止这么做\",{\"1\":{\"952\":1}}],[\"然后只将以下内容的第一个字符转换为大写\",{\"1\":{\"947\":1}}],[\"然后明确两两状态之间是否存在直接转换关系\",{\"1\":{\"871\":1}}],[\"然后进行append操作\",{\"1\":{\"848\":1}}],[\"然后用类来表示这些概念并定义其关系\",{\"1\":{\"819\":1}}],[\"然后看实现类中有哪些方法\",{\"1\":{\"809\":1}}],[\"然后使用\",{\"1\":{\"775\":1}}],[\"然后才能调用\",{\"1\":{\"768\":1}}],[\"然后才可以用泛型t作为方法的返回值\",{\"1\":{\"283\":1}}],[\"然后根据不同需要分别创建它们\",{\"1\":{\"798\":1}}],[\"然后根据\",{\"1\":{\"738\":2}}],[\"然后根据得到\",{\"1\":{\"644\":1}}],[\"然后和\",{\"1\":{\"734\":2}}],[\"然后缓存\",{\"1\":{\"704\":1}}],[\"然后放进这个雏形\",{\"1\":{\"702\":1}}],[\"然后给雏形找个父亲\",{\"1\":{\"702\":1}}],[\"然后传递给\",{\"1\":{\"644\":1}}],[\"然后对该对象进行缓存\",{\"1\":{\"639\":1}}],[\"然后\",{\"1\":{\"625\":1,\"627\":1,\"813\":1,\"839\":1}}],[\"然后交由具体实现类自定义创建流程\",{\"1\":{\"558\":1}}],[\"然后交给虚拟器去区别\",{\"1\":{\"291\":1}}],[\"然后你可以用内存分析器打开\",{\"1\":{\"485\":1}}],[\"然后你有两个方案来解决这个冲突\",{\"1\":{\"459\":1}}],[\"然后添加你所期望结果的条件\",{\"1\":{\"477\":1}}],[\"然后参数类型匹配\",{\"1\":{\"311\":1}}],[\"然后通过调用相同的方法来调用目标对象的方法\",{\"1\":{\"695\":1}}],[\"然后通过进行参数类型比较\",{\"1\":{\"310\":1}}],[\"然后通过putint方法写入一个1\",{\"1\":{\"93\":1}}],[\"然后调用printdepartment\",{\"1\":{\"650\":1}}],[\"然后调用解释器的解释方法\",{\"1\":{\"642\":1}}],[\"然后调用它\",{\"1\":{\"446\":1}}],[\"然后调用\",{\"1\":{\"310\":1}}],[\"然后基于此我们如何通过反射获取class类以及类中的成员变量\",{\"1\":{\"301\":1}}],[\"然后我们想要一个子类继承它\",{\"1\":{\"291\":1}}],[\"然后我们使用javap来分析这段代码\",{\"1\":{\"275\":1}}],[\"然后把不同的异常抛到更高层\",{\"1\":{\"260\":1}}],[\"然后把相同的异常重抛到更高层\",{\"1\":{\"260\":1}}],[\"然后绕过异常发生的地方继续执行\",{\"1\":{\"260\":1}}],[\"然后将aqs子类作为同步组件的内部类\",{\"1\":{\"873\":1}}],[\"然后将异常移交给catch语句块来处理\",{\"1\":{\"260\":1}}],[\"然后将解析properties文件\",{\"1\":{\"106\":1}}],[\"然后在进行类型擦除\",{\"1\":{\"290\":1}}],[\"然后在执行加法操作\",{\"1\":{\"165\":1}}],[\"然后在循环中才能找到我们需要的实现\",{\"1\":{\"115\":1}}],[\"然后存储回内存\",{\"1\":{\"164\":1}}],[\"然后组成一个\",{\"1\":{\"139\":1}}],[\"然后返回放弃前offset行\",{\"1\":{\"864\":1}}],[\"然后返回这个对象引用\",{\"1\":{\"125\":1}}],[\"然后返回实例对象\",{\"1\":{\"114\":1}}],[\"然后保存\",{\"1\":{\"114\":1}}],[\"然后从文件中解析出key=factoryclass类名称的所有value值\",{\"1\":{\"106\":1}}],[\"然后是调用driversiterator\",{\"1\":{\"103\":1}}],[\"然后再手动地覆盖各种执行路径\",{\"1\":{\"990\":1}}],[\"然后再对齐的例子\",{\"1\":{\"912\":1}}],[\"然后再关联\",{\"1\":{\"864\":1}}],[\"然后再使用\",{\"1\":{\"772\":1}}],[\"然后再交给要买计算机的采购员\",{\"1\":{\"549\":1}}],[\"然后再子类中重写参数类型为date的那两个方法\",{\"1\":{\"291\":1}}],[\"然后再进行获取连接等的操作\",{\"1\":{\"98\":1}}],[\"然后再运行上面的程序\",{\"1\":{\"91\":1}}],[\"然后新建接口全限定名的文件\",{\"1\":{\"96\":1}}],[\"单元就是人为规定的最小的被测功能模块\",{\"1\":{\"989\":1}}],[\"单元测试不是越多越好\",{\"1\":{\"992\":1}}],[\"单元测试不负责检查跨类或者跨系统的交互逻辑\",{\"1\":{\"860\":1}}],[\"单元测试要写多细\",{\"0\":{\"992\":1}}],[\"单元测试也差不多完成了\",{\"1\":{\"991\":1}}],[\"单元测试就是一种无价的文档\",{\"1\":{\"990\":1}}],[\"单元测试可以有效地降低程序出现bug的机率\",{\"1\":{\"990\":1}}],[\"单元测试是在软件开发过程中要进行的最低级别的测试活动\",{\"1\":{\"989\":1}}],[\"单元测试是可以重复执行的\",{\"1\":{\"860\":1}}],[\"单元测试与线上故障没有辩证关系\",{\"1\":{\"860\":1}}],[\"单元测试代码有助于理解代码的功能和需求\",{\"1\":{\"992\":1}}],[\"单元测试代码不需要维护\",{\"1\":{\"860\":1}}],[\"单元测试代码是多余的\",{\"1\":{\"860\":1}}],[\"单元测试代码必须写在如下工程目录\",{\"1\":{\"860\":1}}],[\"单元测试作为一种质量保障手段\",{\"1\":{\"860\":1}}],[\"单元测试最好覆盖所有测试用例\",{\"1\":{\"860\":1}}],[\"单元测试通常会被放到持续集成中\",{\"1\":{\"860\":1}}],[\"单元测试用例之间决不能互相调用\",{\"1\":{\"860\":1}}],[\"单元测试必须使用assert来验证\",{\"1\":{\"860\":1}}],[\"单元测试应该是全自动执行的\",{\"1\":{\"860\":1}}],[\"单元测试在线上运行时\",{\"1\":{\"860\":1}}],[\"单元测试等知识丰富立体地呈现出来\",{\"1\":{\"843\":1}}],[\"单元测试\",{\"0\":{\"860\":1},\"1\":{\"843\":1,\"988\":1,\"989\":1}}],[\"单元测试中的标准工具\",{\"1\":{\"476\":1}}],[\"单行格式可以被替换\",{\"1\":{\"955\":1}}],[\"单行字符限制\",{\"1\":{\"888\":1,\"891\":1}}],[\"单行字符数限制不超过\",{\"1\":{\"847\":1}}],[\"单个\",{\"1\":{\"911\":1}}],[\"单个空行也可以出现在任何需要提高代码可读性的地方\",{\"1\":{\"910\":1}}],[\"单个空行总是出现在以下情况中\",{\"1\":{\"910\":1}}],[\"单个方法的总行数不超过\",{\"1\":{\"847\":1}}],[\"单一原则最易理解却是最难实现的一条规则\",{\"1\":{\"871\":1}}],[\"单一职责原则主要是约束类\",{\"1\":{\"721\":1}}],[\"单一职责原则注重的是职责\",{\"1\":{\"721\":1}}],[\"单一职责原则注意事项和细节\",{\"0\":{\"719\":1}}],[\"单一职责原则的核心就是控制类的粒度大小\",{\"1\":{\"717\":1}}],[\"单一职责原则的优点\",{\"0\":{\"717\":1}}],[\"单一职责原则规定一个类应该有且仅有一个引起它变化的原因\",{\"1\":{\"716\":1}}],[\"单一职责原则\",{\"0\":{\"715\":1},\"1\":{\"714\":1,\"716\":1,\"748\":2,\"775\":1,\"818\":1}}],[\"单位\",{\"1\":{\"870\":1}}],[\"单表行数超过\",{\"1\":{\"863\":1}}],[\"单表时自增\",{\"1\":{\"863\":1}}],[\"单测的基本目标\",{\"1\":{\"860\":1}}],[\"单测粒度至多是类级别\",{\"1\":{\"860\":1}}],[\"单词之间以下划线分隔\",{\"1\":{\"942\":1}}],[\"单词如果需要分隔\",{\"1\":{\"854\":1}}],[\"单词间用下划线隔开\",{\"1\":{\"845\":2}}],[\"单向的关联用\",{\"1\":{\"830\":1}}],[\"单例工厂类都需要注意\",{\"1\":{\"851\":1}}],[\"单例\",{\"1\":{\"773\":1}}],[\"单例除了我们之前讲到的使用方法之外\",{\"1\":{\"769\":1}}],[\"单例不支持有参数的构造函数\",{\"0\":{\"768\":1},\"1\":{\"768\":1}}],[\"单例类中对象的唯一性的作用范围是进程内的\",{\"1\":{\"770\":1}}],[\"单例类在老进程中存在且只能存在一个对象\",{\"1\":{\"770\":1}}],[\"单例类在某些情况下会影响代码的扩展性\",{\"1\":{\"766\":1}}],[\"单例类只能有一个对象实例\",{\"1\":{\"766\":1}}],[\"单例类不需要显示创建\",{\"1\":{\"765\":1}}],[\"单例类也可以被继承\",{\"1\":{\"764\":1}}],[\"单例会隐藏类之间的依赖关系\",{\"0\":{\"765\":1}}],[\"单例这种设计模式对于其中的抽象\",{\"1\":{\"764\":1}}],[\"单例对代码的可测试性不友好\",{\"0\":{\"767\":1}}],[\"单例对代码的扩展性不友好\",{\"0\":{\"766\":1}}],[\"单例对继承\",{\"1\":{\"764\":1}}],[\"单例对\",{\"0\":{\"764\":1}}],[\"单例存在哪些问题\",{\"0\":{\"763\":1}}],[\"单例设计模式八种方式\",{\"0\":{\"751\":1}}],[\"单例设计模式\",{\"1\":{\"750\":1}}],[\"单例设计模式介绍\",{\"0\":{\"750\":1}}],[\"单例模式创建的对象是进程唯一的\",{\"1\":{\"770\":1}}],[\"单例模式书写简洁\",{\"1\":{\"763\":1}}],[\"单例模式可以保证在一个\",{\"1\":{\"762\":1}}],[\"单例模式可以保证内存里只有一个实例\",{\"1\":{\"750\":1}}],[\"单例模式的使用会影响到代码的可测试性\",{\"1\":{\"767\":1}}],[\"单例模式的应用场景主要有以下几个方面\",{\"1\":{\"762\":1}}],[\"单例模式的应用场景\",{\"0\":{\"762\":1}}],[\"单例模式的功能代码通常写在一个类中\",{\"1\":{\"750\":1}}],[\"单例模式使用的场景\",{\"1\":{\"761\":1}}],[\"单例模式保证了\",{\"1\":{\"761\":1}}],[\"单例模式注意事项和细节说明\",{\"0\":{\"761\":1}}],[\"单例模式jdk应用\",{\"0\":{\"760\":1}}],[\"单例模式有八种方式\",{\"1\":{\"751\":1}}],[\"单例模式不利于代码调试\",{\"1\":{\"750\":1}}],[\"单例模式一般没有接口\",{\"1\":{\"750\":1}}],[\"单例模式设置全局访问点\",{\"1\":{\"750\":1}}],[\"单例模式在现实生活中的应用也非常广泛\",{\"1\":{\"750\":1}}],[\"单例模式\",{\"1\":{\"589\":1,\"798\":1}}],[\"单品咖啡\",{\"1\":{\"581\":1}}],[\"单独的对象\",{\"1\":{\"702\":1}}],[\"单独的\",{\"1\":{\"457\":1}}],[\"单点登录\",{\"1\":{\"427\":1}}],[\"绝对值得一读\",{\"1\":{\"453\":1}}],[\"统计修正等\",{\"1\":{\"866\":1}}],[\"统计学自然语言处理\",{\"1\":{\"418\":1}}],[\"统一代码格式化详解\",{\"0\":{\"965\":1}}],[\"统一命名规范详解\",{\"0\":{\"963\":1}}],[\"统一目录\",{\"1\":{\"859\":1}}],[\"统一规定使用三个斜杠\",{\"1\":{\"855\":1}}],[\"统一为gmt\",{\"1\":{\"854\":1}}],[\"统一使用下划线\",{\"1\":{\"854\":1}}],[\"统一建模语言\",{\"1\":{\"822\":1}}],[\"统一\",{\"1\":{\"822\":1}}],[\"统一遍历问题\",{\"1\":{\"651\":1}}],[\"统一管理多个子工厂\",{\"1\":{\"614\":1}}],[\"统一管理网状资源\",{\"1\":{\"591\":1}}],[\"统一对集合的访问方式\",{\"1\":{\"591\":1}}],[\"统一整体和个体\",{\"1\":{\"590\":1}}],[\"统一访问入口\",{\"1\":{\"590\":1}}],[\"统一样板的文档比没有文档更加糟糕\",{\"1\":{\"454\":1}}],[\"统一化你的代码格式对阅读你的代码的人有帮助吗\",{\"1\":{\"453\":1}}],[\"阅读了很多别人写的源码和框架\",{\"1\":{\"794\":1}}],[\"阅读计算机科学领域最糟糕的错误了解更多为何不使用\",{\"1\":{\"450\":1}}],[\"阅读是自我提升最便捷的方式\",{\"1\":{\"36\":1}}],[\"谷歌的\",{\"1\":{\"467\":1}}],[\"谷歌的auto\",{\"1\":{\"447\":1}}],[\"谷歌官方推出的json处理库\",{\"1\":{\"409\":1}}],[\"促进了对象的不可变性\",{\"1\":{\"447\":1}}],[\"他是依赖关系的特例\",{\"1\":{\"834\":1}}],[\"他是属于动态代理的范畴\",{\"1\":{\"692\":1}}],[\"他在\",{\"1\":{\"736\":1}}],[\"他\",{\"1\":{\"655\":1}}],[\"他大舅他二舅都是他舅\",{\"1\":{\"590\":1}}],[\"他们各自实现\",{\"1\":{\"727\":1}}],[\"他们之间没有继承的关系\",{\"1\":{\"573\":1}}],[\"他们的方法签名是一样的\",{\"1\":{\"291\":1}}],[\"他会让你感受到构建器到底是怎么回事\",{\"1\":{\"446\":1}}],[\"别名前加as使别名更容易识别\",{\"1\":{\"865\":1}}],[\"别名可以是表的简称\",{\"1\":{\"865\":1}}],[\"别给我们打电话\",{\"1\":{\"819\":1}}],[\"别的线程是无法进入的\",{\"1\":{\"758\":1}}],[\"别墅也好都需要经历这些过程\",{\"1\":{\"555\":1}}],[\"别墅\",{\"1\":{\"552\":1}}],[\"别这么干\",{\"1\":{\"445\":1}}],[\"别人看到这多少得琢磨一会这块到底写了个啥玩意\",{\"1\":{\"90\":1}}],[\"确认订单超时\",{\"1\":{\"874\":1}}],[\"确认无误才能执行更新语句\",{\"1\":{\"865\":1}}],[\"确定非功能性需求\",{\"1\":{\"871\":1}}],[\"确定指导后续设计与演化的原则\",{\"1\":{\"871\":1}}],[\"确定模块之间的依赖关系及模块的宏观输入与输出\",{\"1\":{\"871\":1}}],[\"确定系统内模块之间的关系\",{\"1\":{\"871\":1}}],[\"确定系统在技术层面上的做与不做\",{\"1\":{\"871\":1}}],[\"确定系统边界\",{\"1\":{\"871\":1}}],[\"确定访问者访问一个元素时该做什么\",{\"1\":{\"838\":1}}],[\"确实是这样的一门编程语言\",{\"1\":{\"443\":1}}],[\"确保你的代码的健壮性\",{\"1\":{\"990\":1}}],[\"确保countdown方法被执行到\",{\"1\":{\"851\":1}}],[\"确保所有的代码都调用新接口之后\",{\"1\":{\"818\":1}}],[\"确保协议独立性的工具\",{\"1\":{\"414\":1}}],[\"确保重新编译你的程序\",{\"1\":{\"183\":1}}],[\"好像是结束了一段代码块\",{\"1\":{\"923\":1}}],[\"好的单元测试能够最大限度地规避线上故障\",{\"1\":{\"860\":1}}],[\"好的单元测试宏观上来说\",{\"1\":{\"860\":1}}],[\"好的单元测试必须遵守air原则\",{\"1\":{\"860\":1}}],[\"好的命名\",{\"1\":{\"853\":1}}],[\"好的代码设计\",{\"1\":{\"808\":1}}],[\"好的替代品\",{\"1\":{\"472\":1,\"476\":1,\"480\":1,\"482\":1}}],[\"好处\",{\"1\":{\"794\":1}}],[\"好吧\",{\"1\":{\"443\":1}}],[\"好了\",{\"1\":{\"94\":1}}],[\"虽作为最流行的编程语言之一\",{\"1\":{\"443\":1}}],[\"虽然示例代码是属于\",{\"1\":{\"878\":1}}],[\"虽然在debug\",{\"1\":{\"859\":1}}],[\"虽然共享该实例是线程安全的\",{\"1\":{\"851\":1}}],[\"虽然继承有诸多作用\",{\"1\":{\"812\":1}}],[\"虽然它不强制要求所有的子类必须遵循这些契约\",{\"1\":{\"731\":1}}],[\"虽然它们是java平台库迄今为止最常被重用的异常\",{\"1\":{\"265\":1}}],[\"虽然也违反了\",{\"1\":{\"610\":1}}],[\"虽然作为独立的进程运行\",{\"1\":{\"484\":1}}],[\"虽然对重点支持的\",{\"1\":{\"472\":1}}],[\"虽然这很难提炼总结出我有多喜欢这个库\",{\"1\":{\"466\":1}}],[\"虽然反编译后发现注解继承了annotation接口\",{\"1\":{\"237\":1}}],[\"虽然\",{\"1\":{\"186\":1}}],[\"虽然可以对两个\",{\"1\":{\"151\":1}}],[\"演讲者\",{\"1\":{\"440\":4}}],[\"演示try\",{\"1\":{\"258\":1}}],[\"演示\",{\"1\":{\"9\":1}}],[\"创始人兼ceo\",{\"1\":{\"440\":1}}],[\"创建索引时避免有如下极端误解\",{\"1\":{\"864\":1}}],[\"创建线程或线程池时请指定有意义的线程名称\",{\"1\":{\"851\":1}}],[\"创建框架是一项投入重大且风险很高的工作\",{\"1\":{\"819\":1}}],[\"创建bucke\",{\"1\":{\"809\":1}}],[\"创建bucket\",{\"1\":{\"809\":1}}],[\"创建活动对象\",{\"1\":{\"778\":1}}],[\"创建环境\",{\"1\":{\"776\":1}}],[\"创建完实例之后\",{\"1\":{\"768\":1}}],[\"创建单例对象\",{\"1\":{\"753\":1}}],[\"创建相关的审批人\",{\"1\":{\"710\":1}}],[\"创建处理链\",{\"1\":{\"708\":1}}],[\"创建子类对象\",{\"1\":{\"703\":1}}],[\"创建增强器\",{\"1\":{\"702\":1}}],[\"创建代理对象\",{\"1\":{\"695\":1,\"700\":1}}],[\"创建目标对象\",{\"1\":{\"695\":1,\"700\":1,\"702\":1,\"703\":1}}],[\"创建开销大的对象或需要安全控制的对象\",{\"1\":{\"692\":1}}],[\"创建流对象\",{\"1\":{\"689\":1}}],[\"创建观察者\",{\"1\":{\"678\":1}}],[\"创建接入方\",{\"1\":{\"676\":1}}],[\"创建游戏角色\",{\"1\":{\"667\":1}}],[\"创建了一个\",{\"1\":{\"742\":1,\"743\":1}}],[\"创建了\",{\"1\":{\"659\":1}}],[\"创建学院\",{\"1\":{\"650\":1}}],[\"创建那么多的对象将会耗费很多的系统资源\",{\"1\":{\"629\":1}}],[\"创建哪些对象\",{\"1\":{\"627\":1}}],[\"创建对应的实例\",{\"1\":{\"618\":1}}],[\"创建对象时耗时过多或耗费资源过多\",{\"1\":{\"761\":1}}],[\"创建对象用到的主要技术点就是\",{\"1\":{\"627\":1}}],[\"创建对象实例时\",{\"1\":{\"619\":1}}],[\"创建对象的任务由多个具体子工厂中的某一个完成\",{\"1\":{\"614\":1}}],[\"创建对象\",{\"1\":{\"305\":1,\"308\":1,\"622\":1,\"627\":2}}],[\"创建抽象工厂和子工厂\",{\"1\":{\"617\":1}}],[\"创建小米和华为的路由器\",{\"1\":{\"617\":1}}],[\"创建小米和华为的手机\",{\"1\":{\"617\":1}}],[\"创建伦敦口味的各种\",{\"1\":{\"613\":1}}],[\"创建北京口味的各种\",{\"1\":{\"613\":1}}],[\"创建不同的简单工厂类\",{\"1\":{\"613\":1}}],[\"创建所需的产品对象\",{\"1\":{\"608\":1}}],[\"创建各个子系统的对象\",{\"1\":{\"600\":1}}],[\"创建各个学院下面的系\",{\"1\":{\"574\":1}}],[\"创建型单例模式\",{\"0\":{\"749\":1}}],[\"创建型原型模式\",{\"0\":{\"681\":1}}],[\"创建型模式\",{\"1\":{\"608\":1,\"798\":2}}],[\"创建型工厂模式\",{\"0\":{\"605\":1}}],[\"创建型设计模式\",{\"0\":{\"589\":1}}],[\"创建型建造者模式\",{\"0\":{\"548\":1}}],[\"创建具体构件角色\",{\"1\":{\"580\":1}}],[\"创建电灯相关的开关命令\",{\"1\":{\"562\":1}}],[\"创建命令接口\",{\"1\":{\"562\":1}}],[\"创建一个更加基础的基类\",{\"1\":{\"734\":1}}],[\"创建一个请求\",{\"1\":{\"710\":1}}],[\"创建一个增强器\",{\"1\":{\"703\":1}}],[\"创建一个中介者对象\",{\"1\":{\"659\":1}}],[\"创建一个工厂类\",{\"1\":{\"636\":1}}],[\"创建一个\",{\"1\":{\"550\":1,\"678\":1}}],[\"创建新的\",{\"1\":{\"312\":1}}],[\"创建新的对象比较复杂时\",{\"1\":{\"690\":1}}],[\"创建新的对象\",{\"1\":{\"145\":1,\"682\":1,\"700\":1}}],[\"创建user对象\",{\"1\":{\"306\":1}}],[\"创建user\",{\"1\":{\"306\":1}}],[\"创建的对象中添加整数会报错呢\",{\"1\":{\"290\":1}}],[\"创建\",{\"1\":{\"263\":1,\"408\":1,\"574\":1,\"659\":2,\"667\":1,\"676\":1,\"779\":1,\"809\":2,\"839\":1}}],[\"问答平台\",{\"1\":{\"437\":1}}],[\"问题等\",{\"1\":{\"872\":1}}],[\"问题本身不需要设计模式\",{\"1\":{\"797\":1}}],[\"问题又来了\",{\"1\":{\"788\":1}}],[\"问题分析\",{\"0\":{\"635\":1,\"677\":1},\"1\":{\"779\":1}}],[\"问题\",{\"1\":{\"582\":1,\"731\":1,\"755\":1,\"872\":1}}],[\"问题排查之jvm可视化工具\",{\"0\":{\"376\":1}}],[\"问题排查之工具单\",{\"0\":{\"370\":1}}],[\"问题排查之linux命令\",{\"0\":{\"369\":1}}],[\"问题排查之使用idea本地调试和远程调试\",{\"0\":{\"368\":1}}],[\"问题排查之应用在线调试arthas\",{\"0\":{\"362\":1}}],[\"问题就是\",{\"1\":{\"264\":1}}],[\"社区开发者集体智慧的结晶\",{\"1\":{\"872\":1}}],[\"社区\",{\"0\":{\"437\":1}}],[\"致力于构建开发与业务分析人员之间的桥梁\",{\"1\":{\"435\":1}}],[\"业务场景逻辑\",{\"1\":{\"871\":1}}],[\"业务线\",{\"1\":{\"869\":1}}],[\"业务对象\",{\"1\":{\"868\":1,\"873\":1}}],[\"业务上具有唯一特性的字段\",{\"1\":{\"864\":1}}],[\"业务名称\",{\"1\":{\"863\":1,\"869\":1}}],[\"业务代码应避免以下情况\",{\"1\":{\"860\":1}}],[\"业务允许外等\",{\"1\":{\"860\":1}}],[\"业务方通知活动暂停\",{\"1\":{\"855\":1}}],[\"业务流程管理套件\",{\"0\":{\"435\":1}}],[\"业务规划与资源调度优化求解程序\",{\"1\":{\"391\":1}}],[\"微信信息\",{\"1\":{\"727\":1}}],[\"微信\",{\"1\":{\"727\":1}}],[\"微信公众号与微信用户\",{\"1\":{\"671\":1}}],[\"微框架\",{\"1\":{\"434\":1}}],[\"微服务网关鉴权\",{\"1\":{\"427\":1}}],[\"国际化团队或海外部署的服务器由于字符集问题\",{\"1\":{\"859\":1}}],[\"国际化支持和gui控件\",{\"1\":{\"434\":1}}],[\"国人开发的一个轻量级的mvc框架\",{\"1\":{\"424\":1,\"434\":1}}],[\"刮取\",{\"1\":{\"433\":1}}],[\"定位异常\",{\"1\":{\"874\":1}}],[\"定价发布\",{\"1\":{\"779\":1}}],[\"定时任务\",{\"1\":{\"432\":1}}],[\"定义依赖的时候\",{\"1\":{\"869\":1}}],[\"定义gav遵从以下规则\",{\"1\":{\"869\":1}}],[\"定义字段类型为text\",{\"1\":{\"863\":1}}],[\"定义时区分unchecked\",{\"1\":{\"858\":1}}],[\"定义线程组名称\",{\"1\":{\"851\":1}}],[\"定义do\",{\"1\":{\"848\":1}}],[\"定义数据对象do类时\",{\"1\":{\"848\":1}}],[\"定义为基本数据类型boolean\",{\"1\":{\"845\":1}}],[\"定义为一个抽象类\",{\"1\":{\"812\":1}}],[\"定义整形数组int\",{\"1\":{\"845\":1}}],[\"定义子类需要通过\",{\"1\":{\"835\":1}}],[\"定义到父类中\",{\"1\":{\"814\":1}}],[\"定义出一个接口叫状态接口\",{\"1\":{\"778\":1}}],[\"定义环境类的初始状态\",{\"1\":{\"776\":1}}],[\"定义中提到\",{\"1\":{\"770\":1}}],[\"定义的所有程序\",{\"1\":{\"732\":1}}],[\"定义接口\",{\"1\":{\"727\":1}}],[\"定义同事类的接口\",{\"1\":{\"656\":1}}],[\"定义访问和遍历聚合元素的接口\",{\"1\":{\"649\":1}}],[\"定义存储\",{\"1\":{\"649\":1}}],[\"定义表达式\",{\"1\":{\"644\":1}}],[\"定义解释器的接口\",{\"1\":{\"642\":1}}],[\"定义它的文法的一种表示\",{\"1\":{\"641\":1}}],[\"定义它的语法表示\",{\"1\":{\"591\":1}}],[\"定义了算法的骨架\",{\"1\":{\"801\":1}}],[\"定义了一系列算法\",{\"1\":{\"798\":1}}],[\"定义了一个公共接口\",{\"1\":{\"784\":1}}],[\"定义了一个\",{\"1\":{\"616\":1}}],[\"定义了一个创建对象的抽象方法\",{\"1\":{\"612\":1}}],[\"定义了一个创建对象的类\",{\"1\":{\"608\":1}}],[\"定义了策略接口\",{\"1\":{\"783\":1}}],[\"定义了产品的规范\",{\"1\":{\"612\":1,\"616\":1}}],[\"定义了抽象方法\",{\"1\":{\"556\":1}}],[\"定义各个子系统对象\",{\"1\":{\"601\":1}}],[\"定义新的操作行为\",{\"1\":{\"591\":1}}],[\"定义一套流程模板\",{\"1\":{\"591\":1}}],[\"定义一个测试方法变得简单很多\",{\"1\":{\"972\":1}}],[\"定义一个访问具体元素的接口\",{\"1\":{\"838\":1}}],[\"定义一个中介对象来简化原有对象之间的交互关系\",{\"1\":{\"798\":1}}],[\"定义一个操作中的算法骨架\",{\"1\":{\"798\":1}}],[\"定义一个用于创建产品的接口\",{\"1\":{\"798\":1}}],[\"定义一个处理请求的接口\",{\"1\":{\"708\":1}}],[\"定义一个接口\",{\"1\":{\"695\":1,\"776\":1}}],[\"定义一个\",{\"1\":{\"656\":1,\"812\":1}}],[\"定义一个抽象方法\",{\"1\":{\"613\":1}}],[\"定义一个抽象接口以规范准备接收附加责任的对象\",{\"1\":{\"580\":1}}],[\"定义一个可以实例化\",{\"1\":{\"610\":1}}],[\"定义一个高层接口\",{\"1\":{\"600\":1}}],[\"定义一个异常类应包含两个构造函数\",{\"1\":{\"254\":1}}],[\"定义一些通用的方法\",{\"1\":{\"568\":1}}],[\"定义实现化角色的接口\",{\"1\":{\"538\":1}}],[\"定义抽象类\",{\"1\":{\"538\":1}}],[\"定义抽象方法\",{\"1\":{\"282\":1}}],[\"定义泛型变量\",{\"1\":{\"284\":2}}],[\"定义泛型方法时\",{\"1\":{\"283\":1}}],[\"定义泛型方法语法格式\",{\"1\":{\"283\":1}}],[\"定义泛型接口的子类\",{\"1\":{\"282\":1}}],[\"定义属性\",{\"1\":{\"282\":1}}],[\"定义两个泛型类型的对象\",{\"1\":{\"281\":1}}],[\"定义自己的注解\",{\"1\":{\"234\":1}}],[\"定义注解后\",{\"1\":{\"233\":1}}],[\"定义\",{\"0\":{\"894\":1,\"947\":1},\"1\":{\"230\":1,\"876\":1}}],[\"定义在retentionpolicy枚举中\",{\"1\":{\"228\":1}}],[\"定义标准\",{\"0\":{\"109\":1},\"1\":{\"109\":1}}],[\"命名\",{\"0\":{\"936\":1}}],[\"命名方式\",{\"1\":{\"859\":1}}],[\"命名风格\",{\"0\":{\"845\":1}}],[\"命名模式使得\",{\"1\":{\"560\":1}}],[\"命名为checked\",{\"1\":{\"198\":1}}],[\"命令对象起到了纽带桥梁的作用\",{\"1\":{\"564\":1}}],[\"命令对象会负责让接收者执行请求的动作\",{\"1\":{\"564\":1}}],[\"命令接口的子类还有\",{\"1\":{\"563\":1}}],[\"命令调用者是\",{\"1\":{\"563\":1}}],[\"命令类\",{\"1\":{\"562\":1}}],[\"命令\",{\"1\":{\"560\":1}}],[\"命令的具体执行者\",{\"1\":{\"560\":1}}],[\"命令发布者\",{\"1\":{\"560\":1}}],[\"命令模式通常适用于以下场景\",{\"1\":{\"565\":1}}],[\"命令模式不足\",{\"1\":{\"564\":1}}],[\"命令模式的应用场景\",{\"0\":{\"565\":1}}],[\"命令模式的注意事项和细节\",{\"0\":{\"564\":1}}],[\"命令模式的结构与实现\",{\"0\":{\"561\":1}}],[\"命令模式的结果其实就是接收方的执行结果\",{\"1\":{\"560\":1}}],[\"命令模式可以定义宏命令来实现该功能\",{\"1\":{\"565\":1}}],[\"命令模式可以方便地实现这些功能\",{\"1\":{\"565\":1}}],[\"命令模式可以使调用者和接收者不直接交互\",{\"1\":{\"565\":1}}],[\"命令模式可以与\",{\"1\":{\"560\":2}}],[\"命令模式可将\",{\"1\":{\"562\":1}}],[\"命令模式解决智能生活项目\",{\"0\":{\"562\":1}}],[\"命令模式包含以下主要角色\",{\"1\":{\"561\":1}}],[\"命令模式\",{\"1\":{\"560\":1,\"562\":1,\"591\":1,\"798\":1}}],[\"命令模式就能很好地解决这个问题\",{\"1\":{\"560\":1}}],[\"命令模式基本介绍\",{\"0\":{\"560\":1}}],[\"命令行参数解析器\",{\"1\":{\"432\":2}}],[\"验证码校验\",{\"1\":{\"861\":1}}],[\"验证\",{\"1\":{\"432\":1}}],[\"私有方法\",{\"1\":{\"848\":1}}],[\"私有方法以及移除静态初始化器的模拟工具\",{\"1\":{\"431\":1}}],[\"私有云不需要支持\",{\"1\":{\"809\":1}}],[\"私有构造\",{\"1\":{\"306\":1}}],[\"私有构造器\",{\"1\":{\"114\":1,\"302\":1}}],[\"集群相当于多个进程构成的一个集合\",{\"1\":{\"772\":1}}],[\"集群唯一\",{\"1\":{\"772\":3}}],[\"集群管理\",{\"0\":{\"387\":1}}],[\"集合的\",{\"1\":{\"872\":1}}],[\"集合的组合模式剖析\",{\"0\":{\"575\":1}}],[\"集合里的元素即使isnotempty\",{\"1\":{\"858\":1}}],[\"集合初始化时\",{\"1\":{\"850\":1}}],[\"集合处理\",{\"0\":{\"850\":1}}],[\"集合中就使用了迭代器模式\",{\"1\":{\"651\":1}}],[\"集合类\",{\"1\":{\"469\":1,\"850\":1}}],[\"集合就变成了不可变的\",{\"1\":{\"451\":1}}],[\"集合\",{\"1\":{\"432\":2,\"466\":1,\"636\":1,\"659\":2}}],[\"集成了spring的一些功能\",{\"1\":{\"972\":1,\"981\":1}}],[\"集成\",{\"1\":{\"484\":1}}],[\"集成java\",{\"1\":{\"431\":1}}],[\"集成测试和功能行测试平台\",{\"1\":{\"431\":1}}],[\"旨在简化java\",{\"1\":{\"434\":1}}],[\"旨在提供一个高效开发环境\",{\"1\":{\"434\":1}}],[\"旨在替换jsp\",{\"1\":{\"430\":1}}],[\"旨在填补java\",{\"1\":{\"403\":1}}],[\"逻辑复杂的\",{\"1\":{\"992\":1}}],[\"逻辑复用\",{\"1\":{\"591\":1}}],[\"逻辑分组\",{\"1\":{\"910\":1}}],[\"逻辑分析\",{\"0\":{\"675\":1}}],[\"逻辑排序\",{\"1\":{\"896\":1}}],[\"逻辑删除在数据删除后可以追溯到行为操作\",{\"1\":{\"863\":1}}],[\"逻辑运算符\",{\"1\":{\"847\":1}}],[\"逻辑简单\",{\"1\":{\"430\":1}}],[\"逻辑代数与优化问题最先进的求解程序\",{\"1\":{\"391\":1}}],[\"健壮性好且适用性强\",{\"1\":{\"429\":1}}],[\"搜索其他类即可\",{\"1\":{\"826\":1}}],[\"搜索引擎回滚\",{\"1\":{\"866\":1}}],[\"搜索引擎\",{\"0\":{\"426\":1}}],[\"搜索的实现可能是基于文件系统的搜索\",{\"1\":{\"96\":1}}],[\"科学计算与分析\",{\"0\":{\"425\":1}}],[\"商业分析器\",{\"1\":{\"422\":2}}],[\"商业版主要针对企业客户\",{\"1\":{\"407\":1}}],[\"带来的负面影响\",{\"1\":{\"850\":1}}],[\"带空心三角箭头的虚线\",{\"1\":{\"834\":1}}],[\"带空心三角箭头的实线\",{\"1\":{\"833\":1}}],[\"带空心菱形的实线\",{\"1\":{\"831\":1}}],[\"带实心菱形的实线\",{\"1\":{\"832\":1}}],[\"带一个箭头的实线\",{\"1\":{\"830\":1}}],[\"带两个箭头或者没有箭头的实线\",{\"1\":{\"830\":1}}],[\"带箭头的虚线\",{\"1\":{\"828\":1}}],[\"带有存储过程或者sql语句的耦合对象\",{\"1\":{\"420\":1}}],[\"带符号右移\",{\"1\":{\"203\":1}}],[\"广泛使用\",{\"1\":{\"420\":1}}],[\"低层次模块依赖于高层次模块的抽象\",{\"1\":{\"871\":1}}],[\"低层模块尽量都要有抽象类或接口\",{\"1\":{\"729\":1}}],[\"低内聚\",{\"1\":{\"741\":3}}],[\"低耦合的代码结构更加简单\",{\"1\":{\"741\":1}}],[\"低耦合\",{\"1\":{\"419\":1,\"748\":1}}],[\"低位补0\",{\"1\":{\"203\":1}}],[\"易产生npe\",{\"1\":{\"858\":1}}],[\"易读的特点\",{\"1\":{\"854\":1}}],[\"易懂常量也要统一定义成应用内共享常量\",{\"1\":{\"846\":1}}],[\"易于扩展\",{\"1\":{\"791\":1}}],[\"易于理解\",{\"1\":{\"791\":1}}],[\"易于上手且支持语法超前预测\",{\"1\":{\"389\":1}}],[\"易扩展\",{\"1\":{\"419\":1}}],[\"涵盖性能测试和基准测试工具\",{\"1\":{\"431\":1}}],[\"涵盖了从基础的帮助函数到pgp\",{\"1\":{\"427\":1}}],[\"涵盖了从集合到特定开发库的高性能计算相关工具\",{\"1\":{\"406\":1}}],[\"涵盖\",{\"1\":{\"419\":1}}],[\"斯坦佛corenlp提供了一组基础工具\",{\"1\":{\"418\":1}}],[\"监控生产环境中应用程序的工具\",{\"1\":{\"416\":1}}],[\"未来也不可能被其他实现方式替换\",{\"1\":{\"810\":1}}],[\"未分类其它资源\",{\"1\":{\"415\":1}}],[\"未被实例化的服务提供者会被保存到缓存中去\",{\"1\":{\"114\":1}}],[\"清华大学\",{\"1\":{\"574\":1}}],[\"清晰的代码只是文档的某个片断\",{\"1\":{\"871\":1}}],[\"清晰立体地反映系统的调用纵深链路\",{\"1\":{\"871\":1}}],[\"清晰\",{\"1\":{\"414\":1,\"741\":1}}],[\"清空缓存中所有已实例化的服务提供者\",{\"1\":{\"114\":1}}],[\"聚能聊\",{\"1\":{\"872\":1}}],[\"聚集在一起\",{\"1\":{\"835\":1}}],[\"聚类\",{\"1\":{\"418\":1}}],[\"聚类和分类的可扩展算法\",{\"1\":{\"413\":1}}],[\"聚合通过方法参数\",{\"1\":{\"832\":1}}],[\"聚合与组合\",{\"1\":{\"826\":1}}],[\"聚合的方式引用其他类\",{\"1\":{\"748\":1}}],[\"聚合的内容有\",{\"1\":{\"649\":1}}],[\"聚合图\",{\"1\":{\"745\":1}}],[\"聚合复用原则\",{\"1\":{\"745\":1}}],[\"聚合等\",{\"1\":{\"741\":1,\"822\":1}}],[\"聚合或其他方式等\",{\"1\":{\"545\":1}}],[\"聚合及继承等行为让不同的类承担不同的职责\",{\"1\":{\"537\":1}}],[\"聚合及关联\",{\"1\":{\"187\":1}}],[\"聚合\",{\"1\":{\"527\":1,\"528\":1,\"545\":1,\"734\":1,\"783\":1,\"791\":1,\"831\":1,\"835\":2}}],[\"聚合关系可以用\",{\"1\":{\"831\":1}}],[\"聚合关系也是通过成员对象来实现的\",{\"1\":{\"831\":1}}],[\"聚合关系和组合关系\",{\"1\":{\"830\":1}}],[\"聚合关系\",{\"0\":{\"215\":1,\"831\":1},\"1\":{\"827\":1}}],[\"融合了面向对象和函数式编程思想的静态类型编程语言\",{\"1\":{\"411\":1}}],[\"强\",{\"1\":{\"835\":1}}],[\"强耦合\",{\"1\":{\"818\":1}}],[\"强烈鼓励使用面向对象的设计\",{\"1\":{\"449\":1}}],[\"强健的\",{\"1\":{\"434\":1}}],[\"强健的持久化框架\",{\"1\":{\"420\":1}}],[\"强健的日期开发库\",{\"1\":{\"412\":1}}],[\"强大的任务调度库\",{\"1\":{\"415\":1}}],[\"强大且易于使用的java到json转换开发库\",{\"1\":{\"409\":1}}],[\"强制错误信息输入\",{\"1\":{\"860\":1}}],[\"强制\",{\"1\":{\"263\":1,\"843\":1,\"845\":13,\"846\":3,\"847\":10,\"848\":19,\"849\":5,\"850\":15,\"851\":12,\"852\":5,\"853\":5,\"854\":10,\"855\":6,\"857\":7,\"858\":9,\"859\":10,\"860\":7,\"861\":10,\"863\":10,\"864\":4,\"865\":9,\"866\":7,\"869\":8,\"870\":1,\"871\":7}}],[\"强制转换为\",{\"0\":{\"161\":1}}],[\"安排运算先后顺序\",{\"1\":{\"644\":1}}],[\"安装的组件等等\",{\"1\":{\"601\":1}}],[\"安卓和浏览器提供的静态类型编程语言\",{\"1\":{\"411\":1}}],[\"安卓图片下载和图片缓存开发库\",{\"1\":{\"408\":1}}],[\"安全包除外\",{\"1\":{\"869\":1}}],[\"安全规约\",{\"0\":{\"861\":1},\"1\":{\"843\":1}}],[\"安全代理\",{\"1\":{\"705\":1}}],[\"安全方式\",{\"0\":{\"570\":1}}],[\"安全\",{\"0\":{\"427\":1}}],[\"安全性异常\",{\"1\":{\"261\":1}}],[\"安全性是简单而纯粹的\",{\"1\":{\"192\":1}}],[\"安全性\",{\"1\":{\"123\":1}}],[\"安全的在\",{\"1\":{\"14\":2}}],[\"评审内容包括存储介质选型\",{\"1\":{\"871\":1}}],[\"评分\",{\"1\":{\"845\":1}}],[\"评价有不同的种类\",{\"1\":{\"839\":1}}],[\"评价和操作图片的支持库\",{\"1\":{\"408\":1}}],[\"评论\",{\"1\":{\"6\":1,\"34\":1,\"861\":1}}],[\"老师依然存在\",{\"1\":{\"831\":1}}],[\"老师授课中\",{\"1\":{\"695\":1,\"700\":1,\"703\":1}}],[\"老手和\",{\"1\":{\"797\":1}}],[\"老的使用方式\",{\"1\":{\"769\":1}}],[\"老牌开源项目\",{\"1\":{\"407\":1}}],[\"老话说\",{\"1\":{\"36\":1}}],[\"受到sinatra启发的java\",{\"1\":{\"424\":1}}],[\"受retrofit\",{\"1\":{\"424\":1}}],[\"受smalltalk启发的集合框架\",{\"1\":{\"406\":1}}],[\"受检查的异常必须在编译时被捕捉处理\",{\"1\":{\"198\":1}}],[\"受检查的异常\",{\"1\":{\"198\":1}}],[\"受检查异常和运行时异常\",{\"0\":{\"198\":1}}],[\"受检异常\",{\"1\":{\"146\":1}}],[\"全大写\",{\"1\":{\"942\":1}}],[\"全角字符\",{\"1\":{\"905\":1}}],[\"全省略方式\",{\"1\":{\"850\":1}}],[\"全部正常\",{\"1\":{\"857\":1}}],[\"全部使用equals方法比较\",{\"1\":{\"848\":1}}],[\"全部替换成\",{\"1\":{\"610\":1}}],[\"全局变量引用其他类\",{\"1\":{\"748\":1}}],[\"全国社保联网\",{\"1\":{\"590\":1}}],[\"全文本搜索引擎\",{\"1\":{\"426\":1}}],[\"全面的跨平台高级框架\",{\"1\":{\"404\":1}}],[\"全限定类名\",{\"1\":{\"305\":1}}],[\"现要求打印出学校总部员工\",{\"1\":{\"742\":1}}],[\"现实生活中的备忘录是用来记录某些要去做的事情\",{\"1\":{\"663\":1}}],[\"现实生活中的适配器例子\",{\"0\":{\"521\":1}}],[\"现实生活中\",{\"1\":{\"593\":1}}],[\"现实角度可能会提供更加开阔的思路\",{\"1\":{\"545\":1}}],[\"现如今有两种主流的方式\",{\"1\":{\"456\":1}}],[\"现代软件架构的复杂性需要协同开发完成\",{\"1\":{\"843\":1}}],[\"现代软件行业的高速发展对开发者的综合素质要求越来越高\",{\"1\":{\"843\":1}}],[\"现代图形化用户界面开发库\",{\"1\":{\"405\":1}}],[\"现代3d游戏开发引擎\",{\"1\":{\"404\":1}}],[\"现在让我们看看\",{\"1\":{\"979\":1}}],[\"现在将所有内容转换为小写\",{\"1\":{\"947\":1}}],[\"现在的标准时间是协调世界时\",{\"1\":{\"873\":1}}],[\"现在的写法\",{\"1\":{\"290\":1}}],[\"现在人们想要\",{\"1\":{\"820\":1}}],[\"现在我们来分析其基本结构和实现方法\",{\"1\":{\"776\":1,\"784\":1}}],[\"现在我们来分析其基本结构与实现方法\",{\"1\":{\"649\":1}}],[\"现在有一只羊\",{\"1\":{\"684\":1}}],[\"现在有这样一个泛型类\",{\"1\":{\"291\":1}}],[\"现在来分析以下的应用场景\",{\"1\":{\"705\":1}}],[\"现在来分析其基本结构和实现方法\",{\"1\":{\"594\":1}}],[\"现在来看该模式的以下应用场景\",{\"1\":{\"669\":1}}],[\"现在对不同手机类型的不同品牌实现操作编程\",{\"1\":{\"539\":1}}],[\"现在你就可以这么用了\",{\"1\":{\"471\":1}}],[\"现在你可以确定\",{\"1\":{\"451\":1}}],[\"现在你可以清晰地知道\",{\"1\":{\"450\":1}}],[\"现在你可以将相同的注解在同一类型上使用多次\",{\"1\":{\"187\":1}}],[\"现在\",{\"1\":{\"187\":1,\"462\":1,\"772\":1}}],[\"现在驱动就被找到并实例化了\",{\"1\":{\"103\":1}}],[\"现在使用spi扩展来加载具体的驱动\",{\"1\":{\"102\":1}}],[\"现在这种方式就是使用了java的spi扩展机制来实现\",{\"1\":{\"98\":1}}],[\"结尾\",{\"1\":{\"940\":1}}],[\"结尾的单个语句的地方\",{\"1\":{\"901\":1}}],[\"结论\",{\"1\":{\"752\":1,\"753\":1,\"754\":1,\"755\":1,\"757\":1,\"758\":1,\"759\":1}}],[\"结构清晰\",{\"1\":{\"775\":1}}],[\"结构与实现\",{\"1\":{\"669\":1}}],[\"结构复杂度\",{\"1\":{\"614\":1}}],[\"结构图\",{\"1\":{\"608\":1}}],[\"结构图如下所示\",{\"1\":{\"649\":1}}],[\"结构图如下\",{\"1\":{\"561\":1,\"838\":1}}],[\"结构\",{\"1\":{\"585\":1,\"626\":1}}],[\"结构型模式\",{\"1\":{\"798\":2}}],[\"结构型模式和行为型模式\",{\"1\":{\"798\":1}}],[\"结构型代理模式\",{\"0\":{\"691\":1}}],[\"结构型享元模式\",{\"0\":{\"628\":1}}],[\"结构型外观模式\",{\"0\":{\"592\":1}}],[\"结构型设计模式\",{\"0\":{\"590\":1}}],[\"结构型装饰者模式\",{\"0\":{\"578\":1}}],[\"结构型组合模式\",{\"0\":{\"566\":1}}],[\"结构型桥接模式\",{\"0\":{\"536\":1}}],[\"结构型适配器模式\",{\"0\":{\"517\":1}}],[\"结合业界分层规范与流行技术框架分析\",{\"1\":{\"868\":1}}],[\"结合一线开发的实践经验和故障案例\",{\"1\":{\"843\":1}}],[\"结合装饰器模式会更加灵活\",{\"1\":{\"560\":1}}],[\"结合\",{\"1\":{\"560\":2}}],[\"结合了传统的rdbms和nosql的最佳特性\",{\"1\":{\"400\":1}}],[\"结果出现\",{\"1\":{\"866\":1}}],[\"结果等于\",{\"1\":{\"848\":1}}],[\"结果如下\",{\"1\":{\"291\":1}}],[\"结果就是\",{\"1\":{\"264\":1}}],[\"结果都为\",{\"1\":{\"138\":1}}],[\"帮忙\",{\"1\":{\"655\":1}}],[\"帮我们自动完成了\",{\"1\":{\"627\":1}}],[\"帮实现依赖翻转范式的开发库\",{\"1\":{\"397\":1}}],[\"帮助你更深入地理解代码\",{\"1\":{\"990\":1}}],[\"帮助我们快速地定位出问题\",{\"1\":{\"854\":1}}],[\"帮助我们保证了线程的安全性\",{\"1\":{\"758\":1}}],[\"帮助人们简化对软件系统的理解\",{\"1\":{\"826\":1}}],[\"帮助解决约束满足问题的开发库\",{\"1\":{\"391\":1}}],[\"帮助程序员正确地进行选择以防止系统的崩溃\",{\"1\":{\"206\":1}}],[\"帮助同事治疗好多年的低血压\",{\"1\":{\"88\":1}}],[\"高德地图服务等\",{\"1\":{\"868\":1}}],[\"高并发服务器建议调小tcp协议的time\",{\"1\":{\"870\":1}}],[\"高并发集群\",{\"1\":{\"865\":1}}],[\"高并发时\",{\"1\":{\"851\":1}}],[\"高聚合\",{\"1\":{\"748\":1}}],[\"高层不应该依赖低层\",{\"1\":{\"748\":1}}],[\"高层模块不应该依赖低层模块\",{\"1\":{\"725\":1}}],[\"高层模块只需要知道产品的抽象类\",{\"1\":{\"612\":1}}],[\"高内聚会让代码更加松耦合\",{\"1\":{\"818\":1}}],[\"高内聚\",{\"1\":{\"741\":5,\"816\":6,\"817\":1,\"818\":2}}],[\"高配中配和低配\",{\"1\":{\"589\":1}}],[\"高楼的透明屋顶\",{\"1\":{\"555\":1}}],[\"高楼的砌墙\",{\"1\":{\"555\":1}}],[\"高楼的打地基\",{\"1\":{\"555\":1}}],[\"高楼\",{\"1\":{\"552\":1,\"555\":1}}],[\"高度注意表达式\",{\"1\":{\"852\":1}}],[\"高度注意map类集合k\",{\"1\":{\"850\":1}}],[\"高度注意对父集合元素的增加或删除\",{\"1\":{\"850\":1}}],[\"高度模块化的类sinatra框架\",{\"1\":{\"434\":1}}],[\"高度可扩展的web应用程序\",{\"1\":{\"434\":1}}],[\"高吞吐量分布式消息系统\",{\"1\":{\"414\":1}}],[\"高效创建对象\",{\"1\":{\"589\":1}}],[\"高效的对象图形序列化框架\",{\"1\":{\"428\":1}}],[\"高效利用内存的序列化函数库\",{\"1\":{\"428\":1}}],[\"高效可扩展的单播\",{\"1\":{\"414\":1}}],[\"高效机器学习库\",{\"1\":{\"413\":1}}],[\"高效\",{\"1\":{\"408\":1,\"409\":1,\"434\":1}}],[\"高性能\",{\"1\":{\"419\":1}}],[\"高性能应用中常见的数据结构和工具方法\",{\"1\":{\"406\":1}}],[\"高性能计算\",{\"0\":{\"406\":1}}],[\"高性能jdbc连接工具\",{\"1\":{\"394\":1}}],[\"高可扩展内存数据网格\",{\"1\":{\"399\":1}}],[\"高级时间和日期库\",{\"1\":{\"396\":1}}],[\"针对统计时间等场景\",{\"1\":{\"849\":1}}],[\"针对\",{\"1\":{\"813\":1}}],[\"针对这个问题\",{\"1\":{\"768\":1}}],[\"针对接口编程而不是具体类\",{\"1\":{\"783\":1}}],[\"针对接口编程\",{\"1\":{\"746\":1}}],[\"针对servlet和jsp的应用服务器\",{\"1\":{\"429\":1}}],[\"针对缓存的高并发键值对数据存储\",{\"1\":{\"400\":1}}],[\"针对大数据的hadoop数据库\",{\"1\":{\"400\":1}}],[\"针对大数据的分布式sql查询引擎\",{\"1\":{\"394\":1}}],[\"针对大型分布式系统的协调服务\",{\"1\":{\"399\":1}}],[\"针对代数数据类型的jsr\",{\"1\":{\"398\":1}}],[\"针对jvm语言的配置库\",{\"1\":{\"390\":1}}],[\"缩进\",{\"0\":{\"923\":1},\"1\":{\"847\":1}}],[\"缩小功能改动导致的代码改动范围\",{\"1\":{\"818\":1}}],[\"缩放\",{\"1\":{\"394\":1}}],[\"缩写\",{\"1\":{\"104\":1,\"845\":3}}],[\"容量不足\",{\"1\":{\"874\":1}}],[\"容器最核心的一个类了\",{\"1\":{\"627\":1}}],[\"容器会主动调用\",{\"1\":{\"622\":1}}],[\"容器在创建好对象之后\",{\"1\":{\"622\":1}}],[\"容器中\",{\"1\":{\"622\":1}}],[\"容器读取这个配置文件\",{\"1\":{\"622\":1}}],[\"容器读取配置文件\",{\"1\":{\"622\":1}}],[\"容器的详细讲解\",{\"1\":{\"769\":1}}],[\"容器的最小原型\",{\"1\":{\"624\":1}}],[\"容器的具体实现的时候\",{\"1\":{\"622\":1}}],[\"容器的配置文件\",{\"1\":{\"622\":1}}],[\"容器的核心功能一般有三个\",{\"1\":{\"622\":1}}],[\"容器的核心功能有哪些\",{\"0\":{\"622\":1},\"1\":{\"620\":1}}],[\"容器来创建的类对象和创建类对象的必要信息\",{\"1\":{\"622\":1}}],[\"容器要创建哪些对象\",{\"1\":{\"622\":1}}],[\"容器事先并不知道应用会创建哪些对象\",{\"1\":{\"622\":1}}],[\"容器应该包含哪些核心功能\",{\"1\":{\"621\":1}}],[\"容器负责的事情要比单纯的工厂模式要多\",{\"1\":{\"621\":1}}],[\"容器负责的是整个应用中所有类对象的创建\",{\"1\":{\"621\":1}}],[\"容器相对于我们上面讲的工厂模式的例子来说\",{\"1\":{\"621\":1}}],[\"容器相当于一个大的工厂类\",{\"1\":{\"621\":1}}],[\"容器底层最基本的设计思路就是基于工厂模式的\",{\"1\":{\"621\":1}}],[\"容器有何区别\",{\"0\":{\"621\":1}}],[\"容器跟我们讲的工厂模式又有何区别和联系\",{\"1\":{\"620\":1}}],[\"容器\",{\"0\":{\"623\":1},\"1\":{\"620\":2,\"621\":1,\"623\":1,\"624\":1,\"769\":2,\"819\":1}}],[\"容器集成平台\",{\"1\":{\"392\":1}}],[\"容易出错的\",{\"1\":{\"992\":1}}],[\"容易出现类型转型异常\",{\"1\":{\"162\":1}}],[\"容易忘记去更新这些测试方法\",{\"1\":{\"972\":1}}],[\"容易遗漏\",{\"1\":{\"871\":1}}],[\"容易导致持续集成机制的不可用\",{\"1\":{\"860\":1}}],[\"容易造成文件大小\",{\"1\":{\"859\":1}}],[\"容易误认为是sync\",{\"1\":{\"852\":1}}],[\"容易忽略count值已经被改变\",{\"1\":{\"852\":1}}],[\"容易产生等值判断被\",{\"1\":{\"852\":1}}],[\"容易做到插拔替换\",{\"1\":{\"818\":1}}],[\"容易\",{\"1\":{\"816\":1}}],[\"容易修改\",{\"1\":{\"804\":1}}],[\"容易增删状态\",{\"1\":{\"780\":1}}],[\"容易混乱\",{\"1\":{\"658\":1}}],[\"容易实现\",{\"1\":{\"641\":1}}],[\"容易实现对请求的撤销和重做\",{\"1\":{\"564\":1}}],[\"容易添加节点或者叶子从而创建出复杂的\",{\"1\":{\"576\":1}}],[\"容易设计一个命令队列\",{\"1\":{\"564\":1}}],[\"外键影响数据库的插入速度\",{\"1\":{\"865\":1}}],[\"外键与级联更新适用于单机低并发\",{\"1\":{\"865\":1}}],[\"外观角色\",{\"1\":{\"596\":1}}],[\"外观\",{\"1\":{\"593\":1,\"594\":1,\"595\":2}}],[\"外观模式可以为系统设计一个简单的接口供外界访问\",{\"1\":{\"604\":1}}],[\"外观模式可以理解为转换一群接口\",{\"1\":{\"601\":1}}],[\"外观模式对客户端与子系统的耦合关系\",{\"1\":{\"603\":1}}],[\"外观模式的应用场景\",{\"0\":{\"604\":1}}],[\"外观模式的注意事项和细节\",{\"0\":{\"603\":1}}],[\"外观模式的结构与实现\",{\"0\":{\"594\":1}}],[\"外观模式就是解决多个复杂接口带来的使用困难\",{\"1\":{\"601\":1}}],[\"外观模式解决影院管理\",{\"0\":{\"601\":1}}],[\"外观模式基本介绍\",{\"0\":{\"593\":1}}],[\"外观模式\",{\"1\":{\"590\":1,\"593\":1,\"600\":1,\"603\":1,\"798\":1}}],[\"外部部重定向地址必须使用url\",{\"1\":{\"870\":1}}],[\"外部\",{\"1\":{\"868\":1}}],[\"外部数据接口\",{\"1\":{\"868\":1}}],[\"外部重定向地址必须使用url统一代理模块生成\",{\"1\":{\"854\":1}}],[\"外部正在调用的接口或者二方库依赖的接口\",{\"1\":{\"848\":1}}],[\"外部依赖的模块或者类\",{\"1\":{\"816\":1}}],[\"外部调用demofunction\",{\"1\":{\"769\":1}}],[\"外部能new\",{\"1\":{\"753\":1}}],[\"外部能\",{\"1\":{\"752\":1}}],[\"外部状态指对象得以依赖的一个标记\",{\"1\":{\"631\":1}}],[\"外部应用程序不用关心内部子系统的具体细节\",{\"1\":{\"593\":1}}],[\"外部配置工具\",{\"0\":{\"390\":1}}],[\"外界只能通过\",{\"1\":{\"209\":1}}],[\"复数结尾\",{\"1\":{\"845\":1}}],[\"复用性好\",{\"1\":{\"837\":1}}],[\"复用程度会不断增加\",{\"1\":{\"819\":1}}],[\"复用可以分为三个层次\",{\"1\":{\"819\":1}}],[\"复用的灵活性高\",{\"1\":{\"747\":1}}],[\"复用\",{\"1\":{\"747\":2}}],[\"复用了现存的类\",{\"1\":{\"518\":1}}],[\"复制对象的所有基本数据类型的成员变量值\",{\"1\":{\"689\":1}}],[\"复制一份给新的对象\",{\"1\":{\"689\":1}}],[\"复制的分布式数据存储\",{\"1\":{\"394\":1}}],[\"复杂性降低\",{\"1\":{\"717\":1}}],[\"复杂度\",{\"1\":{\"614\":1}}],[\"复杂的全功能自顶向下解析框架\",{\"1\":{\"389\":1}}],[\"复盘会成为你自我提升路上最好的帮手\",{\"1\":{\"36\":1}}],[\"测量数据更新时\",{\"1\":{\"673\":1}}],[\"测量和报告延迟的工具\",{\"1\":{\"422\":1}}],[\"测量代码指标和质量工具\",{\"1\":{\"388\":1}}],[\"测试用例\",{\"0\":{\"998\":1}}],[\"测试用例通常是被定期执行的\",{\"1\":{\"860\":1}}],[\"测试替身有如下\",{\"1\":{\"996\":1}}],[\"测试替身\",{\"0\":{\"996\":1},\"1\":{\"996\":1}}],[\"测试依赖组件\",{\"0\":{\"995\":1}}],[\"测试顺序\",{\"0\":{\"983\":1}}],[\"测试套件批量运行\",{\"1\":{\"999\":1}}],[\"测试套件\",{\"0\":{\"999\":1},\"1\":{\"982\":1}}],[\"测试例子\",{\"1\":{\"981\":1}}],[\"测试运行器则决定了用什么方式偏好去运行这些测试集\",{\"1\":{\"972\":1,\"981\":1}}],[\"测试运行器\",{\"1\":{\"972\":1,\"981\":1}}],[\"测试集运行器配合使用测试集功能\",{\"1\":{\"972\":1,\"981\":1}}],[\"测试集是一个suite\",{\"1\":{\"972\":1,\"981\":1}}],[\"测试集\",{\"1\":{\"972\":1,\"981\":1}}],[\"测试允许你编写代码更快\",{\"1\":{\"970\":1}}],[\"测试粒度小才能在出错时尽快定位到出错的位置\",{\"1\":{\"860\":1}}],[\"测试抽象工厂模式\",{\"1\":{\"617\":1}}],[\"测试代码\",{\"1\":{\"542\":1,\"574\":1,\"584\":1}}],[\"测试覆盖率百分比\",{\"1\":{\"484\":1}}],[\"测试是软件的关键环节\",{\"1\":{\"475\":1}}],[\"测试框架\",{\"1\":{\"431\":1}}],[\"测试内容从对象到接口\",{\"1\":{\"431\":1}}],[\"测试对象为空\",{\"1\":{\"241\":2}}],[\"测试对象不为空\",{\"1\":{\"241\":2}}],[\"测试失败\",{\"1\":{\"241\":2}}],[\"测试有返回值的方法\",{\"1\":{\"241\":2}}],[\"测试没有返回值\",{\"1\":{\"241\":2}}],[\"测试方式通过test的前缀方法获取\",{\"1\":{\"241\":1}}],[\"测试方法都必须以\",{\"1\":{\"998\":1}}],[\"测试方法必须是public\",{\"1\":{\"972\":1}}],[\"测试方法的命名没有一种唯一正确的方式\",{\"1\":{\"941\":1}}],[\"测试方法名中\",{\"1\":{\"941\":1}}],[\"测试方法\",{\"1\":{\"96\":1,\"972\":1,\"981\":1}}],[\"测试类2\",{\"1\":{\"982\":1}}],[\"测试类1\",{\"1\":{\"982\":1}}],[\"测试类是包含一个或多个测试方法的一个\",{\"1\":{\"981\":1}}],[\"测试类是包含一个或多个测试方法的一个test\",{\"1\":{\"972\":1}}],[\"测试类的名称以\",{\"1\":{\"940\":1}}],[\"测试类命名以它要测试的类的名称开始\",{\"1\":{\"845\":1}}],[\"测试类\",{\"1\":{\"236\":1,\"532\":1,\"555\":1,\"562\":1,\"601\":1,\"636\":1,\"644\":1,\"650\":1,\"659\":1,\"667\":1,\"676\":1,\"678\":1,\"695\":1,\"700\":1,\"703\":1,\"710\":1,\"778\":1,\"779\":1,\"789\":1,\"803\":1,\"839\":1,\"972\":2,\"981\":2}}],[\"测试的输出\",{\"1\":{\"234\":1}}],[\"测试\",{\"0\":{\"431\":1,\"975\":1,\"976\":1,\"977\":1,\"978\":1,\"979\":1,\"980\":1,\"981\":1,\"982\":1,\"983\":1},\"1\":{\"209\":1,\"678\":2,\"752\":1,\"753\":1}}],[\"后缀\",{\"1\":{\"935\":1}}],[\"后期维护\",{\"1\":{\"871\":1}}],[\"后期维护成本较大\",{\"1\":{\"549\":1}}],[\"后续的行从\",{\"1\":{\"957\":1}}],[\"后续的行中必须以\",{\"1\":{\"933\":1}}],[\"后续可能恢复使用的代码片断\",{\"1\":{\"855\":1}}],[\"后续会恢复此段代码逻辑\",{\"1\":{\"853\":1}}],[\"后端发现用户输入的参数大于总页数\",{\"1\":{\"854\":1}}],[\"后端解析会出错\",{\"1\":{\"854\":1}}],[\"后端传输的\",{\"1\":{\"854\":1}}],[\"后者过去分词表示被动式更新\",{\"1\":{\"863\":1}}],[\"后者建议直接删掉即可\",{\"1\":{\"853\":1}}],[\"后者的表述方式其实更能体现这条原则的设计初衷\",{\"1\":{\"808\":1}}],[\"后台便在用户不知情的情况下对数据库中用户参数进行相应修改\",{\"1\":{\"861\":1}}],[\"后台输送给页面的变量必须加\",{\"1\":{\"855\":1}}],[\"后台的数据仍是数组\",{\"1\":{\"850\":1}}],[\"后台运行\",{\"1\":{\"387\":1}}],[\"后文迪米特法则有介绍\",{\"1\":{\"816\":1}}],[\"后攻击力和防御力下降\",{\"1\":{\"665\":1}}],[\"后悔机制\",{\"1\":{\"591\":1}}],[\"后退\",{\"1\":{\"481\":1}}],[\"后面我们就不可以抽奖\",{\"1\":{\"778\":1}}],[\"后面就会讲到\",{\"1\":{\"773\":1}}],[\"后面再次访问时\",{\"1\":{\"757\":1}}],[\"后面再说\",{\"1\":{\"105\":1}}],[\"后面的想获得该类实例\",{\"1\":{\"755\":1}}],[\"后面的解释器可以从这里获取这些值\",{\"1\":{\"642\":1}}],[\"后面的很多架构设计\",{\"1\":{\"606\":1}}],[\"后面的日志也没有附加更有用的信息\",{\"1\":{\"270\":1}}],[\"后面的数值为散列码的无符号十六进制表示\",{\"1\":{\"140\":1}}],[\"后面接上要声明的异常\",{\"1\":{\"252\":1}}],[\"构成一个访问者\",{\"1\":{\"837\":1}}],[\"构建一个使用\",{\"1\":{\"550\":1}}],[\"构建和装配各个部件\",{\"1\":{\"550\":1}}],[\"构建和表示分离\",{\"1\":{\"549\":1}}],[\"构建模式\",{\"1\":{\"549\":1}}],[\"构建的对象就变成了不可变的了\",{\"1\":{\"446\":1}}],[\"构建器构建对象的时候\",{\"1\":{\"446\":1}}],[\"构建\",{\"1\":{\"432\":1,\"644\":1}}],[\"构建异步和基于事件的程序\",{\"1\":{\"423\":1}}],[\"构建响应式快速数据\",{\"1\":{\"423\":1}}],[\"构建高性能网络应用程序开发框架\",{\"1\":{\"419\":1}}],[\"构建及应用依赖关系处理工具\",{\"1\":{\"385\":1}}],[\"构建工具\",{\"0\":{\"385\":1}}],[\"构造方法中做的事情过多\",{\"1\":{\"860\":1}}],[\"构造方法里面禁止加入任何业务逻辑\",{\"1\":{\"848\":1}}],[\"构造方法传递\",{\"1\":{\"728\":1}}],[\"构造方法的类\",{\"1\":{\"306\":2}}],[\"构造方法等\",{\"1\":{\"301\":1,\"304\":1}}],[\"构造方法\",{\"1\":{\"227\":2,\"301\":1,\"901\":1,\"910\":1}}],[\"构造器私有化\",{\"1\":{\"752\":2,\"753\":1,\"758\":1}}],[\"构造器传入\",{\"1\":{\"555\":1}}],[\"构造器\",{\"1\":{\"225\":1,\"542\":3,\"562\":1,\"574\":3,\"601\":1,\"613\":1,\"636\":1,\"659\":1,\"689\":1,\"695\":1,\"700\":1,\"703\":1,\"710\":1,\"728\":1,\"745\":1,\"748\":1,\"778\":1,\"789\":1,\"832\":1}}],[\"构造静态内部类的对象\",{\"1\":{\"201\":1}}],[\"构造内部类对象需要外部类的引用\",{\"1\":{\"201\":1}}],[\"构造内部类和静态内部类对象\",{\"0\":{\"201\":1}}],[\"构造函数等\",{\"1\":{\"809\":2}}],[\"构造函数传参\",{\"1\":{\"644\":1}}],[\"构造函数对象\",{\"1\":{\"306\":2}}],[\"构造函数\",{\"1\":{\"144\":3,\"306\":4,\"431\":1}}],[\"管理很多人\",{\"1\":{\"839\":1}}],[\"管理学院员工的管理类\",{\"1\":{\"742\":1,\"743\":1}}],[\"管理\",{\"1\":{\"678\":1}}],[\"管理类\",{\"1\":{\"667\":1,\"839\":1}}],[\"管理者也能协调各个模块\",{\"1\":{\"818\":1}}],[\"管理者\",{\"1\":{\"664\":2}}],[\"管理对象集合\",{\"1\":{\"652\":1}}],[\"管理复杂度\",{\"1\":{\"614\":1}}],[\"管理工作由树枝构件完成\",{\"1\":{\"568\":1}}],[\"管理和应用数据库scheme变化的工具\",{\"1\":{\"384\":1}}],[\"管finally中的代码怎么样\",{\"1\":{\"197\":1}}],[\"持久化存储三个模块\",{\"1\":{\"818\":1}}],[\"持有一个策略类的引用\",{\"1\":{\"784\":1}}],[\"持有一个泛型t\",{\"1\":{\"283\":1}}],[\"持有接收对象\",{\"1\":{\"560\":1}}],[\"持有\",{\"1\":{\"527\":1,\"534\":1}}],[\"持续集成往往以软件即服务为产品目标\",{\"1\":{\"482\":1}}],[\"持续集成工具\",{\"1\":{\"392\":1}}],[\"持续集成\",{\"0\":{\"392\":1}}],[\"持续集成服务器\",{\"1\":{\"384\":1}}],[\"官方github\",{\"1\":{\"971\":1}}],[\"官方入门文档\",{\"1\":{\"971\":1}}],[\"官方资料\",{\"0\":{\"971\":1}}],[\"官方给出的解释\",{\"1\":{\"851\":1}}],[\"官方文档\",{\"1\":{\"294\":1}}],[\"官网地址\",{\"1\":{\"971\":1}}],[\"官网api\",{\"1\":{\"434\":1}}],[\"官网兼容junit框架\",{\"1\":{\"431\":1}}],[\"官网github\",{\"1\":{\"414\":2,\"435\":1}}],[\"官网repository\",{\"1\":{\"401\":1}}],[\"官网\",{\"1\":{\"384\":7,\"385\":4,\"386\":4,\"387\":2,\"388\":6,\"389\":2,\"390\":2,\"391\":4,\"392\":9,\"393\":1,\"394\":10,\"395\":4,\"396\":3,\"397\":5,\"398\":11,\"399\":8,\"400\":5,\"401\":6,\"402\":3,\"403\":5,\"404\":4,\"405\":2,\"406\":9,\"407\":5,\"408\":6,\"409\":6,\"410\":2,\"411\":6,\"412\":6,\"413\":9,\"414\":10,\"415\":7,\"416\":6,\"417\":1,\"418\":4,\"419\":7,\"420\":8,\"421\":6,\"422\":6,\"423\":3,\"424\":10,\"425\":3,\"426\":3,\"427\":6,\"428\":4,\"429\":5,\"430\":5,\"431\":18,\"432\":10,\"433\":3,\"434\":12,\"435\":1,\"437\":3,\"439\":2,\"442\":7}}],[\"古董级工具\",{\"0\":{\"384\":1}}],[\"古有赵高指鹿为马\",{\"1\":{\"91\":1}}],[\"垃圾回收基础知识\",{\"0\":{\"373\":1}}],[\"垃圾回收器之zgc详解\",{\"0\":{\"372\":1}}],[\"垃圾回收器之g1详解\",{\"0\":{\"371\":1}}],[\"垃圾回收器之cms\",{\"0\":{\"367\":1}}],[\"函数\",{\"1\":{\"814\":1}}],[\"函数的命名不能暴露任何实现细节\",{\"1\":{\"809\":1}}],[\"函数传递参数\",{\"1\":{\"768\":1}}],[\"函数式编程支持库\",{\"1\":{\"403\":1}}],[\"函数式编程\",{\"0\":{\"403\":1}}],[\"函数编程\",{\"0\":{\"356\":1}}],[\"函数访问父类的构造函数\",{\"1\":{\"134\":1}}],[\"移动端展示等\",{\"1\":{\"868\":1}}],[\"移除一切不必要的api和依赖\",{\"1\":{\"869\":1}}],[\"移除一个观察者\",{\"1\":{\"678\":1}}],[\"移除\",{\"1\":{\"839\":1,\"872\":1}}],[\"移除和通知\",{\"1\":{\"678\":1}}],[\"移除permgen\",{\"0\":{\"354\":1}}],[\"移位前先转化为它的补码\",{\"1\":{\"90\":1}}],[\"零拷贝实现\",{\"0\":{\"334\":1}}],[\"详细参考附表3\",{\"1\":{\"872\":1}}],[\"详细规定参考下方\",{\"1\":{\"869\":1}}],[\"详尽版\",{\"1\":{\"872\":1}}],[\"详见第\",{\"1\":{\"847\":1}}],[\"详解\",{\"0\":{\"330\":1,\"968\":1,\"985\":1,\"986\":1}}],[\"详情容器\",{\"1\":{\"14\":2}}],[\"装饰模式\",{\"1\":{\"798\":1}}],[\"装饰者代码\",{\"1\":{\"584\":1}}],[\"装饰者模式下的订单\",{\"1\":{\"584\":1}}],[\"装饰者模式解决订单项目\",{\"0\":{\"584\":1}}],[\"装饰者模式\",{\"0\":{\"328\":1},\"1\":{\"583\":1,\"814\":1}}],[\"装饰器是继承的有力补充\",{\"1\":{\"579\":1}}],[\"装饰器模式最著名的应用莫过于\",{\"1\":{\"586\":1}}],[\"装饰器模式通常在以下几种情况使用\",{\"1\":{\"586\":1}}],[\"装饰器模式主要包含以下角色\",{\"1\":{\"580\":1}}],[\"装饰器模式的应用场景\",{\"0\":{\"586\":1}}],[\"装饰器模式的结构图如图所示\",{\"1\":{\"580\":1}}],[\"装饰器模式的结构与实现\",{\"0\":{\"580\":1}}],[\"装饰器模式的定义与特点\",{\"0\":{\"579\":1}}],[\"装饰器模式会增加许多子类\",{\"1\":{\"579\":1}}],[\"装饰器模式完全遵守开闭原则\",{\"1\":{\"579\":1}}],[\"装饰器模式\",{\"1\":{\"579\":1,\"590\":1}}],[\"装箱\",{\"1\":{\"119\":1}}],[\"异步流处理标准\",{\"1\":{\"423\":1}}],[\"异步http和websocket客户端函数库\",{\"1\":{\"419\":1}}],[\"异步io详解\",{\"0\":{\"324\":1}}],[\"异常测试\",{\"0\":{\"979\":1}}],[\"异常流程\",{\"1\":{\"860\":1}}],[\"异常或者重要的错误信息\",{\"1\":{\"859\":1}}],[\"异常设计的初衷是解决程序运行中的各种意外情况\",{\"1\":{\"858\":1}}],[\"异常捕获中的\",{\"1\":{\"907\":1}}],[\"异常捕获后不要用来做流程控制\",{\"1\":{\"858\":1}}],[\"异常捕获处理的方法通常有\",{\"1\":{\"255\":1}}],[\"异常处理\",{\"0\":{\"858\":1}}],[\"异常处理者处理的异常的类信息\",{\"1\":{\"275\":1}}],[\"异常退出\",{\"1\":{\"848\":1}}],[\"异常日志\",{\"0\":{\"856\":1},\"1\":{\"843\":1}}],[\"异常不就可以了吗\",{\"1\":{\"812\":1}}],[\"异常不仅仅是一个错误控制机制\",{\"1\":{\"262\":1}}],[\"异常是否耗时\",{\"0\":{\"276\":1}}],[\"异常是一个事件\",{\"1\":{\"245\":1}}],[\"异常表的后两个item的type为any\",{\"1\":{\"275\":1}}],[\"异常表中包含了一个或多个异常处理者\",{\"1\":{\"275\":1}}],[\"异常时\",{\"1\":{\"266\":1}}],[\"异常类命名使用exception结尾\",{\"1\":{\"845\":1}}],[\"异常类越少\",{\"1\":{\"265\":1}}],[\"异常类型可能有多种\",{\"1\":{\"253\":1}}],[\"异常也不例外\",{\"1\":{\"265\":1}}],[\"异常机制的设计初衷是用于不正常的情况\",{\"1\":{\"263\":1}}],[\"异常机制详解\",{\"0\":{\"244\":1},\"1\":{\"146\":1}}],[\"异常只应该被用于不正常的条件\",{\"1\":{\"263\":1}}],[\"异常实践\",{\"0\":{\"262\":1}}],[\"异常代码之后的语句不再执行\",{\"1\":{\"258\":1}}],[\"异常就被抛出\",{\"1\":{\"251\":1}}],[\"异常关键字\",{\"0\":{\"251\":1}}],[\"异常基础总结\",{\"0\":{\"260\":1}}],[\"异常基础\",{\"0\":{\"250\":1}}],[\"异常指不期而至的各种状况\",{\"1\":{\"245\":1}}],[\"异常的illegalargumentexception\",{\"1\":{\"267\":1}}],[\"异常的捕获\",{\"0\":{\"255\":1}}],[\"异常的自定义\",{\"0\":{\"254\":1}}],[\"异常的抛出\",{\"0\":{\"253\":1}}],[\"异常的申明\",{\"0\":{\"252\":1}}],[\"异常的层次结构\",{\"0\":{\"245\":1}}],[\"异常的相关知识\",{\"1\":{\"244\":1}}],[\"异常信息应该包括两类信息\",{\"1\":{\"859\":1}}],[\"异常信息\",{\"1\":{\"242\":1}}],[\"异常\",{\"0\":{\"146\":1,\"196\":1,\"248\":1},\"1\":{\"242\":1,\"246\":1,\"265\":1,\"267\":2,\"853\":1,\"865\":1}}],[\"咱们主要看这一句\",{\"1\":{\"312\":1}}],[\"戳详情\",{\"1\":{\"312\":1}}],[\"避免与数字\",{\"1\":{\"935\":1}}],[\"避免为了设计而设计\",{\"1\":{\"871\":1}}],[\"避免如下误解\",{\"1\":{\"871\":1}}],[\"避免版本号不一致\",{\"1\":{\"869\":1}}],[\"避免随意发布此类定制包\",{\"1\":{\"869\":1}}],[\"避免执行后面的分页语句\",{\"1\":{\"865\":1}}],[\"避免回表\",{\"1\":{\"864\":1}}],[\"避免查询时需要调用ic服务获取\",{\"1\":{\"863\":1}}],[\"避免影响其它字段索引率\",{\"1\":{\"863\":1}}],[\"避免节外生枝\",{\"1\":{\"863\":1}}],[\"避免被滥刷而导致资损\",{\"1\":{\"861\":1}}],[\"避免频繁报警\",{\"1\":{\"859\":1}}],[\"避免用户投诉时\",{\"1\":{\"859\":1}}],[\"避免用apachebeanutils进行属性的copy\",{\"1\":{\"855\":1}}],[\"避免把服务器磁盘撑爆\",{\"1\":{\"859\":1}}],[\"避免直接抛出new\",{\"1\":{\"858\":1}}],[\"避免空指针\",{\"1\":{\"858\":1}}],[\"避免程序过度臃肿\",{\"1\":{\"855\":1}}],[\"避免数据结构无限增长吃光内存\",{\"1\":{\"855\":1}}],[\"避免出现误删除的情况\",{\"1\":{\"865\":1}}],[\"避免出现filesort的情况\",{\"1\":{\"864\":1}}],[\"避免出现注释的另一个极端\",{\"1\":{\"853\":1}}],[\"避免出现超长链无意识地破坏系统性能\",{\"1\":{\"711\":1}}],[\"避免采用取反逻辑运算符\",{\"1\":{\"852\":1}}],[\"避免后续代码维护困难\",{\"1\":{\"852\":1}}],[\"避免使用\",{\"1\":{\"852\":1,\"952\":1}}],[\"避免使用list的contains\",{\"1\":{\"850\":1}}],[\"避免random实例被多线程使用\",{\"1\":{\"851\":1}}],[\"避免主线程无法执行至await方法\",{\"1\":{\"851\":1}}],[\"避免更新丢失\",{\"1\":{\"851\":1}}],[\"避免加锁成功后\",{\"1\":{\"851\":1}}],[\"避免集合的无序性\",{\"1\":{\"850\":1}}],[\"避免抛出classcastexception异常\",{\"1\":{\"850\":1}}],[\"避免公历闰年\",{\"1\":{\"849\":1}}],[\"避免在gc后调整堆大小带来的压力\",{\"1\":{\"870\":1}}],[\"避免在锁代码块中调用rpc方法\",{\"1\":{\"851\":1}}],[\"避免在公历闰年时出现日期转换错误或程序逻辑错误\",{\"1\":{\"849\":1}}],[\"避免在子父类的成员变量之间\",{\"1\":{\"845\":1}}],[\"避免上下文重复使用一个变量\",{\"1\":{\"848\":1}}],[\"避免反序列化混乱\",{\"1\":{\"848\":1}}],[\"避免反序列失败\",{\"1\":{\"848\":1}}],[\"避免对接口调用方产生影响\",{\"1\":{\"848\":1}}],[\"避免通过一个类的对象引用访问此类的静态变量或静态方法\",{\"1\":{\"848\":1}}],[\"避免望文不知义\",{\"1\":{\"845\":1}}],[\"避免歧义\",{\"1\":{\"845\":1}}],[\"避免了使用多重转移语句\",{\"1\":{\"791\":1}}],[\"避免了线程不安全\",{\"1\":{\"758\":1}}],[\"避免了线程同步问题\",{\"1\":{\"752\":1}}],[\"避免其他进程再将其获取\",{\"1\":{\"772\":1}}],[\"避免大量同一对象的多次创建\",{\"1\":{\"639\":1}}],[\"避免重复打印日志\",{\"1\":{\"859\":1}}],[\"避免重复创建string\",{\"1\":{\"311\":1}}],[\"避免重新创建\",{\"1\":{\"629\":1}}],[\"避免每次重新从jvm获取带来的开销\",{\"1\":{\"313\":1}}],[\"避免团队协作不当引入\",{\"1\":{\"88\":1}}],[\"选材料\",{\"1\":{\"803\":1}}],[\"选材\",{\"1\":{\"802\":2}}],[\"选\",{\"1\":{\"597\":1}}],[\"选择\",{\"1\":{\"885\":1}}],[\"选择好的新鲜黄豆\",{\"1\":{\"803\":1}}],[\"选择排序\",{\"1\":{\"783\":1}}],[\"选择支付方式\",{\"1\":{\"591\":1}}],[\"选择重用哪一种异常并没有必须遵循的规则\",{\"1\":{\"265\":1}}],[\"选配\",{\"1\":{\"589\":1}}],[\"选出符合要求的方法\",{\"1\":{\"311\":1}}],[\"剩下就只有两个动作了\",{\"1\":{\"311\":1}}],[\"剩下的最低位是原来的符号位\",{\"1\":{\"90\":1}}],[\"了解每个服务大致的平均耗时\",{\"1\":{\"870\":1}}],[\"了解即可\",{\"1\":{\"232\":1}}],[\"了\",{\"1\":{\"310\":1,\"473\":1}}],[\"前一章节\",{\"1\":{\"929\":1}}],[\"前端拿到的值却是\",{\"1\":{\"854\":1}}],[\"前端开发\",{\"1\":{\"854\":1}}],[\"前后端的时间格式统一为\",{\"1\":{\"854\":1}}],[\"前后端数据列表相关的接口返回\",{\"1\":{\"854\":1}}],[\"前后端交互的api\",{\"1\":{\"854\":1}}],[\"前后端规约\",{\"0\":{\"854\":1}}],[\"前者现在时表示主动式创建\",{\"1\":{\"863\":1}}],[\"前者如果没有备注信息\",{\"1\":{\"853\":1}}],[\"前者的时间复杂度为o\",{\"1\":{\"850\":1}}],[\"前者采用了过程式管理\",{\"1\":{\"385\":1}}],[\"前言\",{\"0\":{\"843\":1}}],[\"前保存自身的状态\",{\"1\":{\"665\":1}}],[\"前台\",{\"1\":{\"590\":1}}],[\"前面提到的\",{\"1\":{\"809\":1}}],[\"前面我们讲到了一些\",{\"1\":{\"817\":1}}],[\"前面我们讲到继承可以实现代码复用\",{\"1\":{\"814\":1}}],[\"前面我们也提到\",{\"1\":{\"810\":1}}],[\"前面我们提到\",{\"1\":{\"808\":1}}],[\"前面我们克隆羊案例就是浅拷贝\",{\"1\":{\"689\":1}}],[\"前面设计的问题在于\",{\"1\":{\"743\":1}}],[\"前面也提到\",{\"1\":{\"741\":1}}],[\"前面学习了备忘录模式的定义与特点\",{\"1\":{\"669\":1}}],[\"前面介绍了关于迭代器模式的结构与特点\",{\"1\":{\"653\":1}}],[\"前面介绍了解释器模式的结构与特点\",{\"1\":{\"646\":1}}],[\"前面一种分类方法更加常见\",{\"1\":{\"606\":1}}],[\"前面分析了代理模式的结构与特点\",{\"1\":{\"705\":1}}],[\"前面分析了中介者模式的结构与特点\",{\"1\":{\"661\":1}}],[\"前面分析了享元模式的结构与特点\",{\"1\":{\"639\":1}}],[\"前面分析了组合模式的结构与特点\",{\"1\":{\"577\":1}}],[\"前面分析到方案\",{\"1\":{\"583\":1}}],[\"前面已分析过\",{\"1\":{\"308\":1}}],[\"前方的路才会越走越顺\",{\"1\":{\"36\":1}}],[\"圈圈\",{\"1\":{\"308\":2}}],[\"倘若需要连带获取到父类的字段\",{\"1\":{\"307\":1}}],[\"报错\",{\"1\":{\"305\":1,\"885\":1}}],[\"立即就进行了初始化\",{\"1\":{\"305\":1}}],[\"方括号是类型而非变量的一部分\",{\"1\":{\"921\":1}}],[\"方面的回滚方案\",{\"1\":{\"866\":1}}],[\"方式编写\",{\"1\":{\"940\":1,\"941\":2,\"943\":1,\"944\":1,\"945\":1}}],[\"方式解决\",{\"1\":{\"864\":1}}],[\"方式表达逻辑\",{\"1\":{\"852\":1}}],[\"方式传递\",{\"1\":{\"728\":1}}],[\"方式二\",{\"1\":{\"689\":1,\"727\":1}}],[\"方式一\",{\"1\":{\"689\":1,\"727\":1}}],[\"方式\",{\"1\":{\"689\":4,\"727\":1,\"728\":3,\"790\":2,\"859\":1,\"868\":1}}],[\"方式存放系\",{\"1\":{\"650\":1}}],[\"方式连接\",{\"1\":{\"482\":1}}],[\"方言\",{\"1\":{\"591\":1}}],[\"方案\",{\"0\":{\"582\":1,\"583\":1},\"1\":{\"583\":1}}],[\"方便系统间的解耦\",{\"1\":{\"871\":1}}],[\"方便维护\",{\"1\":{\"866\":1}}],[\"方便出错时回溯\",{\"1\":{\"851\":1}}],[\"方便更好地进行重构\",{\"1\":{\"848\":1}}],[\"方便客户端访问\",{\"1\":{\"705\":1}}],[\"方便创建出复杂的层次结构\",{\"1\":{\"576\":1}}],[\"方便实现\",{\"1\":{\"560\":1}}],[\"方便部署和操作\",{\"1\":{\"387\":1}}],[\"方便你快速学习\",{\"1\":{\"299\":1}}],[\"方法签名可以是任意的\",{\"1\":{\"998\":1}}],[\"方法签名相同\",{\"1\":{\"143\":1}}],[\"方法完成\",{\"1\":{\"997\":1}}],[\"方法测试if条件或变量是true还是false\",{\"1\":{\"978\":1}}],[\"方法测试一个变量是否为空或不为空\",{\"1\":{\"978\":1}}],[\"方法测试两个对象引用指向完全相同的对象\",{\"1\":{\"978\":1}}],[\"方法总会被标记\",{\"1\":{\"949\":1}}],[\"方法总共会调用\",{\"1\":{\"850\":1}}],[\"方法引用中的两个冒号\",{\"1\":{\"907\":1,\"911\":1}}],[\"方法重载\",{\"0\":{\"897\":1}}],[\"方法或者构造方法的名称紧随着与它相连的开括号\",{\"1\":{\"907\":1}}],[\"方法或\",{\"1\":{\"877\":1}}],[\"方法转为map集合时\",{\"1\":{\"850\":2}}],[\"方法打印其属性值\",{\"1\":{\"848\":1}}],[\"方法内代码\",{\"1\":{\"847\":1}}],[\"方法内部多行注释使用\",{\"1\":{\"853\":1}}],[\"方法内部单行注释\",{\"1\":{\"853\":1}}],[\"方法内部类\",{\"1\":{\"204\":1}}],[\"方法内部通过throw抛出异常\",{\"1\":{\"196\":1}}],[\"方法呢\",{\"1\":{\"812\":1}}],[\"方法不能照抄到\",{\"1\":{\"809\":1}}],[\"方法不能既负责摩托车\",{\"1\":{\"718\":1}}],[\"方法省略\",{\"1\":{\"778\":1}}],[\"方法进行同步效率太低\",{\"1\":{\"755\":1}}],[\"方法进行依赖传递\",{\"1\":{\"728\":1}}],[\"方法都要进行同步\",{\"1\":{\"755\":1}}],[\"方法即可\",{\"1\":{\"739\":1}}],[\"方法传递\",{\"1\":{\"728\":1}}],[\"方法竟然直接引用\",{\"1\":{\"727\":1}}],[\"方法赋值给成员变量即可\",{\"1\":{\"689\":1}}],[\"方法里返回成员变量\",{\"1\":{\"689\":1}}],[\"方法实现深拷贝\",{\"1\":{\"689\":1}}],[\"方法位于类的内部\",{\"1\":{\"682\":1}}],[\"方法得到一个\",{\"1\":{\"637\":1}}],[\"方法就是计算费用\",{\"1\":{\"582\":1}}],[\"方法就可以让接收者工作\",{\"1\":{\"564\":1}}],[\"方法被调用\",{\"1\":{\"561\":1}}],[\"方法添加监听器\",{\"1\":{\"532\":1}}],[\"方法添加到原来的异常\",{\"1\":{\"259\":1}}],[\"方法会比较值和精度\",{\"1\":{\"848\":1}}],[\"方法会被以一个字符串为参数的形式调用\",{\"1\":{\"477\":1}}],[\"方法会打印这些详细信息\",{\"1\":{\"254\":1}}],[\"方法吗\",{\"1\":{\"471\":1}}],[\"方法之后\",{\"1\":{\"446\":1}}],[\"方法后返回\",{\"1\":{\"311\":1}}],[\"方法列表需要进行过滤\",{\"1\":{\"311\":1}}],[\"方法调用了几次等\",{\"1\":{\"996\":1}}],[\"方法调用时传递了哪些参数\",{\"1\":{\"996\":1}}],[\"方法调用中的多个参数需要换行时\",{\"1\":{\"847\":1}}],[\"方法调用的点符号与下文一起换行\",{\"1\":{\"847\":1}}],[\"方法调用\",{\"1\":{\"308\":1,\"859\":1}}],[\"方法调用与\",{\"1\":{\"145\":1}}],[\"方法说明\",{\"1\":{\"306\":2,\"307\":2,\"308\":2}}],[\"方法返回值中的类为直接的朋友\",{\"1\":{\"741\":1}}],[\"方法返回值\",{\"1\":{\"306\":2,\"307\":2,\"308\":2,\"741\":1}}],[\"方法返回类型是org\",{\"1\":{\"104\":1}}],[\"方法名可以任意\",{\"1\":{\"972\":1}}],[\"方法名通常是动词或者动词短语\",{\"1\":{\"941\":1}}],[\"方法名以\",{\"1\":{\"941\":1}}],[\"方法名put\",{\"1\":{\"853\":1}}],[\"方法名称\",{\"1\":{\"306\":2,\"307\":2,\"308\":2}}],[\"方法名\",{\"0\":{\"941\":1},\"1\":{\"305\":1,\"845\":1}}],[\"方法取值的时候\",{\"1\":{\"290\":1}}],[\"方法取得一个对象引用\",{\"1\":{\"125\":1}}],[\"方法只能存储整形\",{\"1\":{\"288\":1}}],[\"方法获取他们的类的信息\",{\"1\":{\"288\":1}}],[\"方法获取一个\",{\"1\":{\"209\":1}}],[\"方法二\",{\"1\":{\"264\":1,\"610\":1}}],[\"方法一\",{\"1\":{\"264\":1,\"610\":1}}],[\"方法创建一个类的实例\",{\"1\":{\"261\":1}}],[\"方法创建的\",{\"1\":{\"104\":1}}],[\"方法未找到抛出的异常\",{\"1\":{\"261\":1}}],[\"方法放在\",{\"1\":{\"259\":1}}],[\"方法也可能抛出\",{\"1\":{\"259\":1}}],[\"方法头中使用关键字throws\",{\"1\":{\"252\":1}}],[\"方法上是否有mymethodannotation注解\",{\"1\":{\"234\":1}}],[\"方法参数在定义和传入时\",{\"1\":{\"847\":1}}],[\"方法参数和本地变量\",{\"1\":{\"227\":1}}],[\"方法参数\",{\"1\":{\"220\":1,\"221\":1,\"227\":1,\"741\":2}}],[\"方法使用注意等\",{\"1\":{\"872\":1}}],[\"方法使用了设计模式\",{\"1\":{\"845\":1}}],[\"方法使用\",{\"1\":{\"209\":1}}],[\"方法和类清晰地描述\",{\"1\":{\"454\":1}}],[\"方法和类\",{\"1\":{\"182\":1}}],[\"方法关系特别紧密\",{\"1\":{\"181\":1}}],[\"方法是\",{\"1\":{\"952\":1}}],[\"方法是field类本身的方法\",{\"1\":{\"307\":1}}],[\"方法是相应对象整型的\",{\"1\":{\"181\":1}}],[\"方法是一个本地方法\",{\"1\":{\"163\":1}}],[\"方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作\",{\"1\":{\"182\":1}}],[\"方法在\",{\"1\":{\"163\":1}}],[\"方法读取和修改\",{\"1\":{\"145\":1}}],[\"方法中应该避免使用一个字符的参数名\",{\"1\":{\"944\":1}}],[\"方法中使用到\",{\"1\":{\"829\":1}}],[\"方法中使用父类\",{\"1\":{\"211\":1}}],[\"方法中判断是否已经超过阀值\",{\"1\":{\"711\":1}}],[\"方法中\",{\"1\":{\"563\":1,\"600\":1,\"637\":1,\"768\":1}}],[\"方法中传入的是user类的完整路径\",{\"1\":{\"283\":1}}],[\"方法中的参数是何种类型\",{\"1\":{\"283\":1}}],[\"方法中的条件\",{\"1\":{\"92\":1}}],[\"方法中不能有\",{\"1\":{\"144\":1}}],[\"方法隐式地被指定为\",{\"1\":{\"143\":1}}],[\"方法来解决\",{\"1\":{\"788\":1}}],[\"方法来实现深拷贝\",{\"1\":{\"689\":1}}],[\"方法来实现\",{\"1\":{\"689\":1}}],[\"方法来完成\",{\"1\":{\"687\":1}}],[\"方法来创建一个具有指定类型和维度的数组\",{\"1\":{\"295\":1}}],[\"方法来获取\",{\"1\":{\"259\":1}}],[\"方法来判断相等的对象\",{\"1\":{\"181\":1}}],[\"方法来拷贝一个对象即复杂又有风险\",{\"1\":{\"141\":1}}],[\"方法来替换公有字段\",{\"1\":{\"132\":1}}],[\"方法并不是\",{\"1\":{\"141\":1}}],[\"方法结果不变\",{\"1\":{\"138\":1}}],[\"方法区逻辑上规范\",{\"1\":{\"125\":1}}],[\"方法区还是堆区\",{\"1\":{\"125\":1}}],[\"方法的假对象\",{\"1\":{\"996\":1}}],[\"方法的返回值可以为null\",{\"1\":{\"858\":1}}],[\"方法的返回值也是class<t>\",{\"1\":{\"283\":1}}],[\"方法的参数\",{\"1\":{\"838\":1}}],[\"方法的参数或者对静态方法的调用来访问另一个类\",{\"1\":{\"828\":1}}],[\"方法的\",{\"1\":{\"813\":3}}],[\"方法的父类\",{\"1\":{\"812\":1}}],[\"方法的对象\",{\"1\":{\"718\":1}}],[\"方法的实现者\",{\"1\":{\"560\":1}}],[\"方法的实现比较简单\",{\"1\":{\"120\":1}}],[\"方法的请求者\",{\"1\":{\"560\":1}}],[\"方法的历史以及更多的信息\",{\"1\":{\"481\":1}}],[\"方法的时候\",{\"1\":{\"288\":1}}],[\"方法的时候需要重写\",{\"0\":{\"179\":1}}],[\"方法的注解信息\",{\"1\":{\"228\":1}}],[\"方法的条件下\",{\"1\":{\"92\":1}}],[\"方法\",{\"0\":{\"163\":1,\"179\":1,\"312\":1},\"1\":{\"92\":1,\"103\":2,\"104\":1,\"120\":1,\"125\":3,\"133\":2,\"138\":1,\"139\":2,\"141\":4,\"143\":1,\"180\":1,\"211\":2,\"224\":1,\"225\":1,\"227\":1,\"228\":2,\"259\":1,\"288\":1,\"301\":2,\"304\":1,\"308\":1,\"310\":2,\"312\":1,\"451\":1,\"533\":1,\"556\":1,\"561\":1,\"563\":1,\"569\":1,\"574\":3,\"582\":1,\"608\":1,\"609\":1,\"613\":1,\"622\":1,\"637\":1,\"651\":1,\"675\":1,\"682\":1,\"686\":1,\"689\":2,\"695\":2,\"699\":1,\"703\":2,\"723\":4,\"739\":2,\"741\":2,\"752\":1,\"758\":1,\"768\":3,\"809\":3,\"812\":2,\"813\":1,\"848\":5,\"850\":1,\"855\":1,\"858\":1,\"859\":1,\"910\":1,\"972\":1,\"981\":1,\"996\":1,\"997\":2}}],[\"方法时应当总是覆盖\",{\"1\":{\"139\":1}}],[\"方法时\",{\"1\":{\"92\":1,\"211\":1,\"850\":1}}],[\"代替\",{\"1\":{\"997\":2}}],[\"代表一种资源\",{\"1\":{\"854\":1}}],[\"代表器皿里已经有实体结构的存在\",{\"1\":{\"835\":1}}],[\"代表空器皿里可以放很多相同的东西\",{\"1\":{\"835\":1}}],[\"代表两种不同的角色\",{\"1\":{\"830\":1}}],[\"代表了最佳的实践\",{\"1\":{\"795\":1}}],[\"代表了java中的所有类型\",{\"1\":{\"298\":1}}],[\"代表\",{\"1\":{\"759\":1}}],[\"代理附加一些额外的处理功能\",{\"1\":{\"705\":1}}],[\"代理不需要接口\",{\"1\":{\"703\":1}}],[\"代理归属到动态代理\",{\"1\":{\"702\":1}}],[\"代理也叫作子类代理\",{\"1\":{\"702\":1}}],[\"代理基本介绍\",{\"0\":{\"702\":1}}],[\"代理提交\",{\"1\":{\"700\":1}}],[\"代理开始\",{\"1\":{\"700\":1}}],[\"代理类所在包\",{\"1\":{\"699\":1}}],[\"代理对象的生成\",{\"1\":{\"698\":1}}],[\"代理对象再去调用目标对象的方法\",{\"1\":{\"695\":1}}],[\"代理对象\",{\"1\":{\"695\":1,\"698\":1}}],[\"代理对象与目标对象要实现相同的接口\",{\"1\":{\"695\":1}}],[\"代理对象可以扩展目标对象的功能\",{\"1\":{\"692\":1}}],[\"代理\",{\"0\":{\"701\":1},\"1\":{\"692\":2,\"694\":1,\"698\":1,\"702\":3}}],[\"代理模式实现\",{\"1\":{\"703\":1}}],[\"代理模式应用实例\",{\"0\":{\"703\":1}}],[\"代理模式都要求目标对象是实现一个接口\",{\"1\":{\"702\":1}}],[\"代理模式的应用场景\",{\"0\":{\"705\":1}}],[\"代理模式的主要角色如下\",{\"1\":{\"694\":1}}],[\"代理模式的基本介绍\",{\"0\":{\"692\":1}}],[\"代理模式示意图\",{\"1\":{\"692\":1}}],[\"代理模式会造成系统设计中类的数量增加\",{\"1\":{\"692\":1}}],[\"代理模式能将客户端与目标对象分离\",{\"1\":{\"692\":1}}],[\"代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用\",{\"1\":{\"692\":1}}],[\"代理模式有不同的形式\",{\"1\":{\"692\":1}}],[\"代理模式\",{\"1\":{\"590\":1,\"692\":1,\"700\":1,\"703\":4,\"798\":1}}],[\"代码规约检测插件\",{\"1\":{\"872\":1}}],[\"代码即文档的观点是错误的\",{\"1\":{\"871\":1}}],[\"代码冗余\",{\"1\":{\"855\":1}}],[\"代码结构是自解释的\",{\"1\":{\"853\":1}}],[\"代码结构清晰\",{\"1\":{\"816\":1}}],[\"代码被注释掉有两种可能性\",{\"1\":{\"853\":1}}],[\"代码与注释更新不同步\",{\"1\":{\"853\":1}}],[\"代码修改的同时\",{\"1\":{\"853\":1}}],[\"代码修改量可能就会很大\",{\"1\":{\"809\":1}}],[\"代码格式\",{\"0\":{\"847\":1}}],[\"代码和注释中都要避免使用任何人类语言中的种族歧视性或侮辱性词语\",{\"1\":{\"845\":1}}],[\"代码质\",{\"1\":{\"843\":1}}],[\"代码质量不怎么高\",{\"1\":{\"816\":1}}],[\"代码耦合也就相应的降低了\",{\"1\":{\"818\":1}}],[\"代码是否需要解耦\",{\"0\":{\"817\":1}}],[\"代码改动比较集中\",{\"1\":{\"816\":1}}],[\"代码中写分页查询逻辑时\",{\"1\":{\"865\":1}}],[\"代码中容易equals\",{\"1\":{\"857\":1}}],[\"代码中用到了\",{\"1\":{\"809\":1}}],[\"代码中有一个\",{\"1\":{\"770\":1}}],[\"代码逻辑分清红花和绿叶\",{\"1\":{\"847\":1}}],[\"代码逻辑\",{\"1\":{\"809\":1}}],[\"代码编制更加工程化\",{\"1\":{\"797\":1}}],[\"代码编写规范和标准静态分析工具\",{\"1\":{\"388\":1}}],[\"代码重用性\",{\"1\":{\"797\":1}}],[\"代码重用是值得提倡的\",{\"1\":{\"265\":1}}],[\"代码写着写着\",{\"1\":{\"794\":1}}],[\"代码解释\",{\"1\":{\"790\":1}}],[\"代码更有层次性\",{\"1\":{\"775\":1}}],[\"代码低耦合\",{\"1\":{\"741\":1}}],[\"代码容易维护\",{\"1\":{\"741\":1}}],[\"代码类\",{\"1\":{\"703\":1}}],[\"代码的缩进可以根据实际需要超过\",{\"1\":{\"908\":1}}],[\"代码的列限制为\",{\"1\":{\"905\":1}}],[\"代码的深度调用\",{\"1\":{\"871\":1}}],[\"代码的逻辑一旦修改\",{\"1\":{\"853\":1}}],[\"代码的字里行间流淌的是软件系统的血液\",{\"1\":{\"843\":1}}],[\"代码的话\",{\"1\":{\"813\":1}}],[\"代码的可读性非常重要\",{\"1\":{\"765\":1}}],[\"代码的可维护性\",{\"1\":{\"658\":1}}],[\"代码的内聚性更好\",{\"1\":{\"741\":1}}],[\"代码的维护量很大\",{\"1\":{\"583\":1}}],[\"代码说明\",{\"1\":{\"637\":1}}],[\"代码量跟创建对象的个数成正比\",{\"1\":{\"622\":1}}],[\"代码复杂度\",{\"1\":{\"614\":1}}],[\"代码复用是减少开发成本最常用的方式之一\",{\"1\":{\"819\":1}}],[\"代码复用我们可以通过组合和委托来实现\",{\"1\":{\"813\":1}}],[\"代码复用\",{\"0\":{\"819\":1},\"1\":{\"279\":1,\"813\":1}}],[\"代码抽离肯定比代码聚合更加难理解\",{\"1\":{\"560\":1}}],[\"代码示例请见\",{\"1\":{\"903\":1}}],[\"代码示例\",{\"1\":{\"542\":1,\"574\":1,\"584\":1,\"601\":1,\"718\":3,\"778\":1}}],[\"代码如下\",{\"1\":{\"532\":1,\"788\":1}}],[\"代码检查功能也是顶尖的\",{\"1\":{\"480\":1}}],[\"代码覆盖率非常有用\",{\"1\":{\"460\":1}}],[\"代码分析\",{\"0\":{\"388\":1}}],[\"代码2\",{\"1\":{\"263\":1}}],[\"代码1\",{\"1\":{\"263\":1}}],[\"代码实现非常简单\",{\"1\":{\"809\":1}}],[\"代码实现\",{\"0\":{\"676\":1},\"1\":{\"259\":1,\"524\":1,\"528\":1,\"561\":1,\"562\":1,\"580\":1,\"613\":1,\"632\":1,\"636\":1,\"642\":1,\"644\":1,\"649\":1,\"650\":1,\"656\":1,\"659\":1,\"664\":1,\"667\":1,\"672\":1,\"678\":1,\"695\":1,\"700\":1,\"703\":1,\"708\":1,\"710\":1,\"752\":1,\"776\":1,\"784\":1,\"789\":1,\"801\":1,\"803\":1,\"838\":1,\"839\":1}}],[\"代码很简单\",{\"1\":{\"234\":1}}],[\"代码演示如下\",{\"1\":{\"306\":1,\"307\":1}}],[\"代码演示\",{\"0\":{\"28\":1},\"1\":{\"738\":1}}],[\"代码块匹配添加空格上耗一天\",{\"1\":{\"453\":1}}],[\"代码块包裹住可能抛出异常的部分\",{\"1\":{\"448\":1}}],[\"代码块执行后或异常处理后自动关闭\",{\"1\":{\"264\":1}}],[\"代码块中使用\",{\"1\":{\"451\":1}}],[\"代码块中处理完异常后都会执行\",{\"1\":{\"264\":1}}],[\"代码块中不同的是\",{\"1\":{\"259\":1}}],[\"代码块成功执行之后还是你在\",{\"1\":{\"264\":1}}],[\"代码块总是会被执行\",{\"1\":{\"264\":1}}],[\"代码块不同\",{\"1\":{\"264\":1}}],[\"代码块的最后部分\",{\"1\":{\"264\":1}}],[\"代码块是有原因的\",{\"1\":{\"264\":1}}],[\"代码块内代码会正常执行\",{\"1\":{\"264\":1}}],[\"代码块退出时\",{\"1\":{\"259\":1}}],[\"代码块\",{\"0\":{\"15\":1},\"1\":{\"264\":1}}],[\"代码\",{\"1\":{\"14\":2,\"88\":1,\"608\":1,\"816\":1}}],[\"禁止这么做\",{\"1\":{\"952\":1}}],[\"禁止出现数字开头禁止两个下划线中间只出现数字\",{\"1\":{\"863\":1}}],[\"禁止向html页面输出未经安全过滤或未正确转义的用户数据\",{\"1\":{\"861\":1}}],[\"禁止字符串拼接sql访问数据库\",{\"1\":{\"861\":1}}],[\"禁止在子项目的pom依赖中出现相同的groupid\",{\"1\":{\"869\":1}}],[\"禁止在程序中写死一年为\",{\"1\":{\"849\":1}}],[\"禁止在pojo类中\",{\"1\":{\"848\":1}}],[\"禁止在catch子句中使用泛型变量\",{\"1\":{\"297\":1}}],[\"禁止使用map类来传输\",{\"1\":{\"868\":1,\"873\":1}}],[\"禁止使用存储过程\",{\"1\":{\"865\":1}}],[\"禁止使用float和double\",{\"1\":{\"863\":1}}],[\"禁止使用long类型\",{\"1\":{\"854\":1}}],[\"禁止使用构造方法bigdecimal\",{\"1\":{\"848\":1}}],[\"禁止使用tab字符\",{\"1\":{\"847\":1}}],[\"禁止命名成xxxpojo\",{\"1\":{\"845\":1}}],[\"禁用测试\",{\"0\":{\"977\":1}}],[\"禁用\",{\"0\":{\"952\":1}}],[\"禁用保留字\",{\"1\":{\"863\":1}}],[\"禁用了如下功能\",{\"1\":{\"6\":1}}],[\"禁用展示\",{\"1\":{\"5\":1}}],[\"综述就是说java\",{\"1\":{\"294\":1}}],[\"符\",{\"1\":{\"911\":2}}],[\"符合自然逻辑的操作顺序如下\",{\"1\":{\"871\":1}}],[\"符合表达习惯\",{\"1\":{\"863\":1}}],[\"符合英文表达习惯\",{\"1\":{\"854\":1}}],[\"符合单一职责原则\",{\"1\":{\"837\":1}}],[\"符合类的单一职责原则\",{\"1\":{\"707\":1}}],[\"符合依赖倒置原则\",{\"1\":{\"671\":1}}],[\"符合迪米特原则\",{\"1\":{\"660\":1}}],[\"符合迪米特法则\",{\"1\":{\"655\":1}}],[\"符合\",{\"1\":{\"557\":1,\"780\":1}}],[\"符合合成复用原则\",{\"1\":{\"537\":1}}],[\"符合开闭原则\",{\"1\":{\"537\":1,\"800\":1}}],[\"符合预期\",{\"1\":{\"294\":1}}],[\"符合预期逻辑\",{\"1\":{\"294\":1}}],[\"符号或者类型转换的闭括号\",{\"1\":{\"911\":1}}],[\"符号之前\",{\"1\":{\"892\":1}}],[\"符号的\",{\"1\":{\"892\":1}}],[\"符号\",{\"1\":{\"284\":1,\"907\":2}}],[\"能不能给问题排查带来好处\",{\"1\":{\"859\":1}}],[\"能不能采用具体的泛型类型进行初始化\",{\"0\":{\"294\":1}}],[\"能用对象锁\",{\"1\":{\"851\":1}}],[\"能用无锁数据结构\",{\"1\":{\"851\":1}}],[\"能锁区块\",{\"1\":{\"851\":1}}],[\"能为软件开发的所有阶段提供模型化和可视化支持\",{\"1\":{\"823\":1}}],[\"能表达软件设计中的动态与静态信息\",{\"1\":{\"822\":1}}],[\"能减少项目工程中的代码冗余\",{\"1\":{\"722\":1}}],[\"能通过代理对象对目标功能扩展\",{\"1\":{\"696\":1}}],[\"能力\",{\"1\":{\"549\":1}}],[\"能正确地识别出系统中两个独立变化的维度\",{\"1\":{\"537\":1}}],[\"能画不同形状和不同颜色的图形呢\",{\"1\":{\"537\":1}}],[\"能够识别并执行它们\",{\"1\":{\"975\":1}}],[\"能够建立索引的种类分为主键索引\",{\"1\":{\"864\":1}}],[\"能够取到零值\",{\"1\":{\"855\":1}}],[\"能够描述业务含义\",{\"1\":{\"853\":1}}],[\"能够准确反映设计思想和代码逻辑\",{\"1\":{\"853\":1}}],[\"能够表示额外的信息\",{\"1\":{\"848\":1}}],[\"能够在不修改对象结构中的元素的情况下\",{\"1\":{\"837\":1}}],[\"能够有效提高代码的可读性和可维护性\",{\"1\":{\"818\":1}}],[\"能够让开发和重构同步进行\",{\"1\":{\"818\":1}}],[\"能够让你没有\",{\"1\":{\"466\":1}}],[\"能够保证系统的稳定性\",{\"1\":{\"722\":1}}],[\"能够保留到运行时\",{\"1\":{\"224\":1}}],[\"能够撤销与重做\",{\"1\":{\"591\":1}}],[\"能够将其代码转换为简洁高效的java代码\",{\"1\":{\"411\":1}}],[\"能够更加清晰的知道它能够被用来修饰哪些对象\",{\"1\":{\"227\":1}}],[\"能够修饰构造方法\",{\"1\":{\"224\":1}}],[\"失足不成千古恨\",{\"1\":{\"591\":1}}],[\"失去了本意\",{\"1\":{\"293\":1}}],[\"失败等\",{\"1\":{\"839\":1}}],[\"失败会抛出异常\",{\"1\":{\"809\":3}}],[\"失败\",{\"1\":{\"242\":3,\"779\":1}}],[\"失败反而能给我们更多启发和教训\",{\"1\":{\"36\":1}}],[\"竟然有4个方法\",{\"1\":{\"291\":1}}],[\"知名网站\",{\"0\":{\"441\":1}}],[\"知名java博客作者\",{\"1\":{\"440\":1}}],[\"知道的越少越好\",{\"1\":{\"741\":1}}],[\"知道\",{\"1\":{\"291\":1}}],[\"知识体系\",{\"0\":{\"156\":1}}],[\"知识点\",{\"0\":{\"117\":1}}],[\"根本就没有这样的一个子类继承自父类的object类型参数的方法\",{\"1\":{\"291\":1}}],[\"根本就不会是重写\",{\"1\":{\"291\":1}}],[\"根据测试类型的不同\",{\"1\":{\"994\":1}}],[\"根据用例数而定\",{\"1\":{\"972\":1}}],[\"根据云栖社区的\",{\"1\":{\"872\":1}}],[\"根据依赖倒置原则\",{\"1\":{\"871\":1}}],[\"根据依赖关系图的复杂性来判断是否需要解耦重构\",{\"1\":{\"817\":1}}],[\"根据经验表明\",{\"1\":{\"870\":1}}],[\"根据业务架构实践\",{\"1\":{\"868\":1}}],[\"根据墨菲定律\",{\"1\":{\"864\":1}}],[\"根据国家法律\",{\"1\":{\"859\":1}}],[\"根据mvc理论\",{\"1\":{\"855\":1}}],[\"根据模式是用来完成什么工作来划分\",{\"1\":{\"798\":1}}],[\"根据我们的业务流程处理\",{\"1\":{\"779\":1}}],[\"根据原子和抽象编程可以提高代码的可复用性\",{\"1\":{\"737\":1}}],[\"根据实际文本区分度决定索引长度\",{\"1\":{\"864\":1}}],[\"根据实际情况\",{\"1\":{\"778\":1}}],[\"根据实际情况拆分为三个接口\",{\"1\":{\"723\":1}}],[\"根据实际业务\",{\"1\":{\"614\":1}}],[\"根据采购金额来调用对应的\",{\"1\":{\"709\":1}}],[\"根据得到消息\",{\"1\":{\"659\":1}}],[\"根据网站的类型\",{\"1\":{\"636\":1}}],[\"根据需要返回压一个网站\",{\"1\":{\"636\":1}}],[\"根据需要实现模板中的操作\",{\"1\":{\"591\":1}}],[\"根据这个结构来创建对象\",{\"1\":{\"626\":1}}],[\"根据配置文件通过\",{\"1\":{\"623\":1}}],[\"根据配置文件提供的信息来创建对象\",{\"1\":{\"622\":1}}],[\"根据配置\",{\"1\":{\"621\":1}}],[\"根据配置的函数名\",{\"1\":{\"309\":1}}],[\"根据设计原则\",{\"1\":{\"614\":1}}],[\"根据不同的状态做出不同的行为\",{\"1\":{\"591\":1}}],[\"根据合成复用原则\",{\"1\":{\"529\":1}}],[\"根据方法名和参数类型过滤指定方法返回\",{\"1\":{\"311\":1}}],[\"根据方法名称和方法列表\",{\"1\":{\"311\":1}}],[\"根据参数获取public的method\",{\"1\":{\"308\":1}}],[\"根据全限定类名\",{\"1\":{\"305\":3}}],[\"根据对象\",{\"1\":{\"305\":3}}],[\"根据类名\",{\"1\":{\"305\":3}}],[\"根据类型参数的上下界推断并替换所有的类型参数为原生态类型\",{\"1\":{\"287\":1}}],[\"根据异常捕获的原则\",{\"1\":{\"297\":1}}],[\"根据\",{\"1\":{\"176\":1,\"181\":1,\"527\":1,\"618\":1,\"625\":1,\"644\":1,\"809\":2}}],[\"根据资源文件url解析properties文件\",{\"1\":{\"106\":1}}],[\"根据第一步获取到的驱动列表来实例化具体实现类\",{\"1\":{\"103\":1}}],[\"谁还敢上路行驶\",{\"1\":{\"843\":1}}],[\"谁是一个引用\",{\"1\":{\"290\":1}}],[\"谁都无法做到\",{\"1\":{\"92\":1}}],[\"举个例子\",{\"1\":{\"631\":1}}],[\"举个简单的例子\",{\"1\":{\"90\":1}}],[\"举例\",{\"1\":{\"732\":1}}],[\"举例说明\",{\"1\":{\"296\":1}}],[\"举例子\",{\"1\":{\"290\":1}}],[\"情感分析等\",{\"1\":{\"418\":1}}],[\"情况\",{\"1\":{\"290\":2}}],[\"情理可容的异常状况\",{\"1\":{\"249\":1}}],[\"各层接收上层的查询请求\",{\"1\":{\"868\":1,\"873\":1}}],[\"各层命名规约\",{\"1\":{\"845\":1}}],[\"各类基本参数校验\",{\"1\":{\"868\":1}}],[\"各类参数或者对象tostring\",{\"1\":{\"859\":1}}],[\"各业务线经常冗余存储商品名称\",{\"1\":{\"863\":1}}],[\"各人自扫门前雪\",{\"1\":{\"591\":1}}],[\"各种类型的标识符的规则\",{\"0\":{\"938\":1}}],[\"各种不同的算法以不同的方式实现这个接口\",{\"1\":{\"784\":1}}],[\"各种状态子类\",{\"1\":{\"779\":1}}],[\"各种房子的过程虽然一样\",{\"1\":{\"552\":1}}],[\"各种引用传值之间\",{\"1\":{\"290\":1}}],[\"各个端的模板渲染并执行显示的层\",{\"1\":{\"868\":1}}],[\"各个电器对象之间所传递的消息\",{\"1\":{\"658\":1}}],[\"各个电器对象彼此联系\",{\"1\":{\"658\":1}}],[\"各个设备可以协同工作\",{\"1\":{\"657\":1}}],[\"各个具体的建造者相互独立\",{\"1\":{\"549\":1}}],[\"各个部件可以灵活选择\",{\"1\":{\"549\":1}}],[\"各版本的新特性\",{\"0\":{\"150\":1}}],[\"替换掉\",{\"1\":{\"809\":1}}],[\"替换掉继承\",{\"1\":{\"545\":1}}],[\"替换为下面一行代码\",{\"1\":{\"764\":2}}],[\"替换\",{\"1\":{\"289\":1,\"767\":1}}],[\"却是非常关键的\",{\"1\":{\"860\":1}}],[\"却是是重写了\",{\"1\":{\"291\":1}}],[\"却要实现它们\",{\"1\":{\"569\":1}}],[\"却可以存储字符串\",{\"1\":{\"288\":1}}],[\"却不能调用2个\",{\"1\":{\"200\":1}}],[\"擦除方法定义中的类型参数原则和擦除类定义中的类型参数是一样的\",{\"1\":{\"287\":1}}],[\"擦除方法定义中的类型参数\",{\"1\":{\"287\":1}}],[\"擦除类定义中的类型参数\",{\"1\":{\"287\":2}}],[\"消极的词\",{\"1\":{\"835\":1}}],[\"消除了\",{\"1\":{\"775\":1}}],[\"消除用户对服务器慢的感觉\",{\"1\":{\"705\":1}}],[\"消除类型参数声明\",{\"1\":{\"287\":1}}],[\"消息分组未查到\",{\"1\":{\"874\":1}}],[\"消息分类\",{\"1\":{\"546\":1}}],[\"消息订阅出错\",{\"1\":{\"874\":1}}],[\"消息消费出错\",{\"1\":{\"874\":1}}],[\"消息投递超时\",{\"1\":{\"874\":1}}],[\"消息投递超时等问题\",{\"1\":{\"857\":1}}],[\"消息投递出错\",{\"1\":{\"874\":1}}],[\"消息服务出错\",{\"1\":{\"874\":1}}],[\"消息服务出错是三级\",{\"1\":{\"857\":1}}],[\"消息补偿\",{\"1\":{\"866\":1}}],[\"消息\",{\"1\":{\"546\":1}}],[\"消息类型\",{\"1\":{\"546\":1}}],[\"消息管理\",{\"1\":{\"546\":1}}],[\"消息传递\",{\"0\":{\"414\":1}}],[\"消费和可视化restful\",{\"1\":{\"424\":1}}],[\"消费者有下限\",{\"1\":{\"284\":1}}],[\"弄明白了类型擦除也就迎刃而解了\",{\"1\":{\"287\":1}}],[\"疑难杂症\",{\"1\":{\"287\":1}}],[\"讨巧的使用场景\",{\"1\":{\"285\":1}}],[\"工程调用方法时\",{\"1\":{\"853\":1}}],[\"工程结构\",{\"0\":{\"867\":1},\"1\":{\"843\":1}}],[\"工程结构混乱导致后续项目维护艰难\",{\"1\":{\"843\":1}}],[\"工厂\",{\"1\":{\"761\":1}}],[\"工厂簇\",{\"1\":{\"616\":1}}],[\"工厂类代码都是一样的\",{\"1\":{\"622\":1}}],[\"工厂类要创建哪个类对象是事先确定好的\",{\"1\":{\"622\":1}}],[\"工厂类的创建产品类的方法可以被外界直接调用\",{\"1\":{\"608\":1}}],[\"工厂类包含必要的逻辑判断\",{\"1\":{\"608\":1}}],[\"工厂和产品的职责区分明确\",{\"1\":{\"608\":1}}],[\"工厂方法\",{\"0\":{\"611\":1},\"1\":{\"608\":1}}],[\"工厂方法原理比较简单\",{\"1\":{\"606\":1}}],[\"工厂方法和抽象工厂\",{\"1\":{\"606\":1}}],[\"工厂方法模式只生产一个等级的产品\",{\"1\":{\"616\":1}}],[\"工厂方法模式可以理解为在多个简单工厂模式\",{\"1\":{\"614\":1}}],[\"工厂方法模式代码\",{\"1\":{\"613\":1}}],[\"工厂方法模式设计方案\",{\"1\":{\"613\":1}}],[\"工厂方法模式完成案例\",{\"0\":{\"613\":1}}],[\"工厂方法模式将\",{\"1\":{\"612\":1}}],[\"工厂方法模式介绍\",{\"0\":{\"612\":1}}],[\"工厂方法模式\",{\"1\":{\"549\":1,\"606\":1,\"612\":2,\"614\":1,\"619\":1,\"639\":1,\"798\":1}}],[\"工厂生产物品\",{\"1\":{\"589\":1}}],[\"工厂模式和\",{\"0\":{\"621\":1}}],[\"工厂模式的意义将实例化对象的代码提取出来\",{\"1\":{\"619\":1}}],[\"工厂模式小结\",{\"0\":{\"619\":1}}],[\"工厂模式在\",{\"0\":{\"618\":1}}],[\"工厂模式家族\",{\"1\":{\"608\":1}}],[\"工厂模式分为三种更加细分的类型\",{\"1\":{\"606\":1}}],[\"工厂模式很重要\",{\"1\":{\"606\":1}}],[\"工厂模式概述\",{\"0\":{\"606\":1}}],[\"工厂模式\",{\"1\":{\"589\":1}}],[\"工作原理是\",{\"1\":{\"682\":1}}],[\"工作原理\",{\"0\":{\"520\":1}}],[\"工具类等\",{\"1\":{\"992\":1}}],[\"工具类不允许有public或default构造方法\",{\"1\":{\"848\":1}}],[\"工具类\",{\"1\":{\"771\":1,\"851\":1}}],[\"工具类对象\",{\"1\":{\"761\":1}}],[\"工具实现\",{\"1\":{\"485\":1}}],[\"工具\",{\"1\":{\"477\":1}}],[\"工具为类生成帮助文档时是否要保留其注解信息\",{\"1\":{\"229\":1}}],[\"工资低于2500元的上斑族并且站立的乘客车票打8折\",{\"1\":{\"284\":1}}],[\"小\",{\"1\":{\"991\":1}}],[\"小骆峰\",{\"1\":{\"941\":2,\"943\":1,\"944\":1,\"945\":1}}],[\"小数类型为decimal\",{\"1\":{\"863\":1}}],[\"小时制的则是小写的h\",{\"1\":{\"849\":1}}],[\"小时制的是大写的h\",{\"1\":{\"849\":1}}],[\"小写容易跟数字混淆\",{\"1\":{\"846\":1}}],[\"小小\",{\"1\":{\"820\":1}}],[\"小牛\",{\"1\":{\"689\":1}}],[\"小偷与警察等\",{\"1\":{\"671\":1}}],[\"小米系列工厂\",{\"1\":{\"617\":1}}],[\"小米工厂\",{\"1\":{\"617\":2}}],[\"小米路由器\",{\"1\":{\"617\":2}}],[\"小米手机发送消息\",{\"1\":{\"617\":1}}],[\"小米手机\",{\"1\":{\"617\":1}}],[\"小米手机和小米路由器称为\",{\"1\":{\"617\":1}}],[\"小米手机和华为手机称为\",{\"1\":{\"617\":1}}],[\"小米手机打电话\",{\"1\":{\"542\":1,\"617\":1}}],[\"小米手机关机\",{\"1\":{\"542\":1}}],[\"小米手机开机\",{\"1\":{\"542\":1}}],[\"小型的外包项目\",{\"1\":{\"633\":1}}],[\"小型\",{\"1\":{\"434\":1}}],[\"小型sql数据库\",{\"1\":{\"394\":1}}],[\"小巧的应用服务器\",{\"1\":{\"429\":1}}],[\"小结\",{\"0\":{\"829\":1},\"1\":{\"284\":1,\"637\":1}}],[\"小议\",{\"1\":{\"113\":1}}],[\"既不是父子关系\",{\"1\":{\"814\":1}}],[\"既统一了算法\",{\"1\":{\"804\":1}}],[\"既然单例类大部分情况下都用来表示全局类\",{\"1\":{\"766\":1}}],[\"既然类型被擦除了\",{\"1\":{\"298\":1}}],[\"既然类型擦除了\",{\"1\":{\"290\":1}}],[\"既然说类型变量会在编译的时候擦除掉\",{\"1\":{\"290\":1}}],[\"既然是泛型方法\",{\"1\":{\"283\":1}}],[\"既有return\",{\"1\":{\"275\":1}}],[\"姓名为\",{\"1\":{\"684\":1}}],[\"姓名\",{\"1\":{\"281\":1}}],[\"汤姆\",{\"1\":{\"281\":1,\"282\":1}}],[\"尖括号中的内容\",{\"1\":{\"278\":1,\"287\":1}}],[\"系\",{\"1\":{\"650\":1}}],[\"系都看做是组织结构\",{\"1\":{\"573\":1}}],[\"系的添加\",{\"1\":{\"573\":1}}],[\"系是学院的子类\",{\"1\":{\"573\":1}}],[\"系统读取磁盘文件\",{\"1\":{\"874\":1}}],[\"系统线程池耗尽\",{\"1\":{\"874\":1}}],[\"系统连接池耗尽\",{\"1\":{\"874\":1}}],[\"系统内存耗尽\",{\"1\":{\"874\":1}}],[\"系统内存中该类只存在一个对象\",{\"1\":{\"761\":1}}],[\"系统磁盘空间耗尽\",{\"1\":{\"874\":1}}],[\"系统资源访问异常\",{\"1\":{\"874\":1}}],[\"系统资源耗尽\",{\"1\":{\"874\":1}}],[\"系统资源异常\",{\"1\":{\"874\":1}}],[\"系统功能降级\",{\"1\":{\"874\":1}}],[\"系统限流\",{\"1\":{\"874\":1}}],[\"系统容灾功能被触发\",{\"1\":{\"874\":1}}],[\"系统订单处理超时\",{\"1\":{\"874\":1}}],[\"系统执行超时\",{\"1\":{\"874\":1}}],[\"系统执行出错\",{\"1\":{\"857\":1,\"874\":1}}],[\"系统出现的严重状况\",{\"1\":{\"873\":1}}],[\"系统设计文档有助于后期的系统维护和重构\",{\"1\":{\"871\":1}}],[\"系统设计阶段\",{\"1\":{\"871\":3}}],[\"系统设计时要准确识别出弱依赖\",{\"1\":{\"871\":1}}],[\"系统架构设计时明确以下目标\",{\"1\":{\"871\":1}}],[\"系统自动进行降级或熔断操作\",{\"1\":{\"871\":1}}],[\"系统依赖的第三方服务被降级或屏蔽后\",{\"1\":{\"871\":1}}],[\"系统的整体功能与各单元部件的测试正常与否是强相关的\",{\"1\":{\"860\":1}}],[\"系统的采购审批项目\",{\"0\":{\"709\":1}}],[\"系统配置相关常量放在类systemconfigconsts下\",{\"1\":{\"846\":1}}],[\"系统化地整理成册\",{\"1\":{\"843\":1}}],[\"系统越不稳定\",{\"1\":{\"814\":1}}],[\"系统更加庞大\",{\"1\":{\"800\":1}}],[\"系统要求使用算法的客户不应该知道其操作的数据时\",{\"1\":{\"792\":1}}],[\"系统处于哪种情况\",{\"1\":{\"775\":1}}],[\"系统性能将受到一定影响\",{\"1\":{\"707\":1}}],[\"系统中均是勉强能运行但像面条一样的代码\",{\"1\":{\"871\":1}}],[\"系统中各算法彼此完全独立\",{\"1\":{\"792\":1}}],[\"系统中有些\",{\"1\":{\"766\":1}}],[\"系统中有大量对象\",{\"1\":{\"638\":1}}],[\"系统中的缓存等常常被设计成单例\",{\"1\":{\"750\":1}}],[\"系统中感兴趣的对象会自动接收该广播\",{\"1\":{\"680\":1}}],[\"系统中存在大量相同或相似的对象\",{\"1\":{\"639\":1}}],[\"系统扩展困难\",{\"1\":{\"608\":1}}],[\"系统扩展方便\",{\"1\":{\"557\":1}}],[\"系统随机请求命令或经常增加\",{\"1\":{\"565\":1}}],[\"系统到底做了什么事情\",{\"1\":{\"276\":1}}],[\"系列虽然挺全\",{\"1\":{\"383\":1}}],[\"系列\",{\"1\":{\"219\":1}}],[\"追求精确的读者可以再测一下空循环的耗时然后在对比前减掉这部分\",{\"1\":{\"276\":1}}],[\"说明每个数据项的用途\",{\"1\":{\"853\":1}}],[\"说明三\",{\"1\":{\"851\":1}}],[\"说明二\",{\"1\":{\"851\":1}}],[\"说明一\",{\"1\":{\"851\":1}}],[\"说明一下\",{\"1\":{\"283\":1}}],[\"说明需要提防的雷区\",{\"1\":{\"843\":1}}],[\"说明如下\",{\"1\":{\"802\":1}}],[\"说明\",{\"1\":{\"305\":1,\"574\":1,\"675\":1,\"700\":1,\"790\":1,\"822\":1,\"839\":1,\"843\":1,\"845\":6,\"846\":3,\"847\":5,\"848\":17,\"849\":5,\"850\":18,\"851\":13,\"852\":9,\"853\":5,\"854\":9,\"855\":6,\"857\":8,\"858\":9,\"859\":10,\"860\":7,\"861\":8,\"863\":8,\"864\":8,\"865\":7,\"866\":4,\"869\":9,\"870\":4,\"871\":16,\"874\":1}}],[\"说明这就是在编译之前的检查\",{\"1\":{\"290\":1}}],[\"说明泛型类型string和integer都被擦除掉了\",{\"1\":{\"288\":1}}],[\"说用异常慢\",{\"1\":{\"276\":1}}],[\"说出\",{\"0\":{\"186\":1,\"187\":1}}],[\"答案是否定的\",{\"1\":{\"812\":1}}],[\"答案是后者\",{\"1\":{\"770\":1}}],[\"答案是finally会执行\",{\"1\":{\"275\":1}}],[\"答案是异常发生的时候\",{\"1\":{\"275\":1}}],[\"又有经常变化的功能需求\",{\"1\":{\"840\":1}}],[\"又有finally\",{\"1\":{\"275\":1}}],[\"又负责飞机\",{\"1\":{\"718\":1}}],[\"又称单一功能原则\",{\"1\":{\"716\":1}}],[\"又称为类变量\",{\"1\":{\"144\":1}}],[\"又如找女朋友\",{\"1\":{\"692\":1}}],[\"又不想生成新的子类时\",{\"1\":{\"661\":1}}],[\"又叫作\",{\"1\":{\"608\":1}}],[\"又叫\",{\"1\":{\"549\":1,\"567\":1,\"655\":1,\"663\":1,\"707\":1,\"741\":1,\"745\":1,\"800\":1}}],[\"又可按颜色分\",{\"1\":{\"537\":1}}],[\"直到完成功能代码开发\",{\"1\":{\"991\":1}}],[\"直到超时才返回结果\",{\"1\":{\"851\":1}}],[\"直到请求被响应为止\",{\"1\":{\"798\":1}}],[\"直到该对象\",{\"1\":{\"689\":1}}],[\"直到有对象处理它为止\",{\"1\":{\"591\":1,\"707\":1}}],[\"直到object\",{\"1\":{\"289\":1}}],[\"直立样式手机\",{\"1\":{\"542\":4}}],[\"直流电\",{\"1\":{\"524\":1,\"528\":1}}],[\"直至执行got到41位置\",{\"1\":{\"275\":1}}],[\"直至goto到41位置\",{\"1\":{\"275\":1}}],[\"直接用类名来访问即可\",{\"1\":{\"848\":1}}],[\"直接在类内部private\",{\"1\":{\"846\":1}}],[\"直接出现在代码中\",{\"1\":{\"846\":1}}],[\"直接使用hashtable来接收数据库返回结果\",{\"1\":{\"866\":1}}],[\"直接使用random对象的nextint或者nextlong方法\",{\"1\":{\"855\":1}}],[\"直接使用属性名取值即可\",{\"1\":{\"855\":1}}],[\"直接使用<>来指代前边已经指定的类型\",{\"1\":{\"850\":1}}],[\"直接使用toarray无参方法存在问题\",{\"1\":{\"850\":1}}],[\"直接使用实现类就可以了\",{\"1\":{\"810\":1}}],[\"直接使用实现类编程\",{\"1\":{\"810\":1}}],[\"直接使用相应的状态类对象进行处理\",{\"1\":{\"775\":1}}],[\"直接通过类似\",{\"1\":{\"763\":1}}],[\"直接通过\",{\"1\":{\"745\":1}}],[\"直接朋友和非直接朋友举例\",{\"1\":{\"741\":1}}],[\"直接的朋友\",{\"1\":{\"741\":1}}],[\"直接继承\",{\"1\":{\"732\":1,\"745\":1}}],[\"直接修改\",{\"1\":{\"718\":1}}],[\"直接从\",{\"1\":{\"627\":1}}],[\"直接从容器中获取即可\",{\"1\":{\"621\":1}}],[\"直接\",{\"1\":{\"470\":1,\"637\":1,\"755\":1,\"757\":1}}],[\"直接会报错\",{\"1\":{\"290\":1}}],[\"直接打印\",{\"1\":{\"284\":2}}],[\"直接执行finally语句\",{\"1\":{\"258\":1}}],[\"直接停止\",{\"1\":{\"251\":1}}],[\"直接返回最后一页\",{\"1\":{\"854\":1}}],[\"直接返回\",{\"1\":{\"138\":1,\"758\":1}}],[\"直接访问\",{\"1\":{\"132\":1}}],[\"直接赋值给\",{\"1\":{\"128\":1}}],[\"直接获取连接就可以了\",{\"1\":{\"98\":1}}],[\"部署在同一台服务器中\",{\"1\":{\"852\":1}}],[\"部署图\",{\"1\":{\"822\":1}}],[\"部分描述\",{\"1\":{\"872\":1}}],[\"部分对象不能脱离整体对象而存在\",{\"1\":{\"832\":1}}],[\"部分对象也将不存在\",{\"1\":{\"832\":1}}],[\"部分方法是由子类实现的\",{\"1\":{\"800\":1}}],[\"部分整体模式\",{\"1\":{\"567\":1}}],[\"部分\",{\"1\":{\"567\":2}}],[\"部分的功能\",{\"1\":{\"472\":1}}],[\"部分明确地支出你所使用的\",{\"1\":{\"459\":1}}],[\"部分文本分析引擎\",{\"1\":{\"426\":1}}],[\"部分提取finally代码\",{\"1\":{\"275\":1}}],[\"部门经理等都属于单例模型\",{\"1\":{\"750\":1}}],[\"部门存在用户\",{\"1\":{\"242\":1}}],[\"部门名称已存在\",{\"1\":{\"242\":2}}],[\"部门管理\",{\"1\":{\"242\":3}}],[\"部门\",{\"1\":{\"242\":1}}],[\"仍然能够在不破坏原有代码设计的情况下灵活应对\",{\"1\":{\"808\":1}}],[\"仍然是可选的\",{\"1\":{\"900\":1}}],[\"仍然是遵守单一职责\",{\"1\":{\"718\":1}}],[\"仍然是\",{\"1\":{\"644\":1}}],[\"仍然是构建\",{\"1\":{\"458\":1}}],[\"仍然是之前保存的值\",{\"1\":{\"197\":1}}],[\"仍然要把这个异常抛出去\",{\"1\":{\"275\":1}}],[\"仍然没有处理\",{\"1\":{\"275\":1}}],[\"弹栈处理\",{\"1\":{\"275\":1}}],[\"9999\",{\"1\":{\"857\":1}}],[\"997\",{\"1\":{\"822\":1}}],[\"9f\",{\"1\":{\"848\":4}}],[\"91\",{\"1\":{\"743\":1}}],[\"9007199254740992\",{\"1\":{\"854\":1}}],[\"90\",{\"1\":{\"742\":1,\"872\":1}}],[\"90204111\",{\"1\":{\"277\":1}}],[\"9的早期访问版本\",{\"1\":{\"410\":1}}],[\"94483820\",{\"1\":{\"314\":1}}],[\"945\",{\"1\":{\"270\":1}}],[\"986f732ed2f1\",{\"1\":{\"299\":1}}],[\"9829\",{\"1\":{\"73\":1}}],[\"9589080\",{\"1\":{\"276\":1}}],[\"9\",{\"0\":{\"361\":1},\"1\":{\"275\":4,\"410\":1,\"459\":1,\"734\":4,\"790\":1,\"843\":1,\"848\":1,\"850\":1,\"911\":1}}],[\"965\",{\"1\":{\"270\":1}}],[\"开头\",{\"1\":{\"958\":2}}],[\"开头并且与上一行中的\",{\"1\":{\"933\":1}}],[\"开头的注释符和注释文本之间\",{\"1\":{\"911\":1}}],[\"开头的注释之间\",{\"1\":{\"911\":1}}],[\"开放接口层要将异常处理成错误码和错误信息方式返回\",{\"1\":{\"868\":1}}],[\"开放api层\",{\"1\":{\"868\":1}}],[\"开放api层可以依赖于web层\",{\"1\":{\"868\":1}}],[\"开放个性配置步骤\",{\"1\":{\"589\":1}}],[\"开关的接口\",{\"1\":{\"728\":1}}],[\"开销也很大\",{\"1\":{\"666\":1}}],[\"开\",{\"1\":{\"597\":1}}],[\"开音响\",{\"1\":{\"597\":1}}],[\"开投影仪\",{\"1\":{\"597\":1}}],[\"开爆米花机\",{\"1\":{\"597\":2}}],[\"开按钮的命令数组\",{\"1\":{\"562\":1}}],[\"开闭原则是面向对象程序设计的终极目标\",{\"1\":{\"737\":1}}],[\"开闭原则的作用\",{\"0\":{\"737\":1}}],[\"开闭原则\",{\"0\":{\"735\":1},\"1\":{\"557\":1,\"560\":1,\"567\":1,\"593\":2,\"613\":1,\"714\":1,\"736\":3,\"739\":1,\"748\":2,\"775\":1,\"780\":1,\"837\":1}}],[\"开机\",{\"1\":{\"539\":1}}],[\"开源\",{\"1\":{\"872\":1}}],[\"开源类库\",{\"1\":{\"593\":1}}],[\"开源黑客\",{\"1\":{\"440\":1}}],[\"开源数据分析集群计算框架\",{\"1\":{\"413\":1}}],[\"开源分布式htap数据库\",{\"1\":{\"400\":1}}],[\"开发人员需要和测试人员一起确定单元测试范围\",{\"1\":{\"860\":1}}],[\"开发者b使用缓存时直接复制少了下划线\",{\"1\":{\"846\":1}}],[\"开发者a定义了缓存的key\",{\"1\":{\"846\":1}}],[\"开发者很有自信不会抛出异常\",{\"1\":{\"269\":1}}],[\"开发手册\",{\"0\":{\"842\":1},\"1\":{\"872\":1}}],[\"开发javafx应用的可视化布局工具\",{\"1\":{\"405\":1}}],[\"开发流程增强工具\",{\"0\":{\"398\":1}}],[\"开始下课\",{\"1\":{\"700\":1}}],[\"开始上课\",{\"1\":{\"700\":1}}],[\"开始代理\",{\"1\":{\"695\":1}}],[\"开始\",{\"1\":{\"130\":1,\"133\":2,\"170\":1,\"443\":1,\"618\":1,\"703\":2}}],[\"开始时\",{\"1\":{\"36\":1}}],[\"开始运动吧\",{\"1\":{\"36\":1}}],[\"添加解释性的注释是非常有帮助的\",{\"1\":{\"885\":1}}],[\"添加不同的配料\",{\"1\":{\"803\":1}}],[\"添加配料\",{\"1\":{\"802\":1}}],[\"添加\",{\"1\":{\"266\":1,\"649\":1}}],[\"纸牌对象的纸牌太少\",{\"1\":{\"265\":1}}],[\"子业务线可选\",{\"1\":{\"869\":1}}],[\"子业务线\",{\"1\":{\"869\":1}}],[\"子线程抛出异常堆栈\",{\"1\":{\"851\":1}}],[\"子工程内部共享常量\",{\"1\":{\"846\":1}}],[\"子工程内共享常量\",{\"1\":{\"846\":1}}],[\"子工厂\",{\"1\":{\"614\":1}}],[\"子系统03的method3\",{\"1\":{\"596\":1}}],[\"子系统02的method2\",{\"1\":{\"596\":1}}],[\"子系统01的method1\",{\"1\":{\"596\":1}}],[\"子系统角色\",{\"1\":{\"596\":3}}],[\"子系统\",{\"1\":{\"595\":1}}],[\"子系统会越来越多\",{\"1\":{\"593\":1}}],[\"子句中使用\",{\"1\":{\"268\":1}}],[\"子句中使用它\",{\"1\":{\"268\":1}}],[\"子句中打开资源\",{\"1\":{\"264\":1}}],[\"子类即可在客户端调用即可\",{\"1\":{\"839\":1}}],[\"子类复用父类中的属性和方法\",{\"1\":{\"814\":1}}],[\"子类的实现依赖父类的实现\",{\"1\":{\"812\":1}}],[\"子类就会继承这些修改\",{\"1\":{\"804\":1}}],[\"子类具体实现\",{\"1\":{\"803\":1}}],[\"子类可以视情况要不要覆盖它\",{\"1\":{\"803\":1}}],[\"子类执行的结果会影响父类的结果\",{\"1\":{\"800\":1}}],[\"子类实现\",{\"1\":{\"789\":1}}],[\"子类实现特性\",{\"1\":{\"545\":1}}],[\"子类重写方法功能发生改变\",{\"1\":{\"748\":1}}],[\"子类与父类的耦合度高\",{\"1\":{\"747\":1}}],[\"子类决定要实例化的类\",{\"1\":{\"612\":1}}],[\"子类来实现\",{\"1\":{\"584\":1}}],[\"子类会很膨胀\",{\"1\":{\"580\":1}}],[\"子类都需要实现\",{\"1\":{\"574\":1}}],[\"子类也会继承得到\",{\"1\":{\"545\":1}}],[\"子类中尽量不要重写父类的方法\",{\"1\":{\"732\":1,\"748\":1}}],[\"子类中的桥方法object\",{\"1\":{\"291\":1}}],[\"子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法\",{\"1\":{\"291\":1}}],[\"子类对象必须能够替换掉所有父类对象\",{\"1\":{\"210\":1}}],[\"子类\",{\"1\":{\"144\":3,\"585\":3,\"845\":1}}],[\"子类方法的返回类型必须是父类方法返回类型或为其子类型\",{\"1\":{\"135\":1}}],[\"子类方法的访问权限必须大于等于父类方法\",{\"1\":{\"135\":1}}],[\"里氏替换原是继承复用的基础\",{\"1\":{\"732\":1}}],[\"里氏替换原则是实现开闭原则的重要方式之一\",{\"1\":{\"733\":1}}],[\"里氏替换原则的主要作用如下\",{\"1\":{\"733\":1}}],[\"里氏替换原则的作用\",{\"0\":{\"733\":1}}],[\"里氏替换原则\",{\"0\":{\"730\":1},\"1\":{\"714\":1,\"729\":1,\"732\":2,\"748\":2}}],[\"里提出来的\",{\"1\":{\"732\":1}}],[\"里\",{\"1\":{\"534\":3,\"702\":1}}],[\"里的形式\",{\"1\":{\"534\":1}}],[\"里面还不是很多图形\",{\"1\":{\"823\":1}}],[\"里面指定生成目标对象的过程\",{\"1\":{\"702\":1}}],[\"里面包含了享元方法\",{\"1\":{\"632\":1}}],[\"里面包含了非共享的外部状态信息\",{\"1\":{\"632\":1}}],[\"里面都是创建好的连接对象\",{\"1\":{\"629\":1}}],[\"里面的值既可以像下面的代码那样通过静态常量来定义\",{\"1\":{\"768\":1}}],[\"里面的key为string\",{\"1\":{\"281\":1}}],[\"里面的var类型为string类型\",{\"1\":{\"281\":1}}],[\"里面加上我们需要用到的实现类\",{\"1\":{\"96\":1}}],[\"里去\",{\"1\":{\"264\":1}}],[\"怎样创建对象\",{\"1\":{\"798\":1}}],[\"怎样使用的\",{\"1\":{\"796\":1}}],[\"怎样处理等等\",{\"1\":{\"262\":1}}],[\"怎么判断代码是否符合\",{\"1\":{\"817\":1}}],[\"怎么办\",{\"1\":{\"796\":1}}],[\"怎么会需要两个或者多个实例呢\",{\"1\":{\"766\":1}}],[\"怎么造出新对象呢\",{\"1\":{\"699\":1,\"702\":1}}],[\"怎么实现我不管\",{\"1\":{\"591\":1}}],[\"怎么搞定我不管\",{\"1\":{\"591\":1}}],[\"怎么说呢\",{\"1\":{\"291\":1}}],[\"怎么将\",{\"0\":{\"159\":1}}],[\"怎么样构建你的缓存\",{\"1\":{\"466\":1}}],[\"怎么样\",{\"1\":{\"90\":1,\"92\":1}}],[\"找出差异点\",{\"1\":{\"869\":1}}],[\"找出应用中可能需要变化之处\",{\"1\":{\"746\":1}}],[\"找工作等都可以通过找中介完成\",{\"1\":{\"692\":1}}],[\"找保姆\",{\"1\":{\"692\":1}}],[\"找不到类异常\",{\"1\":{\"261\":1}}],[\"找到你按下的关的按钮\",{\"1\":{\"562\":1}}],[\"找到你按下的开的按钮\",{\"1\":{\"562\":1}}],[\"找到匹配后\",{\"1\":{\"310\":1}}],[\"找到与之对应的处理程序\",{\"1\":{\"257\":1}}],[\"找到指定名称的配置后返回\",{\"1\":{\"106\":1}}],[\"计算该列除null之外的不重复行数\",{\"1\":{\"865\":1}}],[\"计算长方形和圆形的周长与面积\",{\"1\":{\"826\":1}}],[\"计算类\",{\"1\":{\"644\":1}}],[\"计算费用的抽象方法\",{\"1\":{\"584\":1}}],[\"计算机科学与技术是老牌的专业\",{\"1\":{\"574\":1}}],[\"计算机科学与技术\",{\"1\":{\"574\":1}}],[\"计算机学院\",{\"1\":{\"574\":2,\"650\":1}}],[\"计算机销售公司安排技术人员去组装计算机\",{\"1\":{\"549\":1}}],[\"计算机是由\",{\"1\":{\"549\":1}}],[\"计算null对象的长度\",{\"1\":{\"261\":1}}],[\"计划\",{\"1\":{\"20\":2}}],[\"整个上传流程包含三个步骤\",{\"1\":{\"809\":1}}],[\"整个系统就会受到影响\",{\"1\":{\"660\":1}}],[\"整个系统将受影响\",{\"1\":{\"608\":1}}],[\"整合到一个网站中\",{\"1\":{\"635\":1}}],[\"整体和局部的关系\",{\"1\":{\"835\":1}}],[\"整体和部分的关系\",{\"1\":{\"831\":1}}],[\"整体对象可以控制部分对象的生命周期\",{\"1\":{\"832\":1}}],[\"整体与部分可以分开\",{\"1\":{\"831\":1}}],[\"整体\",{\"1\":{\"567\":2}}],[\"整体不存在了部分也不存在了\",{\"1\":{\"216\":1}}],[\"整体不存在了部分还是会存在\",{\"1\":{\"215\":1}}],[\"整洁轻量级协议缓存\",{\"1\":{\"395\":1}}],[\"整数除零等\",{\"1\":{\"261\":1}}],[\"譬如短信\",{\"1\":{\"861\":1}}],[\"譬如\",{\"1\":{\"261\":2}}],[\"告知方法调用者\",{\"1\":{\"260\":1}}],[\"抛出nosuchmethoderror错误\",{\"1\":{\"858\":1}}],[\"抛出nosuchmethodexception\",{\"1\":{\"858\":1}}],[\"抛出npe异常\",{\"1\":{\"852\":1}}],[\"抛出nullpointerexception异常\",{\"1\":{\"850\":1}}],[\"抛出illegalmonitorstateexception异常\",{\"1\":{\"851\":1}}],[\"抛出illegalstateexception异常\",{\"1\":{\"850\":1}}],[\"抛出\",{\"1\":{\"276\":1}}],[\"抛出并接住异常对象\",{\"1\":{\"276\":2}}],[\"抛出并接住异常对象三者的耗时对比\",{\"1\":{\"276\":1}}],[\"抛出去\",{\"1\":{\"275\":1}}],[\"抛出错误\",{\"1\":{\"268\":1}}],[\"抛出和捕获异常的开销是很昂贵的\",{\"1\":{\"263\":1}}],[\"抛出该异常\",{\"1\":{\"261\":3}}],[\"抛出一个异常\",{\"1\":{\"260\":1}}],[\"抛出一个运行时异常\",{\"1\":{\"253\":1}}],[\"抛出的仍然为原始异常\",{\"1\":{\"259\":1}}],[\"抛出异常被catch后\",{\"1\":{\"858\":1}}],[\"抛出异常\",{\"1\":{\"259\":1,\"311\":1,\"812\":1,\"849\":2}}],[\"退出程序\",{\"1\":{\"258\":1}}],[\"调整附近代码行中的空格\",{\"1\":{\"912\":1}}],[\"调大服务器所支持的最大文件句柄数\",{\"1\":{\"870\":1}}],[\"调停模式\",{\"1\":{\"655\":1}}],[\"调暗灯光\",{\"1\":{\"597\":1}}],[\"调味品的价格\",{\"1\":{\"584\":1}}],[\"调料组合会造成类的倍增\",{\"1\":{\"583\":1}}],[\"调料组合\",{\"1\":{\"581\":1}}],[\"调料\",{\"1\":{\"581\":1,\"582\":1}}],[\"调度作业和一次性任务\",{\"1\":{\"387\":1}}],[\"调度反射方法\",{\"1\":{\"313\":1}}],[\"调优参数\",{\"0\":{\"378\":1}}],[\"调试时逻辑可能比较复杂\",{\"1\":{\"711\":1}}],[\"调试时很有用\",{\"1\":{\"254\":1}}],[\"调试不方便\",{\"1\":{\"711\":1}}],[\"调试多租户系统的框架和环境\",{\"1\":{\"432\":1}}],[\"调试排错\",{\"0\":{\"362\":1,\"363\":1,\"368\":1,\"369\":1,\"370\":1,\"375\":1,\"376\":1,\"377\":1,\"378\":1,\"380\":1}}],[\"调用第三方服务出\",{\"1\":{\"874\":1}}],[\"调用第三方服务出错是一级\",{\"1\":{\"857\":1}}],[\"调用第三方服务出错\",{\"1\":{\"857\":1}}],[\"调用远程操作必须有超时设置\",{\"1\":{\"870\":1}}],[\"调用频次低的方法\",{\"1\":{\"852\":1}}],[\"调用不成功时\",{\"1\":{\"848\":1}}],[\"调用当前状态的\",{\"1\":{\"778\":1}}],[\"调用完成的功能就会很明确\",{\"1\":{\"734\":1}}],[\"调用多个类只需要一个接口类\",{\"1\":{\"727\":1}}],[\"调用目标对象的方法\",{\"1\":{\"700\":1}}],[\"调用到被代理对象的方法\",{\"1\":{\"695\":1}}],[\"调用的rpc服务\",{\"1\":{\"848\":1}}],[\"调用的时候通过调用代理对象的方法来调用目标对象\",{\"1\":{\"695\":1}}],[\"调用的中介者对象的\",{\"1\":{\"659\":1}}],[\"调用引用类型的\",{\"1\":{\"689\":1}}],[\"调用接入方的\",{\"1\":{\"676\":1}}],[\"调用相关表达式类的解释方法\",{\"1\":{\"642\":1}}],[\"调用具体构件角色的方法\",{\"1\":{\"580\":1}}],[\"调用具体方法的无参构造方法\",{\"1\":{\"310\":1}}],[\"调用者通过它访问具体工厂的工厂方法\",{\"1\":{\"612\":1}}],[\"调用者只要调用命令对象的\",{\"1\":{\"564\":1}}],[\"调用者类\",{\"1\":{\"562\":1}}],[\"调用者执行命令command\",{\"1\":{\"561\":1}}],[\"调用者\",{\"1\":{\"561\":2}}],[\"调用时\",{\"1\":{\"312\":1}}],[\"调用method\",{\"0\":{\"312\":1}}],[\"调用无参构造器\",{\"1\":{\"310\":1}}],[\"调用无参构造器创建此\",{\"1\":{\"306\":1}}],[\"调用泛型方法语法格式\",{\"1\":{\"283\":1}}],[\"调用14位置的异常处理者\",{\"1\":{\"275\":1}}],[\"调用native方法\",{\"1\":{\"310\":1}}],[\"调用native方法进行获取class信息\",{\"1\":{\"310\":1}}],[\"调用null对象的实例方法\",{\"1\":{\"261\":1}}],[\"调用next方法的时候进行实例化并缓存\",{\"1\":{\"114\":1}}],[\"调用super\",{\"1\":{\"200\":1}}],[\"调用父类构造\",{\"1\":{\"199\":1}}],[\"调用\",{\"1\":{\"138\":1,\"310\":1,\"312\":1,\"562\":1,\"563\":1,\"676\":1,\"678\":2,\"739\":1,\"758\":1,\"814\":1}}],[\"调用hasnext方法的时候会去加载配置文件进行解析\",{\"1\":{\"114\":1}}],[\"调用方如果没有捕获到就会产生运行时错误\",{\"1\":{\"858\":1}}],[\"调用方一旦在返回的集合中进行了添加元素的操作\",{\"1\":{\"850\":1}}],[\"调用方法必须遵循任何可查异常的处理和声明规则\",{\"1\":{\"252\":1}}],[\"调用方\",{\"1\":{\"113\":1}}],[\"调用下面的方法\",{\"1\":{\"91\":1}}],[\"目的是测试系统能否正确操作\",{\"1\":{\"994\":1}}],[\"目的是为了给调用者提供尽可能多的信息\",{\"1\":{\"266\":1}}],[\"目的是为了改变异常的类型\",{\"1\":{\"253\":1}}],[\"目的\",{\"1\":{\"589\":1,\"590\":1,\"591\":1,\"748\":1}}],[\"目标对象的方法如果为\",{\"1\":{\"703\":1}}],[\"目标对象的类\",{\"1\":{\"702\":1}}],[\"目标对象不需要实现接口\",{\"1\":{\"702\":1}}],[\"目标对象需要实现接口\",{\"1\":{\"702\":1}}],[\"目标对象实现的接口类型\",{\"1\":{\"700\":1}}],[\"目标对象与代理对象都要维护\",{\"1\":{\"696\":1}}],[\"目标对象\",{\"1\":{\"695\":3,\"699\":1,\"702\":1}}],[\"目标与观察者之间的依赖关系并没有完全解除\",{\"1\":{\"671\":1}}],[\"目标与观察者之间建立了一套触发机制\",{\"1\":{\"671\":1}}],[\"目标\",{\"1\":{\"519\":1}}],[\"目前的javadoc还没有实现\",{\"1\":{\"853\":1}}],[\"目前的jvm和jdk实现\",{\"1\":{\"410\":1}}],[\"目前程序员门槛越来越高\",{\"1\":{\"796\":1}}],[\"目前还处于beta版本\",{\"1\":{\"427\":1}}],[\"目前是一个apache孵化器项目\",{\"1\":{\"411\":1}}],[\"目前仍在活跃开发\",{\"1\":{\"384\":1}}],[\"目录浏览一下就好\",{\"1\":{\"864\":1}}],[\"目录下\",{\"1\":{\"859\":1}}],[\"目录里创建一个以服务接口命名的文件\",{\"1\":{\"95\":1,\"114\":1}}],[\"目录\",{\"0\":{\"5\":1},\"1\":{\"96\":1,\"114\":1}}],[\"仅包含用于对齐的前导星号\",{\"1\":{\"956\":1}}],[\"仅\",{\"1\":{\"911\":1}}],[\"仅在右花括号结束一条语句或者方法\",{\"1\":{\"901\":1}}],[\"仅影响信息展示\",{\"1\":{\"871\":1}}],[\"仅部分\",{\"1\":{\"306\":1}}],[\"仅仅是为了填充参数列表的对象\",{\"1\":{\"996\":1}}],[\"仅仅保证实例引用的不可变属性是不够的\",{\"1\":{\"942\":1}}],[\"仅仅为了代码复用\",{\"1\":{\"814\":1}}],[\"仅仅包含一个外部依赖\",{\"1\":{\"458\":1}}],[\"仅仅当想要处理异常时才去捕获\",{\"1\":{\"270\":1}}],[\"仅仅起到辅助性的作用\",{\"1\":{\"148\":1}}],[\"仅当抛出了异常\",{\"1\":{\"252\":1}}],[\"正如在\",{\"1\":{\"902\":1,\"905\":1,\"959\":1}}],[\"正如名字表示的那样\",{\"1\":{\"432\":1}}],[\"正在授权中\",{\"1\":{\"874\":1}}],[\"正在抽奖\",{\"1\":{\"778\":1}}],[\"正式版\",{\"1\":{\"872\":1}}],[\"正式发布的类库必须先去中央仓库进行查证\",{\"1\":{\"869\":1}}],[\"正常运行两年后\",{\"1\":{\"865\":1}}],[\"正则输入源串拒绝服务redos\",{\"1\":{\"861\":1}}],[\"正例\",{\"1\":{\"843\":1,\"845\":14,\"846\":3,\"847\":7,\"848\":7,\"849\":3,\"850\":7,\"851\":8,\"852\":3,\"853\":1,\"854\":3,\"855\":1,\"857\":2,\"858\":3,\"859\":5,\"860\":2,\"863\":5,\"864\":4,\"865\":3,\"866\":1,\"869\":2,\"870\":1,\"871\":6}}],[\"正确执行后的返回\",{\"1\":{\"874\":1}}],[\"正确的输入\",{\"1\":{\"860\":1}}],[\"正确的英文拼写和语法可以让阅读者易于理解\",{\"1\":{\"845\":1}}],[\"正确的程序在运行中\",{\"1\":{\"249\":1}}],[\"正确使用设计模式具有以下优点\",{\"1\":{\"797\":1}}],[\"正是因为它持有一堆对象\",{\"1\":{\"621\":1}}],[\"正是由于它使用的基于\",{\"1\":{\"449\":1}}],[\"正数高位补0\",{\"1\":{\"203\":1}}],[\"空语句块\",{\"0\":{\"902\":1}}],[\"空间浪费\",{\"1\":{\"850\":1}}],[\"空集合对象\",{\"1\":{\"850\":1}}],[\"空行\",{\"1\":{\"847\":1}}],[\"空格字符\",{\"0\":{\"883\":1}}],[\"空格\",{\"0\":{\"909\":1},\"1\":{\"847\":1,\"911\":1,\"957\":1}}],[\"空\",{\"1\":{\"835\":1}}],[\"空心菱形\",{\"1\":{\"835\":1}}],[\"空心三角箭头表示继承或实现\",{\"1\":{\"835\":1}}],[\"空实现\",{\"1\":{\"650\":1,\"803\":1}}],[\"空实现或抛异常\",{\"1\":{\"569\":1}}],[\"空命令\",{\"1\":{\"564\":1}}],[\"空方法\",{\"1\":{\"531\":1}}],[\"空指针异常\",{\"1\":{\"248\":1,\"261\":1,\"873\":1}}],[\"空位都以0补齐\",{\"1\":{\"203\":1}}],[\"栈溢出错误\",{\"1\":{\"247\":1}}],[\"出错时的堆内信息对解决问题非常有帮助\",{\"1\":{\"870\":1}}],[\"出对象\",{\"1\":{\"832\":1}}],[\"出行旅游可以乘坐飞机\",{\"1\":{\"783\":1}}],[\"出另外一个对象出来\",{\"1\":{\"666\":1}}],[\"出该对象\",{\"1\":{\"609\":1}}],[\"出有副作用\",{\"1\":{\"477\":1}}],[\"出来\",{\"1\":{\"310\":1}}],[\"出现在上一行代码中的另一些单词的正下方\",{\"1\":{\"912\":1}}],[\"出现数组越界异常\",{\"1\":{\"849\":1}}],[\"出现异常就停止执行下面的代码\",{\"1\":{\"260\":1}}],[\"出现异常之后的语句也不会被执行\",{\"1\":{\"257\":1}}],[\"出现问题\",{\"1\":{\"247\":1}}],[\"出于速度和安全性两个方面的综合考虑\",{\"1\":{\"205\":1}}],[\"干过这个吗\",{\"1\":{\"478\":1}}],[\"干扰了正常的指令流程\",{\"1\":{\"245\":1}}],[\"干净清爽的形象会为你加分许多\",{\"1\":{\"36\":1}}],[\"干净清爽最重要\",{\"1\":{\"36\":1}}],[\"网关服务出错\",{\"1\":{\"874\":1}}],[\"网关访问受限\",{\"1\":{\"874\":1}}],[\"网关控制层等\",{\"1\":{\"868\":1}}],[\"网状结构\",{\"1\":{\"655\":2}}],[\"网站\",{\"1\":{\"861\":1}}],[\"网站或者去火车票代售点买\",{\"1\":{\"692\":1}}],[\"网站的计数器\",{\"1\":{\"750\":1}}],[\"网站的分类共=\",{\"1\":{\"636\":1}}],[\"网站的发布形式为\",{\"1\":{\"636\":1}}],[\"网站工厂类\",{\"1\":{\"636\":2}}],[\"网站发布的形式\",{\"1\":{\"636\":1}}],[\"网站类和其子类\",{\"1\":{\"636\":1}}],[\"网络资源服务出错\",{\"1\":{\"874\":1}}],[\"网络安全事件\",{\"1\":{\"859\":1}}],[\"网络安全专业\",{\"1\":{\"650\":2}}],[\"网络运行状态\",{\"1\":{\"859\":1}}],[\"网络工程不错\",{\"1\":{\"574\":1}}],[\"网络工程\",{\"1\":{\"574\":1}}],[\"网络爬虫\",{\"0\":{\"433\":1}}],[\"网络编程函数库\",{\"1\":{\"419\":1}}],[\"网络\",{\"0\":{\"419\":1},\"1\":{\"860\":1}}],[\"网络连接池等\",{\"1\":{\"762\":1}}],[\"网络连接和磁盘文件\",{\"1\":{\"251\":1}}],[\"网络连接失败\",{\"1\":{\"245\":1}}],[\"网上有很多争议\",{\"1\":{\"812\":1}}],[\"网上转账\",{\"1\":{\"546\":1}}],[\"网上知识点比较多也比较散\",{\"1\":{\"299\":1}}],[\"网上很多标注解的原理文章根本没有说到点子上\",{\"1\":{\"238\":1}}],[\"网上找了个例子\",{\"1\":{\"96\":1}}],[\"总的来说\",{\"1\":{\"989\":1}}],[\"总的抽象类或接口\",{\"1\":{\"568\":1}}],[\"总代码的行数\",{\"1\":{\"907\":1}}],[\"总之\",{\"1\":{\"812\":1,\"823\":1}}],[\"总经理等\",{\"1\":{\"707\":1}}],[\"总结一下\",{\"1\":{\"622\":1,\"809\":1}}],[\"总结\",{\"0\":{\"588\":1,\"748\":1}}],[\"总结了java\",{\"1\":{\"244\":1,\"278\":1,\"300\":1}}],[\"总公司中的部门与分公司\",{\"1\":{\"567\":1}}],[\"总是使用\",{\"0\":{\"949\":1}}],[\"总是需要重新初始化对象\",{\"1\":{\"686\":1}}],[\"总是需要重新获取原始对象的属性\",{\"1\":{\"686\":1}}],[\"总是优先捕获最具体的异常类\",{\"1\":{\"267\":1}}],[\"总是只有一个\",{\"1\":{\"178\":1}}],[\"著作权归\",{\"1\":{\"243\":1,\"277\":1,\"299\":1,\"314\":1}}],[\"机械制造等行业\",{\"1\":{\"818\":1}}],[\"机械工业出版社\",{\"1\":{\"153\":1}}],[\"机箱\",{\"1\":{\"549\":1}}],[\"机器学习\",{\"0\":{\"413\":1}}],[\"机制避免了多线程的同步问题\",{\"1\":{\"752\":1}}],[\"机制\",{\"1\":{\"301\":1}}],[\"机制来实现的\",{\"1\":{\"242\":1}}],[\"删除记录时\",{\"1\":{\"865\":1}}],[\"删除别人的数据\",{\"1\":{\"861\":1}}],[\"删除某一行数据的单元测试\",{\"1\":{\"860\":1}}],[\"删除等操作\",{\"1\":{\"860\":1}}],[\"删除元素的条件\",{\"1\":{\"850\":1}}],[\"删除产生concurrentmodificationexception异常\",{\"1\":{\"850\":1}}],[\"删除一下\",{\"1\":{\"848\":1}}],[\"删除掉老的接口\",{\"1\":{\"818\":1}}],[\"删除或更换算法要修改原代码\",{\"1\":{\"783\":1}}],[\"删除观察者方法\",{\"1\":{\"672\":1}}],[\"删除观察者对象的方法\",{\"1\":{\"672\":1}}],[\"删除的方法用remove\",{\"1\":{\"845\":1}}],[\"删除的方法\",{\"1\":{\"650\":1}}],[\"删除聚合对象以及创建迭代器对象的接口\",{\"1\":{\"649\":1}}],[\"删除命令时\",{\"1\":{\"565\":1}}],[\"删除了阻止异常抛出的代码\",{\"1\":{\"269\":1}}],[\"删除\",{\"1\":{\"242\":1,\"568\":1,\"573\":1}}],[\"放置在一方库中\",{\"1\":{\"846\":1}}],[\"放置在二方库中\",{\"1\":{\"846\":1}}],[\"放右边\",{\"1\":{\"790\":1}}],[\"放左边\",{\"1\":{\"790\":1}}],[\"放入所有的同事对象\",{\"1\":{\"659\":1}}],[\"放到豆浆机打碎\",{\"1\":{\"802\":1}}],[\"放到一个抽象类\",{\"1\":{\"748\":1}}],[\"放到一个类中统一管理和维护\",{\"1\":{\"619\":1}}],[\"放到同一个类中\",{\"1\":{\"741\":1}}],[\"放到配置文件中\",{\"1\":{\"622\":1}}],[\"放到log中\",{\"1\":{\"242\":1}}],[\"放在一个方法里\",{\"1\":{\"972\":1}}],[\"放在一个代码块里\",{\"1\":{\"617\":4}}],[\"放在以\",{\"1\":{\"477\":1}}],[\"放在try语句块之内\",{\"1\":{\"251\":1}}],[\"放心使用\",{\"1\":{\"313\":1}}],[\"放着好好的0不用\",{\"1\":{\"90\":1}}],[\"放着简单的代码不用\",{\"1\":{\"90\":1}}],[\"传统下多个类相互耦合\",{\"1\":{\"660\":1}}],[\"传统方案题分析\",{\"1\":{\"709\":1}}],[\"传统方案解决游戏角色恢复\",{\"0\":{\"666\":1}}],[\"传统方案解决智能家具项目\",{\"0\":{\"658\":1}}],[\"传统方案解决网站展现项目\",{\"0\":{\"634\":1}}],[\"传统方案解决学校院系展示\",{\"0\":{\"573\":1}}],[\"传统方案解决手机操作问题分析\",{\"0\":{\"541\":1}}],[\"传统方案解决手机操作问题\",{\"0\":{\"540\":1}}],[\"传统方式问题分析和解决方案\",{\"0\":{\"788\":1}}],[\"传统方式代码实现\",{\"0\":{\"787\":1}}],[\"传统方式是\",{\"1\":{\"709\":1}}],[\"传统方式完成披萨案例\",{\"0\":{\"609\":1}}],[\"传统方式解决鸭子项目\",{\"0\":{\"786\":1}}],[\"传统方式解决克隆羊实例\",{\"0\":{\"685\":1}}],[\"传统方式解决问题分析\",{\"0\":{\"600\":1}}],[\"传统方式解决问题图\",{\"0\":{\"599\":1}}],[\"传统方式解决影院管理\",{\"0\":{\"598\":1}}],[\"传统方式解决盖房案例\",{\"0\":{\"553\":1}}],[\"传统方式的问题分析\",{\"0\":{\"554\":1},\"1\":{\"709\":1}}],[\"传统方法对应的类图\",{\"1\":{\"540\":1}}],[\"传统的设计方案\",{\"1\":{\"786\":1}}],[\"传统的设计方案初步设计出一个\",{\"1\":{\"675\":1}}],[\"传统的解决方案是\",{\"1\":{\"775\":1}}],[\"传统的方法\",{\"1\":{\"685\":1}}],[\"传统的方式是简单地做备份\",{\"1\":{\"666\":1}}],[\"传统的方式的优缺点\",{\"0\":{\"686\":1},\"1\":{\"609\":1}}],[\"传统的代码风格是被用来编写非常复杂的企业级\",{\"1\":{\"444\":1}}],[\"传统的\",{\"1\":{\"301\":1}}],[\"传入为pojo类\",{\"1\":{\"866\":1}}],[\"传入的是类型完全一致\",{\"1\":{\"850\":1}}],[\"传入pattern中表示年份统一使用小写的y\",{\"1\":{\"849\":1}}],[\"传入对象\",{\"1\":{\"832\":1}}],[\"传入idgenerator\",{\"1\":{\"769\":1}}],[\"传入\",{\"1\":{\"555\":1,\"745\":1,\"789\":1}}],[\"传入一个被代理的对象\",{\"1\":{\"703\":1}}],[\"传入一个\",{\"1\":{\"528\":1}}],[\"传入到数据库中\",{\"1\":{\"242\":1}}],[\"传输控制协议连接超时\",{\"1\":{\"853\":1}}],[\"传输\",{\"0\":{\"325\":1}}],[\"传递到后端的参数被截断\",{\"1\":{\"854\":1}}],[\"传递到\",{\"1\":{\"676\":1}}],[\"传递给调用处\",{\"1\":{\"275\":1}}],[\"传递异常可以在方法签名处使用\",{\"1\":{\"252\":1}}],[\"传递性\",{\"1\":{\"138\":1,\"181\":1}}],[\"获得\",{\"1\":{\"745\":1}}],[\"获得值映射\",{\"1\":{\"644\":1}}],[\"获得表达式\",{\"1\":{\"644\":1}}],[\"获得某个类的自己声明的字段\",{\"1\":{\"305\":1}}],[\"获得某个类的所有的公共\",{\"1\":{\"305\":1}}],[\"获得注解\",{\"1\":{\"242\":1}}],[\"获取用户页面数据\",{\"1\":{\"861\":1}}],[\"获取数据库连接\",{\"1\":{\"852\":1}}],[\"获取单例对象需要保证线程安全\",{\"1\":{\"851\":1}}],[\"获取单个对象的方法用get做前缀\",{\"1\":{\"845\":1}}],[\"获取今年的天数\",{\"1\":{\"849\":1}}],[\"获取纳秒级时间\",{\"1\":{\"849\":1}}],[\"获取统计值的方法用count做前缀\",{\"1\":{\"845\":1}}],[\"获取多个对象的方法用list做前缀\",{\"1\":{\"845\":1}}],[\"获取并保存一个对象的内部状态\",{\"1\":{\"798\":1}}],[\"获取并遍历方法上的所有注解\",{\"1\":{\"234\":1}}],[\"获取状态\",{\"1\":{\"779\":1}}],[\"获取加载器的方法固定\",{\"1\":{\"700\":1}}],[\"获取网站分类的总数\",{\"1\":{\"636\":1}}],[\"获取第一次创建的\",{\"1\":{\"632\":3}}],[\"获取对象\",{\"1\":{\"627\":1}}],[\"获取折叠式手机\",{\"1\":{\"542\":1}}],[\"获取\",{\"1\":{\"528\":1}}],[\"获取到的对象实例是不同的\",{\"1\":{\"773\":1}}],[\"获取到的对象实例是相同的\",{\"1\":{\"773\":1}}],[\"获取到学校总部员工\",{\"1\":{\"742\":1,\"743\":1}}],[\"获取到学院员工\",{\"1\":{\"742\":1,\"743\":1}}],[\"获取到代理对象\",{\"1\":{\"703\":1}}],[\"获取到\",{\"1\":{\"310\":1,\"524\":1}}],[\"获取保存的信息\",{\"1\":{\"310\":1}}],[\"获取无参构造器\",{\"1\":{\"310\":1}}],[\"获取信息\",{\"1\":{\"310\":1}}],[\"获取调用进来的类信息\",{\"1\":{\"310\":1}}],[\"获取类信息\",{\"1\":{\"310\":1}}],[\"获取类名\",{\"1\":{\"305\":3}}],[\"获取字段值\",{\"1\":{\"307\":1}}],[\"获取父类public字段并赋值\",{\"1\":{\"307\":1}}],[\"获取当前毫秒数\",{\"1\":{\"849\":1}}],[\"获取当前类所有的构造方法\",{\"1\":{\"310\":1}}],[\"获取当前类所字段\",{\"1\":{\"307\":1}}],[\"获取当前类的所有方法包含private\",{\"1\":{\"308\":1}}],[\"获取当前类的方法包含private\",{\"1\":{\"308\":1}}],[\"获取当前的用户\",{\"1\":{\"242\":1}}],[\"获取指定某年的天数\",{\"1\":{\"849\":1}}],[\"获取指定参数的方法对象method\",{\"1\":{\"308\":1}}],[\"获取指定字段名称的field类\",{\"1\":{\"307\":2}}],[\"获取指定name名称\",{\"1\":{\"307\":1}}],[\"获取指定name名称的\",{\"1\":{\"307\":1}}],[\"获取修饰符为public的字段\",{\"1\":{\"307\":1}}],[\"获取构造函数参数类型\",{\"1\":{\"306\":2}}],[\"获取所有方法列表\",{\"1\":{\"311\":1}}],[\"获取所有的构造器主要步骤\",{\"1\":{\"310\":1}}],[\"获取所有构造器\",{\"1\":{\"310\":1}}],[\"获取所有构造包含private\",{\"1\":{\"306\":1}}],[\"获取所有public的方法\",{\"1\":{\"308\":1}}],[\"获取所有修饰符为public的字段\",{\"1\":{\"307\":1}}],[\"获取所有methods\",{\"1\":{\"234\":1}}],[\"获取带string参数的public构造函数\",{\"1\":{\"306\":1}}],[\"获取class对象引用\",{\"1\":{\"307\":1}}],[\"获取class对象所表示的类或接口的所有\",{\"1\":{\"307\":1}}],[\"获取class对象的引用\",{\"1\":{\"306\":1}}],[\"获取class对象的一个引用\",{\"1\":{\"305\":2}}],[\"获取class对象的三种方式\",{\"1\":{\"305\":1}}],[\"获取class对象的方式的主要有三种\",{\"1\":{\"305\":1}}],[\"获取constructor对象是通过class类中的方法获取的\",{\"1\":{\"306\":1}}],[\"获取全限定的类名\",{\"1\":{\"305\":1}}],[\"获取全限定类名\",{\"1\":{\"305\":2}}],[\"获取泛型\",{\"1\":{\"298\":1}}],[\"获取请求的参数\",{\"1\":{\"242\":1}}],[\"获取参数的信息\",{\"1\":{\"242\":1}}],[\"获取注解中对方法的描述信息\",{\"1\":{\"242\":1}}],[\"获取mymethodannotation对象信息\",{\"1\":{\"234\":1}}],[\"获取某个实现类的方式不够灵活\",{\"1\":{\"115\":1}}],[\"获取迭代器\",{\"1\":{\"103\":1,\"111\":1,\"114\":1}}],[\"功能列表\",{\"1\":{\"808\":1}}],[\"功能模块\",{\"1\":{\"796\":1}}],[\"功能解耦\",{\"1\":{\"748\":1}}],[\"功能大而全\",{\"1\":{\"741\":1}}],[\"功能性测试和性能评测\",{\"1\":{\"431\":1}}],[\"功能强大\",{\"1\":{\"430\":1}}],[\"功能\",{\"1\":{\"242\":1,\"741\":1}}],[\"发送等即时消息\",{\"1\":{\"861\":1}}],[\"发送者和接收者也无须拥有对方的明确信息\",{\"1\":{\"707\":1}}],[\"发贴\",{\"1\":{\"861\":1}}],[\"发挥它们各自的优势\",{\"1\":{\"814\":1}}],[\"发放奖品后改变其状态\",{\"1\":{\"778\":1}}],[\"发放奖品的状态\",{\"1\":{\"778\":1}}],[\"发放奖品\",{\"1\":{\"778\":2}}],[\"发放奖品方法\",{\"1\":{\"778\":1}}],[\"发放奖品和奖品领完\",{\"1\":{\"777\":1}}],[\"发起人类\",{\"1\":{\"667\":1}}],[\"发起人\",{\"1\":{\"664\":2}}],[\"发起人不需要管理和保存其内部状态的各个备份\",{\"1\":{\"663\":1}}],[\"发起请求的对象是调用者\",{\"1\":{\"564\":1}}],[\"发现\",{\"1\":{\"814\":1}}],[\"发现自己已经在使用了\",{\"1\":{\"794\":1}}],[\"发现消息\",{\"1\":{\"659\":1}}],[\"发现org\",{\"1\":{\"104\":1}}],[\"发动机\",{\"1\":{\"549\":1}}],[\"发型等特性都有所差异\",{\"1\":{\"549\":1}}],[\"发布错误码统一解决方案\",{\"1\":{\"872\":1}}],[\"发布日期\",{\"1\":{\"872\":1}}],[\"发布到线上却出故障的先例\",{\"1\":{\"869\":1}}],[\"发布逻辑\",{\"1\":{\"779\":1}}],[\"发布可立即使用的组件\",{\"1\":{\"401\":1}}],[\"发布二进制文件版本控制工具\",{\"1\":{\"401\":1}}],[\"发布\",{\"0\":{\"401\":1},\"1\":{\"779\":2}}],[\"发生依赖\",{\"1\":{\"727\":1}}],[\"发生了exception类型的异常\",{\"1\":{\"275\":1}}],[\"发生异常\",{\"1\":{\"241\":1}}],[\"框架在调用属性xxx的提取方法时\",{\"1\":{\"848\":1}}],[\"框架在反向解析时\",{\"1\":{\"845\":1}}],[\"框架通常比单个类的颗粒度要大\",{\"1\":{\"819\":1}}],[\"框架位于最高层\",{\"1\":{\"819\":1}}],[\"框架代码\",{\"1\":{\"814\":1}}],[\"框架代码跟应用代码应该是高度解耦的\",{\"1\":{\"622\":1}}],[\"框架应用中的\",{\"1\":{\"750\":1}}],[\"框架非常类似\",{\"1\":{\"624\":1}}],[\"框架这样的\",{\"1\":{\"624\":1}}],[\"框架中\",{\"1\":{\"622\":1}}],[\"框架的原型模式\",{\"0\":{\"688\":1}}],[\"框架的外观模式剖析\",{\"0\":{\"602\":1}}],[\"框架的\",{\"1\":{\"563\":1}}],[\"框架的支持和对\",{\"1\":{\"480\":1}}],[\"框架的演进\",{\"0\":{\"240\":1}}],[\"框架其实是一个完整的\",{\"1\":{\"472\":1}}],[\"框架来完成依赖注入\",{\"1\":{\"449\":1}}],[\"框架\",{\"0\":{\"332\":1},\"1\":{\"240\":1,\"431\":1,\"457\":1,\"472\":2,\"474\":1,\"796\":1,\"820\":1}}],[\"且必须是\",{\"1\":{\"998\":1}}],[\"且也只执行一次\",{\"1\":{\"976\":1}}],[\"且只执行一次\",{\"1\":{\"976\":1}}],[\"且只能被接口类直接调用\",{\"1\":{\"194\":1}}],[\"且所有的测试类必须继承junit的测试基类\",{\"1\":{\"972\":1}}],[\"且存在复杂的依赖关系\",{\"1\":{\"871\":1}}],[\"且版本号不允许覆盖升级\",{\"1\":{\"869\":1}}],[\"且使用的系统和事务日志资源少\",{\"1\":{\"865\":1}}],[\"且扩大了表示范围\",{\"1\":{\"863\":1}}],[\"且异常的处理效率比条件判断方式要低很多\",{\"1\":{\"858\":1}}],[\"且表意完整\",{\"1\":{\"854\":1}}],[\"且在size处插入null值\",{\"1\":{\"850\":1}}],[\"且构造方法被默认强制是私有\",{\"1\":{\"845\":1}}],[\"且不用修改原来的程序代码与数据结构\",{\"1\":{\"837\":1}}],[\"且不具备扩展性\",{\"1\":{\"775\":1}}],[\"且每种元素也存在多种不同的访问者和处理方式\",{\"1\":{\"837\":1}}],[\"且这种耦合关系非常脆弱\",{\"1\":{\"818\":1}}],[\"且这两个维度都需要进行扩展时\",{\"1\":{\"545\":1}}],[\"且算法的改变不会影响使用算法的客户\",{\"1\":{\"798\":1}}],[\"且算法的变化不会影响使用算法的客户\",{\"1\":{\"783\":1}}],[\"且要求对客户隐藏具体算法的实现细节时\",{\"1\":{\"792\":1}}],[\"且减少对象间的相互依赖\",{\"1\":{\"775\":1}}],[\"且增加新的状态时要添加新的\",{\"1\":{\"775\":1}}],[\"且经常使用\",{\"1\":{\"762\":1}}],[\"且加入到\",{\"1\":{\"659\":1}}],[\"且可以用一种简单的语言来进行表达时\",{\"1\":{\"646\":1}}],[\"且可将不同部分外部化\",{\"1\":{\"639\":1}}],[\"且执行效率不是关键问题时\",{\"1\":{\"646\":1}}],[\"且代码的调试过程也比较麻烦\",{\"1\":{\"641\":1}}],[\"且工厂类代码会非常臃肿\",{\"1\":{\"608\":1}}],[\"且命令实现不稳定\",{\"1\":{\"565\":1}}],[\"且满足\",{\"1\":{\"560\":1}}],[\"且很容易出现java\",{\"1\":{\"279\":1}}],[\"且未处理异常\",{\"1\":{\"275\":1}}],[\"且该注解为可继承的\",{\"1\":{\"233\":1}}],[\"描述进行修正\",{\"1\":{\"872\":1}}],[\"描述错误\",{\"1\":{\"872\":1}}],[\"描述了产品的主要特性和功能\",{\"1\":{\"612\":1,\"616\":1}}],[\"描述了出现在一段编码中的\",{\"1\":{\"245\":1}}],[\"描述=\",{\"1\":{\"584\":1}}],[\"描述\",{\"1\":{\"584\":6,\"872\":1,\"978\":1}}],[\"描述在使用\",{\"1\":{\"229\":1}}],[\"描述注解保留的时间范围\",{\"1\":{\"228\":1}}],[\"描述注解的使用范围\",{\"1\":{\"227\":1}}],[\"新方法和新技术\",{\"1\":{\"823\":1}}],[\"新开发的代码依赖中间层提供的新接口\",{\"1\":{\"818\":1}}],[\"新对象可以动态地引用与成分对象类型相同的对象\",{\"1\":{\"747\":1}}],[\"新对象可以调用已有对象的功能\",{\"1\":{\"747\":1}}],[\"新对象存取成分对象的唯一方法是通过成分对象的接口\",{\"1\":{\"747\":1}}],[\"新旧类之间的耦合度低\",{\"1\":{\"747\":1}}],[\"新功能出现\",{\"1\":{\"699\":1,\"702\":1}}],[\"新闻\",{\"1\":{\"636\":1}}],[\"新手的区别就是前者手背上有很多伤疤\",{\"1\":{\"797\":1}}],[\"新手\",{\"1\":{\"458\":1}}],[\"新手或者想提高效率的人尤有帮助\",{\"1\":{\"457\":1}}],[\"新的方法不是习惯性地添加到类的最后\",{\"1\":{\"896\":1}}],[\"新的\",{\"1\":{\"809\":1}}],[\"新的使用方式\",{\"1\":{\"769\":1}}],[\"新的状态\",{\"1\":{\"664\":1}}],[\"新的代码风格看起来会更加整洁\",{\"1\":{\"444\":1}}],[\"新的对象\",{\"1\":{\"290\":1}}],[\"新特性教程例子\",{\"1\":{\"437\":1}}],[\"新特性概述\",{\"0\":{\"338\":1,\"339\":1,\"341\":1,\"342\":1,\"343\":1,\"344\":1,\"345\":1,\"346\":1,\"361\":1}}],[\"新一代的模板引擎\",{\"1\":{\"430\":1}}],[\"新创建缓存\",{\"1\":{\"310\":1}}],[\"新增扩展说明\",{\"1\":{\"872\":1}}],[\"新增描述中的正反例\",{\"1\":{\"872\":1}}],[\"新增涉及敏感操作的情况下日志需要保存六个月的约定\",{\"1\":{\"872\":1}}],[\"新增禁止任何歧视性用语的约定\",{\"1\":{\"872\":1}}],[\"新增前后端规约\",{\"1\":{\"872\":1}}],[\"新增次要功能特性等\",{\"1\":{\"869\":1}}],[\"新增代码及时补充单元测试\",{\"1\":{\"860\":1}}],[\"新增或改变功能\",{\"1\":{\"820\":1}}],[\"新增一个图形\",{\"1\":{\"739\":1}}],[\"新增画三角形\",{\"1\":{\"738\":1,\"739\":1}}],[\"新增部门\",{\"1\":{\"242\":1}}],[\"新增保存部门\",{\"1\":{\"242\":1}}],[\"新增\",{\"1\":{\"227\":2,\"872\":3}}],[\"新建了两个等价的对象\",{\"1\":{\"139\":1}}],[\"新建一个迭代器\",{\"1\":{\"114\":1}}],[\"抑制没被使用过的代码的警告\",{\"1\":{\"225\":1}}],[\"抑制没有权限访问的域的警告\",{\"1\":{\"225\":1}}],[\"抑制没有进行类型检查操作的警告\",{\"1\":{\"225\":1}}],[\"抑制子类没有按最优方法访问内部类的警告\",{\"1\":{\"225\":1}}],[\"抑制不正确的静态访问方式警告\",{\"1\":{\"225\":1}}],[\"抑制与使用不建议或禁止参照相关的警告\",{\"1\":{\"225\":1}}],[\"抑制与隐藏变数的区域变数相关的警告\",{\"1\":{\"225\":1}}],[\"抑制finally模块没有返回的警告\",{\"1\":{\"225\":1}}],[\"抑制确在switch中缺失breaks的警告\",{\"1\":{\"225\":1}}],[\"抑制过期方法警告\",{\"1\":{\"225\":1}}],[\"抑制启用注释的警告\",{\"1\":{\"225\":1}}],[\"抑制映射相关的警告\",{\"1\":{\"225\":1}}],[\"抑制装箱\",{\"1\":{\"225\":1}}],[\"抑制所有警告\",{\"1\":{\"225\":1}}],[\"原始单词的大小写几乎完全被忽略\",{\"1\":{\"947\":1}}],[\"原始类型为object\",{\"1\":{\"290\":1}}],[\"原始类型也变为object\",{\"1\":{\"289\":1}}],[\"原始类型都是object\",{\"1\":{\"289\":1}}],[\"原始类型object\",{\"1\":{\"289\":1}}],[\"原始类型\",{\"1\":{\"289\":1,\"298\":1}}],[\"原始类型相等\",{\"1\":{\"288\":1}}],[\"原来程序员离职\",{\"1\":{\"796\":1}}],[\"原来的父类和子类都继承一个更通俗的基类\",{\"1\":{\"734\":1}}],[\"原有的继承关系去掉\",{\"1\":{\"734\":1}}],[\"原因可能为调用的外部依赖服务rt过高而导致系统假死\",{\"1\":{\"871\":1}}],[\"原因就是类\",{\"1\":{\"734\":1}}],[\"原因是这个代码块的逻辑过于复杂\",{\"1\":{\"614\":1}}],[\"原因是这样的\",{\"1\":{\"291\":1}}],[\"原型接口\",{\"1\":{\"683\":1}}],[\"原型模式的注意事项和细节\",{\"0\":{\"690\":1}}],[\"原型模式完成对象的创建\",{\"1\":{\"687\":1}}],[\"原型模式解决克隆羊实例\",{\"0\":{\"687\":1}}],[\"原型模式包含以下主要角色\",{\"1\":{\"683\":1}}],[\"原型模式原理结构图\",{\"0\":{\"683\":1}}],[\"原型模式是一种创建型设计模式\",{\"1\":{\"682\":1}}],[\"原型模式基本介绍\",{\"0\":{\"682\":1}}],[\"原型模式\",{\"1\":{\"589\":1,\"682\":1,\"686\":1,\"798\":1}}],[\"原生开发库\",{\"0\":{\"417\":1}}],[\"原文链接\",{\"1\":{\"243\":1,\"277\":1,\"299\":1,\"314\":1}}],[\"原描述\",{\"1\":{\"225\":1}}],[\"原则就是\",{\"1\":{\"789\":1}}],[\"原则在新窗口打开\",{\"1\":{\"219\":1}}],[\"原则\",{\"1\":{\"219\":1,\"533\":1,\"610\":4,\"677\":1,\"678\":1,\"690\":1,\"714\":1,\"716\":1,\"738\":1,\"791\":1,\"850\":1}}],[\"作为查询的字段列表\",{\"1\":{\"866\":1}}],[\"作为调用方来说\",{\"1\":{\"848\":1}}],[\"作为\",{\"1\":{\"651\":1}}],[\"作为一个抽象策略类的子类\",{\"1\":{\"784\":1}}],[\"作为一个通用的框架来说\",{\"1\":{\"622\":1}}],[\"作为一个接口\",{\"1\":{\"534\":1}}],[\"作为一个对象\",{\"1\":{\"534\":1}}],[\"作为参数传入\",{\"1\":{\"839\":1}}],[\"作为参数传递给函数\",{\"1\":{\"769\":1}}],[\"作为参数\",{\"1\":{\"271\":1,\"283\":1}}],[\"作者yongshun\",{\"1\":{\"993\":1}}],[\"作者是\",{\"1\":{\"795\":1}}],[\"作者和演讲者\",{\"1\":{\"440\":1}}],[\"作者设置为\",{\"1\":{\"32\":1}}],[\"作家\",{\"1\":{\"440\":5}}],[\"作用\",{\"1\":{\"225\":1}}],[\"废弃\",{\"1\":{\"224\":1}}],[\"忽略参数校验可能导致\",{\"1\":{\"861\":1}}],[\"忽略第一个检查权限\",{\"1\":{\"311\":1}}],[\"忽略在serializable类中没有声明serialversionuid变量\",{\"1\":{\"225\":1}}],[\"忽略对null的操作\",{\"1\":{\"225\":1}}],[\"忽略非nls格式的字符\",{\"1\":{\"225\":1}}],[\"忽略没有完整的switch语句\",{\"1\":{\"225\":1}}],[\"忽略告警\",{\"1\":{\"222\":1}}],[\"忽略符号位\",{\"1\":{\"203\":1}}],[\"生命周期\",{\"0\":{\"976\":1}}],[\"生命周期短\",{\"1\":{\"205\":1}}],[\"生死与共整体与局部的关系\",{\"1\":{\"835\":1}}],[\"生硬地抽象出一个父类出来\",{\"1\":{\"814\":1}}],[\"生活案例\",{\"1\":{\"589\":1,\"590\":1,\"591\":1}}],[\"生活用品中的衣服与衣柜\",{\"1\":{\"567\":1}}],[\"生活中这样的例子很多\",{\"1\":{\"549\":1}}],[\"生产环境提交执行后\",{\"1\":{\"871\":1}}],[\"生产环境禁止输出debug日志\",{\"1\":{\"859\":1}}],[\"生产环境禁止使用system\",{\"1\":{\"859\":1}}],[\"生产环境必须使用https\",{\"1\":{\"854\":1}}],[\"生产小米手机\",{\"1\":{\"617\":1}}],[\"生产更高效\",{\"1\":{\"589\":1}}],[\"生产\",{\"1\":{\"424\":1}}],[\"生产者有上限\",{\"1\":{\"284\":1}}],[\"生产者或者消费者\",{\"1\":{\"284\":1}}],[\"生成的方式相同\",{\"1\":{\"905\":1}}],[\"生成的map集合中只有一个键值对\",{\"1\":{\"850\":1}}],[\"生成javadoc可以正确输出相应注释\",{\"1\":{\"853\":1}}],[\"生成\",{\"1\":{\"809\":1}}],[\"生成算法\",{\"1\":{\"764\":1}}],[\"生成器来生成\",{\"1\":{\"764\":1}}],[\"生成器类\",{\"1\":{\"763\":1}}],[\"生成器模式\",{\"1\":{\"549\":1}}],[\"生成一个代理对象\",{\"1\":{\"700\":1}}],[\"生成及处理图像的工具集\",{\"1\":{\"408\":1}}],[\"生成实例并返回\",{\"1\":{\"310\":1}}],[\"生成文档\",{\"1\":{\"221\":1}}],[\"顺序和间隔\",{\"0\":{\"892\":1}}],[\"顺序\",{\"1\":{\"886\":1}}],[\"顺序图\",{\"1\":{\"219\":1}}],[\"顺序至少有一个不同\",{\"1\":{\"135\":1}}],[\"模板设计模式\",{\"1\":{\"848\":1}}],[\"模板方法只在特定点调用钩子操作\",{\"1\":{\"805\":1}}],[\"模板方法可以做成final\",{\"1\":{\"803\":1}}],[\"模板方法\",{\"1\":{\"801\":2,\"803\":1}}],[\"模板方法模式通常适用于以下场景\",{\"1\":{\"805\":1}}],[\"模板方法模式的应用场景\",{\"0\":{\"805\":1}}],[\"模板方法模式的注意事项和细节\",{\"0\":{\"804\":1}}],[\"模板方法模式的钩子方法\",{\"0\":{\"803\":1}}],[\"模板方法模式的结构图如下\",{\"1\":{\"801\":1}}],[\"模板方法模式解决豆浆制作问题\",{\"0\":{\"802\":1}}],[\"模板方法模式包含以下主要角色\",{\"1\":{\"801\":1}}],[\"模板方法模式结构与实现\",{\"0\":{\"801\":1}}],[\"模板方法模式定义一个操作中的算法的骨架\",{\"1\":{\"800\":1}}],[\"模板方法模式基本介绍\",{\"0\":{\"800\":1}}],[\"模板方法模式\",{\"1\":{\"798\":1,\"800\":1,\"802\":1}}],[\"模板模式\",{\"1\":{\"591\":1,\"800\":1}}],[\"模板\",{\"1\":{\"474\":1}}],[\"模板引擎会自动按规范调用pojo的getxxx\",{\"1\":{\"855\":1}}],[\"模板引擎\",{\"0\":{\"430\":1},\"1\":{\"432\":1}}],[\"模式则能让你独立于具体代码来复用设计思想和理念\",{\"1\":{\"819\":1}}],[\"模式不是代码\",{\"1\":{\"795\":1}}],[\"模式和实践\",{\"1\":{\"716\":1}}],[\"模式和工厂模式的关注点不同\",{\"1\":{\"549\":1}}],[\"模式\",{\"1\":{\"603\":1,\"655\":1,\"798\":1,\"841\":1}}],[\"模式是\",{\"1\":{\"593\":1}}],[\"模式的实现\",{\"0\":{\"571\":1,\"596\":1}}],[\"模式的实现化角色的接口与现有类的接口不一致时\",{\"1\":{\"547\":1}}],[\"模式的主要角色如下\",{\"1\":{\"551\":1}}],[\"模式的结构比较简单\",{\"1\":{\"594\":1}}],[\"模式的结构\",{\"0\":{\"519\":1,\"595\":1,\"632\":1}}],[\"模式可与\",{\"1\":{\"547\":1}}],[\"模式包含以下主要角色\",{\"1\":{\"538\":1,\"595\":1}}],[\"模式最大的作用还是将原本不兼容的接口融合在一起工作\",{\"1\":{\"534\":1}}],[\"模式匹配\",{\"1\":{\"403\":1,\"469\":1}}],[\"模式与实践\",{\"1\":{\"219\":1}}],[\"模型是现实的简化\",{\"1\":{\"824\":1}}],[\"模型大多以图表的方式表现出来\",{\"1\":{\"823\":1}}],[\"模型\",{\"0\":{\"331\":2},\"1\":{\"655\":1,\"671\":1}}],[\"模块层面上的依赖关系网\",{\"1\":{\"871\":1}}],[\"模块名\",{\"1\":{\"869\":1}}],[\"模块或者类的职责设计得单一\",{\"1\":{\"818\":1}}],[\"模块或类之间的耦合小\",{\"1\":{\"816\":1}}],[\"模块的设计\",{\"1\":{\"816\":1}}],[\"模块和函数应该\",{\"1\":{\"736\":1}}],[\"模块化是构建复杂系统常用的手段\",{\"1\":{\"818\":1}}],[\"模块化测试函数库\",{\"1\":{\"431\":1}}],[\"模块化应用服务器\",{\"1\":{\"429\":1}}],[\"模块化\",{\"0\":{\"815\":1},\"1\":{\"414\":1,\"818\":1}}],[\"模块\",{\"1\":{\"242\":1,\"818\":1}}],[\"模块之间只通过它们的\",{\"1\":{\"132\":1}}],[\"泛化\",{\"1\":{\"822\":1,\"826\":1,\"833\":1}}],[\"泛化的设计思想\",{\"1\":{\"808\":1}}],[\"泛化关系用\",{\"1\":{\"833\":1}}],[\"泛化关系和实现关系\",{\"1\":{\"827\":1}}],[\"泛化关系\",{\"0\":{\"213\":1,\"833\":1}}],[\"泛型集合使用时\",{\"1\":{\"850\":1}}],[\"泛型通配符<\",{\"1\":{\"850\":1}}],[\"泛型作为java基础知识点之一\",{\"1\":{\"299\":1}}],[\"泛型信息全都会被擦除掉\",{\"1\":{\"297\":1}}],[\"泛型出现的原因\",{\"1\":{\"290\":1}}],[\"泛型变量的类型为该方法中的几种类型的同一父类的最小级\",{\"1\":{\"289\":1}}],[\"泛型中的引用传递的问题\",{\"1\":{\"290\":1}}],[\"泛型中的类型在使用时指定\",{\"1\":{\"279\":1}}],[\"泛型中参数话类型为什么不考虑继承关系\",{\"1\":{\"290\":1}}],[\"泛型中类型擦除\",{\"0\":{\"287\":1}}],[\"泛型数组\",{\"0\":{\"285\":1,\"294\":1,\"295\":1}}],[\"泛型上下限的引入\",{\"1\":{\"284\":1}}],[\"泛型类扩展throwable都不合法\",{\"1\":{\"297\":1}}],[\"泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数\",{\"1\":{\"296\":1}}],[\"泛型类\",{\"0\":{\"281\":1},\"1\":{\"280\":1}}],[\"泛型有三种使用方式\",{\"1\":{\"280\":1}}],[\"泛型方法不是仅仅可以有一个参数class<t>\",{\"1\":{\"283\":1}}],[\"泛型方法要求的参数是class<t>类型\",{\"1\":{\"283\":1}}],[\"泛型方法\",{\"0\":{\"283\":1},\"1\":{\"279\":1,\"280\":1,\"283\":1}}],[\"泛型接口\",{\"0\":{\"282\":1},\"1\":{\"279\":1,\"280\":1}}],[\"泛型的擦除机制\",{\"1\":{\"294\":1}}],[\"泛型的桥接方法\",{\"0\":{\"291\":1}}],[\"泛型的类型擦除原则是\",{\"1\":{\"287\":1}}],[\"泛型的上下限\",{\"0\":{\"284\":1}}],[\"泛型的基本使用\",{\"0\":{\"280\":1}}],[\"泛型的本质是为了参数化类型\",{\"1\":{\"279\":1}}],[\"泛型的相关知识\",{\"1\":{\"278\":1}}],[\"泛型机制详解\",{\"0\":{\"278\":1},\"1\":{\"147\":1}}],[\"泛型\",{\"0\":{\"147\":1}}],[\"绘制其它图形\",{\"1\":{\"739\":1}}],[\"绘制三角形\",{\"1\":{\"738\":2,\"739\":1}}],[\"绘制圆形\",{\"1\":{\"738\":4,\"739\":1}}],[\"绘制矩形\",{\"1\":{\"738\":4,\"739\":1}}],[\"绘制\",{\"1\":{\"212\":1}}],[\"覆盖更广泛的潜在客户\",{\"1\":{\"819\":1}}],[\"覆盖解决\",{\"1\":{\"788\":1}}],[\"覆盖\",{\"1\":{\"211\":1}}],[\"向上抛出允许本系统转义\",{\"1\":{\"857\":1}}],[\"向上转型\",{\"1\":{\"210\":1,\"211\":1}}],[\"向外暴露一个静态的公共方法\",{\"1\":{\"752\":1}}],[\"向多个处理者中的一个提交请求\",{\"1\":{\"712\":1}}],[\"向下转型\",{\"1\":{\"162\":1}}],[\"减法解释器\",{\"1\":{\"644\":1}}],[\"减少交互的平均延迟\",{\"1\":{\"854\":1}}],[\"减少前端很多琐碎的null判断\",{\"1\":{\"854\":1}}],[\"减少乐观锁的重试次数\",{\"1\":{\"851\":1}}],[\"减少开发成本\",{\"1\":{\"823\":1}}],[\"减少对象间的相互依赖\",{\"1\":{\"775\":1}}],[\"减少\",{\"1\":{\"762\":1}}],[\"减少代码臃肿\",{\"1\":{\"748\":1}}],[\"减少了内存的开销\",{\"1\":{\"750\":1}}],[\"减少了对外交互\",{\"1\":{\"722\":1}}],[\"减少了客户处理的对象数目\",{\"1\":{\"593\":1}}],[\"减少服务器资源\",{\"1\":{\"635\":1}}],[\"减少重复浪费\",{\"1\":{\"590\":1}}],[\"减少产生\",{\"1\":{\"447\":1}}],[\"减少冗余的代码生成器\",{\"1\":{\"398\":1}}],[\"减少冗余配置属性\",{\"1\":{\"390\":1}}],[\"减少耦合\",{\"1\":{\"209\":1}}],[\"减轻维护的负担\",{\"1\":{\"209\":1}}],[\"理\",{\"1\":{\"872\":1}}],[\"理顺逻辑\",{\"1\":{\"871\":1}}],[\"理论基础\",{\"0\":{\"514\":1}}],[\"理解反而费脑筋\",{\"1\":{\"853\":1}}],[\"理解成本非常高\",{\"1\":{\"852\":1}}],[\"理解不了\",{\"1\":{\"814\":1}}],[\"理解这条原则的关键\",{\"1\":{\"808\":1}}],[\"理解责任链模式应当理解其模式\",{\"1\":{\"708\":1}}],[\"理解类型擦除对于用好泛型是很有帮助的\",{\"1\":{\"287\":1}}],[\"理解和修改\",{\"1\":{\"209\":1}}],[\"理想的散列函数应当具有均匀性\",{\"1\":{\"139\":1}}],[\"优雅简洁\",{\"1\":{\"970\":1}}],[\"优雅性\",{\"1\":{\"843\":1}}],[\"优雅的设计\",{\"1\":{\"424\":1,\"434\":1}}],[\"优缺点和上面\",{\"1\":{\"753\":1}}],[\"优缺点说明\",{\"1\":{\"752\":1,\"753\":1,\"754\":1,\"755\":1,\"757\":1,\"758\":1,\"759\":1}}],[\"优先使用聚合\",{\"1\":{\"871\":1}}],[\"优先调用getxxx\",{\"1\":{\"855\":1}}],[\"优先推荐入参为string的构造方法\",{\"1\":{\"848\":1}}],[\"优先考虑将一个类设置成不变类\",{\"1\":{\"741\":1}}],[\"优先捕获最具体的异常\",{\"0\":{\"267\":1}}],[\"优势模式\",{\"1\":{\"614\":1}}],[\"优质代码\",{\"1\":{\"442\":1}}],[\"优化资源配置\",{\"1\":{\"590\":1}}],[\"优化\",{\"1\":{\"209\":1}}],[\"优点是比较好理解\",{\"1\":{\"554\":1,\"609\":1,\"686\":1,\"738\":1}}],[\"优点\",{\"1\":{\"209\":1,\"616\":1,\"696\":1,\"752\":1,\"758\":1}}],[\"尽可能带上参数和上下文信息\",{\"1\":{\"868\":1}}],[\"尽可能在原有错误码附表中找到语义相同或者相近的错误码在代码中使用即可\",{\"1\":{\"857\":1}}],[\"尽可能使加锁的代码块工作量尽可能的小\",{\"1\":{\"851\":1}}],[\"尽可能地隐藏内部的细节\",{\"1\":{\"209\":1}}],[\"尽量依赖抽象类与接口\",{\"1\":{\"871\":1}}],[\"尽量是provided引入\",{\"1\":{\"869\":1}}],[\"尽量加上友好的错误提示信息\",{\"1\":{\"868\":1}}],[\"尽量用英文来描述日志错误信息\",{\"1\":{\"859\":1}}],[\"尽量在代理中使用try\",{\"1\":{\"851\":1}}],[\"尽量在自己的视线内\",{\"1\":{\"848\":1}}],[\"尽量不要在接口里定义常量\",{\"1\":{\"845\":1}}],[\"尽量不修改代码\",{\"1\":{\"738\":1}}],[\"尽量只依赖必要的接口\",{\"1\":{\"818\":1}}],[\"尽量使用业界稳定的二方工具包\",{\"1\":{\"869\":1}}],[\"尽量使用组合或者聚合关系实现代码复用\",{\"1\":{\"748\":1}}],[\"尽量使用合成\",{\"1\":{\"748\":1}}],[\"尽量使用标准的异常\",{\"0\":{\"265\":1}}],[\"尽量降低类成员的访问权限\",{\"1\":{\"741\":1}}],[\"尽量\",{\"1\":{\"736\":1}}],[\"尽量保证一个接口只能由一个或多个类共同使用的方法\",{\"1\":{\"721\":1}}],[\"尽量避免使用空值\",{\"1\":{\"450\":1}}],[\"尽管这当然是推荐的\",{\"1\":{\"962\":1}}],[\"尽管http支持使用不同的输出格式\",{\"1\":{\"854\":1}}],[\"尽管依赖注入无法将本应该有依赖关系的两个类\",{\"1\":{\"818\":1}}],[\"尽管有些人说\",{\"1\":{\"814\":1}}],[\"尽管我们鼓励多用组合少用继承\",{\"1\":{\"814\":1}}],[\"尽管大部分鸟都会飞\",{\"1\":{\"812\":1}}],[\"尽管概念理解起来比较复杂\",{\"1\":{\"771\":1}}],[\"尽管单例是一个很常用的设计模式\",{\"1\":{\"763\":1}}],[\"尽管你在需要更新其他依赖的时候也需要更新它\",{\"1\":{\"459\":1}}],[\"尽管目前tuple的概念还有留有争议\",{\"1\":{\"432\":1}}],[\"尽管可以用this调用一个构造器\",{\"1\":{\"200\":1}}],[\"面向接口编程\",{\"1\":{\"725\":1}}],[\"面向开源社区提供免费服务\",{\"1\":{\"401\":1}}],[\"面向切面编程\",{\"1\":{\"398\":1}}],[\"面向对象思想\",{\"1\":{\"843\":1}}],[\"面向对象软件构造\",{\"1\":{\"736\":1}}],[\"面向对象技术的高峰会议\",{\"1\":{\"732\":1}}],[\"面向对象编程\",{\"1\":{\"219\":1}}],[\"面向对象编程三大特性\",{\"1\":{\"219\":1}}],[\"面向对象设计的最后一步是\",{\"1\":{\"625\":1}}],[\"面向对象设计的\",{\"1\":{\"219\":1}}],[\"面向对象基础和相关类图\",{\"1\":{\"207\":1}}],[\"面向对象\",{\"0\":{\"207\":1},\"1\":{\"796\":1}}],[\"面试过程中关于\",{\"1\":{\"187\":1}}],[\"另一次是从hashmap中取出key所对应的value\",{\"1\":{\"850\":1}}],[\"另一方面\",{\"1\":{\"459\":1,\"809\":1,\"812\":2}}],[\"另一个线程也通过了这个判断语句\",{\"1\":{\"754\":1}}],[\"另一个ssh\",{\"1\":{\"420\":1}}],[\"另一个值得一提的特性是改善异常处理\",{\"1\":{\"186\":1}}],[\"另一种是每次都返回同一个事先创建好的对象\",{\"1\":{\"622\":1}}],[\"另一种是对象创建需要组装多个其他类对象或者需要复杂的初始化过程\",{\"1\":{\"620\":1}}],[\"另一种是\",{\"1\":{\"301\":1}}],[\"另外使用事务的地方需要考虑各\",{\"1\":{\"866\":1}}],[\"另外具体元素中可能还包含本身业务逻辑的相关操作\",{\"1\":{\"838\":1}}],[\"另外实现\",{\"1\":{\"563\":1}}],[\"另外需要注意\",{\"1\":{\"292\":1}}],[\"另外\",{\"1\":{\"206\":1,\"310\":1,\"848\":1,\"851\":1,\"864\":1,\"869\":1}}],[\"形状\",{\"1\":{\"702\":2}}],[\"形成一种链式触发机制\",{\"1\":{\"680\":1}}],[\"形式的变量声明是不允许的\",{\"1\":{\"917\":1}}],[\"形式返回此\",{\"1\":{\"308\":1}}],[\"形式参数只能用final修饰符\",{\"1\":{\"204\":1}}],[\"形式参数可被视为local\",{\"1\":{\"204\":1}}],[\"形式获取\",{\"1\":{\"115\":1}}],[\"形参的值在调用时根据调用者更改\",{\"1\":{\"204\":1}}],[\"形参和局部变量一样都不能离开方法\",{\"1\":{\"204\":1}}],[\"形参\",{\"0\":{\"204\":1}}],[\"病毒\",{\"1\":{\"197\":1}}],[\"程序\",{\"1\":{\"732\":1,\"924\":1}}],[\"程序的可移植性降低\",{\"1\":{\"731\":1}}],[\"程序的扩展和维护不好\",{\"1\":{\"554\":1}}],[\"程序稳定性更好\",{\"1\":{\"729\":1}}],[\"程序员常常会遇到这种情况\",{\"1\":{\"800\":1}}],[\"程序员面临着来自\",{\"1\":{\"797\":1}}],[\"程序员可以根据创建对象类型使用对应的工厂子类\",{\"1\":{\"616\":1}}],[\"程序员不需要修改原有代码而重用现有的适配者类\",{\"1\":{\"518\":1}}],[\"程序里的匿名内部类就是\",{\"1\":{\"532\":1}}],[\"程序所在的线程死亡\",{\"1\":{\"258\":1}}],[\"程序将跳到catch语句块\",{\"1\":{\"257\":1}}],[\"程序将跳过catch语句块\",{\"1\":{\"257\":1}}],[\"程序就不能编译通过\",{\"1\":{\"248\":1}}],[\"程序就可以调用该对象的方法来访问annotation信息\",{\"1\":{\"233\":1}}],[\"程序应该从逻辑角度尽可能避免这类异常的发生\",{\"1\":{\"248\":1}}],[\"程序中可以选择捕获处理\",{\"1\":{\"248\":1}}],[\"程序中无法处理的错误\",{\"1\":{\"247\":1}}],[\"程序本身可以捕获并且可以处理的异常\",{\"1\":{\"248\":1}}],[\"程序提前终止如调用了system\",{\"1\":{\"197\":1}}],[\"程序猿使用\",{\"0\":{\"111\":1},\"1\":{\"108\":1}}],[\"若没有特别配置的话\",{\"1\":{\"996\":1}}],[\"若没有注解\",{\"1\":{\"233\":1}}],[\"若实在避免不了\",{\"1\":{\"865\":1}}],[\"若count为\",{\"1\":{\"865\":1}}],[\"若浮点数尾数位与指数位空间不限\",{\"1\":{\"854\":1}}],[\"若强转其它类型数组将出现classcastexception错误\",{\"1\":{\"850\":1}}],[\"若是static成员变量\",{\"1\":{\"848\":1}}],[\"若是父类的方法没有声明异常\",{\"1\":{\"252\":1}}],[\"若想实现深拷贝需覆写clone方法实现域对象的深度遍历式拷贝\",{\"1\":{\"848\":1}}],[\"若有若无表示一种使用关系\",{\"1\":{\"835\":1}}],[\"若有异常\",{\"1\":{\"196\":1}}],[\"若即若离\",{\"1\":{\"835\":1}}],[\"若\",{\"1\":{\"259\":1}}],[\"若覆盖一个方法\",{\"1\":{\"252\":1}}],[\"若声明多个异常\",{\"1\":{\"252\":1}}],[\"若方法中存在检查异常\",{\"1\":{\"252\":1}}],[\"若程序元素为类\",{\"1\":{\"233\":1}}],[\"若发现父类中不存在这个方法或是存在的方法签名不同\",{\"1\":{\"223\":1}}],[\"若x\",{\"1\":{\"181\":2}}],[\"枚举的属性字段必须是私\",{\"1\":{\"872\":1}}],[\"枚举等\",{\"1\":{\"869\":1}}],[\"枚举enum\",{\"1\":{\"855\":1}}],[\"枚举名字为processstatusenum的成员名称\",{\"1\":{\"845\":1}}],[\"枚举其实就是特殊的常量类\",{\"1\":{\"845\":1}}],[\"枚举成员名称需要全大写\",{\"1\":{\"845\":1}}],[\"枚举常量之间的空行在\",{\"1\":{\"910\":1}}],[\"枚举常量\",{\"1\":{\"227\":1}}],[\"枚举中\",{\"1\":{\"227\":1}}],[\"枚举值\",{\"1\":{\"227\":1}}],[\"枚举\",{\"0\":{\"759\":1},\"1\":{\"227\":1,\"751\":1}}],[\"枚举均可用于switch\",{\"1\":{\"193\":1}}],[\"枚举类名带上enum后缀\",{\"1\":{\"845\":1}}],[\"枚举类型也相当于多例模式\",{\"1\":{\"773\":1}}],[\"枚举类\",{\"0\":{\"172\":1,\"915\":1},\"1\":{\"227\":1,\"877\":1,\"901\":1,\"910\":1}}],[\"除下面详细说明的情况外\",{\"1\":{\"901\":1}}],[\"除常用方法\",{\"1\":{\"852\":1}}],[\"除注释之外的方法签名\",{\"1\":{\"847\":1}}],[\"除java外\",{\"1\":{\"411\":1}}],[\"除非\",{\"1\":{\"907\":1}}],[\"除非另有说明\",{\"1\":{\"877\":1,\"905\":1,\"950\":1}}],[\"除非用户主动升级版本\",{\"1\":{\"869\":1}}],[\"除非你有很好的理由去修改他们\",{\"1\":{\"451\":1}}],[\"除非你确定自己处于一种特殊的情况下能够处理错误\",{\"1\":{\"268\":1}}],[\"除非是采用通配符的方式且要做显式类型转换才可以\",{\"1\":{\"294\":1}}],[\"除了\",{\"1\":{\"960\":1}}],[\"除了第一个以外的每个段落\",{\"1\":{\"956\":1}}],[\"除了第一个以外的每个单词\",{\"1\":{\"947\":1}}],[\"除了以下两种特殊情况\",{\"1\":{\"911\":1}}],[\"除了在字面量\",{\"1\":{\"911\":1}}],[\"除了在开发工程中使用这些工具\",{\"1\":{\"484\":1}}],[\"除了编程语言或者编程规范的要求之外\",{\"1\":{\"911\":1}}],[\"除了换行符\",{\"1\":{\"883\":1}}],[\"除了返回值\",{\"1\":{\"853\":1}}],[\"除了上面讲到的这些设计思想和原则之外\",{\"1\":{\"818\":1}}],[\"除了模板方法模式和解释器模式是类行为型模式\",{\"1\":{\"798\":1}}],[\"除了适配器模式分为类结构型模式和对象结构型模式两种\",{\"1\":{\"798\":1}}],[\"除了工厂方法模式属于类创建型模式\",{\"1\":{\"798\":1}}],[\"除了使用单例\",{\"1\":{\"769\":1}}],[\"除了创建它的发起人之外\",{\"1\":{\"663\":1}}],[\"除了具有工厂方法模式的优点外\",{\"1\":{\"616\":1}}],[\"除了简单的try\",{\"1\":{\"275\":1}}],[\"除了runtimeexception及其子类以外\",{\"1\":{\"249\":1}}],[\"除了clone和finalize其他均为公共方法\",{\"1\":{\"190\":1}}],[\"除此之外还可以使用基于sql的语法跨集群查询\",{\"1\":{\"394\":1}}],[\"除此之外\",{\"1\":{\"193\":1,\"606\":1,\"614\":1,\"621\":1,\"622\":1,\"741\":1,\"764\":1,\"767\":1,\"773\":1,\"809\":1,\"810\":1,\"814\":1,\"816\":1,\"817\":1,\"818\":1,\"892\":1}}],[\"表不存在\",{\"1\":{\"874\":1}}],[\"表或字段之间的辩证关系\",{\"1\":{\"871\":1}}],[\"表结构设计能否满足技术方案\",{\"1\":{\"871\":1}}],[\"表的作用\",{\"1\":{\"863\":1}}],[\"表的命名最好是遵循\",{\"1\":{\"863\":1}}],[\"表必备三字段\",{\"1\":{\"863\":1}}],[\"表名应该仅仅表示表里面的实体内容\",{\"1\":{\"863\":1}}],[\"表名不使用复数名词\",{\"1\":{\"863\":1}}],[\"表名\",{\"1\":{\"863\":2}}],[\"表单\",{\"1\":{\"861\":1}}],[\"表明该请求被成功地完成\",{\"1\":{\"854\":1}}],[\"表达规则和表达工具的熟练性\",{\"1\":{\"871\":1}}],[\"表达只是自然而然的事情\",{\"1\":{\"871\":1}}],[\"表达逻辑删除的字段名is\",{\"1\":{\"863\":1}}],[\"表达是与否概念的字段\",{\"1\":{\"863\":1}}],[\"表达是与否的变量采用is\",{\"1\":{\"845\":1}}],[\"表达到位\",{\"1\":{\"853\":1}}],[\"表达异常的分支时\",{\"1\":{\"852\":1}}],[\"表达式中的箭头\",{\"1\":{\"911\":1}}],[\"表达式中的花括号\",{\"1\":{\"900\":1}}],[\"表达式实现\",{\"1\":{\"790\":1}}],[\"表达式拆分成字符数组\",{\"1\":{\"644\":1}}],[\"表达式相减后的结果\",{\"1\":{\"644\":1}}],[\"表达式的匹配器\",{\"1\":{\"431\":1}}],[\"表达式\",{\"1\":{\"187\":1,\"641\":2,\"644\":1,\"852\":6}}],[\"表胜于言\",{\"1\":{\"843\":1}}],[\"表示正在被测试的系统\",{\"1\":{\"994\":1}}],[\"表示可以接受\",{\"1\":{\"947\":1}}],[\"表示此定制包的顺序号\",{\"1\":{\"869\":1}}],[\"表示相等时带上此条\",{\"1\":{\"866\":1}}],[\"表示范围\",{\"1\":{\"863\":1}}],[\"表示未删除\",{\"1\":{\"863\":1}}],[\"表示删除\",{\"1\":{\"863\":1}}],[\"表示否\",{\"1\":{\"863\":1}}],[\"表示是\",{\"1\":{\"863\":1}}],[\"表示是否要添加相应的调料\",{\"1\":{\"583\":1}}],[\"表示原理与取值范围等同于java中的double\",{\"1\":{\"854\":1}}],[\"表示api具体的请求地址\",{\"1\":{\"854\":1}}],[\"表示需要实现\",{\"1\":{\"853\":1}}],[\"表示分钟则是小写的m\",{\"1\":{\"849\":1}}],[\"表示月份是大写的m\",{\"1\":{\"849\":1}}],[\"表示日期和时间的格式如下所示\",{\"1\":{\"849\":1}}],[\"表示终止的右大括号后必须换行\",{\"1\":{\"847\":1}}],[\"表示类型的名词放在词尾\",{\"1\":{\"845\":1}}],[\"表示一年中的第几个季节\",{\"1\":{\"846\":1}}],[\"表示一个类对象和另一个类对象有关联通常一个类中有另一个类对象作为属性\",{\"1\":{\"835\":1}}],[\"表示一般与特殊的关系\",{\"1\":{\"833\":1}}],[\"表示扩展\",{\"1\":{\"835\":1}}],[\"表示至少\",{\"1\":{\"830\":1}}],[\"表示有且仅有一个\",{\"1\":{\"830\":1}}],[\"表示\",{\"1\":{\"813\":1,\"825\":1,\"830\":3,\"877\":3}}],[\"表示豆浆\",{\"1\":{\"803\":1}}],[\"表示四种状态\",{\"1\":{\"778\":1}}],[\"表示活动当前的状态\",{\"1\":{\"778\":1}}],[\"表示接收者\",{\"1\":{\"727\":1}}],[\"表示对象\",{\"1\":{\"638\":1}}],[\"表示返回单例对象\",{\"1\":{\"622\":1}}],[\"表示返回新创建的对象\",{\"1\":{\"622\":1}}],[\"表示饮料\",{\"1\":{\"582\":1}}],[\"表示的字段的值\",{\"1\":{\"307\":1}}],[\"表示class对象所引用的类所继承的直接基类\",{\"1\":{\"305\":1}}],[\"表示class对象所引用的类所实现的所有接口\",{\"1\":{\"305\":1}}],[\"表示要操作的数据是\",{\"1\":{\"284\":1}}],[\"表示要被加载的服务的类或接口\",{\"1\":{\"114\":1}}],[\"表示参数化的类型可能是指定的类型\",{\"1\":{\"284\":1}}],[\"表示参数化的类型可能是所指定的类型\",{\"1\":{\"284\":1}}],[\"表示运行应用程序中出现了严重的错误\",{\"1\":{\"247\":1}}],[\"表示关闭编译器警告信息\",{\"1\":{\"222\":1}}],[\"表示代码被弃用\",{\"1\":{\"222\":1}}],[\"表示当前的方法定义将覆盖父类中的方法\",{\"1\":{\"222\":1}}],[\"表示不同类对象之间有关联\",{\"1\":{\"217\":1}}],[\"表示整体由部分组成\",{\"1\":{\"215\":1}}],[\"表示在继承体系中成员对于子类可见\",{\"1\":{\"132\":1}}],[\"表示包级可见\",{\"1\":{\"132\":1}}],[\"个步骤来创建参数化测试\",{\"1\":{\"981\":1}}],[\"个缩进级别\",{\"1\":{\"923\":1}}],[\"个参数的查询封装\",{\"1\":{\"868\":1,\"873\":1}}],[\"个之内\",{\"1\":{\"865\":1}}],[\"个人英语水平有限\",{\"1\":{\"875\":1}}],[\"个人敏感信息操作等相关记录\",{\"1\":{\"859\":1}}],[\"个人开发的高性能并发库官网\",{\"1\":{\"406\":1}}],[\"个元素扩容的次数\",{\"1\":{\"872\":1}}],[\"个元素\",{\"1\":{\"850\":1}}],[\"个在构造方法super\",{\"1\":{\"849\":1}}],[\"个不记录日期\",{\"1\":{\"849\":1}}],[\"个不记录时间\",{\"1\":{\"849\":1}}],[\"个字符\",{\"1\":{\"847\":1,\"905\":1}}],[\"个字符的情况下\",{\"1\":{\"847\":2}}],[\"个tab为\",{\"1\":{\"847\":1}}],[\"个空格的缩进\",{\"1\":{\"903\":1}}],[\"个空格时\",{\"1\":{\"847\":1}}],[\"个空格\",{\"0\":{\"903\":1,\"908\":1},\"1\":{\"847\":4,\"908\":2,\"923\":1}}],[\"个空格缩进\",{\"1\":{\"847\":1}}],[\"个空位可以放棋子\",{\"1\":{\"631\":1}}],[\"个都可以\",{\"1\":{\"830\":1}}],[\"个或者一个\",{\"1\":{\"830\":1}}],[\"个或者多个\",{\"1\":{\"830\":1}}],[\"个矩形拼接表示\",{\"1\":{\"826\":1}}],[\"个奖品\",{\"1\":{\"778\":1}}],[\"个对象之间存在协作关系\",{\"1\":{\"871\":1}}],[\"个对象\",{\"1\":{\"773\":1}}],[\"个员工到\",{\"1\":{\"742\":2,\"743\":2}}],[\"个优点\",{\"1\":{\"722\":1}}],[\"个接口\",{\"1\":{\"721\":1}}],[\"个性和共性\",{\"1\":{\"847\":1}}],[\"个性\",{\"1\":{\"549\":1}}],[\"个主要的特性\",{\"1\":{\"187\":1}}],[\"个\",{\"0\":{\"187\":1},\"1\":{\"820\":1,\"830\":1,\"847\":1,\"871\":4}}],[\"个数\",{\"1\":{\"135\":1}}],[\"允许在任何时候代码重构\",{\"1\":{\"990\":1}}],[\"允许你对代码做出任何改变\",{\"1\":{\"990\":1}}],[\"允许你控制整个序列化过程\",{\"1\":{\"185\":1}}],[\"允许存在多个空格\",{\"1\":{\"911\":2}}],[\"允许超过列限制\",{\"1\":{\"905\":1}}],[\"允许的创建线程数量为integer\",{\"1\":{\"851\":1}}],[\"允许的请求队列长度为integer\",{\"1\":{\"851\":2}}],[\"允许为null\",{\"1\":{\"850\":3}}],[\"允许使用者根据自己的需求去更新它\",{\"1\":{\"800\":1}}],[\"允许一个对象在其内部状态发生改变时改变其行为能力\",{\"1\":{\"798\":1}}],[\"允许一个对象再创建另外一个可定制的对象\",{\"1\":{\"682\":1}}],[\"允许改变其行为\",{\"1\":{\"775\":1}}],[\"允许状态对象在其内部状态发生改变时改变其行为\",{\"1\":{\"775\":1}}],[\"允许对象组合实现与继承相同的代码重用\",{\"1\":{\"591\":2}}],[\"允许像对象一样传递匿名函数\",{\"1\":{\"187\":1}}],[\"允许\",{\"1\":{\"186\":1,\"885\":2,\"912\":1}}],[\"版\",{\"1\":{\"843\":1}}],[\"版的\",{\"1\":{\"186\":1}}],[\"版本名\",{\"1\":{\"872\":1}}],[\"版本号\",{\"1\":{\"872\":1}}],[\"版本历史\",{\"0\":{\"872\":1}}],[\"版本控制在http头信息中体现\",{\"1\":{\"854\":1}}],[\"版本\",{\"1\":{\"105\":1}}],[\"脆弱而且不安全\",{\"1\":{\"185\":1}}],[\"成1\",{\"1\":{\"869\":1}}],[\"成为共性方法\",{\"1\":{\"847\":1}}],[\"成fu\",{\"1\":{\"845\":1}}],[\"成condi\",{\"1\":{\"845\":1}}],[\"成absclass\",{\"1\":{\"845\":1}}],[\"成功\",{\"1\":{\"839\":1}}],[\"成本和时间都是最重要的\",{\"1\":{\"819\":1}}],[\"成本高\",{\"1\":{\"185\":1}}],[\"成三个\",{\"1\":{\"718\":1}}],[\"成员名=参数名\",{\"1\":{\"848\":1}}],[\"成员\",{\"1\":{\"728\":1,\"877\":1,\"959\":1}}],[\"成员方法\",{\"1\":{\"227\":1}}],[\"成员变量有引用类型\",{\"1\":{\"689\":1}}],[\"成员变量\",{\"1\":{\"227\":2,\"301\":1,\"741\":1,\"767\":1,\"845\":1,\"848\":1}}],[\"成员可见表示其它类可以用这个类的实例对象访问到该成员\",{\"1\":{\"132\":1}}],[\"甚至其他的测试套件\",{\"1\":{\"970\":1}}],[\"甚至不要求在已经水平对齐的地方继续保持水平对齐\",{\"1\":{\"912\":1}}],[\"甚至不用\",{\"1\":{\"812\":1}}],[\"甚至是词不达意的情况\",{\"1\":{\"871\":1}}],[\"甚至是组件化\",{\"1\":{\"871\":1}}],[\"甚至是一组通信的协议都可以叫作\",{\"1\":{\"808\":1}}],[\"甚至相隔数月才出现一例\",{\"1\":{\"870\":1}}],[\"甚至各种方法纵深调用\",{\"1\":{\"852\":1}}],[\"甚至可以自定义迭代器的子类以支持新的遍历\",{\"1\":{\"648\":1}}],[\"甚至更强大的功能\",{\"1\":{\"483\":1}}],[\"甚至你已经部署了一个新的jar\",{\"1\":{\"183\":1}}],[\"甚至在编译时期该类的\",{\"1\":{\"145\":1}}],[\"块标签\",{\"0\":{\"957\":1},\"1\":{\"957\":1,\"962\":1}}],[\"块缩进\",{\"0\":{\"903\":1}}],[\"块状结构\",{\"1\":{\"898\":1}}],[\"块处理所有\",{\"1\":{\"267\":1}}],[\"块添加到列表的末尾\",{\"1\":{\"267\":1}}],[\"块\",{\"1\":{\"267\":1}}],[\"块会被执行\",{\"1\":{\"267\":1}}],[\"块中清理资源或者使用\",{\"0\":{\"264\":1}}],[\"块中捕获多个异常\",{\"1\":{\"186\":1}}],[\"块中是否有发生异常\",{\"1\":{\"182\":1}}],[\"块一定会被执行\",{\"1\":{\"182\":1}}],[\"技术允许使用\",{\"1\":{\"182\":1}}],[\"意思的注释都是可行的\",{\"1\":{\"924\":1}}],[\"意思是在测试类里所有用例运行之前\",{\"1\":{\"972\":1}}],[\"意思是当天所在的周属于的年份\",{\"1\":{\"849\":1}}],[\"意思是直接访问并调用父类中的方法\",{\"1\":{\"199\":1}}],[\"意思是获取父类中xxx的变量或引用\",{\"1\":{\"199\":1}}],[\"意大利咖啡\",{\"1\":{\"584\":1}}],[\"意大利浓咖啡\",{\"1\":{\"581\":1}}],[\"意味着任意的\",{\"1\":{\"905\":1}}],[\"意味着内存占用越小\",{\"1\":{\"265\":1}}],[\"意味着该变量的值在初始化后不能被改变\",{\"1\":{\"182\":1}}],[\"意不意外\",{\"1\":{\"92\":1}}],[\"修复\",{\"1\":{\"885\":1}}],[\"修复bug\",{\"1\":{\"869\":1}}],[\"修正嵩山版中部分代码格式错误和描述错误\",{\"1\":{\"872\":1}}],[\"修正泰山版中部分格式错误和描述错误\",{\"1\":{\"872\":1}}],[\"修正架构分层规范与相关说明\",{\"1\":{\"872\":1}}],[\"修正部分描述\",{\"1\":{\"872\":1}}],[\"修正页码总数和部分示例\",{\"1\":{\"872\":1}}],[\"修正关于异常和方法签名的部分描述\",{\"1\":{\"872\":1}}],[\"修正成\",{\"1\":{\"872\":1}}],[\"修正\",{\"1\":{\"872\":5}}],[\"修订号\",{\"1\":{\"869\":2}}],[\"修饰的\",{\"1\":{\"981\":2}}],[\"修饰的字段\",{\"1\":{\"942\":1}}],[\"修饰符\",{\"0\":{\"934\":1}}],[\"修饰者\",{\"1\":{\"585\":1}}],[\"修饰变量\",{\"1\":{\"182\":1}}],[\"修改描述\",{\"1\":{\"872\":3}}],[\"修改了相应的方法签名\",{\"1\":{\"858\":1}}],[\"修改了单例类中的同一个成员变量的值\",{\"1\":{\"767\":1}}],[\"修改注释又是相当大的负担\",{\"1\":{\"853\":1}}],[\"修改的方法用update做前缀\",{\"1\":{\"845\":1}}],[\"修改的地方较多\",{\"1\":{\"738\":1}}],[\"修改代码不至于牵一发而动全身\",{\"1\":{\"816\":1}}],[\"修改代码可以接受\",{\"1\":{\"609\":1}}],[\"修改会比较集中\",{\"1\":{\"741\":1}}],[\"修改关闭\",{\"1\":{\"736\":1}}],[\"修改私有方法的访问标识\",{\"1\":{\"308\":1}}],[\"修改部门\",{\"1\":{\"242\":2}}],[\"修改\",{\"1\":{\"164\":1,\"861\":1}}],[\"始终false\",{\"1\":{\"181\":1}}],[\"永远与代码同步\",{\"1\":{\"990\":1}}],[\"永远不要使用小写\",{\"1\":{\"935\":1}}],[\"永远false\",{\"1\":{\"181\":1}}],[\"永久不用\",{\"1\":{\"853\":1}}],[\"永久代以及元空间是实际的存放位置\",{\"1\":{\"125\":1}}],[\"永久代\",{\"1\":{\"125\":1}}],[\"大\",{\"1\":{\"991\":1}}],[\"大骆峰\",{\"1\":{\"940\":1}}],[\"大陆身份证编号校验\",{\"1\":{\"874\":1}}],[\"大量地输出无效日志\",{\"1\":{\"859\":1}}],[\"大类之间的步长间距预留\",{\"1\":{\"857\":1}}],[\"大概率会出现前后端订单数据不一致的情况\",{\"1\":{\"854\":1}}],[\"大概意思看得明白\",{\"1\":{\"311\":1}}],[\"大于size\",{\"1\":{\"850\":1}}],[\"大于\",{\"1\":{\"850\":1}}],[\"大写的h和小写的h分别指代的意义\",{\"1\":{\"849\":1}}],[\"大括号中间无需换行和空格\",{\"1\":{\"847\":1}}],[\"大而全的常量类\",{\"1\":{\"846\":1}}],[\"大厂\",{\"1\":{\"796\":1}}],[\"大战后\",{\"1\":{\"667\":1}}],[\"大数据专业\",{\"1\":{\"650\":2}}],[\"大小写有区别\",{\"1\":{\"853\":1}}],[\"大小\",{\"1\":{\"637\":1}}],[\"大工程\",{\"1\":{\"620\":3}}],[\"大学接口及其实现类\",{\"1\":{\"650\":1}}],[\"大学类\",{\"1\":{\"574\":1}}],[\"大学中的部门与学院\",{\"1\":{\"567\":1}}],[\"大牛\",{\"1\":{\"486\":1,\"689\":1}}],[\"大头\",{\"1\":{\"276\":1}}],[\"大多数格式化程序不会重新包装\",{\"1\":{\"933\":1}}],[\"大多数情况下和getname一样\",{\"1\":{\"305\":1}}],[\"大多数\",{\"1\":{\"267\":1}}],[\"大多数的\",{\"1\":{\"264\":1}}],[\"大部分鸟都会飞\",{\"1\":{\"812\":1}}],[\"大部分情况下\",{\"1\":{\"763\":1}}],[\"大部分情况下都不需要手动抛出异常\",{\"1\":{\"253\":1}}],[\"大部分的对象可以按照内部状态进行分组\",{\"1\":{\"639\":1}}],[\"大部分估计都以为这是一段乱码\",{\"1\":{\"89\":1}}],[\"大大减少查询匹配次数\",{\"1\":{\"181\":1}}],[\"引起社会高度关注\",{\"1\":{\"871\":1}}],[\"引导用户进行下一步操作或解释错误原因\",{\"1\":{\"854\":1}}],[\"引用这个特殊情况来证明省略典型的阅读者可能需要知道的相关信息是不合适的\",{\"1\":{\"960\":1}}],[\"引用该版本\",{\"1\":{\"869\":1}}],[\"引用类型\",{\"1\":{\"689\":2}}],[\"引用调用\",{\"1\":{\"211\":1}}],[\"引用\",{\"1\":{\"210\":1}}],[\"引用皆在此列\",{\"1\":{\"204\":1}}],[\"引用的其他类\",{\"1\":{\"741\":1}}],[\"引用的是同一个字符串常量池的对象\",{\"1\":{\"125\":1}}],[\"引用的对象放到\",{\"1\":{\"125\":1}}],[\"引入一个中间层\",{\"1\":{\"818\":1}}],[\"引入一个抽象的接口\",{\"1\":{\"727\":1}}],[\"引入中间层可以起到过渡的作用\",{\"1\":{\"818\":1}}],[\"引入中间层能简化模块或类之间的依赖关系\",{\"1\":{\"818\":1}}],[\"引入新的工厂类\",{\"1\":{\"608\":1}}],[\"引入外观模式可将它们分离\",{\"1\":{\"604\":1}}],[\"引入了一个新的功能参数化测试\",{\"1\":{\"981\":1}}],[\"引入了请求方与抽象命令接口\",{\"1\":{\"560\":1}}],[\"引入了额外类型结构\",{\"1\":{\"560\":1}}],[\"引入\",{\"1\":{\"459\":1,\"816\":1}}],[\"引入泛型\",{\"1\":{\"279\":1}}],[\"引入泛型的意义在于\",{\"1\":{\"279\":1}}],[\"引入的新特性\",{\"0\":{\"187\":1}}],[\"引入hashcode\",{\"1\":{\"181\":1}}],[\"规避资源耗尽的风险\",{\"1\":{\"851\":1}}],[\"规避被辞退的风险\",{\"1\":{\"88\":1}}],[\"规约依次分为\",{\"1\":{\"843\":1}}],[\"规定了具体原型对象必须实现的接口\",{\"1\":{\"683\":1}}],[\"规则中相互联系和扩展\",{\"1\":{\"823\":1}}],[\"规则化测试\",{\"1\":{\"476\":1}}],[\"规则\",{\"1\":{\"386\":1,\"855\":1}}],[\"规范性\",{\"1\":{\"796\":1}}],[\"规范\",{\"1\":{\"181\":1,\"725\":1}}],[\"则该方法将继续进行不会发出错误\",{\"1\":{\"978\":1}}],[\"则变成红色\",{\"1\":{\"970\":1}}],[\"则它的名称是该类的名称加上\",{\"1\":{\"940\":1}}],[\"则除外\",{\"1\":{\"931\":1}}],[\"则除了修改原来的代码\",{\"1\":{\"750\":1}}],[\"则应使用空行分隔它们\",{\"1\":{\"892\":1}}],[\"则采用与service一致的处理方式\",{\"1\":{\"868\":1}}],[\"则可能会因为打印日志而影响正常业务流程的执行\",{\"1\":{\"859\":1}}],[\"则可以精确表示任何整数\",{\"1\":{\"854\":1}}],[\"则可以省略文本定义\",{\"1\":{\"42\":1}}],[\"则前端返回第一页参数给后端\",{\"1\":{\"854\":1}}],[\"则删除\",{\"1\":{\"853\":1}}],[\"则抛出illegalmonitorstateexception异常\",{\"1\":{\"851\":1}}],[\"则抛给当前的thread\",{\"1\":{\"275\":1}}],[\"则直接执行finally代码块\",{\"1\":{\"851\":1}}],[\"则直接抛出异常\",{\"1\":{\"850\":1}}],[\"则直接返回\",{\"1\":{\"310\":1}}],[\"则认为是相等的\",{\"1\":{\"848\":1}}],[\"则给one\",{\"1\":{\"847\":1}}],[\"则必须换行\",{\"1\":{\"847\":1}}],[\"则必须严格遵循里氏替换原则\",{\"1\":{\"745\":1}}],[\"则在类名上方加\",{\"1\":{\"826\":1}}],[\"则在此直接返回\",{\"1\":{\"273\":1}}],[\"则使用system\",{\"1\":{\"849\":1}}],[\"则使用钩子方法\",{\"1\":{\"803\":1}}],[\"则使用逗号分割\",{\"1\":{\"252\":1}}],[\"则所有子类都要改一遍\",{\"1\":{\"800\":1}}],[\"则系统会完全乱套\",{\"1\":{\"762\":1}}],[\"则很容易违背单一职责原则\",{\"1\":{\"750\":1}}],[\"则把这些方法放到一个抽象类\",{\"1\":{\"732\":1}}],[\"则当这个类需要修改时\",{\"1\":{\"731\":1}}],[\"则新增类\",{\"1\":{\"727\":1}}],[\"则是件令人爽心悦目的事情\",{\"1\":{\"852\":1}}],[\"则是浅拷贝\",{\"1\":{\"689\":1}}],[\"则是获取字段的值\",{\"1\":{\"307\":1}}],[\"则仍然\",{\"1\":{\"637\":1}}],[\"则创建\",{\"1\":{\"632\":2}}],[\"则创建一个新的享元对象\",{\"1\":{\"632\":1}}],[\"则创建一个\",{\"1\":{\"629\":1}}],[\"则能节省大量的系统资源\",{\"1\":{\"629\":1}}],[\"则只需要新增两个类\",{\"1\":{\"613\":1}}],[\"则每个智能家电厂家都要提供一个统一的接口给\",{\"1\":{\"562\":1}}],[\"则建造者也要同步修改\",{\"1\":{\"549\":1}}],[\"则从jvm中获取\",{\"1\":{\"311\":1}}],[\"则从jvm中重新获取\",{\"1\":{\"310\":1}}],[\"则也算是成功了\",{\"1\":{\"310\":1}}],[\"则立即返回\",{\"1\":{\"310\":1}}],[\"则需使用class类的getdeclaredfield\",{\"1\":{\"307\":1}}],[\"则就变成了\",{\"1\":{\"293\":1}}],[\"则就不会跳回执行\",{\"1\":{\"251\":1}}],[\"则执行输出finally操作\",{\"1\":{\"275\":2}}],[\"则执行完try块就执行finally语句\",{\"1\":{\"258\":1}}],[\"则向上查找\",{\"1\":{\"275\":1}}],[\"则继续查找异常表中的剩余条目\",{\"1\":{\"275\":1}}],[\"则jvm调用位于target的调用者来处理\",{\"1\":{\"275\":1}}],[\"则永远不会到达应该处理更具体的\",{\"1\":{\"267\":1}}],[\"则不适合使用建造者模式\",{\"1\":{\"557\":1}}],[\"则不要犹豫\",{\"1\":{\"265\":1}}],[\"则不能声明与覆盖方法不同的异常\",{\"1\":{\"252\":1}}],[\"则子类继承方法后\",{\"1\":{\"252\":1}}],[\"则返回空数组\",{\"1\":{\"854\":1}}],[\"则返回这个唯一标识码所标识的对象\",{\"1\":{\"638\":1}}],[\"则返回\",{\"1\":{\"308\":1}}],[\"则返回o<t>\",{\"1\":{\"298\":1}}],[\"则返回长度为零的一个数组\",{\"1\":{\"233\":1}}],[\"则返回null\",{\"1\":{\"233\":2}}],[\"则会严重影响当前调用者\",{\"1\":{\"871\":1}}],[\"则会在此直接返回\",{\"1\":{\"858\":1}}],[\"则会忽略精度\",{\"1\":{\"848\":1}}],[\"则会造成接口数量过多\",{\"1\":{\"722\":1}}],[\"则会导致jvm终止运行\",{\"1\":{\"275\":1}}],[\"则会被抑制\",{\"1\":{\"259\":1}}],[\"则会去父类上检测对应的注解\",{\"1\":{\"233\":1}}],[\"则会报错\",{\"1\":{\"223\":1}}],[\"则表示这个变量可以被本地代码引用\",{\"1\":{\"232\":1}}],[\"则其子类将自动具有该注解\",{\"1\":{\"230\":1,\"237\":1}}],[\"则属于严重错误\",{\"1\":{\"198\":1}}],[\"则x\",{\"1\":{\"181\":1,\"850\":2}}],[\"则y\",{\"1\":{\"181\":1}}],[\"则\",{\"1\":{\"180\":1,\"752\":1,\"847\":1}}],[\"许多对象并不是独立存在的\",{\"1\":{\"671\":1}}],[\"许多容器类\",{\"1\":{\"179\":1}}],[\"许多人晚睡的原因\",{\"1\":{\"36\":1}}],[\"两者在接口调用赋值的场景中容易出错\",{\"1\":{\"850\":1}}],[\"两者具有相同的生命周期\",{\"1\":{\"835\":1}}],[\"两者有独立的生命周期\",{\"1\":{\"835\":1}}],[\"两者高度耦合\",{\"1\":{\"812\":1}}],[\"两者的区别等到我们讲到享元模式的时候再来分析\",{\"1\":{\"773\":1}}],[\"两者之间是抽象耦合关系\",{\"1\":{\"671\":1}}],[\"两者都是由应用程序控制之外的情况引起的\",{\"1\":{\"268\":1}}],[\"两次提到了原始类型\",{\"1\":{\"289\":1}}],[\"两次失败就郁郁寡欢\",{\"1\":{\"36\":1}}],[\"两个注解\",{\"1\":{\"999\":1}}],[\"两个连续字段\",{\"1\":{\"910\":1}}],[\"两个浮点数的差值在此范围之内\",{\"1\":{\"848\":1}}],[\"两个程序员在两个类中分别定义了表示\",{\"1\":{\"846\":1}}],[\"两个行为搭配起来会产生四种情况\",{\"1\":{\"812\":1}}],[\"两个字\",{\"1\":{\"808\":1}}],[\"两个院系的迭代器类\",{\"1\":{\"650\":1}}],[\"两个类\",{\"1\":{\"625\":1}}],[\"两个类具体实现如下所示\",{\"1\":{\"625\":1}}],[\"两个accessor详情\",{\"1\":{\"312\":1}}],[\"两个使用\",{\"1\":{\"181\":1}}],[\"两个相同的对象会有不同的\",{\"0\":{\"176\":1}}],[\"两个不相等的对象可能会有相同的\",{\"1\":{\"175\":1}}],[\"任意重定向\",{\"1\":{\"861\":1}}],[\"任何换行符之前都可以有任意数量的跟随着实现注释的空格\",{\"1\":{\"932\":1}}],[\"任何可以表达\",{\"1\":{\"924\":1}}],[\"任何可能的情况下尽量使用\",{\"1\":{\"451\":1}}],[\"任何的二元或三元操作符的两侧\",{\"1\":{\"911\":1}}],[\"任何的左花括号\",{\"1\":{\"911\":1}}],[\"任何超过此限制的代码行都必须被换行\",{\"1\":{\"905\":1}}],[\"任何数组的初始化可以选择写成\",{\"1\":{\"920\":1}}],[\"任何数组的初始化可以选择被认为是一个块状结构\",{\"1\":{\"898\":1}}],[\"任何数据结构的构造或初始化\",{\"1\":{\"855\":1}}],[\"任何字段如果为非负数\",{\"1\":{\"863\":1}}],[\"任何\",{\"1\":{\"854\":1}}],[\"任何类\",{\"1\":{\"848\":1}}],[\"任何npe问题\",{\"1\":{\"848\":1}}],[\"任何货币金额\",{\"1\":{\"848\":1}}],[\"任何情形\",{\"1\":{\"847\":1}}],[\"任何二目\",{\"1\":{\"847\":1}}],[\"任何自定义编程元素在命名时\",{\"1\":{\"845\":1}}],[\"任何对它的改变都应该产生一个新的对象\",{\"1\":{\"173\":1}}],[\"任何修改都会创建一个新的对象\",{\"1\":{\"173\":1}}],[\"任务列表\",{\"0\":{\"20\":1}}],[\"什么目的\",{\"1\":{\"859\":1}}],[\"什么类型\",{\"1\":{\"859\":1}}],[\"什么情况会抛出nosuchmethoderror呢\",{\"1\":{\"858\":1}}],[\"什么时候写单元测试\",{\"0\":{\"991\":1}}],[\"什么时候显示依赖关系\",{\"1\":{\"829\":1}}],[\"什么时候不需要定义接口\",{\"1\":{\"810\":1}}],[\"什么时候不应该使用继承\",{\"1\":{\"732\":1}}],[\"什么时候该用工厂方法模式\",{\"0\":{\"614\":1}}],[\"什么时候该用工厂模式\",{\"1\":{\"606\":1}}],[\"什么时候用spi\",{\"1\":{\"113\":1}}],[\"什么是单元测试\",{\"0\":{\"989\":1}}],[\"什么是junit\",{\"0\":{\"969\":1}}],[\"什么是线程唯一的单例\",{\"1\":{\"771\":1}}],[\"什么是\",{\"1\":{\"741\":1,\"772\":1,\"816\":1,\"981\":1}}],[\"什么是原始类型\",{\"1\":{\"289\":1}}],[\"什么是不可变对象\",{\"0\":{\"173\":1}}],[\"吗\",{\"0\":{\"170\":1,\"176\":1}}],[\"更多测试\",{\"1\":{\"978\":1}}],[\"更多语法及使用请参考\",{\"1\":{\"212\":1}}],[\"更少冗余\",{\"1\":{\"972\":1}}],[\"更容易阅读和理解\",{\"1\":{\"885\":1}}],[\"更容易在组合体内加入新的对象\",{\"1\":{\"567\":1}}],[\"更通用的术语\",{\"1\":{\"877\":1}}],[\"更没有移植性\",{\"1\":{\"865\":1}}],[\"更没有了今天文章要谈论的内容\",{\"1\":{\"275\":1}}],[\"更重要的是提升检索速度\",{\"1\":{\"863\":1}}],[\"更不能是text字段\",{\"1\":{\"863\":1}}],[\"更不允许抛出exception或者throwable\",{\"1\":{\"858\":1}}],[\"更不允许直接使用中文的方式\",{\"1\":{\"845\":1}}],[\"更不与组织架构挂钩\",{\"1\":{\"857\":1}}],[\"更不用说坏点检查了\",{\"1\":{\"483\":1}}],[\"更利于代码结构的升级扩展\",{\"1\":{\"748\":1}}],[\"更利于代码的维护和扩展\",{\"1\":{\"616\":1}}],[\"更新数据表记录时\",{\"1\":{\"866\":1}}],[\"更新记录\",{\"1\":{\"865\":1}}],[\"更新天气情况\",{\"1\":{\"676\":1}}],[\"更新\",{\"1\":{\"676\":1,\"678\":2,\"860\":1}}],[\"更新时间等页面元信息\",{\"1\":{\"34\":1}}],[\"更新时间\",{\"1\":{\"6\":1}}],[\"更注重零部件的创建过程\",{\"1\":{\"549\":1}}],[\"更灵活\",{\"1\":{\"529\":1}}],[\"更好的实现异常处理\",{\"1\":{\"469\":1}}],[\"更好\",{\"1\":{\"443\":1}}],[\"更进一步的\",{\"1\":{\"294\":1}}],[\"更加可读\",{\"1\":{\"614\":1}}],[\"更加正确\",{\"1\":{\"444\":1}}],[\"更加灵活\",{\"1\":{\"283\":1,\"814\":1}}],[\"更加方便\",{\"1\":{\"241\":1}}],[\"更简洁的代码\",{\"1\":{\"186\":1}}],[\"更详细的内容参见答案\",{\"1\":{\"169\":1}}],[\"哪个会占用更多的内存\",{\"0\":{\"168\":1}}],[\"哪个类包含\",{\"0\":{\"163\":1}}],[\"操作流程不允许\",{\"1\":{\"779\":1}}],[\"操作系统默认\",{\"1\":{\"870\":1}}],[\"操作系统会给新进程分配新的地址空间\",{\"1\":{\"770\":1}}],[\"操作系统会启动一个进程\",{\"1\":{\"770\":1}}],[\"操作系统中的文件系统\",{\"1\":{\"750\":1}}],[\"操作分成\",{\"1\":{\"601\":1}}],[\"操作时\",{\"1\":{\"565\":1}}],[\"操作和恢复\",{\"1\":{\"565\":1}}],[\"操作和清理html\",{\"1\":{\"433\":1}}],[\"操作和流操作工具类\",{\"1\":{\"403\":1}}],[\"操作字节码进行测试和故障排除\",{\"1\":{\"386\":1}}],[\"操作\",{\"0\":{\"325\":1},\"1\":{\"560\":1,\"562\":2,\"838\":1}}],[\"操作的数据类型被指定为一个参数\",{\"1\":{\"279\":1}}],[\"操作数据库异常类\",{\"1\":{\"261\":1}}],[\"操作输入流和输出流时可能出现的异常\",{\"1\":{\"261\":1}}],[\"操作日志\",{\"1\":{\"242\":1}}],[\"操作人类别\",{\"1\":{\"242\":1}}],[\"操作会将\",{\"1\":{\"165\":1}}],[\"操作符是线程安全的吗\",{\"0\":{\"164\":1}}],[\"或等价的\",{\"1\":{\"885\":1}}],[\"或消息通知等非关键功能\",{\"1\":{\"871\":1}}],[\"或近硬件端系统谨慎引入第三方实现\",{\"1\":{\"869\":1}}],[\"或表名\",{\"1\":{\"865\":3}}],[\"或count\",{\"1\":{\"865\":1}}],[\"或动态生成类的相关方法时\",{\"1\":{\"858\":1}}],[\"或用户输入密码过于简单\",{\"1\":{\"858\":1}}],[\"或用户名称已存在\",{\"1\":{\"858\":1}}],[\"或程序健壮性差等问题\",{\"1\":{\"857\":1}}],[\"或空集合\",{\"1\":{\"854\":1}}],[\"或使用bigdecimal的valueof方法\",{\"1\":{\"848\":1}}],[\"或作为返回值\",{\"1\":{\"835\":1}}],[\"或下载\",{\"1\":{\"809\":3}}],[\"或实例化耗时较长\",{\"1\":{\"762\":1}}],[\"或添加新的处理者\",{\"1\":{\"712\":1}}],[\"或缺省适配器模式\",{\"1\":{\"531\":1}}],[\"或log打印\",{\"1\":{\"305\":1}}],[\"或接口\",{\"1\":{\"302\":1}}],[\"或\",{\"1\":{\"163\":2,\"646\":1,\"775\":1,\"852\":3,\"897\":1,\"911\":1,\"956\":1,\"996\":1}}],[\"或者更多\",{\"1\":{\"957\":1}}],[\"或者如这个单行例子所示\",{\"1\":{\"955\":1}}],[\"或者如果打印日志是\",{\"1\":{\"950\":1}}],[\"或者以此为开头\",{\"1\":{\"950\":1}}],[\"或者抛出异常\",{\"1\":{\"924\":1}}],[\"或者会在声明之后立即初始化\",{\"1\":{\"918\":1}}],[\"或者分组括号不会更有助于阅读代码的情况下\",{\"1\":{\"913\":1}}],[\"或者最后一个成员或初始化方法的之后\",{\"1\":{\"910\":1}}],[\"或者偶尔使用实际的\",{\"1\":{\"885\":1}}],[\"或者抽象公共类\",{\"1\":{\"871\":1}}],[\"或者架构不兼容升级\",{\"1\":{\"869\":1}}],[\"或者大规模api不兼容\",{\"1\":{\"869\":1}}],[\"或者不复用的业务简单处理等\",{\"1\":{\"868\":1}}],[\"或者不同代码块的局部变量之间采用完全相同的命名\",{\"1\":{\"845\":1}}],[\"或者对单元测试产生的数据有明确的前后缀标识\",{\"1\":{\"860\":1}}],[\"或者对着空白处右键\",{\"1\":{\"826\":1}}],[\"或者直接操作数据库把数据插入进去\",{\"1\":{\"860\":1}}],[\"或者空对象等\",{\"1\":{\"858\":1}}],[\"或者在字节码修改框架\",{\"1\":{\"858\":1}}],[\"或者在方法签名里通过throws子句声明\",{\"1\":{\"198\":1}}],[\"或者捕获异常是抛异常的父类\",{\"1\":{\"858\":1}}],[\"或者用户端的日志中\",{\"1\":{\"854\":1}}],[\"或者调用注意事项\",{\"1\":{\"853\":1}}],[\"或者错误\",{\"1\":{\"852\":1}}],[\"或者错误的部分\",{\"1\":{\"484\":1}}],[\"或者多个同名方法\",{\"1\":{\"848\":1}}],[\"或者入库检查\",{\"1\":{\"848\":1}}],[\"或者很少需要\",{\"1\":{\"816\":1}}],[\"或者说\",{\"1\":{\"817\":1}}],[\"或者说某些步骤的实现与具体的环境相关\",{\"1\":{\"800\":1}}],[\"或者说提前写好的\",{\"1\":{\"627\":1}}],[\"或者行为\",{\"1\":{\"791\":1}}],[\"或者实例\",{\"1\":{\"770\":1}}],[\"或者从系统上来讲应当是单一控制逻辑的操作\",{\"1\":{\"762\":1}}],[\"或者其他的静态方法\",{\"1\":{\"752\":1}}],[\"或者尽可能少修改代码\",{\"1\":{\"738\":1}}],[\"或者两者都有\",{\"1\":{\"729\":1}}],[\"或者某些数据\",{\"1\":{\"663\":1}}],[\"或者某些类实例化很耗时\",{\"1\":{\"115\":1}}],[\"或者执行流程改变时\",{\"1\":{\"658\":1}}],[\"或者遍历一组相同对象时使用\",{\"1\":{\"652\":1}}],[\"或者还有其他方式\",{\"1\":{\"648\":1}}],[\"或者叫依赖注入容器\",{\"1\":{\"620\":1}}],[\"或者称为进一步的抽象\",{\"1\":{\"616\":1}}],[\"或者是鼓励的\",{\"1\":{\"910\":1}}],[\"或者是依照表在sql语句中出现的顺序\",{\"1\":{\"865\":1}}],[\"或者是记录已经达成的共同意见的事情\",{\"1\":{\"663\":1}}],[\"或者是伦敦的奶酪\",{\"1\":{\"613\":1}}],[\"或者是此类型的父类\",{\"1\":{\"284\":1}}],[\"或者是此类型的子类\",{\"1\":{\"284\":1}}],[\"或者一个新的调料\",{\"1\":{\"582\":1}}],[\"或者处理的对象具有树形结构时\",{\"1\":{\"576\":1}}],[\"或者产品类中不同的调用顺序产生不同的作用\",{\"1\":{\"558\":1}}],[\"或者甚至\",{\"1\":{\"466\":1}}],[\"或者工具包都有一个\",{\"1\":{\"459\":1}}],[\"或者它本身已经很明显是什么意思了\",{\"1\":{\"454\":1}}],[\"或者immutableset\",{\"1\":{\"451\":1}}],[\"或者干脆别用\",{\"1\":{\"448\":1}}],[\"或者a的子类类型\",{\"1\":{\"284\":1}}],[\"或者无法确定这里的代码未来是不是会改动\",{\"1\":{\"269\":1}}],[\"或者使用dateutils工具类\",{\"1\":{\"851\":1}}],[\"或者使用\",{\"1\":{\"264\":1}}],[\"或者\",{\"0\":{\"887\":1},\"1\":{\"133\":1,\"165\":1,\"268\":1,\"311\":1,\"445\":2,\"449\":1,\"451\":1,\"452\":1,\"459\":1,\"466\":1,\"472\":1,\"484\":2,\"655\":1,\"707\":1,\"808\":1,\"884\":1,\"886\":1,\"902\":1,\"905\":1,\"922\":2,\"939\":1,\"940\":1,\"941\":1,\"943\":1,\"947\":1,\"958\":1,\"959\":1}}],[\"如c语言中单元指一个函数\",{\"1\":{\"989\":1}}],[\"如加载配置\",{\"1\":{\"976\":1}}],[\"如有自定义标签实现的控件设置控件类型可使用role属性\",{\"1\":{\"871\":1}}],[\"如在原有表中新增字段\",{\"1\":{\"871\":1}}],[\"如淘宝开放平台\",{\"1\":{\"868\":1}}],[\"如缓存方案\",{\"1\":{\"868\":1}}],[\"如desc\",{\"1\":{\"863\":1}}],[\"如注册时发送验证码到手机\",{\"1\":{\"861\":1}}],[\"如数量限制\",{\"1\":{\"861\":1}}],[\"如数据排序策略有冒泡排序\",{\"1\":{\"783\":1}}],[\"如数据库工具\",{\"1\":{\"480\":1}}],[\"如数据库连接\",{\"1\":{\"251\":1}}],[\"如非必要\",{\"1\":{\"859\":1}}],[\"如stats\",{\"1\":{\"859\":1}}],[\"如setint\",{\"1\":{\"307\":1}}],[\"如打点\",{\"1\":{\"859\":1}}],[\"如阿拉伯语\",{\"1\":{\"857\":1}}],[\"如定义对象\",{\"1\":{\"852\":1}}],[\"如getxxx\",{\"1\":{\"852\":1}}],[\"如使用tab缩进\",{\"1\":{\"847\":1}}],[\"如盘子\",{\"1\":{\"835\":1}}],[\"如老师和学生\",{\"1\":{\"830\":1}}],[\"如机械系统\",{\"1\":{\"823\":1}}],[\"如右图\",{\"1\":{\"822\":1}}],[\"如人都有高兴和伤心的时候\",{\"1\":{\"775\":1}}],[\"如多线程的线程池\",{\"1\":{\"762\":1}}],[\"如一个班中的班长\",{\"1\":{\"762\":1}}],[\"如代码中所示\",{\"1\":{\"757\":1}}],[\"如可能会造成循环调用\",{\"1\":{\"707\":1}}],[\"如总线网中数据报传送\",{\"1\":{\"707\":1}}],[\"如某单位的内部数据库等\",{\"1\":{\"692\":1}}],[\"如视频或大图像等\",{\"1\":{\"692\":1}}],[\"如新浪网站\",{\"1\":{\"677\":1}}],[\"如玩游戏时的中间结果的存档功能\",{\"1\":{\"669\":1}}],[\"如前面所说的\",{\"1\":{\"655\":1}}],[\"如办房产证或注册一家公司\",{\"1\":{\"593\":1}}],[\"如房子装修\",{\"1\":{\"579\":1}}],[\"如游戏中的不同角色\",{\"1\":{\"549\":1}}],[\"如不同颜色和字体的文字\",{\"1\":{\"537\":1}}],[\"如不好的做法\",{\"1\":{\"484\":1}}],[\"如图形既可按形状分\",{\"1\":{\"537\":1}}],[\"如图\",{\"1\":{\"520\":1,\"539\":1,\"572\":1,\"583\":1,\"643\":1}}],[\"如上\",{\"1\":{\"310\":1}}],[\"如上的输出结果\",{\"1\":{\"308\":1}}],[\"如上所示\",{\"1\":{\"270\":1}}],[\"如list<\",{\"1\":{\"298\":1}}],[\"如map<string\",{\"1\":{\"298\":2}}],[\"如pair<string>或pair<integer>\",{\"1\":{\"289\":1}}],[\"如同泛型加入java语言之前的已经实现的样子\",{\"1\":{\"289\":1}}],[\"如下的代码输出是什么\",{\"1\":{\"852\":1}}],[\"如下是一个首先未对齐\",{\"1\":{\"912\":1}}],[\"如下是一个反例\",{\"1\":{\"273\":1}}],[\"如下是大学和教师的代码和关系图\",{\"1\":{\"831\":1}}],[\"如下图\",{\"1\":{\"563\":1,\"797\":1,\"832\":1,\"834\":1}}],[\"如下fund方法会报错\",{\"1\":{\"284\":1}}],[\"如下两个方法不会报错\",{\"1\":{\"284\":1}}],[\"如下\",{\"1\":{\"270\":2,\"295\":1,\"528\":1,\"738\":1}}],[\"如下表格\",{\"1\":{\"265\":1,\"850\":1}}],[\"如下所示是\",{\"1\":{\"826\":1}}],[\"如下所示是图形类接口的\",{\"1\":{\"825\":1}}],[\"如下所示\",{\"1\":{\"252\":1,\"253\":1,\"771\":1}}],[\"如ioexception\",{\"1\":{\"248\":1}}],[\"如nullpointerexception\",{\"1\":{\"248\":1}}],[\"如循环变量\",{\"1\":{\"227\":1}}],[\"如系统崩溃\",{\"1\":{\"198\":1}}],[\"如组合\",{\"1\":{\"187\":1}}],[\"如类\",{\"1\":{\"187\":1,\"716\":1}}],[\"如允许在同一个\",{\"1\":{\"186\":1}}],[\"如何高效地协同呢\",{\"1\":{\"843\":1}}],[\"如何给代码解耦\",{\"0\":{\"818\":1}}],[\"如何判断系统是否需要解耦重构呢\",{\"1\":{\"817\":1}}],[\"如何判断该用组合还是继承\",{\"0\":{\"814\":1},\"1\":{\"811\":1}}],[\"如何将这条原则应用到实战中\",{\"0\":{\"809\":1}}],[\"如何将方法的请求者与实现者解耦\",{\"1\":{\"560\":1}}],[\"如何解读原则中的\",{\"0\":{\"808\":1}}],[\"如何实现一个多例模式\",{\"0\":{\"773\":1}}],[\"如何实现一个简单的\",{\"0\":{\"623\":1}}],[\"如何实现集群环境下的单例\",{\"0\":{\"772\":1}}],[\"如何实现线程唯一的单例\",{\"0\":{\"771\":1}}],[\"如何正确的使用继承\",{\"1\":{\"731\":1}}],[\"如何正确的初始化泛型数组实例\",{\"0\":{\"295\":1}}],[\"如何设计实现一个dependency\",{\"0\":{\"620\":1}}],[\"如何设计类似于\",{\"1\":{\"537\":1}}],[\"如何处理建造房子的流程\",{\"1\":{\"555\":1}}],[\"如何获取泛型的参数类型\",{\"0\":{\"298\":1}}],[\"如何获取注解中的内容呢\",{\"1\":{\"233\":1}}],[\"如何确定这个泛型参数是何种类型\",{\"1\":{\"296\":1}}],[\"如何保证我们只能使用泛型变量限定的类型呢\",{\"1\":{\"290\":1}}],[\"如何保证set不重复呢\",{\"1\":{\"181\":1}}],[\"如何理解呢\",{\"1\":{\"773\":1}}],[\"如何理解单例模式中的唯一性\",{\"0\":{\"770\":1}}],[\"如何理解异常中使用泛型\",{\"0\":{\"297\":1}}],[\"如何理解泛型类中的静态方法和静态变量\",{\"0\":{\"296\":1}}],[\"如何理解泛型类型不能实例化\",{\"0\":{\"293\":1}}],[\"如何理解泛型的多态\",{\"0\":{\"291\":1}}],[\"如何理解泛型的编译期检查\",{\"0\":{\"290\":1}}],[\"如何理解基本类型不能作为泛型类型\",{\"0\":{\"292\":1}}],[\"如何理解类型擦除后保留的原始类型\",{\"0\":{\"289\":1}}],[\"如何理解java中的泛型是伪泛型\",{\"0\":{\"287\":1}}],[\"如何证明类型的擦除呢\",{\"0\":{\"288\":1}}],[\"如何在java中写出immutable的类\",{\"1\":{\"173\":1}}],[\"如读取变量值\",{\"1\":{\"164\":1}}],[\"如\",{\"0\":{\"162\":1},\"1\":{\"165\":1,\"173\":1,\"179\":1,\"181\":1,\"184\":1,\"186\":1,\"188\":1,\"245\":1,\"284\":1,\"298\":1,\"458\":1,\"484\":1,\"614\":1,\"646\":1,\"663\":1,\"669\":1,\"752\":1,\"762\":1,\"783\":1,\"792\":1,\"830\":1,\"845\":1,\"848\":5,\"850\":2,\"858\":1,\"859\":1,\"860\":1,\"864\":2,\"868\":1,\"897\":1,\"972\":1}}],[\"如果比较的两个对象是相等的\",{\"1\":{\"978\":1}}],[\"如果运行失败\",{\"1\":{\"970\":1}}],[\"如果运行良好则是绿色\",{\"1\":{\"970\":1}}],[\"如果捕获的异常名称是\",{\"1\":{\"950\":1}}],[\"如果任何单词在普遍用法中已经具有常规的驼峰形式\",{\"1\":{\"947\":1}}],[\"如果实例的任何外在状态是可变的\",{\"1\":{\"942\":1}}],[\"如果它们相等\",{\"1\":{\"978\":1}}],[\"如果它覆盖了一整个类\",{\"1\":{\"940\":1}}],[\"如果它表示一个\",{\"1\":{\"284\":1}}],[\"如果注解是用于类型的注解\",{\"1\":{\"931\":1}}],[\"如果遗漏了任何情况\",{\"1\":{\"925\":1}}],[\"如果同时存在静态导入和非静态导入\",{\"1\":{\"892\":1}}],[\"如果同台服务器再打日志\",{\"1\":{\"868\":1}}],[\"如果文件中包含许可证和版权信息\",{\"1\":{\"887\":1}}],[\"如果真的发生这种情况\",{\"1\":{\"885\":1}}],[\"如果真的不能的话\",{\"1\":{\"291\":1}}],[\"如果内存位置的值与预期原值相匹配\",{\"1\":{\"873\":1}}],[\"如果下游服务耗时过长\",{\"1\":{\"871\":1}}],[\"如果搭平房\",{\"1\":{\"871\":1}}],[\"如果系统中超过\",{\"1\":{\"871\":1}}],[\"如果系统中模型类超过\",{\"1\":{\"871\":1}}],[\"如果系统中某个功能的调用链路上的涉及对象超过\",{\"1\":{\"871\":1}}],[\"如果与系统交互的user超过一类并且相关的usercase超过\",{\"1\":{\"871\":1}}],[\"如果依赖其它二方库\",{\"1\":{\"869\":1}}],[\"如果依赖关系复杂\",{\"1\":{\"817\":1}}],[\"如果仲裁结果完全不一致\",{\"1\":{\"869\":1}}],[\"如果意识到这个异常将导致页面无法正常渲染\",{\"1\":{\"868\":1}}],[\"如果更新学生表中的student\",{\"1\":{\"865\":1}}],[\"如果更新成功\",{\"1\":{\"310\":1}}],[\"如果其中一列全为null\",{\"1\":{\"865\":1}}],[\"如果where\",{\"1\":{\"864\":1}}],[\"如果左边的值未确定\",{\"1\":{\"864\":1}}],[\"如果预计三年后的数据量根本达不到这个级别\",{\"1\":{\"863\":1}}],[\"如果预期对方抛的是绣球\",{\"1\":{\"858\":1}}],[\"如果修改字段含义或对字段表示的状态追加时\",{\"1\":{\"863\":1}}],[\"如果存储长度大于此值\",{\"1\":{\"863\":1}}],[\"如果存储的字符串长度几乎相等\",{\"1\":{\"863\":1}}],[\"如果存储的数据范围超过decimal的范围\",{\"1\":{\"863\":1}}],[\"如果存在名称之外的延伸属性应使用enum类型\",{\"1\":{\"846\":1}}],[\"如果存在则提供给客户\",{\"1\":{\"632\":1}}],[\"如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型\",{\"1\":{\"287\":1}}],[\"如果存在就获取\",{\"1\":{\"242\":1}}],[\"如果日志中的错误信息用英文描述不清楚的话使用中文描述即可\",{\"1\":{\"859\":1}}],[\"如果日志实现提供者只要实现该接口\",{\"1\":{\"104\":1}}],[\"如果大量输出送往这两个文件\",{\"1\":{\"859\":1}}],[\"如果大括号内为空\",{\"1\":{\"847\":1}}],[\"如果判断为真\",{\"1\":{\"859\":1}}],[\"如果debug\",{\"1\":{\"859\":1}}],[\"如果加了栈信息\",{\"1\":{\"858\":1}}],[\"如果找不到方法\",{\"1\":{\"858\":1}}],[\"如果jdk7\",{\"1\":{\"858\":1}}],[\"如果var等于null或者不存在\",{\"1\":{\"855\":1}}],[\"如果缓存\",{\"1\":{\"854\":1}}],[\"如果缓存没有\",{\"1\":{\"310\":1}}],[\"如果为空\",{\"1\":{\"854\":1}}],[\"如果为null\",{\"1\":{\"850\":1,\"858\":1}}],[\"如果无用\",{\"1\":{\"853\":1}}],[\"如果导航软件严重滞后\",{\"1\":{\"853\":1}}],[\"如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题\",{\"1\":{\"852\":1}}],[\"如果能把它们相同的部分提取出来共享\",{\"1\":{\"629\":1}}],[\"如果赋值一个非常好理解的布尔变量名字\",{\"1\":{\"852\":1}}],[\"如果非使用if\",{\"1\":{\"852\":1}}],[\"如果并发控制没有处理好\",{\"1\":{\"852\":1}}],[\"如果并发操作\",{\"1\":{\"850\":1}}],[\"如果每次访问冲突概率小于20\",{\"1\":{\"851\":1}}],[\"如果lock方法在try代码块之内\",{\"1\":{\"851\":1}}],[\"如果暂时无法确定初始值大小\",{\"1\":{\"850\":1}}],[\"如果暂时无法确定集合大小\",{\"1\":{\"850\":1}}],[\"如果查询无结果\",{\"1\":{\"850\":1}}],[\"如果自定义对象作为map的键\",{\"1\":{\"850\":1}}],[\"如果继承了另一个pojo类\",{\"1\":{\"848\":1}}],[\"如果完全不兼容升级\",{\"1\":{\"848\":1}}],[\"如果变量值仅在一个固定范围内变化用enum类型来定义\",{\"1\":{\"846\":1}}],[\"如果一本书需要知道第\",{\"1\":{\"864\":1}}],[\"如果一定要定义\",{\"1\":{\"845\":1}}],[\"如果一个测试用例比起指定的毫秒数花费了更多的时间\",{\"1\":{\"980\":1}}],[\"如果一个系统有比较稳定的数据结构\",{\"1\":{\"840\":1}}],[\"如果一个类被其他的类所继承\",{\"1\":{\"731\":1}}],[\"如果一个类没有实现\",{\"1\":{\"141\":1}}],[\"如果一个对象承担了太多的职责\",{\"1\":{\"716\":1}}],[\"如果一个对象不能处理该请求\",{\"1\":{\"707\":1}}],[\"如果一个异常满足你的需要\",{\"1\":{\"265\":1}}],[\"如果一个接口想要添加新的方法\",{\"1\":{\"133\":1}}],[\"如果一个\",{\"1\":{\"123\":1}}],[\"如果模块\",{\"1\":{\"845\":1}}],[\"如果新增代码影响了原有单元测试\",{\"1\":{\"860\":1}}],[\"如果新增一个新的类如希腊披萨\",{\"1\":{\"613\":1}}],[\"如果新建一个类图\",{\"1\":{\"826\":1}}],[\"如果新开发的代码也用到这个接口\",{\"1\":{\"818\":1}}],[\"如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段\",{\"1\":{\"816\":1}}],[\"如果按照这种思考方式\",{\"1\":{\"809\":1}}],[\"如果开发这个功能的同事没有接口意识\",{\"1\":{\"809\":1}}],[\"如果落实到具体的编码\",{\"1\":{\"808\":1}}],[\"如果父类添加新的抽象方法\",{\"1\":{\"800\":1}}],[\"如果引入设计模式使得设计变得复杂\",{\"1\":{\"797\":1}}],[\"如果项目开发完后\",{\"1\":{\"796\":1}}],[\"如果客户\",{\"1\":{\"796\":1}}],[\"如果采用策略模式就能很好解决该问题\",{\"1\":{\"783\":1}}],[\"如果把每个状态的行为都放到一个类中\",{\"1\":{\"780\":1}}],[\"如果把这种\",{\"1\":{\"655\":1}}],[\"如果严格按照不同的进程间共享同一个对象来实现\",{\"1\":{\"772\":1}}],[\"如果这个全局变量是一个可变全局变量\",{\"1\":{\"767\":1}}],[\"如果这是一个普通的继承关系\",{\"1\":{\"291\":1}}],[\"如果未来某一天\",{\"1\":{\"764\":1,\"766\":1}}],[\"如果从始至终从未使用过这个实例\",{\"1\":{\"752\":1}}],[\"如果从桥接模式来看\",{\"1\":{\"543\":1}}],[\"如果功能设计不合理\",{\"1\":{\"750\":1}}],[\"如果单测对外部环境\",{\"1\":{\"860\":1}}],[\"如果单例类持有成员变量\",{\"1\":{\"767\":1}}],[\"如果单例类依赖比较重的外部资源\",{\"1\":{\"767\":1}}],[\"如果单例中的代码没有执行完\",{\"1\":{\"750\":1}}],[\"如果单一职责原则遵守得好\",{\"1\":{\"717\":1}}],[\"如果对操作列没有限定表的别名\",{\"1\":{\"865\":1}}],[\"如果对每个类型为\",{\"1\":{\"732\":1}}],[\"如果对象里某些get方法被覆写\",{\"1\":{\"859\":1}}],[\"如果对象的\",{\"1\":{\"627\":3}}],[\"如果对象不可复用\",{\"1\":{\"614\":1}}],[\"如果定义为static\",{\"1\":{\"851\":1}}],[\"如果定义太大\",{\"1\":{\"722\":1}}],[\"如果定义过小\",{\"1\":{\"722\":1}}],[\"如果接口的粒度大小定义合理\",{\"1\":{\"722\":1}}],[\"如果接口\",{\"1\":{\"721\":1,\"723\":1}}],[\"如果遵循单一职责原则将有以下优点\",{\"1\":{\"717\":1}}],[\"如果各个级别的人员审批金额发生变化\",{\"1\":{\"709\":1}}],[\"如果金额超过\",{\"1\":{\"709\":1}}],[\"如果金额小于等于\",{\"1\":{\"709\":3}}],[\"如果取不到资源\",{\"1\":{\"704\":1}}],[\"如果取到资源则\",{\"1\":{\"704\":1}}],[\"如果原始对象发生变化\",{\"1\":{\"690\":1}}],[\"如果直接调用引用类型的\",{\"1\":{\"689\":1}}],[\"如果直接调用add\",{\"1\":{\"288\":1}}],[\"如果创建的对象比较复杂时\",{\"1\":{\"686\":1}}],[\"如果创建简单对象\",{\"1\":{\"558\":1}}],[\"如果只保存一次状态\",{\"1\":{\"667\":1}}],[\"如果设计不当\",{\"1\":{\"660\":1}}],[\"如果碰到对表达式的解释\",{\"1\":{\"646\":1}}],[\"如果分成多个虚拟空间来处理\",{\"1\":{\"635\":1}}],[\"如果某个业务对象的状态超过\",{\"1\":{\"871\":1}}],[\"如果某个系统特别稳定\",{\"1\":{\"810\":1}}],[\"如果某个对象的创建并不是写死在代码中\",{\"1\":{\"627\":1}}],[\"如果某个类使用了被\",{\"1\":{\"230\":1,\"237\":1}}],[\"如果感兴趣的话\",{\"1\":{\"626\":1}}],[\"如果要改为私有云的上传下载流程\",{\"1\":{\"809\":1}}],[\"如果要完全解决这些问题\",{\"1\":{\"769\":1}}],[\"如果要扩展\",{\"1\":{\"750\":1}}],[\"如果要使用继承关系\",{\"1\":{\"745\":1}}],[\"如果要保存的内部状态信息过多或者特别频繁\",{\"1\":{\"663\":1}}],[\"如果要创建的类对象非常多\",{\"1\":{\"622\":1}}],[\"如果要指定过滤\",{\"1\":{\"311\":1}}],[\"如果代码比较复杂\",{\"1\":{\"765\":1}}],[\"如果代码块本身并不复杂\",{\"1\":{\"614\":1}}],[\"如果代码可能会引发某种错误\",{\"1\":{\"253\":1}}],[\"如果使用warn来记录刚上线时的业务行为信息\",{\"1\":{\"859\":1}}],[\"如果使用数字\",{\"1\":{\"849\":1}}],[\"如果使用多重条件转移语句实现\",{\"1\":{\"783\":1}}],[\"如果使用不当会导致程序结构和代码的混乱\",{\"1\":{\"775\":1}}],[\"如果使用\",{\"1\":{\"637\":1,\"905\":1}}],[\"如果使用组合关系来创建一个包装对象\",{\"1\":{\"580\":1}}],[\"如果使用了被\",{\"1\":{\"222\":1}}],[\"如果产品之间的差异性很大\",{\"1\":{\"557\":1}}],[\"如果产品内部发生变化\",{\"1\":{\"549\":1}}],[\"如果产品的内部变化复杂\",{\"1\":{\"549\":1,\"557\":1}}],[\"如果用户输入非法字符\",{\"1\":{\"858\":1}}],[\"如果用\",{\"1\":{\"837\":1}}],[\"如果用代码来简单示例一下的话\",{\"1\":{\"773\":1}}],[\"如果用传统的构造函数来创建对象\",{\"1\":{\"682\":1}}],[\"如果用享元模式来处理棋子\",{\"1\":{\"631\":1}}],[\"如果用组合模式来实现会很方便\",{\"1\":{\"567\":1}}],[\"如果用桥接模式就能很好地解决这些问题\",{\"1\":{\"537\":1}}],[\"如果用继承方式\",{\"1\":{\"537\":1}}],[\"如果用了原来的类加载器\",{\"1\":{\"312\":1}}],[\"如果需要的话\",{\"1\":{\"886\":1}}],[\"如果需要存储表情\",{\"1\":{\"865\":1}}],[\"如果需要请走搜索引擎来解决\",{\"1\":{\"864\":1}}],[\"如果需要回滚\",{\"1\":{\"858\":1}}],[\"如果需要对齐\",{\"1\":{\"847\":1}}],[\"如果需要直接调用\",{\"1\":{\"533\":1}}],[\"如果需要变化时\",{\"1\":{\"174\":1}}],[\"如果重新开发这些组件成本又很高\",{\"1\":{\"518\":1}}],[\"如果有的话\",{\"1\":{\"956\":1}}],[\"如果有改变\",{\"1\":{\"869\":1}}],[\"如果有order\",{\"1\":{\"864\":1}}],[\"如果有初始化逻辑\",{\"1\":{\"848\":1}}],[\"如果有人要求你对程序进行修改\",{\"1\":{\"820\":1}}],[\"如果有多个实例\",{\"1\":{\"762\":1}}],[\"如果有一个值你不确定是否存在\",{\"1\":{\"450\":1}}],[\"如果有更详细的中文介绍\",{\"1\":{\"383\":1}}],[\"如果企业内部部署im使用openfire+spark是最佳的组合\",{\"1\":{\"414\":1}}],[\"如果和自己想要更新的状态一致\",{\"1\":{\"310\":1}}],[\"如果已经加载了的话\",{\"1\":{\"310\":1}}],[\"如果将此方法声明为带有可变数量的参数\",{\"1\":{\"308\":1}}],[\"如果此处抛出异常\",{\"1\":{\"851\":1}}],[\"如果此处存在return语句\",{\"1\":{\"273\":1,\"858\":1}}],[\"如果此字段表示枚举类型的元素则返回\",{\"1\":{\"307\":1}}],[\"如果我们使用的面向用户的服务\",{\"1\":{\"854\":1}}],[\"如果我们使用简单工厂模式来实现\",{\"1\":{\"614\":1}}],[\"如果我们还需要考虑\",{\"1\":{\"812\":1}}],[\"如果我们还想避免烦人的\",{\"1\":{\"614\":1}}],[\"如果我们继续沿用刚才的设计思路\",{\"1\":{\"812\":1}}],[\"如果我们在新类中重新命名\",{\"1\":{\"809\":1}}],[\"如果我们在一个进程中创建另外一个进程\",{\"1\":{\"770\":1}}],[\"如果我们有一个玩具鸭子\",{\"1\":{\"788\":1}}],[\"如果我们如下两次执行\",{\"1\":{\"768\":1}}],[\"如果我们将数据库连接池设计成单例类\",{\"1\":{\"766\":1}}],[\"如果我们获取的对象是\",{\"1\":{\"727\":1}}],[\"如果我们的集合元素是用不同的方式实现的\",{\"1\":{\"648\":1}}],[\"如果我们给每个类都对应创建一个工厂类\",{\"1\":{\"622\":1}}],[\"如果我们再增加手机的样式\",{\"1\":{\"541\":1}}],[\"如果我们不期望获取其父类的字段\",{\"1\":{\"307\":1}}],[\"如果我们确实需要实例化一个泛型\",{\"1\":{\"293\":1}}],[\"如果我说只调用一次这个方法\",{\"1\":{\"92\":1}}],[\"如果可以是const最好\",{\"1\":{\"864\":1}}],[\"如果可以处理请求则处理\",{\"1\":{\"708\":1}}],[\"如果可以进行泛型数组的声明则上面说的这种情况在编译期不会出现任何警告和错误\",{\"1\":{\"294\":1}}],[\"如果可以\",{\"1\":{\"293\":1}}],[\"如果类之间的继承结构稳定\",{\"1\":{\"814\":1}}],[\"如果类的成员变量过多\",{\"1\":{\"668\":1}}],[\"如果类型变量有限定\",{\"1\":{\"289\":1}}],[\"如果类型参数是无限制通配符或没有上下界限定则替换为object\",{\"1\":{\"287\":1}}],[\"如果类中包含mutable类对象\",{\"1\":{\"173\":1}}],[\"如果既是生产又是消费\",{\"1\":{\"284\":1}}],[\"如果参数化类型表示一个\",{\"1\":{\"284\":1}}],[\"如果传入的实例类型b是在这个范围内的话允许转换\",{\"1\":{\"284\":1}}],[\"如果想获取整数类型的随机数\",{\"1\":{\"855\":1}}],[\"如果想成为合格软件工程师\",{\"1\":{\"796\":1}}],[\"如果想换一种类型\",{\"1\":{\"283\":1}}],[\"如果想要提供更加有用的信息\",{\"1\":{\"270\":1}}],[\"如果想要获取被抑制的异常列表\",{\"1\":{\"259\":1}}],[\"如果catch有未处理的异常\",{\"1\":{\"275\":1}}],[\"如果异常没有被catch捕获\",{\"1\":{\"275\":1}}],[\"如果14到19之间\",{\"1\":{\"275\":1}}],[\"如果0到3之间\",{\"1\":{\"275\":2}}],[\"如果当前线程不持有锁\",{\"1\":{\"851\":1}}],[\"如果当前的状态是抽奖成功\",{\"1\":{\"778\":1}}],[\"如果当前thread为最后一个非守护线程\",{\"1\":{\"275\":1}}],[\"如果当前方法的异常表无法处理\",{\"1\":{\"275\":1}}],[\"如果当前方法异常表不为空\",{\"1\":{\"275\":1}}],[\"如果所有的栈帧被弹出\",{\"1\":{\"275\":1}}],[\"如果上一条未找到合理的处理者\",{\"1\":{\"275\":1}}],[\"如果首先捕获\",{\"1\":{\"267\":1}}],[\"如果finally中使用了return或者throw等终止方法的语句\",{\"1\":{\"251\":1}}],[\"如果没有限制次数和频率\",{\"1\":{\"861\":1}}],[\"如果没有对方\",{\"1\":{\"828\":1}}],[\"如果没有就创建一个网站\",{\"1\":{\"636\":1}}],[\"如果没有我们需要的\",{\"1\":{\"629\":1}}],[\"如果没有用空命令\",{\"1\":{\"564\":1}}],[\"如果没有\",{\"1\":{\"311\":1}}],[\"如果没有找到相应方法\",{\"1\":{\"311\":1}}],[\"如果没有泛型\",{\"1\":{\"279\":1}}],[\"如果没有异常发生\",{\"1\":{\"275\":2}}],[\"如果没有注释直接存在于此元素上\",{\"1\":{\"233\":2}}],[\"如果没有指定类加载器\",{\"1\":{\"114\":1}}],[\"如果该类型注解不存在\",{\"1\":{\"233\":1}}],[\"如果该值大于\",{\"0\":{\"161\":1}}],[\"如果虚拟机给每个局部变量都初始化一下\",{\"1\":{\"205\":1}}],[\"如果\",{\"1\":{\"180\":1,\"182\":1,\"451\":1,\"576\":1,\"622\":2,\"637\":1,\"659\":1,\"734\":1,\"925\":1}}],[\"如果两个整型相加\",{\"1\":{\"165\":1}}],[\"如果强制转化是\",{\"1\":{\"161\":1}}],[\"如果子类重写了父类的中某个方法的实现\",{\"1\":{\"134\":1}}],[\"如果子类的方法重写了父类的方法\",{\"1\":{\"132\":1}}],[\"如果是单独部署\",{\"1\":{\"868\":1}}],[\"如果是boolean基本数据类型变量\",{\"1\":{\"855\":1}}],[\"如果是count++操作\",{\"1\":{\"851\":1}}],[\"如果是jdk8的应用\",{\"1\":{\"851\":1}}],[\"如果是jdk8\",{\"1\":{\"850\":1,\"851\":1}}],[\"如果是非空代码块\",{\"1\":{\"847\":1}}],[\"如果是形容能力的接口名称\",{\"1\":{\"845\":1}}],[\"如果是方法的返回类型\",{\"1\":{\"829\":1}}],[\"如果是类的成员属性\",{\"1\":{\"829\":1}}],[\"如果是接口\",{\"1\":{\"826\":1}}],[\"如果是以窗帘发出的消息\",{\"1\":{\"659\":1}}],[\"如果是一个private的方法\",{\"1\":{\"848\":1}}],[\"如果是一个\",{\"1\":{\"644\":1}}],[\"如果是我们自己编写java代码\",{\"1\":{\"291\":1}}],[\"如果是重载\",{\"1\":{\"291\":1}}],[\"如果是与以前的代码兼容\",{\"1\":{\"290\":1}}],[\"如果是不可查异常\",{\"1\":{\"252\":1}}],[\"如果是偶数的话\",{\"1\":{\"139\":1}}],[\"如果是直接返回\",{\"1\":{\"138\":1}}],[\"如果是包级私有的类或者私有的嵌套类\",{\"1\":{\"132\":1}}],[\"如果是采用\",{\"1\":{\"125\":1}}],[\"如果不加栈信息\",{\"1\":{\"858\":1}}],[\"如果不加访问修饰符\",{\"1\":{\"132\":1}}],[\"如果不想处理它\",{\"1\":{\"858\":1}}],[\"如果不想用某些实现类\",{\"1\":{\"115\":1}}],[\"如果不清理自定义的threadlocal变量\",{\"1\":{\"851\":1}}],[\"如果不使用线程池\",{\"1\":{\"851\":1}}],[\"如果不允许外部直接通过new来创建对象\",{\"1\":{\"848\":1}}],[\"如果不熟悉背后设计思路的同事\",{\"1\":{\"814\":1}}],[\"如果不用单例\",{\"1\":{\"769\":1}}],[\"如果不在\",{\"1\":{\"637\":2}}],[\"如果不存在的话\",{\"1\":{\"632\":1}}],[\"如果不通过直接抛出异常\",{\"1\":{\"310\":1}}],[\"如果不指定泛型\",{\"1\":{\"289\":1}}],[\"如果不对其捕获\",{\"1\":{\"252\":1}}],[\"如果不处理\",{\"1\":{\"248\":1,\"859\":1}}],[\"如果不是特别关心内存和性能的话\",{\"1\":{\"158\":1}}],[\"如果不是\",{\"1\":{\"138\":1}}],[\"如果值过于复杂\",{\"1\":{\"130\":1}}],[\"如果在null前换行\",{\"1\":{\"865\":1}}],[\"如果在抽象类中对方法签名进行修改\",{\"1\":{\"848\":1}}],[\"如果在我们的业务场景中\",{\"1\":{\"810\":1}}],[\"如果在多线程下\",{\"1\":{\"754\":1}}],[\"如果在内存中有\",{\"1\":{\"638\":1}}],[\"如果在\",{\"1\":{\"268\":1,\"825\":1}}],[\"如果在子类中定义的方法和基类中的一个\",{\"1\":{\"143\":1}}],[\"如果在某个时刻\",{\"1\":{\"132\":1}}],[\"如果在缓冲池之外\",{\"1\":{\"120\":1}}],[\"如果在的话就直接返回缓存池的内容\",{\"1\":{\"120\":1}}],[\"如果在com\",{\"1\":{\"96\":1}}],[\"如果您稍后为节点定义边\",{\"1\":{\"42\":1}}],[\"如果多次这样做\",{\"1\":{\"42\":1}}],[\"如果你真的需要\",{\"1\":{\"952\":1}}],[\"如果你希望能为了在必要的时候重新包装每行代码而自动格式化\",{\"1\":{\"933\":1}}],[\"如果你不能改变一个函数的入参类型\",{\"1\":{\"814\":1}}],[\"如果你不了解它\",{\"1\":{\"10\":1}}],[\"如果你觉得这种思考方式更加顺畅\",{\"1\":{\"809\":1}}],[\"如果你觉得上面的代码不够绝\",{\"1\":{\"89\":1}}],[\"如果你完成了依赖注入\",{\"1\":{\"477\":1}}],[\"如果你在\",{\"1\":{\"472\":1}}],[\"如果你坚持使用\",{\"1\":{\"466\":1}}],[\"如果你喜欢用这种风格的话\",{\"1\":{\"466\":1}}],[\"如果你引入足够多的库\",{\"1\":{\"459\":1}}],[\"如果你认为你的根\",{\"1\":{\"458\":1}}],[\"如果你是第一次用会觉得有点怪\",{\"1\":{\"481\":1}}],[\"如果你是\",{\"1\":{\"458\":1}}],[\"如果你是一个新手\",{\"1\":{\"9\":1}}],[\"如果你对一个参数的含义没什么可说的\",{\"1\":{\"454\":1}}],[\"如果你确实需要一个代码格式风格的教程\",{\"1\":{\"453\":1}}],[\"如果你确实准备使用\",{\"1\":{\"450\":1}}],[\"如果你发现在你正在往工具类中添加很多方法\",{\"1\":{\"452\":1}}],[\"如果你使用的是\",{\"1\":{\"450\":1}}],[\"如果你使用基于\",{\"1\":{\"449\":1}}],[\"如果你要引入很多的外部依赖\",{\"1\":{\"458\":1}}],[\"如果你要手动创建许多不可变对象\",{\"1\":{\"447\":1}}],[\"如果你要实现诸如复数或者矩阵之类的算术对象\",{\"1\":{\"265\":1}}],[\"如果你想一遍又一遍地设置相同的依赖\",{\"1\":{\"477\":1}}],[\"如果你想明确地指出它\",{\"1\":{\"459\":1}}],[\"如果你想跟踪一个项目的版本\",{\"1\":{\"459\":1}}],[\"如果你想使用内部依赖\",{\"1\":{\"458\":1}}],[\"如果你想用这种构造的方式构造更复杂的对象\",{\"1\":{\"446\":1}}],[\"如果你想保存很容易修改的对象数据\",{\"1\":{\"445\":1}}],[\"如果你的项目依赖于不同版本的同一个库\",{\"1\":{\"459\":1}}],[\"如果你的项目的开发者选择的框架并不合适\",{\"1\":{\"457\":1}}],[\"如果你的资源实现了\",{\"1\":{\"264\":1}}],[\"如果你的异常模式使问题变得太复杂\",{\"1\":{\"260\":1}}],[\"如果你还期望了解junit4是如何实现运行的呢\",{\"1\":{\"241\":1}}],[\"如果你经常迷茫\",{\"1\":{\"36\":1}}],[\"么\",{\"0\":{\"162\":1},\"1\":{\"832\":1}}],[\"到约\",{\"1\":{\"863\":2}}],[\"到点就通知我\",{\"1\":{\"591\":1}}],[\"到了这里\",{\"1\":{\"462\":1}}],[\"到这我们也就可以得出以下几点信息\",{\"1\":{\"302\":1}}],[\"到头来\",{\"1\":{\"290\":1}}],[\"到junit4的演化就是最好的一个例子\",{\"1\":{\"241\":1}}],[\"到\",{\"1\":{\"161\":1,\"527\":1,\"644\":1,\"830\":1,\"849\":1,\"857\":1,\"863\":2}}],[\"位是错误来源\",{\"1\":{\"857\":1}}],[\"位是错误等级\",{\"1\":{\"857\":1}}],[\"位\",{\"1\":{\"854\":2,\"857\":1,\"861\":1}}],[\"位将会被丢弃\",{\"1\":{\"161\":1}}],[\"位的\",{\"1\":{\"161\":2}}],[\"位于\",{\"1\":{\"113\":2}}],[\"转义字符用于非打印字符时\",{\"1\":{\"885\":1}}],[\"转义字符的情况下\",{\"1\":{\"885\":1}}],[\"转义字符\",{\"1\":{\"884\":1,\"885\":2}}],[\"转载并翻译自\",{\"1\":{\"875\":1}}],[\"转发\",{\"1\":{\"656\":1}}],[\"转账用户类型\",{\"1\":{\"546\":1}}],[\"转账\",{\"1\":{\"546\":1}}],[\"转账分类\",{\"1\":{\"546\":1}}],[\"转成\",{\"1\":{\"524\":1}}],[\"转成类似ms\",{\"1\":{\"402\":1}}],[\"转为实际需要的\",{\"1\":{\"524\":1,\"528\":1}}],[\"转换\",{\"1\":{\"415\":1}}],[\"转换为\",{\"0\":{\"159\":1,\"160\":1,\"162\":1}}],[\"转化为十进制的long类型后正好对应4294967297\",{\"1\":{\"93\":1}}],[\"否则失败将显示在junit窗口和中止测试\",{\"1\":{\"978\":1}}],[\"否则失败显示在junit的窗口测试将中止\",{\"1\":{\"978\":1}}],[\"否则因线上采用https协议而导致浏览器提示\",{\"1\":{\"870\":1}}],[\"否则公共二方库的行为不应该发生变化\",{\"1\":{\"869\":1}}],[\"否则容易产生歧义\",{\"1\":{\"859\":1}}],[\"否则容易被打的很惨\",{\"1\":{\"91\":1}}],[\"否则使用悲观锁\",{\"1\":{\"851\":1}}],[\"否则使用预定义精度的\",{\"1\":{\"158\":1}}],[\"否则可能出现死锁\",{\"1\":{\"851\":1}}],[\"否则可能会造成死锁\",{\"1\":{\"851\":1}}],[\"否则当出现相同key时会抛出\",{\"1\":{\"850\":1}}],[\"否则部分框架解析会引起序列化错误\",{\"1\":{\"845\":1}}],[\"否则无法切换到新增状态\",{\"1\":{\"775\":1}}],[\"否则代码会抛出异常\",{\"1\":{\"768\":1}}],[\"否则类应该被拆分\",{\"1\":{\"716\":1}}],[\"否则报错\",{\"1\":{\"703\":1}}],[\"否则不能用动态代理\",{\"1\":{\"698\":1}}],[\"否则不会改变\",{\"1\":{\"445\":1}}],[\"否则将该请求转给它的后继者\",{\"1\":{\"708\":1}}],[\"否则将使两者之间紧密耦合起来\",{\"1\":{\"672\":1}}],[\"否则将抛异常\",{\"1\":{\"306\":1}}],[\"否则那将会很难保持根\",{\"1\":{\"458\":1}}],[\"否则调用\",{\"1\":{\"312\":1}}],[\"否则测查当前已被其他线程更新的情况\",{\"1\":{\"310\":1}}],[\"否则抛出\",{\"1\":{\"310\":1}}],[\"否则抛nosuchfieldexception\",{\"1\":{\"307\":1}}],[\"否则返回对应方法\",{\"1\":{\"311\":1}}],[\"否则返回\",{\"1\":{\"307\":1}}],[\"否则返回false\",{\"1\":{\"233\":1}}],[\"否则就会出现下面的问题\",{\"1\":{\"275\":1}}],[\"否则\",{\"1\":{\"271\":1,\"308\":1,\"637\":1,\"873\":1}}],[\"否则只需要在方法签名中声明让调用者去处理\",{\"1\":{\"270\":1}}],[\"否则会因线上采用https协议而导致浏览器提示\",{\"1\":{\"854\":1}}],[\"否则会抛出unsupportedoperationexception异常\",{\"1\":{\"850\":1}}],[\"否则会抛出classcastexception异常\",{\"1\":{\"850\":1}}],[\"否则会有抛indexoutofboundsexception的风险\",{\"1\":{\"848\":1}}],[\"否则会导致编译错误\",{\"1\":{\"252\":1}}],[\"否则会使用平台默认编码\",{\"1\":{\"159\":1}}],[\"否则编译不会通过\",{\"1\":{\"249\":1}}],[\"否则编译不通过\",{\"1\":{\"200\":2}}],[\"否则程序会提前退出\",{\"1\":{\"197\":1}}],[\"否则为false\",{\"1\":{\"191\":1}}],[\"qq\",{\"1\":{\"238\":1,\"243\":1,\"314\":1,\"546\":1,\"655\":2,\"984\":1}}],[\"q\",{\"0\":{\"154\":1,\"157\":1}}],[\"quickml\",{\"1\":{\"413\":1}}],[\"quickcheckmemberaccess\",{\"1\":{\"310\":2,\"312\":1}}],[\"query\",{\"1\":{\"868\":1,\"873\":1}}],[\"querystatementcallback\",{\"1\":{\"563\":2}}],[\"querydsl\",{\"1\":{\"394\":1}}],[\"queueofwork\",{\"1\":{\"845\":1}}],[\"queue\",{\"0\":{\"318\":1}}],[\"question\",{\"1\":{\"243\":1,\"863\":1}}],[\"questions\",{\"1\":{\"116\":1}}],[\"quackbehavior\",{\"1\":{\"789\":13}}],[\"quack\",{\"1\":{\"787\":1,\"788\":1,\"789\":3}}],[\"quality\",{\"0\":{\"484\":1,\"1015\":1}}],[\"qualified\",{\"1\":{\"145\":1}}],[\"quartz\",{\"1\":{\"415\":1}}],[\"quasar\",{\"1\":{\"399\":1}}],[\"quanke\",{\"1\":{\"155\":2}}],[\"quot\",{\"1\":{\"73\":1}}],[\"quote\",{\"1\":{\"73\":2}}],[\"quotes\",{\"1\":{\"72\":1,\"77\":1}}],[\"等框架\",{\"1\":{\"873\":1}}],[\"等外不要在条件判断中执行其它复杂的语句\",{\"1\":{\"852\":1}}],[\"等于size\",{\"1\":{\"850\":1}}],[\"等于\",{\"1\":{\"850\":1,\"852\":1}}],[\"等都是immutable\",{\"1\":{\"850\":1}}],[\"等都使用了组合关系\",{\"1\":{\"814\":1}}],[\"等聚合类实现\",{\"1\":{\"838\":1}}],[\"等生成\",{\"1\":{\"809\":2}}],[\"等多方面的挑战\",{\"1\":{\"797\":1}}],[\"等多种语言\",{\"1\":{\"419\":1}}],[\"等人在\",{\"1\":{\"796\":1}}],[\"等冗余语句\",{\"1\":{\"775\":1}}],[\"等关联关系来实现\",{\"1\":{\"745\":1}}],[\"等软件在编辑时按\",{\"1\":{\"663\":1,\"669\":1}}],[\"等来设计\",{\"1\":{\"646\":1}}],[\"等信息\",{\"1\":{\"631\":1}}],[\"等等属于接收的范围\",{\"1\":{\"727\":1}}],[\"等等\",{\"1\":{\"613\":1}}],[\"等等方法\",{\"1\":{\"307\":1}}],[\"等方法\",{\"1\":{\"568\":1,\"649\":1}}],[\"等方法获取class对象\",{\"1\":{\"302\":1}}],[\"等处理都很不方便\",{\"1\":{\"560\":1}}],[\"等不可变集合可以使用\",{\"1\":{\"466\":1}}],[\"等一系列权限相关问题\",{\"1\":{\"427\":1}}],[\"等\",{\"1\":{\"247\":1,\"248\":1,\"466\":1,\"563\":1,\"585\":1,\"586\":1,\"609\":1,\"707\":1,\"761\":1,\"873\":1}}],[\"等接口用于获取堆栈跟踪数据等信息\",{\"1\":{\"246\":1}}],[\"等属性\",{\"1\":{\"209\":1}}],[\"等预处理命令从而实现条件编译\",{\"1\":{\"151\":1}}],[\"等价于\",{\"1\":{\"703\":1}}],[\"等价的两个对象散列值一定相同\",{\"1\":{\"139\":1}}],[\"等价关系\",{\"1\":{\"138\":1}}],[\"具备良好的扩展性\",{\"1\":{\"565\":1}}],[\"具有回归性\",{\"1\":{\"990\":1}}],[\"具有自动化\",{\"1\":{\"860\":1}}],[\"具有实用\",{\"1\":{\"854\":1}}],[\"具有实时要求的工业系统或工业过程等\",{\"1\":{\"823\":1}}],[\"具有很宽的应用领域\",{\"1\":{\"823\":1}}],[\"具有更好的\",{\"1\":{\"797\":1}}],[\"具有更好的维护性和扩展性\",{\"1\":{\"784\":1}}],[\"具有良好的扩展性\",{\"1\":{\"581\":1}}],[\"具有较强的扩展性\",{\"1\":{\"576\":1}}],[\"具有不同分类维度的产品组合\",{\"1\":{\"557\":1}}],[\"具有广泛影响且值得阅读的java经典书籍\",{\"1\":{\"438\":1}}],[\"具有public修饰的字段\",{\"1\":{\"307\":1}}],[\"具有public访问权限的构造函数对象\",{\"1\":{\"306\":1}}],[\"具有和\",{\"1\":{\"151\":1}}],[\"具体原理参考\",{\"1\":{\"848\":1}}],[\"具体原型类\",{\"1\":{\"683\":1}}],[\"具体元素b的操作\",{\"1\":{\"838\":1}}],[\"具体元素a的操作\",{\"1\":{\"838\":1}}],[\"具体元素\",{\"1\":{\"838\":1}}],[\"具体访问者b访问\",{\"1\":{\"838\":2}}],[\"具体访问者a访问\",{\"1\":{\"838\":2}}],[\"具体访问者\",{\"1\":{\"838\":3}}],[\"具体来讲\",{\"1\":{\"809\":1}}],[\"具体来说\",{\"1\":{\"737\":1,\"772\":1}}],[\"具体子类\",{\"1\":{\"801\":2}}],[\"具体方法\",{\"1\":{\"801\":2,\"839\":1}}],[\"具体策略b的策略方法被访问\",{\"1\":{\"784\":1}}],[\"具体策略a的策略方法被访问\",{\"1\":{\"784\":1}}],[\"具体策略类\",{\"1\":{\"784\":2}}],[\"具体策略\",{\"1\":{\"784\":1}}],[\"具体要求如下\",{\"1\":{\"777\":1}}],[\"具体要怎么做呢\",{\"1\":{\"93\":1}}],[\"具体状态\",{\"1\":{\"776\":3}}],[\"具体代码如下所示\",{\"1\":{\"773\":1}}],[\"具体代码实现如下所示\",{\"1\":{\"627\":1}}],[\"具体如下所示\",{\"1\":{\"772\":1}}],[\"具体处理者2负责处理该请求\",{\"1\":{\"708\":1}}],[\"具体处理者1负责处理该请求\",{\"1\":{\"708\":1}}],[\"具体处理者角色\",{\"1\":{\"708\":2}}],[\"具体处理者\",{\"1\":{\"708\":1}}],[\"具体目标发生改变\",{\"1\":{\"672\":1}}],[\"具体目标\",{\"1\":{\"672\":1}}],[\"具体观察者2作出反应\",{\"1\":{\"672\":1}}],[\"具体观察者1作出反应\",{\"1\":{\"672\":1}}],[\"具体观察者1\",{\"1\":{\"672\":1}}],[\"具体观察者\",{\"1\":{\"672\":2}}],[\"具体主题\",{\"1\":{\"672\":1}}],[\"具体同事类2发出请求\",{\"1\":{\"656\":1}}],[\"具体同事类2收到请求\",{\"1\":{\"656\":1}}],[\"具体同事类1发出请求\",{\"1\":{\"656\":1}}],[\"具体同事类1收到请求\",{\"1\":{\"656\":1}}],[\"具体同事类\",{\"1\":{\"656\":3}}],[\"具体中介者的核心方法\",{\"1\":{\"659\":1}}],[\"具体中介者\",{\"1\":{\"656\":2}}],[\"具体迭代器\",{\"1\":{\"649\":2}}],[\"具体聚合\",{\"1\":{\"649\":2}}],[\"具体网站\",{\"1\":{\"636\":1}}],[\"具体享元角色\",{\"1\":{\"632\":1}}],[\"具体享元\",{\"1\":{\"632\":4}}],[\"具体工厂\",{\"1\":{\"612\":1,\"616\":1}}],[\"具体产品\",{\"1\":{\"608\":1,\"612\":1,\"616\":1}}],[\"具体哪条你来定\",{\"1\":{\"591\":1}}],[\"具体的实现类都依赖统一的接口定义\",{\"1\":{\"809\":1}}],[\"具体的实现都是由不同厂商来提供的\",{\"1\":{\"99\":1}}],[\"具体的状态类\",{\"1\":{\"779\":1}}],[\"具体的代码如下所示\",{\"1\":{\"769\":1}}],[\"具体的代码实现如下\",{\"1\":{\"768\":1}}],[\"具体的代码实现如下所示\",{\"1\":{\"768\":2,\"809\":1,\"812\":1,\"813\":1,\"814\":1}}],[\"具体的代码框架如下所示\",{\"1\":{\"626\":1}}],[\"具体的中介者类\",{\"1\":{\"659\":1}}],[\"具体的同事对象发出\",{\"1\":{\"659\":1}}],[\"具体的修饰者\",{\"1\":{\"585\":1}}],[\"具体装饰角色\",{\"1\":{\"580\":1}}],[\"具体装饰\",{\"1\":{\"580\":1}}],[\"具体构件角色\",{\"1\":{\"580\":1}}],[\"具体构件\",{\"1\":{\"580\":1}}],[\"具体命令\",{\"1\":{\"561\":1}}],[\"具体命令类\",{\"1\":{\"561\":1}}],[\"具体建造者\",{\"1\":{\"550\":1,\"551\":1}}],[\"具体实现化角色\",{\"1\":{\"538\":1}}],[\"具体实现化\",{\"1\":{\"538\":2}}],[\"具体实现类\",{\"1\":{\"532\":1,\"801\":1}}],[\"具体实现\",{\"1\":{\"532\":2,\"801\":1}}],[\"具体可以查看后文解释\",{\"1\":{\"285\":1}}],[\"具体可以参考下文中关于泛型数组的理解\",{\"1\":{\"285\":1}}],[\"具体错误原因请参考后文\",{\"1\":{\"284\":1}}],[\"具体看如下表格\",{\"1\":{\"125\":1}}],[\"具体厂商或者框架开发者实现\",{\"0\":{\"110\":1},\"1\":{\"108\":1}}],[\"具体日志库相关可以看这篇\",{\"1\":{\"104\":1}}],[\"语音提醒服务失败\",{\"1\":{\"874\":1}}],[\"语音校验码输入错误\",{\"1\":{\"874\":1}}],[\"语义不重复不遗漏\",{\"1\":{\"869\":1}}],[\"语义清晰的代码不需要额外的注释\",{\"1\":{\"853\":1}}],[\"语言规范建议的顺序出现\",{\"1\":{\"934\":1}}],[\"语言式的声明\",{\"0\":{\"921\":1}}],[\"语言编程规范的\",{\"1\":{\"876\":1}}],[\"语言是包括文字和图形的\",{\"1\":{\"823\":1}}],[\"语言\",{\"1\":{\"808\":1}}],[\"语言本身提供了\",{\"1\":{\"771\":1}}],[\"语言来实现一个简单的\",{\"1\":{\"623\":1}}],[\"语言保存数据的风格来写一个类\",{\"1\":{\"445\":1}}],[\"语言中所有错误与异常的超类\",{\"1\":{\"246\":1}}],[\"语句明确包含了覆盖所有可能性的枚举值\",{\"1\":{\"925\":1}}],[\"语句都包含了一个\",{\"1\":{\"925\":1}}],[\"语句组\",{\"1\":{\"922\":1,\"925\":2}}],[\"语句的箭头立即出现的情况下\",{\"1\":{\"907\":1}}],[\"语句的主体仅是一个不带括号的表达式\",{\"1\":{\"907\":1}}],[\"语句的例子\",{\"1\":{\"267\":1}}],[\"语句中的冒号\",{\"1\":{\"911\":1}}],[\"语句中\",{\"1\":{\"907\":2}}],[\"语句中不允许使用其它空行\",{\"1\":{\"892\":1}}],[\"语句和\",{\"1\":{\"905\":1}}],[\"语句块以一个简短的\",{\"1\":{\"958\":1}}],[\"语句块\",{\"1\":{\"955\":1}}],[\"语句块中的任何内容不做处理确实是合适的时候\",{\"1\":{\"950\":1}}],[\"语句块中的内容缩进\",{\"1\":{\"923\":1}}],[\"语句块中\",{\"1\":{\"924\":1}}],[\"语句块中可以捕获多个异常类型\",{\"1\":{\"256\":1}}],[\"语句块的基本格式如这个例子所示\",{\"1\":{\"955\":1}}],[\"语句块的花括号内是一个或多个\",{\"1\":{\"922\":1}}],[\"语句块的缩进规则适用于所有代码和注释\",{\"1\":{\"903\":1}}],[\"语句内部\",{\"1\":{\"901\":1}}],[\"语句以\",{\"1\":{\"892\":1}}],[\"语句应按以下方式排序\",{\"1\":{\"892\":1}}],[\"语句不允许换行\",{\"1\":{\"888\":1}}],[\"语句覆盖率达到70\",{\"1\":{\"860\":1}}],[\"语句删除了\",{\"1\":{\"780\":1}}],[\"语句来做状态判断\",{\"1\":{\"775\":1}}],[\"语句在执行的时候\",{\"1\":{\"766\":1}}],[\"语句运行得非常慢\",{\"1\":{\"766\":1}}],[\"语句处理异常\",{\"1\":{\"469\":1}}],[\"语句\",{\"0\":{\"264\":1,\"888\":1,\"889\":1,\"922\":1},\"1\":{\"186\":1,\"707\":1,\"770\":1,\"775\":1,\"780\":1,\"783\":2,\"886\":2,\"888\":1,\"891\":2,\"900\":1,\"905\":3,\"910\":1}}],[\"语句捕获并进行处理\",{\"1\":{\"146\":1}}],[\"语法中\",{\"1\":{\"808\":1}}],[\"语法来创建对象\",{\"1\":{\"623\":1}}],[\"语法\",{\"0\":{\"26\":1},\"1\":{\"13\":1,\"264\":1,\"455\":1}}],[\"语法进行了扩展\",{\"1\":{\"12\":1}}],[\"语法扩展\",{\"1\":{\"11\":1}}],[\"无返回\",{\"1\":{\"972\":2}}],[\"无返回数据\",{\"1\":{\"972\":1}}],[\"无效的用户输入\",{\"1\":{\"874\":1}}],[\"无权限使用\",{\"1\":{\"874\":1}}],[\"无泛型限制\",{\"1\":{\"872\":1}}],[\"无数次的故障都是因为没有设置超时时间\",{\"1\":{\"870\":1}}],[\"无log具体实现\",{\"1\":{\"869\":1}}],[\"无用字段增加网络消耗\",{\"1\":{\"866\":1}}],[\"无符号值\",{\"1\":{\"863\":4}}],[\"无符号值可以避免误存负数\",{\"1\":{\"863\":1}}],[\"无符号右移\",{\"1\":{\"203\":1}}],[\"无符号右移一位后变成下面的形式\",{\"1\":{\"90\":1}}],[\"无所适从\",{\"1\":{\"859\":1}}],[\"无谓浪费方法调用的开销\",{\"1\":{\"859\":1}}],[\"无谓增加编译器解析成本\",{\"1\":{\"848\":1}}],[\"无规范难以协同\",{\"1\":{\"843\":1}}],[\"无规矩不成方圆\",{\"1\":{\"843\":1}}],[\"无实体\",{\"1\":{\"835\":1}}],[\"无人接单失效\",{\"1\":{\"779\":1}}],[\"无意中重写了父类的方法\",{\"1\":{\"734\":1}}],[\"无须修改原有代码\",{\"1\":{\"648\":1}}],[\"无须关心请求的处理细节和请求的传递过程\",{\"1\":{\"707\":1}}],[\"无须关心其他实现类\",{\"1\":{\"612\":1}}],[\"无须关心自己处理的是单个对象\",{\"1\":{\"567\":1}}],[\"无须知道产品的具体创建过程\",{\"1\":{\"612\":1}}],[\"无因咖啡\",{\"1\":{\"581\":1,\"584\":5}}],[\"无需修改代码\",{\"1\":{\"690\":1}}],[\"无需知道如何创建的细节\",{\"1\":{\"682\":1}}],[\"无需解包和解析即可高效访问序列化数据\",{\"1\":{\"428\":1}}],[\"无需其他第三方库支持\",{\"1\":{\"414\":1}}],[\"无需重新部署\",{\"1\":{\"398\":1}}],[\"无限定的变量用object\",{\"1\":{\"289\":1}}],[\"无限制的到处跑\",{\"1\":{\"848\":1}}],[\"无限制类型擦除\",{\"1\":{\"287\":1}}],[\"无限制通配符\",{\"1\":{\"284\":1}}],[\"无法遵守列限制的代码行\",{\"1\":{\"905\":1}}],[\"无法用细粒度的异常进行catch\",{\"1\":{\"868\":1}}],[\"无法通过预检查的异常除外\",{\"1\":{\"858\":1}}],[\"无法解锁\",{\"1\":{\"851\":1}}],[\"无法提供定制服务\",{\"1\":{\"722\":1}}],[\"无法在运行时动态的添加第三方\",{\"1\":{\"677\":1}}],[\"无法获取父类的私有字段\",{\"1\":{\"307\":1}}],[\"无法约束其中的类型\",{\"1\":{\"279\":1}}],[\"无法处理\",{\"1\":{\"268\":1}}],[\"无法处理的错误\",{\"1\":{\"146\":1}}],[\"无情丢弃掉try块中的返回点\",{\"1\":{\"273\":1,\"858\":1}}],[\"无论测试用例里的其他方法有没有抛出异常\",{\"1\":{\"976\":1}}],[\"无论加锁是否成功\",{\"1\":{\"851\":1}}],[\"无论是开发哪种软件产品\",{\"1\":{\"819\":1}}],[\"无论何种类型\",{\"1\":{\"644\":1}}],[\"无论何时定义一个泛型\",{\"1\":{\"289\":1}}],[\"无论子类需不需要\",{\"1\":{\"545\":1}}],[\"无论你选择了什么工具\",{\"1\":{\"462\":1}}],[\"无论创建多少个实例对象\",{\"1\":{\"302\":1}}],[\"无论发生什么异常\",{\"1\":{\"275\":1}}],[\"无论在\",{\"1\":{\"182\":1}}],[\"无论调用多少次结果不变\",{\"1\":{\"181\":1}}],[\"反过来\",{\"1\":{\"866\":1}}],[\"反复重建哈希表和数据迁移\",{\"1\":{\"850\":1}}],[\"反复出现\",{\"1\":{\"796\":1}}],[\"反编译出的字节码文件显示每次循环都会new出一个stringbuilder对象\",{\"1\":{\"848\":1}}],[\"反例中的执行结果肯定会出乎大家的意料\",{\"1\":{\"850\":1}}],[\"反例\",{\"1\":{\"843\":1,\"845\":8,\"846\":2,\"847\":2,\"848\":7,\"849\":3,\"850\":9,\"851\":1,\"852\":8,\"853\":2,\"854\":2,\"857\":1,\"858\":3,\"860\":2,\"861\":1,\"864\":1,\"865\":2,\"866\":1,\"869\":1,\"871\":2}}],[\"反之亦然\",{\"1\":{\"850\":1}}],[\"反之\",{\"1\":{\"814\":1}}],[\"反馈\",{\"1\":{\"779\":1}}],[\"反序列化注入\",{\"1\":{\"861\":1}}],[\"反序列化\",{\"1\":{\"689\":1}}],[\"反序列化需要一个无参构造函数\",{\"1\":{\"202\":1}}],[\"反应\",{\"1\":{\"672\":1}}],[\"反映的是class\",{\"1\":{\"306\":1}}],[\"反射调用多次生成新代理accessor\",{\"1\":{\"313\":1}}],[\"反射调用流程小结\",{\"0\":{\"313\":1}}],[\"反射使用软引用relectiondata缓存class信息\",{\"1\":{\"313\":1}}],[\"反射也是考虑了线程安全的\",{\"1\":{\"313\":1}}],[\"反射类及反射方法的获取\",{\"1\":{\"313\":1}}],[\"反射获取方法\",{\"0\":{\"311\":1}}],[\"反射获取类信息\",{\"1\":{\"310\":1}}],[\"反射获取类实例\",{\"0\":{\"310\":1}}],[\"反射机制调用目标对象的方法\",{\"1\":{\"700\":1}}],[\"反射机制执行的流程\",{\"0\":{\"309\":1}}],[\"反射机制详解\",{\"0\":{\"300\":1},\"1\":{\"145\":1}}],[\"反射的字段可能是一个类\",{\"1\":{\"307\":1}}],[\"反射的使用\",{\"0\":{\"304\":1}}],[\"反射的相关知识\",{\"1\":{\"300\":1}}],[\"反射就是把java类中的各种成分映射成一个个的java对象\",{\"1\":{\"301\":1}}],[\"反射基础\",{\"0\":{\"301\":1}}],[\"反射包java\",{\"1\":{\"233\":1}}],[\"反射可以提供运行时的类信息\",{\"1\":{\"145\":1}}],[\"反射\",{\"0\":{\"145\":1},\"1\":{\"301\":1,\"622\":1,\"623\":1}}],[\"反思自己的行为是否妥当\",{\"1\":{\"36\":1}}],[\"反思\",{\"1\":{\"36\":1}}],[\"非商业性使用\",{\"1\":{\"993\":1}}],[\"非必需的\",{\"0\":{\"962\":1},\"1\":{\"959\":1,\"962\":1}}],[\"非赋值运算符时\",{\"1\":{\"907\":1}}],[\"非空语句块\",{\"0\":{\"901\":1},\"1\":{\"902\":1,\"903\":1}}],[\"非功能性需求等问题要相应的文档来完整地呈现\",{\"1\":{\"871\":1}}],[\"非功能性需求是指安全性\",{\"1\":{\"871\":1}}],[\"非setter\",{\"1\":{\"845\":1}}],[\"非得给每个类都定义接口\",{\"1\":{\"810\":1}}],[\"非直接朋友\",{\"1\":{\"741\":1}}],[\"非对终结符表达式的处理\",{\"1\":{\"642\":1}}],[\"非终结符表达式类\",{\"1\":{\"642\":1}}],[\"非终结符表达式\",{\"1\":{\"642\":1}}],[\"非享元角色\",{\"1\":{\"632\":1}}],[\"非享元信息是\",{\"1\":{\"632\":1}}],[\"非享元的外部状态以参数的形式通过该方法传入\",{\"1\":{\"632\":1}}],[\"非享元的外部状态以参数的形式通过方法传入\",{\"1\":{\"632\":1}}],[\"非享元\",{\"1\":{\"632\":1}}],[\"非常罕见\",{\"1\":{\"952\":1}}],[\"非常量字段名通常是名词或者名词短语\",{\"1\":{\"943\":1}}],[\"非常量字段名\",{\"0\":{\"943\":1},\"1\":{\"943\":1}}],[\"非常长的标识符\",{\"1\":{\"905\":1}}],[\"非常有帮助\",{\"1\":{\"851\":1}}],[\"非常累赘的事情\",{\"1\":{\"847\":1}}],[\"非常的方便\",{\"1\":{\"797\":1}}],[\"非常复杂\",{\"1\":{\"655\":1}}],[\"非常\",{\"1\":{\"576\":1}}],[\"非常灵活的业务流程管理框架\",{\"1\":{\"435\":1}}],[\"非常稳固\",{\"1\":{\"434\":1}}],[\"非xml\",{\"1\":{\"385\":1}}],[\"非法的时间戳参数\",{\"1\":{\"874\":1}}],[\"非法\",{\"1\":{\"874\":1}}],[\"非法数据\",{\"1\":{\"860\":1}}],[\"非法创建\",{\"1\":{\"285\":2,\"294\":2}}],[\"非法参数异常\",{\"1\":{\"261\":1}}],[\"非法参数等\",{\"1\":{\"245\":1}}],[\"非运行时异常\",{\"1\":{\"248\":1}}],[\"非代码性错误\",{\"1\":{\"247\":1}}],[\"非\",{\"0\":{\"885\":1},\"1\":{\"210\":1}}],[\"非静态内部类能够访问外部类的静态和非静态成员\",{\"1\":{\"201\":1}}],[\"非静态内部类依赖于外部类的实例\",{\"1\":{\"144\":1}}],[\"非受检异常\",{\"1\":{\"146\":1}}],[\"非要写成下面这样\",{\"1\":{\"90\":1}}],[\"静态样式检查详解\",{\"0\":{\"964\":1}}],[\"静态成员\",{\"0\":{\"951\":1}}],[\"静态或者其它形式\",{\"1\":{\"943\":1}}],[\"静态初始化代码块\",{\"1\":{\"910\":1}}],[\"静态类或静态方法加下划线\",{\"1\":{\"826\":1}}],[\"静态结构图\",{\"1\":{\"822\":1}}],[\"静态代码块\",{\"0\":{\"753\":1},\"1\":{\"751\":1,\"753\":1}}],[\"静态代理和\",{\"1\":{\"702\":1}}],[\"静态代理优缺点\",{\"0\":{\"696\":1}}],[\"静态代理应用实例\",{\"0\":{\"695\":1}}],[\"静态代理在使用时\",{\"1\":{\"694\":1}}],[\"静态代理基本介绍\",{\"0\":{\"694\":1}}],[\"静态代理\",{\"0\":{\"693\":1},\"1\":{\"692\":1,\"695\":1}}],[\"静态常量\",{\"0\":{\"752\":1},\"1\":{\"751\":1,\"752\":2,\"760\":1}}],[\"静态工厂模式\",{\"1\":{\"610\":2}}],[\"静态工厂方法模式\",{\"1\":{\"608\":1}}],[\"静态\",{\"1\":{\"307\":1,\"972\":2}}],[\"静态导包\",{\"1\":{\"144\":1}}],[\"静态内部类以常规方式导入\",{\"1\":{\"893\":1}}],[\"静态内部类特点实现延迟加载\",{\"1\":{\"758\":1}}],[\"静态内部类方式在\",{\"1\":{\"758\":1}}],[\"静态内部类完成\",{\"1\":{\"758\":1}}],[\"静态内部类不能访问外部类的非静态成员\",{\"1\":{\"201\":1}}],[\"静态内部类不能访问外部类的非静态的变量和方法\",{\"1\":{\"144\":1}}],[\"静态内部类不需要有指向外部类的引用\",{\"1\":{\"201\":1}}],[\"静态内部类与顶级类有什么区别\",{\"0\":{\"184\":1}}],[\"静态内部类\",{\"0\":{\"758\":1},\"1\":{\"144\":1,\"751\":1}}],[\"静态语句块在类初始化时运行一次\",{\"1\":{\"144\":1}}],[\"静态语句块\",{\"1\":{\"144\":4}}],[\"静态方法这种实现思路\",{\"1\":{\"769\":1}}],[\"静态方法实现方式\",{\"1\":{\"769\":1}}],[\"静态方法在类加载的时候就存在了\",{\"1\":{\"144\":1}}],[\"静态方法\",{\"1\":{\"144\":1,\"618\":1,\"750\":1}}],[\"静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序\",{\"1\":{\"144\":1}}],[\"静态变量和静态语句块优先于实例变量和普通语句块\",{\"1\":{\"144\":1}}],[\"静态变量在内存中只存在一份\",{\"1\":{\"144\":1}}],[\"静态变量仍在堆中\",{\"1\":{\"125\":1}}],[\"静态变量\",{\"1\":{\"125\":2,\"144\":6}}],[\"静态变量移除\",{\"1\":{\"125\":1}}],[\"静态变量存放在永久代上\",{\"1\":{\"125\":1}}],[\"静态变量prefix就是\",{\"1\":{\"114\":1}}],[\"声明变量\",{\"1\":{\"981\":1}}],[\"声明类型尽量是抽象类或接口\",{\"1\":{\"729\":1}}],[\"声明类不允许被继承\",{\"1\":{\"143\":1}}],[\"声明一个包含接受操作\",{\"1\":{\"838\":1}}],[\"声明一个克隆自己的接口\",{\"1\":{\"683\":1}}],[\"声明一个异常\",{\"1\":{\"260\":1}}],[\"声明执行命令的接口\",{\"1\":{\"561\":1}}],[\"声明object的泛型对象\",{\"1\":{\"284\":1}}],[\"声明string的泛型对象\",{\"1\":{\"284\":1}}],[\"声明integer的泛型对象\",{\"1\":{\"284\":1}}],[\"声明接口对象\",{\"1\":{\"282\":1}}],[\"声明\",{\"1\":{\"266\":1,\"448\":1}}],[\"声明的任何异常必须是被覆盖方法所声明异常的同类或子类\",{\"1\":{\"252\":1}}],[\"声明为static和transient类型的数据不能被序列化\",{\"1\":{\"202\":1}}],[\"声明方法不能被子类重写\",{\"1\":{\"143\":1}}],[\"声明数据为常量\",{\"1\":{\"143\":1}}],[\"书上讲到\",{\"1\":{\"141\":1}}],[\"拷贝对象和原始对象的引用类型引用不同对象\",{\"1\":{\"141\":1}}],[\"拷贝对象和原始对象的引用类型引用同一个对象\",{\"1\":{\"141\":1}}],[\"深入浅出的生动表达力\",{\"1\":{\"871\":1}}],[\"深入浅出地将计算机基础\",{\"1\":{\"843\":1}}],[\"深入讨论\",{\"0\":{\"689\":1}}],[\"深入理解泛型\",{\"0\":{\"286\":1}}],[\"深入理解异常\",{\"0\":{\"274\":1}}],[\"深入理解注解\",{\"0\":{\"235\":1}}],[\"深入理解\",{\"1\":{\"133\":1}}],[\"深克隆\",{\"1\":{\"682\":1}}],[\"深拷贝应用实例\",{\"1\":{\"689\":1}}],[\"深拷贝实现方式\",{\"1\":{\"689\":2}}],[\"深拷贝基本介绍\",{\"1\":{\"689\":1}}],[\"深拷贝\",{\"1\":{\"141\":1,\"689\":2}}],[\"信息\",{\"0\":{\"887\":1}}],[\"信息安全专业\",{\"1\":{\"650\":2}}],[\"信息工程好学\",{\"1\":{\"574\":1}}],[\"信息工程\",{\"1\":{\"574\":1}}],[\"信息工程学院是以\",{\"1\":{\"650\":1}}],[\"信息工程学院\",{\"1\":{\"574\":2,\"650\":1}}],[\"信息就会丢失\",{\"1\":{\"139\":1}}],[\"信息容器\",{\"1\":{\"14\":2}}],[\"进一步解读就是哪些代码需要有单元测试覆盖\",{\"1\":{\"992\":1}}],[\"进一步缩短了设计时间\",{\"1\":{\"823\":1}}],[\"进入业务代码块之前\",{\"1\":{\"851\":1}}],[\"进而抛出异常\",{\"1\":{\"845\":1}}],[\"进程在使用这个单例对象的时候\",{\"1\":{\"772\":1}}],[\"进程间也唯一\",{\"1\":{\"772\":1}}],[\"进程间不唯一\",{\"1\":{\"771\":1,\"772\":1}}],[\"进程唯一\",{\"1\":{\"771\":4,\"772\":3}}],[\"进程执行到这条语句的时候会创建一个新的进程\",{\"1\":{\"770\":1}}],[\"进程之间是不共享地址空间的\",{\"1\":{\"770\":1}}],[\"进程就一条一条地执行可执行文件中包含的代码\",{\"1\":{\"770\":1}}],[\"进程的堆栈信息\",{\"1\":{\"485\":1}}],[\"进制字符串来说有很多有用的编\",{\"1\":{\"465\":1}}],[\"进制的整数\",{\"1\":{\"139\":1}}],[\"进制的某一位\",{\"1\":{\"139\":1}}],[\"进类加载\",{\"1\":{\"310\":1}}],[\"进行数据库的连接等\",{\"1\":{\"976\":1}}],[\"进行换行时\",{\"1\":{\"908\":1}}],[\"进行<exclude>排除jar包\",{\"1\":{\"869\":1}}],[\"进行dependency\",{\"1\":{\"869\":1}}],[\"进行限定\",{\"1\":{\"865\":1}}],[\"进行不必要的try\",{\"1\":{\"852\":1}}],[\"进行遍历去重或者判断包含操作\",{\"1\":{\"850\":1}}],[\"进行时间比较时\",{\"1\":{\"849\":1}}],[\"进行判断\",{\"1\":{\"848\":1}}],[\"进行多种操作时\",{\"1\":{\"841\":1}}],[\"进行级联删除\",{\"1\":{\"832\":1}}],[\"进行初始化时\",{\"1\":{\"850\":1}}],[\"进行初始化\",{\"1\":{\"700\":1}}],[\"进行单独处理\",{\"1\":{\"689\":1}}],[\"进行拷贝\",{\"1\":{\"689\":1}}],[\"进行解耦\",{\"1\":{\"660\":1}}],[\"进行解释执行\",{\"1\":{\"644\":1}}],[\"进行递归组合\",{\"1\":{\"590\":1}}],[\"进行适配~~\",{\"1\":{\"528\":1}}],[\"进行增量构建\",{\"1\":{\"385\":1}}],[\"进行\",{\"1\":{\"312\":1}}],[\"进行新创建\",{\"1\":{\"312\":1}}],[\"进行调用的\",{\"1\":{\"312\":1}}],[\"进行调用\",{\"1\":{\"310\":1}}],[\"进行缓存保存\",{\"1\":{\"310\":1}}],[\"进行方法调用\",{\"1\":{\"309\":1}}],[\"进行动态加载类\",{\"1\":{\"309\":1}}],[\"进行比较\",{\"1\":{\"284\":1,\"848\":1}}],[\"进行简化\",{\"1\":{\"260\":1}}],[\"进行少许修补\",{\"1\":{\"260\":1}}],[\"进行操作就会产生一条操作日志存入数据库\",{\"1\":{\"242\":1}}],[\"进行通信\",{\"1\":{\"132\":1}}],[\"进行同步\",{\"1\":{\"124\":1}}],[\"进行引用\",{\"1\":{\"33\":2}}],[\"即如果我们没有重写\",{\"1\":{\"996\":1}}],[\"即如果一个方法可能出现受可查异常\",{\"1\":{\"252\":1}}],[\"即公开\",{\"1\":{\"972\":2}}],[\"即公共\",{\"1\":{\"972\":1}}],[\"即每行一个注解\",{\"1\":{\"928\":1}}],[\"即每个元素有多个访问者对象访问\",{\"1\":{\"798\":1}}],[\"即除初始化方法和注释之外\",{\"1\":{\"877\":1}}],[\"即dry原则\",{\"1\":{\"871\":1}}],[\"即diamond\",{\"1\":{\"850\":1}}],[\"即一个连接对应于一个fd\",{\"1\":{\"870\":1}}],[\"即一个类\",{\"1\":{\"741\":1}}],[\"即一个类应该只负责一项职责\",{\"1\":{\"716\":1}}],[\"即为级联更新\",{\"1\":{\"865\":1}}],[\"即建立组合索引idx\",{\"1\":{\"864\":1}}],[\"即index的简称\",{\"1\":{\"863\":1}}],[\"即unique\",{\"1\":{\"863\":1}}],[\"即primary\",{\"1\":{\"863\":1}}],[\"即是因为对于危险字符\",{\"1\":{\"861\":1}}],[\"即默认值\",{\"1\":{\"850\":1}}],[\"即loaderfactor\",{\"1\":{\"850\":1}}],[\"即<>\",{\"1\":{\"850\":1}}],[\"即频繁往外读取内容的\",{\"1\":{\"850\":1}}],[\"即正负x\",{\"1\":{\"848\":1}}],[\"即在当前包下单独的constant目录下\",{\"1\":{\"846\":1}}],[\"即在当前子工程的constant目录下\",{\"1\":{\"846\":1}}],[\"即key是\",{\"1\":{\"846\":1}}],[\"即未经预先定义的常量\",{\"1\":{\"846\":1}}],[\"即首先在客户端程序中\",{\"1\":{\"839\":1}}],[\"即删除\",{\"1\":{\"832\":1}}],[\"即删除<>及其包围的部分\",{\"1\":{\"287\":1}}],[\"即双向关系或单向关系\",{\"1\":{\"830\":1}}],[\"即便某个具体的类或者模块设计得不怎么合理\",{\"1\":{\"816\":1}}],[\"即便单例有这么多问题\",{\"1\":{\"769\":1}}],[\"即解释器\",{\"1\":{\"798\":1}}],[\"即客户端通过代理间接地访问该对象\",{\"1\":{\"798\":1}}],[\"即增加其额外的功能\",{\"1\":{\"798\":1}}],[\"即增加其额外功能\",{\"1\":{\"579\":1}}],[\"即定义\",{\"1\":{\"783\":1}}],[\"即硬编码\",{\"1\":{\"783\":1}}],[\"即懒汉式\",{\"1\":{\"754\":1,\"755\":1,\"756\":1}}],[\"即当我们给类增加新功能的时候\",{\"1\":{\"738\":1}}],[\"即对被测对象进行测试时锁需要的一切东西\",{\"1\":{\"997\":1}}],[\"即对扩展开放\",{\"1\":{\"738\":1}}],[\"即对注解了\",{\"1\":{\"242\":1}}],[\"即类的扩展不会给已有的系统引入新的错误\",{\"1\":{\"733\":1}}],[\"即类的完整名字\",{\"1\":{\"305\":1}}],[\"即将\",{\"1\":{\"718\":1}}],[\"即不能抽奖的状态\",{\"1\":{\"778\":1}}],[\"即不会执行目标对象额外的业务方法\",{\"1\":{\"703\":1}}],[\"即不相等的对象应当均匀分布到所有可能的散列值上\",{\"1\":{\"139\":1}}],[\"即代理对象\",{\"1\":{\"703\":1}}],[\"即扩展目标对象的功能\",{\"1\":{\"692\":1}}],[\"即通过代理对象访问目标对象\",{\"1\":{\"692\":1}}],[\"即管理\",{\"1\":{\"679\":1}}],[\"即根据当前的状态得到\",{\"1\":{\"667\":1}}],[\"即遍历\",{\"1\":{\"644\":1}}],[\"即满足开闭原则\",{\"1\":{\"612\":1}}],[\"即可\",{\"1\":{\"610\":1,\"791\":1,\"847\":1,\"850\":1}}],[\"即含被装饰者\",{\"1\":{\"585\":1}}],[\"即装饰对象\",{\"1\":{\"580\":1}}],[\"即插即用\",{\"1\":{\"579\":1}}],[\"即空执行\",{\"1\":{\"562\":1}}],[\"即宏命令\",{\"1\":{\"560\":1}}],[\"即命名\",{\"1\":{\"560\":1}}],[\"即充当了指挥者角色\",{\"1\":{\"556\":1}}],[\"即时消息\",{\"1\":{\"546\":1}}],[\"即需要有这样的应用场景\",{\"1\":{\"544\":1}}],[\"即目标对象\",{\"1\":{\"694\":1}}],[\"即目标\",{\"1\":{\"528\":1}}],[\"即被适配者\",{\"1\":{\"524\":1,\"528\":1}}],[\"即返回实例了\",{\"1\":{\"310\":1}}],[\"即返回方法的名称\",{\"1\":{\"308\":1}}],[\"即返回方法的参数类型组成的数组\",{\"1\":{\"308\":1}}],[\"即返回constructor\",{\"1\":{\"306\":1}}],[\"即方法的返回类型\",{\"1\":{\"308\":1}}],[\"即设置其可访问性\",{\"1\":{\"307\":1}}],[\"即包括public\",{\"1\":{\"305\":1}}],[\"即形如<t>和<\",{\"1\":{\"287\":1}}],[\"即父类\",{\"1\":{\"287\":1}}],[\"即用a类型代替类型参数\",{\"1\":{\"284\":1}}],[\"即java在语法上支持泛型\",{\"1\":{\"278\":1,\"287\":1}}],[\"即catch部分\",{\"1\":{\"275\":1}}],[\"即error\",{\"1\":{\"252\":1}}],[\"即使它不包含任何代码\",{\"1\":{\"925\":1}}],[\"即使它们的语句主体是空的或者仅包含一条语句\",{\"1\":{\"900\":1}}],[\"即使它什么代码也没有\",{\"1\":{\"852\":1}}],[\"即使这些方法之间的修饰符\",{\"1\":{\"897\":1}}],[\"即使所有类属性名与数据库字段一一对应\",{\"1\":{\"866\":1}}],[\"即使双表join也要注意表索引\",{\"1\":{\"864\":1}}],[\"即使被调用方法返回空集合或者空对象\",{\"1\":{\"858\":1}}],[\"即使代码编译期是正确的\",{\"1\":{\"858\":1}}],[\"即使隔很长时间\",{\"1\":{\"853\":1}}],[\"即使只有一行代码\",{\"1\":{\"852\":1}}],[\"即使是自己过段时间也会遗忘的\",{\"1\":{\"992\":1}}],[\"即使是\",{\"1\":{\"945\":1}}],[\"即使是组合字段\",{\"1\":{\"864\":1}}],[\"即使是public也是能够通过编译\",{\"1\":{\"845\":1}}],[\"即使是最好的开发者\",{\"1\":{\"484\":1}}],[\"即使纯拼音命名方式也要避免采用\",{\"1\":{\"845\":1}}],[\"即使两个类有依赖关系\",{\"1\":{\"741\":1}}],[\"即使用\",{\"1\":{\"573\":1,\"600\":1}}],[\"即使在应用层做了非常完善的校验控制\",{\"1\":{\"864\":1}}],[\"即使在\",{\"1\":{\"485\":1}}],[\"即使遵循着最佳实践的原则\",{\"1\":{\"484\":1}}],[\"即使你的\",{\"1\":{\"445\":1}}],[\"即使你在使用该静态方法的使用t是arrayindexoutofbounds\",{\"1\":{\"297\":1}}],[\"即使一些有经验的开发者也需要花费很多时间来思考如何处理异常\",{\"1\":{\"262\":1}}],[\"即使没有用try\",{\"1\":{\"248\":1}}],[\"即使java的接口可以实现多继承\",{\"1\":{\"237\":1}}],[\"即使student类没有显示地被注解\",{\"1\":{\"230\":1}}],[\"即使整个系统不可用\",{\"1\":{\"209\":1}}],[\"即\",{\"1\":{\"227\":1,\"228\":1,\"281\":1,\"284\":1,\"312\":1,\"527\":1,\"554\":2,\"556\":1,\"567\":1,\"609\":1,\"648\":1,\"682\":1,\"695\":1,\"700\":1,\"714\":1,\"721\":1,\"761\":1,\"788\":1,\"797\":5,\"819\":1}}],[\"即支持面向对象也支持面向过程\",{\"1\":{\"151\":1}}],[\"即子类对象必须能够替换掉所有父类对象\",{\"1\":{\"133\":1}}],[\"将需要进行测试的类列表作作为参数传入\",{\"1\":{\"999\":1}}],[\"将比较两个数组\",{\"1\":{\"978\":1}}],[\"将所有单词合并为一个标识符\",{\"1\":{\"947\":1}}],[\"将所有的创建逻辑都放到一个工厂类中\",{\"1\":{\"614\":1}}],[\"将所有的泛型表示\",{\"1\":{\"278\":1,\"287\":1}}],[\"将短语划分为单词\",{\"1\":{\"947\":1}}],[\"将短语转换为纯\",{\"1\":{\"947\":1}}],[\"将或可能继续执行到下一个语句组\",{\"1\":{\"924\":1}}],[\"将原本可以合法写在一行的代码拆分成多行\",{\"1\":{\"906\":1}}],[\"将原来不兼容的两个类融合在一起\",{\"1\":{\"590\":1}}],[\"将在\",{\"1\":{\"901\":1,\"932\":1}}],[\"将较慢的服务与主线程池隔离开\",{\"1\":{\"870\":1}}],[\"将执行结果作为method2的输入\",{\"1\":{\"860\":1}}],[\"将错误日志和业务日志分开放\",{\"1\":{\"859\":1}}],[\"将其转化为用户可以理解的内容\",{\"1\":{\"858\":1}}],[\"将设计模式体现在名字中\",{\"1\":{\"845\":1}}],[\"将具体状态作为参数传递\",{\"1\":{\"839\":1}}],[\"将观众分为男人和女人\",{\"1\":{\"839\":1}}],[\"将作用于某种数据结构中的各元素的操作分离出来封装成独立的类\",{\"1\":{\"837\":1}}],[\"将事物之间的联系归纳为\",{\"1\":{\"827\":1}}],[\"将依赖老接口的代码改为调用新接口\",{\"1\":{\"818\":1}}],[\"将父类的实现细节暴露给了子类\",{\"1\":{\"812\":1}}],[\"将父类的泛型类型限定为date\",{\"1\":{\"291\":1}}],[\"将图片存储到阿里云的流程\",{\"1\":{\"809\":1}}],[\"将容易变的部分抽象出来\",{\"1\":{\"805\":1}}],[\"将容易产生问题的\",{\"1\":{\"780\":1}}],[\"将算法的一些步骤延迟到子类中\",{\"1\":{\"798\":1}}],[\"将抽象与实现分离\",{\"1\":{\"798\":1}}],[\"将一个请求封装为一个对象\",{\"1\":{\"798\":1}}],[\"将一个类的接口转换成客户希望的另外一个接口\",{\"1\":{\"798\":1}}],[\"将一个类的接口转换成另一种接口\",{\"1\":{\"520\":1}}],[\"将一个复杂对象分解成多个相对简单的部分\",{\"1\":{\"798\":1}}],[\"将一个对象作为原型\",{\"1\":{\"798\":1}}],[\"将当前状态设置为\",{\"1\":{\"779\":1}}],[\"将状态设置成可以抽奖状态\",{\"1\":{\"778\":1}}],[\"将状态转换显示化\",{\"1\":{\"775\":1}}],[\"将这些所有可能发生的情况全都考虑到\",{\"1\":{\"775\":1}}],[\"将这些对象连接成一条链\",{\"1\":{\"591\":1}}],[\"将这个执行文件从磁盘加载到自己的进程地址空间\",{\"1\":{\"770\":1}}],[\"将参数放到另外一个全局变量中\",{\"1\":{\"768\":1}}],[\"将参数放到\",{\"1\":{\"768\":1}}],[\"将输出学院的员工方法\",{\"1\":{\"743\":1}}],[\"将引用其他对象的次数降到最低\",{\"1\":{\"741\":1}}],[\"将臃肿庞大的接口分解为多个粒度小的接口\",{\"1\":{\"722\":1}}],[\"将接口和实现相分离\",{\"1\":{\"810\":1}}],[\"将接口\",{\"1\":{\"721\":1,\"723\":1}}],[\"将前面的案例用\",{\"1\":{\"703\":1}}],[\"将前面的静态代理改进成动态代理模式\",{\"1\":{\"700\":1}}],[\"将最新的信息推送给接入方\",{\"1\":{\"676\":1,\"678\":1}}],[\"将自己放入到\",{\"1\":{\"659\":1}}],[\"将给中介者对象\",{\"1\":{\"659\":1}}],[\"将大大降低它们之间的\",{\"1\":{\"655\":1}}],[\"将工厂抽象成两层\",{\"1\":{\"616\":1}}],[\"将复杂逻辑判断的结果赋值给一个有意义的布尔变量名\",{\"1\":{\"852\":1}}],[\"将复杂的创建逻辑拆分到多个工厂类中\",{\"1\":{\"614\":1}}],[\"将复杂产品的创建步骤分解在不同的方法中\",{\"1\":{\"557\":1}}],[\"将披萨项目的实例化功能抽象成抽象方法\",{\"1\":{\"613\":1}}],[\"将对象组合成树状层次结构\",{\"1\":{\"798\":1}}],[\"将对象组合成树状结构以表示\",{\"1\":{\"567\":1}}],[\"将对象的创建与使用分离\",{\"1\":{\"798\":1}}],[\"将对象的创建和使用分离\",{\"1\":{\"620\":1}}],[\"将对象解耦\",{\"1\":{\"717\":1}}],[\"将对象间的一对多关联转变为一对一的关联\",{\"1\":{\"655\":1}}],[\"将对象之间的通信关联关系封装到一个中介类中单独处理\",{\"1\":{\"591\":1}}],[\"将请求封装成命令\",{\"1\":{\"591\":1}}],[\"将两个能够独立变化的部分分离开来\",{\"1\":{\"590\":1}}],[\"将整体与局部\",{\"1\":{\"590\":1}}],[\"将调料内置到\",{\"1\":{\"583\":1}}],[\"将学院加入到\",{\"1\":{\"574\":1}}],[\"将学院看做是学校的子类\",{\"1\":{\"573\":1}}],[\"将来实际业务中\",{\"1\":{\"574\":1}}],[\"将管理子构件的方法移到树枝构件中\",{\"1\":{\"570\":1}}],[\"将发起请求的对象与执行请求的对象解耦\",{\"1\":{\"564\":1}}],[\"将多个命令装配成一个组合命令\",{\"1\":{\"560\":1}}],[\"将军\",{\"1\":{\"560\":2}}],[\"将军发布命令\",{\"1\":{\"560\":1}}],[\"将产品本身与产品的创建过程解耦\",{\"1\":{\"557\":1}}],[\"将产品\",{\"1\":{\"555\":1}}],[\"将产品和产品建造的过程解耦\",{\"1\":{\"554\":1}}],[\"将建造的流程写好\",{\"1\":{\"555\":1}}],[\"将实现与抽象放在两个不同的类层次中\",{\"1\":{\"537\":1}}],[\"将目标类和适配者类解耦\",{\"1\":{\"518\":1}}],[\"将某个类的接口转换成客户端期望的另一个接口表示\",{\"1\":{\"518\":1}}],[\"将不同的状态引入独立的对象中会使得状态转换变得更加明确\",{\"1\":{\"775\":1}}],[\"将不同的消息传输api整合在一起\",{\"1\":{\"414\":1}}],[\"将不知道如何处理的异常继续传递下去\",{\"1\":{\"252\":1}}],[\"将jar\",{\"1\":{\"401\":1}}],[\"将jar包装为轻量级本机windows可执行程序\",{\"1\":{\"401\":1}}],[\"将常见编程错误作为运行时错误报告\",{\"1\":{\"388\":1}}],[\"将从jvm中读取的内容\",{\"1\":{\"310\":1}}],[\"将此对象的\",{\"1\":{\"307\":1}}],[\"将指定对象变量上此\",{\"1\":{\"307\":1}}],[\"将第二种情况拓展成下面的形式\",{\"1\":{\"290\":1}}],[\"将第一种情况拓展成下面的形式\",{\"1\":{\"290\":1}}],[\"将要被监听的代码\",{\"1\":{\"251\":1}}],[\"将终止线程\",{\"1\":{\"247\":1}}],[\"将导致应用程序中断\",{\"1\":{\"198\":1}}],[\"将字符串设置为不可变可以允许多个客户端之间共享相同的字符串\",{\"1\":{\"169\":1}}],[\"将会占用比较大的内存资源\",{\"1\":{\"663\":1}}],[\"将会导致调试非常复杂\",{\"1\":{\"645\":1}}],[\"将会返回什么\",{\"0\":{\"167\":1}}],[\"将会出现什么现象\",{\"0\":{\"161\":1}}],[\"将\",{\"1\":{\"138\":1,\"534\":2,\"613\":1,\"947\":1}}],[\"五花八门的错误码会人为地增加排查问题的难度\",{\"1\":{\"843\":1}}],[\"五子棋\",{\"1\":{\"631\":1}}],[\"五\",{\"0\":{\"849\":1,\"862\":1},\"1\":{\"138\":1}}],[\"四位数字编号从\",{\"1\":{\"857\":1}}],[\"四个部分的涉众对象分别是浏览器\",{\"1\":{\"854\":1}}],[\"四个属性\",{\"1\":{\"778\":1}}],[\"四人组\",{\"1\":{\"795\":1}}],[\"四处\",{\"1\":{\"738\":1}}],[\"四则运算问题\",{\"0\":{\"643\":1}}],[\"四\",{\"0\":{\"848\":1,\"861\":1,\"866\":1},\"1\":{\"138\":1}}],[\"三是编写完功能代码再写单元测试\",{\"1\":{\"991\":1}}],[\"三是增加binlog存储\",{\"1\":{\"866\":1}}],[\"三方库\",{\"1\":{\"873\":1}}],[\"三目运算的自动拆箱\",{\"1\":{\"872\":1}}],[\"三目运算符condition\",{\"1\":{\"852\":1}}],[\"三目运算符的左右两边都需要加一个空格\",{\"1\":{\"847\":1}}],[\"三级宏观错误码\",{\"1\":{\"857\":1}}],[\"三大类\",{\"1\":{\"843\":1}}],[\"三大特性\",{\"0\":{\"208\":1}}],[\"三个条件如下\",{\"1\":{\"850\":1}}],[\"三个模块只需要依赖数据存储一个模块即可\",{\"1\":{\"818\":1}}],[\"三个模块都要依赖内存一级缓存\",{\"1\":{\"818\":1}}],[\"三个技术手段\",{\"1\":{\"813\":1}}],[\"三种工厂模式\",{\"1\":{\"619\":1}}],[\"三种命名方式\",{\"1\":{\"534\":1}}],[\"三\",{\"0\":{\"847\":1,\"859\":1,\"860\":1,\"865\":1,\"870\":1},\"1\":{\"138\":1}}],[\"二方库\",{\"1\":{\"873\":1}}],[\"二方库由谁维护\",{\"1\":{\"869\":1}}],[\"二方库发布者应当遵循以下原则\",{\"1\":{\"869\":1}}],[\"二方库不要有配置项\",{\"1\":{\"869\":1}}],[\"二方库定制包的命名方式\",{\"1\":{\"869\":1}}],[\"二方库里可以定义枚举类型\",{\"1\":{\"869\":1}}],[\"二方库的新增或升级\",{\"1\":{\"869\":1}}],[\"二方库版本号命名方式\",{\"1\":{\"869\":1}}],[\"二方库依赖\",{\"0\":{\"869\":1}}],[\"二方包在类冲突时\",{\"1\":{\"858\":1}}],[\"二方包\",{\"1\":{\"858\":1}}],[\"二级\",{\"1\":{\"874\":1}}],[\"二级宏观错误码\",{\"1\":{\"857\":1,\"874\":17}}],[\"二级缓存\",{\"1\":{\"818\":1}}],[\"二进制无法精确表示大部分的十进制小数\",{\"1\":{\"848\":1}}],[\"二进制的所有位上全部是0\",{\"1\":{\"90\":1}}],[\"二字\",{\"0\":{\"808\":1}}],[\"二叉树排序等\",{\"1\":{\"783\":1}}],[\"二者都应该依赖其抽象\",{\"1\":{\"725\":1}}],[\"二是与具体实现代码同步进行\",{\"1\":{\"991\":1}}],[\"二是效率低\",{\"1\":{\"866\":1}}],[\"二是增强目标对象\",{\"1\":{\"705\":1}}],[\"二是\",{\"1\":{\"550\":1}}],[\"二维码\",{\"1\":{\"432\":1}}],[\"二维条形码图片处理开发库\",{\"1\":{\"408\":1}}],[\"二\",{\"0\":{\"846\":1,\"856\":1,\"858\":1,\"864\":1,\"869\":1},\"1\":{\"138\":1}}],[\"指代的内容也不同\",{\"1\":{\"994\":1}}],[\"指类或者普通方法或者构造方法的主体\",{\"1\":{\"898\":1}}],[\"指南说明\",{\"0\":{\"878\":1}}],[\"指位于英国伦敦郊区的皇家格林尼治天文台的标准时间\",{\"1\":{\"873\":1}}],[\"指的就是\",{\"1\":{\"773\":1}}],[\"指的是\",{\"1\":{\"773\":1}}],[\"指的是线程内唯一\",{\"1\":{\"771\":1,\"772\":1}}],[\"指的是进程内唯一\",{\"1\":{\"771\":1,\"772\":1}}],[\"指为了提高系统的性能\",{\"1\":{\"705\":1}}],[\"指多个对象间存在一对多的依赖关系\",{\"1\":{\"671\":1}}],[\"指语言的语法规则\",{\"1\":{\"641\":1}}],[\"指\",{\"1\":{\"579\":1}}],[\"指挥者类针对抽象建造者类编程\",{\"1\":{\"557\":1}}],[\"指挥者\",{\"1\":{\"550\":1,\"551\":1}}],[\"指向当前\",{\"1\":{\"310\":1}}],[\"指向的是堆中的同一个对象才会返回\",{\"1\":{\"180\":1}}],[\"指出不应该由应用程序处理的严重问题\",{\"1\":{\"268\":1}}],[\"指定一个特殊的运行器\",{\"1\":{\"999\":1}}],[\"指定一个误差范围\",{\"1\":{\"848\":1}}],[\"指定定参数运行器\",{\"1\":{\"981\":1}}],[\"指定集合大小\",{\"1\":{\"872\":1}}],[\"指定集合初始值大小\",{\"1\":{\"850\":1}}],[\"指定具体的处理方式\",{\"1\":{\"790\":1}}],[\"指定当前目标对象使用的类加载器\",{\"1\":{\"700\":1}}],[\"指定为number\",{\"1\":{\"289\":1}}],[\"指定了integer\",{\"1\":{\"289\":2}}],[\"指定泛型的时候\",{\"1\":{\"289\":1}}],[\"指定上限\",{\"1\":{\"284\":1}}],[\"指定类型的注解数组\",{\"1\":{\"233\":1}}],[\"指定类型的注解\",{\"1\":{\"233\":1}}],[\"指定特定的二进制格式\",{\"1\":{\"185\":1}}],[\"指针\",{\"1\":{\"204\":1}}],[\"指一个方法与已经存在的方法名称上相同\",{\"1\":{\"135\":1}}],[\"指子类实现了一个与父类在方法声明上完全相同的一个方法\",{\"1\":{\"135\":1}}],[\"存取性能和存储空间能否满足业务发展\",{\"1\":{\"871\":1}}],[\"存放的\",{\"1\":{\"574\":1}}],[\"存储容量已满\",{\"1\":{\"874\":1}}],[\"存储方案和数据结构需要认真地进行设计和评审\",{\"1\":{\"871\":1}}],[\"存储方案和底层数据结构的设计获得评审一致通过\",{\"1\":{\"871\":1}}],[\"存储过程难以调试和扩展\",{\"1\":{\"865\":1}}],[\"存储null值时会抛出npe异常\",{\"1\":{\"850\":1}}],[\"存储\",{\"1\":{\"638\":1}}],[\"存储在享元信息内部\",{\"1\":{\"631\":1}}],[\"存储格式\",{\"1\":{\"395\":1}}],[\"存储的是对象的地址\",{\"1\":{\"127\":1}}],[\"存入\",{\"1\":{\"312\":1}}],[\"存入缓存\",{\"1\":{\"310\":1}}],[\"存在数据库更新风暴的风险\",{\"1\":{\"865\":1}}],[\"存在数据错乱风险\",{\"1\":{\"854\":1}}],[\"存在非等号和等号混合判断条件时\",{\"1\":{\"864\":1}}],[\"存在过多的条件语句\",{\"1\":{\"860\":1}}],[\"存在过多的外部依赖\",{\"1\":{\"860\":1}}],[\"存在过多的全局变量和静态方法\",{\"1\":{\"860\":1}}],[\"存在抛出异常的情况\",{\"1\":{\"859\":1}}],[\"存在npe隐患\",{\"1\":{\"850\":1}}],[\"存在精度损失风险\",{\"1\":{\"848\":1}}],[\"存在大量相同或相似对象的创建问题\",{\"1\":{\"682\":1}}],[\"存在很多\",{\"1\":{\"567\":1}}],[\"存在缓存时\",{\"1\":{\"312\":1}}],[\"存在缓存\",{\"1\":{\"310\":1}}],[\"存在下级部门\",{\"1\":{\"242\":1}}],[\"存在则返回true\",{\"1\":{\"233\":1}}],[\"存在两个类\",{\"0\":{\"162\":1}}],[\"存在继承的情况下\",{\"1\":{\"144\":1}}],[\"存在于jdk的java\",{\"1\":{\"302\":1}}],[\"存在于同一个类中\",{\"1\":{\"135\":1}}],[\"存在于继承体系中\",{\"1\":{\"135\":1}}],[\"使后续的子系统或模块设计在一个既定的框架内和技术方向上继续演化\",{\"1\":{\"871\":1}}],[\"使release版本号有延续性\",{\"1\":{\"869\":1}}],[\"使字段与do类解耦\",{\"1\":{\"866\":1}}],[\"使代码变得可测避免为了达到测试要求而书写不规范测试代码\",{\"1\":{\"860\":1}}],[\"使代码易于维护\",{\"1\":{\"655\":1}}],[\"使程序无法根据不同的异常做出正确的应激反应\",{\"1\":{\"858\":1}}],[\"使程序设计更加标准化\",{\"1\":{\"797\":1}}],[\"使别的程序员能够迅速了解到代码背后的信息\",{\"1\":{\"853\":1}}],[\"使主干代码更加晰\",{\"1\":{\"847\":1}}],[\"使可理解性降低\",{\"1\":{\"845\":1}}],[\"使每一个访问者的功能都比较单一\",{\"1\":{\"837\":1}}],[\"使软件设计人员沟通更简明\",{\"1\":{\"823\":1}}],[\"使软件开发效率大大提高\",{\"1\":{\"797\":1}}],[\"使其能够快速接替自己的工作\",{\"1\":{\"853\":1}}],[\"使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作\",{\"1\":{\"837\":1}}],[\"使其可完成原始计划阶段中完全没有提到的功能\",{\"1\":{\"820\":1}}],[\"使其构成一个不可分割的独立实体\",{\"1\":{\"209\":1}}],[\"使原有对象之间不必相互了解\",{\"1\":{\"798\":1}}],[\"使发出请求的责任和执行请求的责任分割开\",{\"1\":{\"798\":1}}],[\"使这些子系统更加容易被访问\",{\"1\":{\"798\":1}}],[\"使这个抽象过程的不同实现方法可以构造出不同表现\",{\"1\":{\"549\":1}}],[\"使设计的代码可重用性高\",{\"1\":{\"797\":1}}],[\"使设计复杂化\",{\"1\":{\"722\":1}}],[\"使它们可以独立变化\",{\"1\":{\"798\":1}}],[\"使它们可以相互替换\",{\"1\":{\"783\":1,\"798\":1}}],[\"使它易于切换\",{\"1\":{\"791\":1}}],[\"使之成为新对象的一部分\",{\"1\":{\"747\":1}}],[\"使对象不需要知道链的结构\",{\"1\":{\"711\":1}}],[\"使文档恢复到之前的状态\",{\"1\":{\"663\":1}}],[\"使调用者与实现者相关分离\",{\"1\":{\"561\":1}}],[\"使创建产品的灵活性大大增加\",{\"1\":{\"558\":1}}],[\"使高层代码架构稳定\",{\"1\":{\"545\":1}}],[\"使两个层次可以独立改变\",{\"1\":{\"537\":1}}],[\"使你的依赖基于此\",{\"1\":{\"461\":1}}],[\"使得操作集合可相对自由地演化而不影响系统的数据结构\",{\"1\":{\"837\":1}}],[\"使得复用这些代码变得更加困难\",{\"1\":{\"819\":1}}],[\"使得系统更加庞大\",{\"1\":{\"804\":1}}],[\"使得系统易于维护和扩展\",{\"1\":{\"655\":1}}],[\"使得子类可以不改变一个算法的结构\",{\"1\":{\"800\":1}}],[\"使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤\",{\"1\":{\"798\":1}}],[\"使得子系统的变化不会影响调用它的客户类\",{\"1\":{\"593\":1}}],[\"使得原本由于接口不兼容而不能一起工作的那些类能一起工作\",{\"1\":{\"798\":1}}],[\"使得可以独立于其\",{\"1\":{\"791\":1}}],[\"使得以\",{\"1\":{\"732\":1}}],[\"使得事件具备跨域\",{\"1\":{\"680\":1}}],[\"使得一方的变动可以通知到感兴趣的另一方对象\",{\"1\":{\"680\":1}}],[\"使得用户不需要关心状态的保存细节\",{\"1\":{\"668\":1}}],[\"使得对象易于独立地被复用\",{\"1\":{\"655\":1}}],[\"使得调用端只需跟这个接口发生调用\",{\"1\":{\"600\":1}}],[\"使得同样的创建行为可以生产出不同的产品\",{\"1\":{\"558\":1}}],[\"使得创建过程更加清晰\",{\"1\":{\"557\":1}}],[\"使得相同的创建过程可以创建不同的产品对象\",{\"1\":{\"557\":1}}],[\"使得\",{\"1\":{\"525\":1}}],[\"使得无法拿到足够的错误信息来定位问题\",{\"1\":{\"269\":1}}],[\"使得修改接口的成本也变的很低\",{\"1\":{\"133\":1}}],[\"使引用不变\",{\"1\":{\"143\":1}}],[\"使数值不变\",{\"1\":{\"143\":1}}],[\"使用单元测试可以有效地降低程序出错的机率\",{\"1\":{\"990\":1}}],[\"使用单例可以降低系统的内存压力\",{\"1\":{\"762\":1}}],[\"使用单例模式可以提高系统性能\",{\"1\":{\"761\":1}}],[\"使用单例模式\",{\"1\":{\"601\":1}}],[\"使用自定义变量进行测试\",{\"1\":{\"981\":1}}],[\"使用定义的变量作为参数进行测试\",{\"1\":{\"981\":1}}],[\"使用花括号来配对\",{\"1\":{\"900\":1}}],[\"使用活动图来表示\",{\"1\":{\"871\":1}}],[\"使用类图来表达并且明确类之间的关系\",{\"1\":{\"871\":1}}],[\"使用类型的任何地方\",{\"1\":{\"227\":1}}],[\"使用时序图来表达并且明确各调用环节的输入与输出\",{\"1\":{\"871\":1}}],[\"使用状态图来表达并且明确状态变化的各个触发条件\",{\"1\":{\"871\":1}}],[\"使用状态模式完成借贷平台项目的审核模块\",{\"1\":{\"779\":1}}],[\"使用用例图来表达更加清晰的结构化需求\",{\"1\":{\"871\":1}}],[\"使用foundation\",{\"1\":{\"860\":1}}],[\"使用final关键字可以强制重新定义一个变量\",{\"1\":{\"848\":1}}],[\"使用全英文来注释和描述日志错误信息\",{\"1\":{\"859\":1}}],[\"使用占位符仅是替换动作\",{\"1\":{\"859\":1}}],[\"使用门面模式的日志框架\",{\"1\":{\"859\":1}}],[\"使用抛异常返回方式\",{\"1\":{\"858\":1}}],[\"使用纯数字来进行错误码编排不利于感性记忆和分类\",{\"1\":{\"857\":1}}],[\"使用jcl\",{\"1\":{\"859\":1}}],[\"使用jdk8的optional类来防止npe问题\",{\"1\":{\"858\":1}}],[\"使用json格式而非xml\",{\"1\":{\"854\":1}}],[\"使用java创建动态\",{\"1\":{\"434\":1}}],[\"使用java编写的模板引擎\",{\"1\":{\"430\":1}}],[\"使用大于或小于的区间判断条件来代替\",{\"1\":{\"852\":1}}],[\"使用如下类实现\",{\"1\":{\"851\":1}}],[\"使用悲观锁策略\",{\"1\":{\"851\":1}}],[\"使用version作为更新依据\",{\"1\":{\"851\":1}}],[\"使用dateutils\",{\"1\":{\"851\":1}}],[\"使用diamond语法或全省略\",{\"1\":{\"850\":1}}],[\"使用map\",{\"1\":{\"850\":1}}],[\"使用map的方法keyset\",{\"1\":{\"850\":1}}],[\"使用entryset遍历map类集合kv\",{\"1\":{\"850\":1}}],[\"使用工具类arrays\",{\"1\":{\"850\":1}}],[\"使用工厂模式\",{\"1\":{\"613\":1}}],[\"使用catch\",{\"1\":{\"868\":1}}],[\"使用cas保证更新的线程安全性\",{\"1\":{\"310\":1}}],[\"使用char定长字符串类型\",{\"1\":{\"863\":1}}],[\"使用countdownlatch进行异步转同步操作\",{\"1\":{\"851\":1}}],[\"使用collection接口任何实现类的addall\",{\"1\":{\"850\":1}}],[\"使用集合转数组的方法\",{\"1\":{\"850\":1}}],[\"使用集合的时候\",{\"1\":{\"451\":1}}],[\"使用isnull\",{\"1\":{\"865\":1}}],[\"使用isempty\",{\"1\":{\"850\":1}}],[\"使用if\",{\"1\":{\"852\":2}}],[\"使用ide中的工具source\",{\"1\":{\"848\":1}}],[\"使用索引访问用string的split方法得到的数组时\",{\"1\":{\"848\":1}}],[\"使用查找功能才能定位到要修改的常量\",{\"1\":{\"846\":1}}],[\"使用完整的单词组合来表达\",{\"1\":{\"845\":1}}],[\"使用完成之后还需要再存储回外部共享存储区\",{\"1\":{\"772\":1}}],[\"使用slf4j\",{\"1\":{\"859\":1}}],[\"使用scheduledexecutorservice则没有这个问题\",{\"1\":{\"851\":1}}],[\"使用stringbuilder的append方法进行扩展\",{\"1\":{\"848\":1}}],[\"使用string\",{\"1\":{\"845\":1}}],[\"使用spi服务发现机制\",{\"1\":{\"104\":1}}],[\"使用spi来获取驱动的实现\",{\"1\":{\"103\":2}}],[\"使用spi的serviceloader来加载接口的实现\",{\"1\":{\"103\":1}}],[\"使用访问者模式\",{\"1\":{\"841\":1}}],[\"使用面向对象的继承机制来实现泛化关系\",{\"1\":{\"833\":1}}],[\"使用者依赖接口\",{\"1\":{\"809\":1}}],[\"使用者是\",{\"1\":{\"636\":1}}],[\"使用户对单个对象和组合对象具有一致的访问性\",{\"1\":{\"798\":1}}],[\"使用到的任何标准\",{\"1\":{\"957\":1}}],[\"使用到多种设计模式\",{\"1\":{\"796\":1}}],[\"使用到了享元模式\",{\"1\":{\"637\":1}}],[\"使用过什么设计模式\",{\"1\":{\"796\":1}}],[\"使用设计模式是增加软件组件灵活性并使其易于复用的方式之一\",{\"1\":{\"819\":1}}],[\"使用设计模式\",{\"1\":{\"796\":1}}],[\"使用策略对象\",{\"1\":{\"790\":2}}],[\"使用算法的客户\",{\"1\":{\"783\":1}}],[\"使用举例\",{\"1\":{\"769\":1}}],[\"使用枚举值来指代月份\",{\"1\":{\"849\":1}}],[\"使用枚举\",{\"1\":{\"759\":1}}],[\"使用静态或者其它形式的\",{\"1\":{\"890\":1}}],[\"使用静态内部类完成单例模式\",{\"1\":{\"758\":1}}],[\"使用静态代理方式\",{\"1\":{\"695\":1}}],[\"使用这种方式\",{\"1\":{\"755\":1}}],[\"使用这个注解\",{\"1\":{\"230\":1}}],[\"使用方便\",{\"1\":{\"763\":1}}],[\"使用方的代码就不需要修\",{\"1\":{\"739\":1}}],[\"使用方\",{\"1\":{\"738\":3,\"739\":1}}],[\"使用方法\",{\"0\":{\"102\":1}}],[\"使用看看存在的问题\",{\"1\":{\"738\":2,\"739\":1}}],[\"使用组合就更加合理\",{\"1\":{\"814\":1}}],[\"使用组合关系\",{\"1\":{\"734\":1}}],[\"使用组合仍然可以使用到\",{\"1\":{\"734\":1}}],[\"使用组合替代继承\",{\"1\":{\"529\":1}}],[\"使用里氏替原则\",{\"1\":{\"731\":1}}],[\"使用一把\",{\"1\":{\"723\":1}}],[\"使用一种方法就可以遍历对象了\",{\"1\":{\"652\":1}}],[\"使用多个专门的接口还能够体现对象的层次\",{\"1\":{\"722\":1}}],[\"使用代理模式主要有两个目的\",{\"1\":{\"705\":1}}],[\"使用代理模式的例子也很多\",{\"1\":{\"692\":1}}],[\"使用泛型方法确认类型\",{\"1\":{\"700\":1}}],[\"使用序列化来实现深拷贝\",{\"1\":{\"689\":1}}],[\"使用默认的\",{\"1\":{\"687\":1}}],[\"使用默认factory实现\",{\"1\":{\"104\":1}}],[\"使用原型模式改进传统方式\",{\"1\":{\"687\":1}}],[\"使用原型模式将对象复制一份\",{\"1\":{\"682\":1}}],[\"使用原则\",{\"1\":{\"284\":1}}],[\"使用备忘录对象恢复到站前\",{\"1\":{\"667\":1}}],[\"使用中介者模式将网状结构分离为星型结构\",{\"1\":{\"660\":1}}],[\"使用解释器可能带来的问题\",{\"1\":{\"645\":1}}],[\"使用该解释器来解释语言中的句子\",{\"1\":{\"641\":1}}],[\"使用该方法创建的类\",{\"1\":{\"305\":1}}],[\"使用享元模式时\",{\"1\":{\"638\":1}}],[\"使用哪个构造函数以及对应的构造函数参数都是什么等等\",{\"1\":{\"622\":1}}],[\"使用简单工厂模式2\",{\"1\":{\"610\":1}}],[\"使用简单工厂模式\",{\"1\":{\"610\":1,\"613\":1}}],[\"使用简单工厂模式会增加系统中类的个数\",{\"1\":{\"608\":1}}],[\"使用简单的持久化数据管理框架\",{\"1\":{\"420\":1}}],[\"使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系\",{\"1\":{\"604\":1}}],[\"使用外观模式好\",{\"1\":{\"603\":1}}],[\"使用外部配置的实现\",{\"1\":{\"309\":1}}],[\"使用饿汉式\",{\"1\":{\"601\":1}}],[\"使用对象池来减少重复对象的创建\",{\"1\":{\"590\":1}}],[\"使用对象适配器\",{\"1\":{\"528\":1}}],[\"使用对象适配器模式完成\",{\"1\":{\"528\":1}}],[\"使用抽象命令接口使请求方的代码架构稳定\",{\"1\":{\"565\":1}}],[\"使用抽象类\",{\"1\":{\"133\":1}}],[\"使用命令设计模式\",{\"1\":{\"562\":1}}],[\"使用程序\",{\"1\":{\"557\":1}}],[\"使用桥接模式可以解耦这些变化的维度\",{\"1\":{\"545\":1}}],[\"使用桥接模式对应的类图\",{\"1\":{\"542\":1}}],[\"使用桥接模式改进传统方式\",{\"1\":{\"542\":1}}],[\"使用桥接模式\",{\"1\":{\"541\":1}}],[\"使用第三方提供的组件\",{\"1\":{\"535\":1}}],[\"使用第三方转换器进行文档格式转换\",{\"1\":{\"402\":1}}],[\"使用成本更低\",{\"1\":{\"529\":1}}],[\"使用起来它们显得更整洁\",{\"1\":{\"466\":1}}],[\"使用框架或者灵活性更高的内部研发的解决方案\",{\"1\":{\"456\":1}}],[\"使用依赖注入是编写可测试软件最好的方法之一\",{\"1\":{\"449\":1}}],[\"使用检查异常的时候一定要注意\",{\"1\":{\"448\":1}}],[\"使用服务端架构\",{\"1\":{\"434\":1}}],[\"使用约定而非配置\",{\"1\":{\"434\":2}}],[\"使用web\",{\"1\":{\"415\":1}}],[\"使用强大的插件和配置架构进行完全重写\",{\"1\":{\"412\":1}}],[\"使用了继承关系\",{\"1\":{\"814\":1}}],[\"使用了观察者模式设计后\",{\"1\":{\"678\":1}}],[\"使用了建造者模式\",{\"1\":{\"556\":1}}],[\"使用了m1的方法\",{\"1\":{\"532\":1}}],[\"使用了method类的invoke\",{\"1\":{\"308\":1}}],[\"使用了jetty\",{\"1\":{\"424\":1}}],[\"使用了约束规划技术\",{\"1\":{\"391\":1}}],[\"使用基于neo4j查询语言进行代码静态分析\",{\"1\":{\"388\":1}}],[\"使用流式api进一步简化字节码生成\",{\"1\":{\"386\":1}}],[\"使用groovy\",{\"1\":{\"385\":1}}],[\"使用generics时忽略没有指定相应的类型\",{\"1\":{\"225\":1}}],[\"使用常量池\",{\"1\":{\"311\":1}}],[\"使用native方法从jvm获取构造器\",{\"1\":{\"310\":1}}],[\"使用软引用保存\",{\"1\":{\"310\":1}}],[\"使用此标注的时候不能与其它标注一起使用\",{\"1\":{\"972\":1}}],[\"使用此\",{\"1\":{\"306\":1}}],[\"使用add方法添加一个整型\",{\"1\":{\"290\":1}}],[\"使用的规则就是\",{\"1\":{\"284\":1}}],[\"使用就可以\",{\"1\":{\"265\":1}}],[\"使用场合\",{\"1\":{\"265\":1}}],[\"使用tinyint类型\",{\"1\":{\"863\":1}}],[\"使用toarray带参方法\",{\"1\":{\"850\":1}}],[\"使用throw语句抛出null等等\",{\"1\":{\"261\":1}}],[\"使用type\",{\"1\":{\"236\":2}}],[\"使用lock对象保证线程同步\",{\"1\":{\"258\":1}}],[\"使用注解\",{\"1\":{\"234\":1}}],[\"使用它又什么风险\",{\"0\":{\"183\":1}}],[\"使用bigdecimal来定义值\",{\"1\":{\"848\":1}}],[\"使用bigdecimal\",{\"1\":{\"158\":1}}],[\"使用接口隔离原则代码\",{\"1\":{\"723\":1}}],[\"使用接口\",{\"1\":{\"133\":1}}],[\"使用选择\",{\"1\":{\"133\":1}}],[\"使用\",{\"1\":{\"125\":1,\"135\":1,\"141\":1,\"209\":1,\"232\":1,\"242\":1,\"264\":2,\"284\":2,\"310\":2,\"449\":1,\"450\":1,\"459\":1,\"474\":1,\"533\":1,\"581\":1,\"678\":1,\"686\":1,\"689\":2,\"723\":5,\"725\":1,\"788\":1,\"853\":2,\"924\":1,\"935\":1,\"939\":1,\"962\":1,\"996\":1}}],[\"使用扩展类加载器为指定的服务创建serviceloader\",{\"1\":{\"114\":1}}],[\"使用线程上下文的类加载器来创建serviceloader\",{\"1\":{\"114\":1}}],[\"使用parseline方法进行解析\",{\"1\":{\"114\":1}}],[\"使用系统类加载器\",{\"1\":{\"114\":1}}],[\"使用指定的类加载器和服务创建服务加载器\",{\"1\":{\"114\":1}}],[\"使用指南\",{\"1\":{\"32\":2}}],[\"使用规范\",{\"0\":{\"112\":1}}],[\"使用后备factory实现\",{\"1\":{\"104\":1}}],[\"默认上层依赖于下层\",{\"1\":{\"868\":1}}],[\"默认为0\",{\"1\":{\"850\":1}}],[\"默认空实现\",{\"1\":{\"650\":1}}],[\"默认实现了\",{\"1\":{\"779\":1}}],[\"默认实现\",{\"1\":{\"532\":2,\"574\":2}}],[\"默认但是不包括父类声明的任何字段\",{\"1\":{\"305\":1}}],[\"默认值\",{\"1\":{\"228\":1}}],[\"默认\",{\"1\":{\"194\":1,\"308\":1}}],[\"默认方法\",{\"0\":{\"348\":1},\"1\":{\"187\":1,\"790\":1}}],[\"默认返回\",{\"1\":{\"140\":1}}],[\"默认都是\",{\"1\":{\"133\":1}}],[\"默认节点\",{\"0\":{\"41\":1}}],[\"关联可以是双向的\",{\"1\":{\"830\":1}}],[\"关联具有多重性\",{\"1\":{\"830\":1}}],[\"关联具有\",{\"1\":{\"830\":1}}],[\"关联\",{\"1\":{\"741\":1,\"826\":1,\"830\":1,\"835\":1}}],[\"关联关系的特例\",{\"1\":{\"831\":1}}],[\"关联关系是类与类之间最常用的一种关系\",{\"1\":{\"830\":1}}],[\"关联关系\",{\"0\":{\"217\":1,\"830\":1},\"1\":{\"527\":1,\"528\":1,\"827\":1}}],[\"关注对象之间的通信\",{\"1\":{\"591\":1}}],[\"关注类和对象的组合\",{\"1\":{\"590\":1}}],[\"关注服务器端编程的\",{\"1\":{\"442\":1}}],[\"关机\",{\"1\":{\"539\":1}}],[\"关键在于思路和条理\",{\"1\":{\"822\":1}}],[\"关键词if与括号之间必须有一个空格\",{\"1\":{\"847\":1}}],[\"关键词\",{\"1\":{\"451\":1}}],[\"关键词也可以在\",{\"1\":{\"451\":1}}],[\"关键字指定父类子类一定是知道父类定义的\",{\"1\":{\"835\":1}}],[\"关键字使起不可变\",{\"1\":{\"451\":1}}],[\"关键字声明了类型的下界\",{\"1\":{\"284\":1}}],[\"关键字声明了类型的上界\",{\"1\":{\"284\":1}}],[\"关键字声明可能会抛出的异常\",{\"1\":{\"252\":1}}],[\"关键字\",{\"0\":{\"142\":1,\"505\":1,\"506\":1,\"507\":1},\"1\":{\"144\":1,\"213\":1,\"214\":1,\"804\":1,\"924\":1}}],[\"关键字来引用父类的方法实现\",{\"1\":{\"134\":1}}],[\"关键字进行声明\",{\"1\":{\"133\":1}}],[\"关闭流\",{\"1\":{\"689\":1}}],[\"关闭文件\",{\"1\":{\"622\":1}}],[\"关闭华为路由器\",{\"1\":{\"617\":1}}],[\"关闭华为手机\",{\"1\":{\"617\":1}}],[\"关闭小米路由器\",{\"1\":{\"617\":1}}],[\"关闭小米手机\",{\"1\":{\"617\":1}}],[\"关闭各种设备\",{\"1\":{\"597\":1}}],[\"关闭cpu\",{\"1\":{\"258\":1}}],[\"关闭连接操作等等\",{\"1\":{\"258\":1}}],[\"关闭相应资源\",{\"1\":{\"258\":1}}],[\"关系更加强烈\",{\"1\":{\"835\":1}}],[\"关系稳定\",{\"1\":{\"835\":1}}],[\"关系也是关联关系的一种\",{\"1\":{\"832\":1}}],[\"关系是接口与实现类之间的关系\",{\"1\":{\"834\":1}}],[\"关系是对象之间耦合度最大的一种关系\",{\"1\":{\"833\":1}}],[\"关系是对象之间的一种引用关系\",{\"1\":{\"830\":1}}],[\"关系是关联关系的一种\",{\"1\":{\"831\":1}}],[\"关系是一种使用关系\",{\"1\":{\"828\":1}}],[\"关系和图这些构件组成\",{\"1\":{\"824\":1}}],[\"关系来替代\",{\"1\":{\"813\":1}}],[\"关系代替\",{\"1\":{\"734\":1}}],[\"关系\",{\"1\":{\"133\":3,\"210\":2,\"527\":1,\"812\":1,\"813\":2,\"832\":1}}],[\"关于枚举类的一些特殊情况\",{\"1\":{\"901\":1}}],[\"关于\",{\"1\":{\"872\":1}}],[\"关于rpc方法返回方式使用result方式的理由\",{\"1\":{\"858\":1}}],[\"关于hashcode和equals的处理\",{\"1\":{\"850\":1}}],[\"关于基本数据类型与包装数据类型的使用标准如下\",{\"1\":{\"848\":1}}],[\"关于这一点\",{\"1\":{\"741\":1,\"773\":1}}],[\"关于这些扩展\",{\"1\":{\"12\":1}}],[\"关于constructor类本身一些常用方法如下\",{\"1\":{\"306\":1}}],[\"关于反射稍后分析\",{\"1\":{\"302\":1}}],[\"关于finally\",{\"0\":{\"197\":1}}],[\"关于驱动的查找其实都在drivermanager中\",{\"1\":{\"103\":1}}],[\"共性业务或公共行为抽取出来公共模块\",{\"1\":{\"871\":1}}],[\"共性逻辑抽取\",{\"1\":{\"847\":1}}],[\"共\",{\"1\":{\"798\":1,\"857\":1,\"872\":1}}],[\"共享该对象可以节省内存\",{\"1\":{\"762\":1}}],[\"共享的部分\",{\"1\":{\"636\":1}}],[\"共享其相关的代码和数据\",{\"1\":{\"635\":1}}],[\"共享资源池\",{\"1\":{\"590\":1}}],[\"共有字段\",{\"1\":{\"132\":1}}],[\"共同实现\",{\"1\":{\"125\":2}}],[\"拥有执行命令的抽象方法\",{\"1\":{\"561\":1}}],[\"拥有所有你能想到的关于文件操作的方法\",{\"1\":{\"465\":1}}],[\"拥有大量的有用的扩展库\",{\"1\":{\"465\":1}}],[\"拥有大量的扩展库也许是最大的特点了\",{\"1\":{\"463\":1}}],[\"拥有\",{\"1\":{\"132\":1}}],[\"把钱交出来\",{\"1\":{\"871\":1}}],[\"把机房编号赋值给whatfeatureofgroup\",{\"1\":{\"851\":1}}],[\"把数组转换成集合时\",{\"1\":{\"850\":1}}],[\"把代码重构一下\",{\"1\":{\"809\":1}}],[\"把代码放在try\",{\"1\":{\"263\":1}}],[\"把请求从链中的一个对象传到下一个对象\",{\"1\":{\"798\":1}}],[\"把这种改变通知给其他多个对象\",{\"1\":{\"798\":1}}],[\"把变化的代码从不变的代码中分离出来\",{\"1\":{\"783\":1}}],[\"把使用算法的责任和算法的实现分割开来\",{\"1\":{\"783\":1}}],[\"把复杂的\",{\"1\":{\"775\":1}}],[\"把相关\",{\"1\":{\"775\":1}}],[\"把更加基础的方法和成员写到\",{\"1\":{\"734\":1}}],[\"把展现细节的任务交给他们的实现类去完成\",{\"1\":{\"725\":1}}],[\"把当前状态设置为\",{\"1\":{\"779\":1}}],[\"把当前状态保存\",{\"1\":{\"667\":1}}],[\"把当前运行环境下能做的事尽量做完\",{\"1\":{\"260\":2}}],[\"把创建\",{\"1\":{\"609\":1,\"739\":1}}],[\"把关机和启动合为一个操作\",{\"1\":{\"601\":1}}],[\"把选择权交给用户\",{\"1\":{\"591\":1}}],[\"把大象装进冰箱\",{\"1\":{\"591\":1}}],[\"把学校\",{\"1\":{\"573\":1}}],[\"把产品\",{\"1\":{\"554\":1}}],[\"把适配者接口转换成目标接口\",{\"1\":{\"519\":1}}],[\"把它们独立出来\",{\"1\":{\"746\":1}}],[\"把它们用在你的构建阶段往往也是一个不错的想法\",{\"1\":{\"484\":1}}],[\"把它的\",{\"1\":{\"132\":1}}],[\"把object类的方法都打印出来了\",{\"1\":{\"308\":1}}],[\"把个个组成部分映射成一个个对象\",{\"1\":{\"301\":1}}],[\"把第二天的闹钟往前调10分钟\",{\"1\":{\"36\":1}}],[\"访问未授权\",{\"1\":{\"874\":1}}],[\"访问日志等\",{\"1\":{\"859\":1}}],[\"访问者依赖的是具体元素\",{\"1\":{\"840\":1}}],[\"访问者类\",{\"1\":{\"839\":1}}],[\"访问者模式就是比较合适的\",{\"1\":{\"840\":1}}],[\"访问者模式可以对功能进行统一\",{\"1\":{\"840\":1}}],[\"访问者模式符合单一职责原则\",{\"1\":{\"840\":1}}],[\"访问者模式的应用场景\",{\"0\":{\"841\":1}}],[\"访问者模式的具体元素对访问者公布细节\",{\"1\":{\"840\":1}}],[\"访问者模式的注意事项和细节\",{\"0\":{\"840\":1}}],[\"访问者模式的结构与实现\",{\"0\":{\"838\":1}}],[\"访问者模式应用实例\",{\"0\":{\"839\":1}}],[\"访问者模式包含以下主要角色\",{\"1\":{\"838\":1}}],[\"访问者模式依赖了具体类\",{\"1\":{\"837\":1}}],[\"访问者模式中具体元素对访问者公布细节\",{\"1\":{\"837\":1}}],[\"访问者模式把相关的行为封装在一起\",{\"1\":{\"837\":1}}],[\"访问者模式将数据结构与作用于结构上的操作解耦\",{\"1\":{\"837\":1}}],[\"访问者模式主要应用场景是\",{\"1\":{\"837\":1}}],[\"访问者模式能把处理方法从数据结构中分离出来\",{\"1\":{\"837\":1}}],[\"访问者模式基本介绍\",{\"0\":{\"837\":1}}],[\"访问者模式\",{\"1\":{\"591\":1,\"798\":1,\"837\":3}}],[\"访问凭证\",{\"1\":{\"809\":1}}],[\"访问类\",{\"1\":{\"683\":1}}],[\"访问一个聚合对象的内容而无须暴露它的内部表示\",{\"1\":{\"648\":1}}],[\"访问和私有方法\",{\"1\":{\"308\":1}}],[\"访问null对象的属性\",{\"1\":{\"261\":1}}],[\"访问父类的成员\",{\"1\":{\"134\":1}}],[\"访问父类的构造函数\",{\"1\":{\"134\":1}}],[\"访问权限异常\",{\"1\":{\"874\":1}}],[\"访问权限\",{\"0\":{\"132\":1}}],[\"访问控制上下文\",{\"1\":{\"114\":1}}],[\"继承是一种强依赖关系\",{\"1\":{\"818\":1}}],[\"继承是面向对象的四大特性之一\",{\"1\":{\"812\":1}}],[\"继承也不是一无是处\",{\"1\":{\"814\":1}}],[\"继承也并非一无是处\",{\"1\":{\"814\":1}}],[\"继承层次很深\",{\"1\":{\"814\":1}}],[\"继承层次比较浅\",{\"1\":{\"814\":1}}],[\"继承层次过深\",{\"1\":{\"812\":1}}],[\"继承改写成组合意味着要做更细粒度的类的拆分\",{\"1\":{\"814\":1}}],[\"继承关系复杂\",{\"1\":{\"814\":1}}],[\"继承关系不复杂\",{\"1\":{\"814\":1}}],[\"继承关系过于复杂会影响到代码的可读性和可维护性\",{\"1\":{\"812\":1}}],[\"继承关系会越来越复杂\",{\"1\":{\"812\":1}}],[\"继承最大的问题就在于\",{\"1\":{\"812\":1}}],[\"继承性和多态性以及类的关联关系和组合关系的充分理解\",{\"1\":{\"797\":1}}],[\"继承复用破坏了类的封装性\",{\"1\":{\"747\":1}}],[\"继承复用虽然有简单和易实现的优点\",{\"1\":{\"747\":1}}],[\"继承图\",{\"1\":{\"745\":1}}],[\"继承必须确保超类所拥有的性质在子类中仍然成立\",{\"1\":{\"732\":1}}],[\"继承在给程序设计带来便利的同时\",{\"1\":{\"731\":1}}],[\"继承包含这样一层含义\",{\"1\":{\"731\":1}}],[\"继承时遵循\",{\"1\":{\"729\":1}}],[\"继承自同一抽象类或者接口的子类\",{\"1\":{\"621\":1}}],[\"继承抽象构件\",{\"1\":{\"580\":1}}],[\"继承了\",{\"1\":{\"556\":1}}],[\"继承具备强侵入性\",{\"1\":{\"545\":1}}],[\"继承可以很好的实现代码复用\",{\"1\":{\"545\":1}}],[\"继承拥有很多优点\",{\"1\":{\"545\":1}}],[\"继承实现到注解实现\",{\"0\":{\"241\":1}}],[\"继承实现了\",{\"1\":{\"210\":1}}],[\"继承应该遵循里氏替换原则\",{\"1\":{\"210\":1}}],[\"继承\",{\"0\":{\"131\":1,\"162\":2,\"210\":1},\"1\":{\"187\":1,\"211\":1,\"219\":1,\"534\":1,\"542\":1,\"582\":1,\"613\":2,\"764\":2,\"826\":1,\"835\":1}}],[\"比atomiclong性能更好\",{\"1\":{\"851\":1}}],[\"比继承灵活\",{\"1\":{\"579\":1}}],[\"比gson与jackson组合方式效果更好\",{\"1\":{\"409\":1}}],[\"比较容易想到\",{\"1\":{\"727\":1}}],[\"比较好的替代品\",{\"1\":{\"449\":1}}],[\"比较好的方式就是使你自定义的异常继承自运行时异常来取而代之\",{\"1\":{\"448\":1}}],[\"比较时的区别\",{\"1\":{\"191\":1}}],[\"比较\",{\"1\":{\"133\":1}}],[\"比较合适\",{\"1\":{\"130\":1}}],[\"比如自定义的所有http请求都会经过的拦截器\",{\"1\":{\"992\":1}}],[\"比如按照方法的名字顺序\",{\"1\":{\"983\":1}}],[\"比如数据库连接的关闭等\",{\"1\":{\"976\":1}}],[\"比如两个用例都需要读取数据库里的用户a信息\",{\"1\":{\"972\":1}}],[\"比如已下单与已收货这两种状态之间是不可能有直接转换关系的\",{\"1\":{\"871\":1}}],[\"比如查看他人的私信内容\",{\"1\":{\"861\":1}}],[\"比如cdn服务出错\",{\"1\":{\"857\":1}}],[\"比如参数错误\",{\"1\":{\"857\":1}}],[\"比如修改helper的属性声明为private\",{\"1\":{\"851\":1}}],[\"比如成功\",{\"1\":{\"839\":1}}],[\"比如类\",{\"1\":{\"822\":1}}],[\"比如以下几种场景\",{\"1\":{\"820\":1}}],[\"比如观察者模式\",{\"1\":{\"818\":1}}],[\"比如系统\",{\"1\":{\"818\":1}}],[\"比如下面这样一段代码\",{\"1\":{\"814\":1}}],[\"比如企鹅\",{\"1\":{\"812\":1}}],[\"比如鸵鸟就不会飞\",{\"1\":{\"812\":1}}],[\"比如麻雀\",{\"1\":{\"812\":1}}],[\"比如服务端与客户端之间的\",{\"1\":{\"808\":1}}],[\"比如叫\",{\"1\":{\"785\":1}}],[\"比如野鸭\",{\"1\":{\"785\":1}}],[\"比如只能创建\",{\"1\":{\"773\":1}}],[\"比如文件地址\",{\"1\":{\"772\":1}}],[\"比如文件\",{\"1\":{\"772\":1}}],[\"比如对\",{\"1\":{\"769\":1}}],[\"比如对学院\",{\"1\":{\"573\":1}}],[\"比如我们创建一个连接池的单例对象\",{\"1\":{\"768\":1}}],[\"比如我们这时要新增加一个图形种类三角形\",{\"1\":{\"738\":1}}],[\"比如使用继承会给程序带来\",{\"1\":{\"731\":1}}],[\"比如说成员变量是某个数组\",{\"1\":{\"689\":1}}],[\"比如说调用add方法\",{\"1\":{\"290\":1}}],[\"比如发布到自己的网站或第三方\",{\"1\":{\"673\":1}}],[\"比如流程为\",{\"1\":{\"657\":1}}],[\"比如围棋\",{\"1\":{\"631\":1}}],[\"比如释放数据库连接池\",{\"1\":{\"622\":1}}],[\"比如北京的奶酪\",{\"1\":{\"613\":1}}],[\"比如在高层接口提供四个方法\",{\"1\":{\"600\":1}}],[\"比如咖啡的名字\",{\"1\":{\"582\":1}}],[\"比如很多方法和属性都不一样\",{\"1\":{\"576\":1}}],[\"比如新增\",{\"1\":{\"568\":1}}],[\"比如日志记录\",{\"1\":{\"560\":1}}],[\"比如普通房\",{\"1\":{\"552\":1}}],[\"比如和\",{\"1\":{\"477\":1}}],[\"比如配置信息类\",{\"1\":{\"763\":1}}],[\"比如配置\",{\"1\":{\"432\":1}}],[\"比如形如<t\",{\"1\":{\"287\":1}}],[\"比如这样的代码\",{\"1\":{\"275\":1}}],[\"比如上面用到的自定义myexception\",{\"1\":{\"254\":1}}],[\"比如学生和学校就是一种关联关系\",{\"1\":{\"217\":1}}],[\"比如公司和部门\",{\"1\":{\"216\":1}}],[\"比如空指针\",{\"1\":{\"198\":1}}],[\"比如\",{\"1\":{\"173\":1,\"247\":1,\"263\":2,\"289\":1,\"292\":1,\"466\":1,\"539\":1,\"545\":1,\"562\":2,\"601\":1,\"609\":1,\"613\":1,\"621\":1,\"622\":3,\"631\":1,\"638\":1,\"643\":1,\"648\":1,\"655\":1,\"704\":1,\"709\":1,\"750\":1,\"761\":1,\"764\":1,\"767\":2,\"769\":3,\"770\":4,\"803\":1,\"808\":2,\"809\":6,\"813\":1,\"814\":3,\"817\":1,\"818\":1,\"820\":1,\"843\":2,\"851\":1,\"854\":2,\"858\":3,\"871\":2,\"872\":10,\"873\":1}}],[\"比如方法区\",{\"1\":{\"125\":1}}],[\"比如me\",{\"1\":{\"110\":1}}],[\"比如接口java\",{\"1\":{\"109\":1}}],[\"比如java\",{\"1\":{\"95\":1,\"110\":1}}],[\"字母和数字\",{\"1\":{\"937\":1}}],[\"字节是取所有浏览器的最小值\",{\"1\":{\"854\":1}}],[\"字节\",{\"1\":{\"854\":1,\"863\":1}}],[\"字节码操作\",{\"0\":{\"386\":1}}],[\"字节码生成库\",{\"1\":{\"384\":1}}],[\"字节码的增强技术\",{\"0\":{\"364\":1}}],[\"字节码文件\",{\"1\":{\"302\":1}}],[\"字节码内容如下\",{\"1\":{\"228\":1}}],[\"字眼的方法\",{\"1\":{\"809\":1}}],[\"字符时\",{\"1\":{\"885\":1}}],[\"字符\",{\"0\":{\"885\":1},\"1\":{\"885\":3,\"905\":1}}],[\"字符集和许多各种各样的实用的方法\",{\"1\":{\"465\":1}}],[\"字符串和字符字面量中的所有非空格字符都要进行转义\",{\"1\":{\"883\":1}}],[\"字符串变量之间的拼接使用占位符的方式\",{\"1\":{\"859\":1}}],[\"字符串的连接方式\",{\"1\":{\"848\":1}}],[\"字符串处理\",{\"1\":{\"432\":1}}],[\"字符串\",{\"0\":{\"353\":1},\"1\":{\"942\":1}}],[\"字符串索引超出范围抛出的异常\",{\"1\":{\"261\":1}}],[\"字符串转换为数字抛出的异常\",{\"1\":{\"261\":1}}],[\"字符串常量池放在哪里\",{\"1\":{\"125\":1}}],[\"字符串常量池属于虚拟机规范中的方法区\",{\"1\":{\"125\":1}}],[\"字符串常量池\",{\"1\":{\"125\":4}}],[\"字面量才是\",{\"1\":{\"128\":1}}],[\"字面量属于\",{\"1\":{\"128\":1}}],[\"字段或局部变量\",{\"1\":{\"917\":1}}],[\"字段或实例字段\",{\"1\":{\"307\":1}}],[\"字段类型\",{\"1\":{\"871\":1}}],[\"字段允许适当冗余\",{\"1\":{\"863\":1}}],[\"字段名称\",{\"1\":{\"871\":1}}],[\"字段名\",{\"1\":{\"863\":4}}],[\"字段名必须使用小写字母或数字\",{\"1\":{\"863\":1}}],[\"字段和方法返回值的数据类型非必需\",{\"1\":{\"826\":1}}],[\"字段未找到异常\",{\"1\":{\"261\":1}}],[\"字段决不能是公有的\",{\"1\":{\"132\":1}}],[\"字段以及方法\",{\"1\":{\"132\":1}}],[\"字段\",{\"1\":{\"125\":3,\"132\":1,\"133\":1,\"220\":1,\"221\":1,\"305\":1,\"307\":2,\"877\":1,\"910\":1}}],[\"去除\",{\"1\":{\"872\":1}}],[\"去除文底水印\",{\"1\":{\"872\":1}}],[\"去银行办理业务一般要经过以下4个流程\",{\"1\":{\"800\":1}}],[\"去覆盖重写\",{\"1\":{\"788\":1}}],[\"去更新数据\",{\"1\":{\"675\":1}}],[\"去订购需要的各种披萨\",{\"1\":{\"609\":1}}],[\"去创建\",{\"1\":{\"602\":1}}],[\"去维护对子系统的操作\",{\"1\":{\"600\":1}}],[\"去拿爆米花\",{\"1\":{\"597\":1}}],[\"去发现问题所在\",{\"1\":{\"485\":1}}],[\"去调用我们重写的setvalue方法\",{\"1\":{\"291\":1}}],[\"去调用我们重写的getvalue方法\",{\"1\":{\"291\":1}}],[\"去存储\",{\"1\":{\"132\":1}}],[\"去永久代\",{\"1\":{\"125\":1}}],[\"去掉它的final修饰符\",{\"1\":{\"91\":1}}],[\"由c转为b\",{\"1\":{\"857\":1}}],[\"由content\",{\"1\":{\"854\":1}}],[\"由子类决定生产什么产品\",{\"1\":{\"798\":1}}],[\"由父类和子类共同继承\",{\"1\":{\"748\":1}}],[\"由勃兰特\",{\"1\":{\"736\":1}}],[\"由麻省理工学院计算机科学实验室的里斯科夫\",{\"1\":{\"732\":1}}],[\"由罗伯特\",{\"1\":{\"716\":1}}],[\"由副校长审批\",{\"1\":{\"709\":1}}],[\"由院长审批\",{\"1\":{\"709\":1}}],[\"由教学主任审批\",{\"1\":{\"709\":1}}],[\"由中介者对象负责后续的交互\",{\"1\":{\"656\":1}}],[\"由工厂方法模式创建的子类\",{\"1\":{\"613\":1}}],[\"由工厂子类完成\",{\"1\":{\"613\":1}}],[\"由具体子类实现\",{\"1\":{\"801\":1}}],[\"由具体工厂来创建\",{\"1\":{\"612\":1,\"616\":1}}],[\"由具体建造者来创建其各个零部件\",{\"1\":{\"551\":1}}],[\"由\",{\"1\":{\"612\":1}}],[\"由这个类来封装实例化对象的行为\",{\"1\":{\"608\":1}}],[\"由red\",{\"1\":{\"429\":1}}],[\"由ibm开发\",{\"1\":{\"429\":1}}],[\"由sun公司提出基于xml的文档格式\",{\"1\":{\"402\":1}}],[\"由oracle开发\",{\"1\":{\"384\":1}}],[\"由oracle赞助支持的java\",{\"1\":{\"384\":1}}],[\"由jvm进行调用业务方法\",{\"1\":{\"312\":1}}],[\"由于枚举类也是类\",{\"1\":{\"915\":1}}],[\"由于多表关联查询语句没有加表的别名\",{\"1\":{\"865\":1}}],[\"由于hashmap的干扰\",{\"1\":{\"850\":1}}],[\"由于没有设置容量初始大小\",{\"1\":{\"850\":1}}],[\"由于使用了\",{\"1\":{\"839\":1}}],[\"由于继承关系自身的缺点\",{\"1\":{\"800\":1}}],[\"由于单例模式只允许创建一个对象\",{\"1\":{\"762\":1}}],[\"由于每个类都减少了不必要的依赖\",{\"1\":{\"744\":1}}],[\"由于亲合度降低\",{\"1\":{\"741\":1}}],[\"由于一个请求没有明确的接收者\",{\"1\":{\"707\":1}}],[\"由于一些问题在新窗口打开的存在\",{\"1\":{\"125\":1}}],[\"由于聚合与迭代器的关系非常密切\",{\"1\":{\"653\":1}}],[\"由于聚合关联关系建立在抽象层\",{\"1\":{\"544\":1}}],[\"由于聚合关系建立在抽象层\",{\"1\":{\"537\":1}}],[\"由于在解释器模式中使用类来表示语言的文法规则\",{\"1\":{\"641\":1}}],[\"由于享元模式需要额外维护一个保存享元的数据结构\",{\"1\":{\"639\":1}}],[\"由于是一份实例\",{\"1\":{\"635\":1}}],[\"由于是private必须设置可访问\",{\"1\":{\"306\":1}}],[\"由于抽象构件声明了所有子类中的全部方法\",{\"1\":{\"569\":1}}],[\"由于其继承了\",{\"1\":{\"525\":1}}],[\"由于它不可变性\",{\"1\":{\"445\":1}}],[\"由于\",{\"1\":{\"294\":1,\"449\":1,\"457\":1}}],[\"由外部指定\",{\"1\":{\"281\":1}}],[\"由哪些实际的部分实现的\",{\"1\":{\"125\":1}}],[\"由内而外\",{\"1\":{\"36\":1}}],[\"被测对象所需要的依赖对象等\",{\"1\":{\"997\":1}}],[\"被测系统所依赖的组件\",{\"1\":{\"995\":1}}],[\"被测系统\",{\"0\":{\"994\":1},\"1\":{\"994\":1}}],[\"被测试类\",{\"1\":{\"241\":1}}],[\"被声明成private只会被自己代码所调用的方法\",{\"1\":{\"852\":1}}],[\"被声明为\",{\"1\":{\"122\":1}}],[\"被接受的访问者对象作为\",{\"1\":{\"838\":1}}],[\"被依赖类\",{\"1\":{\"828\":1}}],[\"被国际对象管理组织\",{\"1\":{\"822\":1}}],[\"被所有的代码共享\",{\"1\":{\"767\":1}}],[\"被复用的可能性就越大\",{\"1\":{\"737\":1}}],[\"被迫设计冗余的代码\",{\"1\":{\"722\":1}}],[\"被\",{\"1\":{\"710\":4}}],[\"被代理对象的方法\",{\"1\":{\"695\":1}}],[\"被代理对象\",{\"1\":{\"694\":1,\"695\":2}}],[\"被代理的对象可以是远程对象\",{\"1\":{\"692\":1}}],[\"被成功获取\",{\"1\":{\"632\":1}}],[\"被创建\",{\"1\":{\"632\":1}}],[\"被调用\",{\"1\":{\"596\":3,\"632\":1}}],[\"被访问\",{\"1\":{\"571\":2}}],[\"被适配的类\",{\"1\":{\"524\":1,\"528\":1}}],[\"被适配类\",{\"1\":{\"523\":1,\"525\":1}}],[\"被擦除为\",{\"1\":{\"293\":1}}],[\"被抑制的异常会由\",{\"1\":{\"259\":1}}],[\"被注解的子类继承父类注解可以用\",{\"1\":{\"237\":1}}],[\"被它修饰的annotation将具有继承性\",{\"1\":{\"230\":1}}],[\"被描述的注解在它所修饰的类中可以被保留到何时\",{\"1\":{\"228\":1}}],[\"被修饰的注解可以用在什么地方\",{\"1\":{\"227\":1}}],[\"被弃用的方法\",{\"1\":{\"222\":1}}],[\"被0除\",{\"1\":{\"198\":1}}],[\"被改变\",{\"1\":{\"123\":1}}],[\"经历了多次大规模一线实战的检验及不断完善\",{\"1\":{\"843\":1}}],[\"经典的单例模式是进程内唯一的\",{\"1\":{\"772\":1}}],[\"经常清理此类标记\",{\"1\":{\"853\":1}}],[\"经常往里插入的\",{\"1\":{\"850\":1}}],[\"经常出现两个对象因接口不兼容而不能在一起工作的实例\",{\"1\":{\"518\":1}}],[\"经常作为参数\",{\"1\":{\"123\":1}}],[\"经过jax\",{\"1\":{\"424\":1}}],[\"经过下面的改造就可以让它变为现实\",{\"1\":{\"91\":1}}],[\"才推荐进行分库分表\",{\"1\":{\"863\":1}}],[\"才能写出有效的单元测试来验证正确性\",{\"1\":{\"991\":1}}],[\"才能在尽量最小化代码修改的情况下\",{\"1\":{\"809\":1}}],[\"才能知道这个类到底依赖了哪些单例类\",{\"1\":{\"765\":1}}],[\"才去创建\",{\"1\":{\"754\":1}}],[\"才被被创建\",{\"1\":{\"622\":1}}],[\"才可被描述为\",{\"1\":{\"876\":1}}],[\"才可以省略可选的分组括号\",{\"1\":{\"913\":1}}],[\"才可以使用的可变参数\",{\"1\":{\"848\":1}}],[\"才可以在代码级违反单一职责原则\",{\"1\":{\"719\":1}}],[\"才可以\",{\"1\":{\"311\":1}}],[\"才可能使用\",{\"1\":{\"123\":1}}],[\"才会关闭处于time\",{\"1\":{\"870\":1}}],[\"才会装载\",{\"1\":{\"758\":1}}],[\"才会回来执行try或者catch块中的return或者throw语句\",{\"1\":{\"251\":1}}],[\"才会加载对应的配置文件去解析\",{\"1\":{\"114\":1}}],[\"才有永久代的概念\",{\"1\":{\"125\":1}}],[\"值类型可能是int\",{\"1\":{\"978\":1}}],[\"值的全局变量\",{\"1\":{\"768\":1}}],[\"值的规定只是说如果两个对象相等\",{\"1\":{\"175\":1}}],[\"值得关注的java技术站点\",{\"1\":{\"441\":1}}],[\"值必须是相同的\",{\"1\":{\"177\":1}}],[\"值赋值给\",{\"0\":{\"166\":1},\"1\":{\"166\":1}}],[\"值也不可变\",{\"1\":{\"123\":1}}],[\"值经常被使用\",{\"1\":{\"123\":1}}],[\"值\",{\"1\":{\"123\":1,\"175\":2,\"181\":1}}],[\"数值的整数字面量会使用大写的\",{\"1\":{\"935\":1}}],[\"数值后使用大写l\",{\"1\":{\"846\":1}}],[\"数字字面量\",{\"0\":{\"935\":1}}],[\"数字是一个整体\",{\"1\":{\"857\":1}}],[\"数量超出限制\",{\"1\":{\"874\":1}}],[\"数千万年\",{\"1\":{\"863\":1}}],[\"数百岁\",{\"1\":{\"863\":1}}],[\"数组初始化\",{\"0\":{\"920\":1},\"1\":{\"898\":1,\"915\":1}}],[\"数组初始化之后就不能再引用其它数组\",{\"1\":{\"122\":1}}],[\"数组创建完成之后\",{\"1\":{\"850\":1}}],[\"数组空间大小的length\",{\"1\":{\"850\":1}}],[\"数组后\",{\"1\":{\"644\":1}}],[\"数组\",{\"0\":{\"919\":1},\"1\":{\"305\":1,\"650\":1,\"790\":1}}],[\"数组等类型的表示形式就不同了\",{\"1\":{\"305\":1}}],[\"数组同样也被映射为class\",{\"1\":{\"302\":1}}],[\"数组类型可能是int\",{\"1\":{\"978\":1}}],[\"数组类型\",{\"1\":{\"298\":1}}],[\"数组中包含不兼容的值抛出的异常\",{\"1\":{\"261\":2}}],[\"数组长度为负异常\",{\"1\":{\"261\":1}}],[\"数组索引越界异常\",{\"1\":{\"261\":1}}],[\"数组的方法\",{\"1\":{\"122\":1}}],[\"数组存储数据\",{\"1\":{\"122\":1}}],[\"数据查询对象\",{\"1\":{\"868\":1,\"873\":1}}],[\"数据存储服务提供的接口\",{\"1\":{\"868\":1}}],[\"数据访问层\",{\"1\":{\"868\":1}}],[\"数据订正\",{\"1\":{\"865\":1}}],[\"数据顺序等\",{\"1\":{\"860\":1}}],[\"数据序列化和传输的性能损耗也是问题\",{\"1\":{\"858\":1}}],[\"数据传输对象\",{\"1\":{\"845\":1,\"868\":1,\"873\":1}}],[\"数据对象\",{\"1\":{\"845\":1}}],[\"数据源\",{\"1\":{\"761\":1}}],[\"数据抽象和层次\",{\"1\":{\"732\":1}}],[\"数据类\",{\"1\":{\"678\":1}}],[\"数据类型中引用太阳系年龄问题\",{\"1\":{\"872\":1}}],[\"数据类型保持绝对一致\",{\"1\":{\"864\":1}}],[\"数据类型是unsigned\",{\"1\":{\"863\":1}}],[\"数据类型进行存储\",{\"1\":{\"209\":1}}],[\"数据类型\",{\"0\":{\"118\":1}}],[\"数据初始化\",{\"1\":{\"642\":1}}],[\"数据分析及数据可视化的开发环境\",{\"1\":{\"425\":1}}],[\"数据结构变更\",{\"1\":{\"871\":1}}],[\"数据结构与集合\",{\"1\":{\"843\":1}}],[\"数据结构\",{\"0\":{\"395\":1},\"1\":{\"796\":1,\"839\":1}}],[\"数据被保护在抽象数据类型的内部\",{\"1\":{\"209\":1}}],[\"数据量大怎么解决\",{\"1\":{\"181\":1}}],[\"数据量小还可以接受\",{\"1\":{\"181\":1}}],[\"数据\",{\"1\":{\"143\":1,\"770\":1}}],[\"数据搜索\",{\"1\":{\"96\":1}}],[\"数据库死锁\",{\"1\":{\"874\":1}}],[\"数据库服务出错\",{\"1\":{\"874\":1}}],[\"数据库服务超时\",{\"1\":{\"874\":1}}],[\"数据库名\",{\"1\":{\"863\":1}}],[\"数据库字段名的修改代价很大\",{\"1\":{\"863\":1}}],[\"数据库字段的bigint必须与类属性的long类型相对应\",{\"1\":{\"848\":1}}],[\"数据库表示是与否的值\",{\"1\":{\"863\":1}}],[\"数据库表\",{\"1\":{\"851\":1}}],[\"数据库的查询结果可能为null\",{\"1\":{\"858\":1}}],[\"数据库的查询结果可能是null\",{\"1\":{\"848\":1}}],[\"数据库的表结构和索引设计缺陷带来的系统架构缺陷或性能风险\",{\"1\":{\"843\":1}}],[\"数据库的连接池等\",{\"1\":{\"762\":1}}],[\"数据库的连接池\",{\"1\":{\"750\":1}}],[\"数据库中的连接池等也都是单例模式\",{\"1\":{\"750\":1}}],[\"数据库与操作系统的备份操作\",{\"1\":{\"663\":1}}],[\"数据库事务管理中的回滚操作\",{\"1\":{\"663\":1}}],[\"数据库空间等服务器资源\",{\"1\":{\"635\":1}}],[\"数据库连接池\",{\"1\":{\"629\":1,\"638\":1,\"766\":1}}],[\"数据库连接代码时\",{\"1\":{\"258\":1}}],[\"数据库操作\",{\"1\":{\"432\":1}}],[\"数据库访问\",{\"1\":{\"407\":1}}],[\"数据库搜索实现\",{\"1\":{\"96\":1}}],[\"数据库\",{\"0\":{\"2\":1,\"3\":1,\"394\":1}}],[\"内就不能再创建新的\",{\"1\":{\"771\":1}}],[\"内\",{\"1\":{\"771\":2}}],[\"内聚性和耦合性并非独立的\",{\"1\":{\"818\":1}}],[\"内聚性以及可维护性\",{\"1\":{\"797\":1}}],[\"内聚\",{\"1\":{\"741\":1}}],[\"内网通过代理穿透防火墙\",{\"1\":{\"704\":1}}],[\"内置支持\",{\"1\":{\"450\":1}}],[\"内置注解\",{\"0\":{\"223\":1,\"224\":1,\"225\":1}}],[\"内存位置\",{\"1\":{\"873\":1}}],[\"内存爆了\",{\"1\":{\"852\":1}}],[\"内存中动态生成了代理对象\",{\"1\":{\"700\":1}}],[\"内存地址\",{\"1\":{\"689\":1}}],[\"内存\",{\"1\":{\"549\":1,\"635\":1,\"860\":1}}],[\"内存卡时需要一个读卡器等\",{\"1\":{\"518\":1}}],[\"内存文件系统\",{\"1\":{\"415\":1}}],[\"内存模型引入\",{\"0\":{\"381\":1}}],[\"内存模型详解\",{\"0\":{\"374\":1}}],[\"内存结构\",{\"0\":{\"379\":1}}],[\"内存分析之堆内存和metaspace内存\",{\"0\":{\"377\":1}}],[\"内存分析之堆外内存\",{\"0\":{\"375\":1}}],[\"内存不足错误\",{\"1\":{\"247\":1}}],[\"内嵌的默认序列化方式\",{\"1\":{\"185\":1}}],[\"内部的实现类用impl的后缀与接口区别\",{\"1\":{\"845\":1}}],[\"内部维护一个当前状态\",{\"1\":{\"776\":1}}],[\"内部状态\",{\"1\":{\"636\":1}}],[\"内部状态指对象共享出来的信息\",{\"1\":{\"631\":1}}],[\"内部状态和外部状态\",{\"0\":{\"631\":1},\"1\":{\"631\":1}}],[\"内部方法无需一致\",{\"1\":{\"565\":1}}],[\"内部类\",{\"1\":{\"305\":1,\"651\":2,\"853\":1,\"910\":1}}],[\"内部实现在\",{\"1\":{\"170\":1}}],[\"内部没有改变\",{\"1\":{\"122\":1}}],[\"内部使用\",{\"1\":{\"122\":1,\"124\":1}}],[\"内容不是严格要求遵守\",{\"1\":{\"962\":1}}],[\"内容也可以出现\",{\"1\":{\"959\":1}}],[\"内容违禁词过滤等风控策略\",{\"1\":{\"861\":1}}],[\"内容\",{\"1\":{\"11\":1,\"282\":1,\"549\":1,\"853\":1}}],[\"概念解释\",{\"1\":{\"865\":1}}],[\"概念是多线程开发中常使用到的\",{\"1\":{\"757\":1}}],[\"概念上更接近实现方\",{\"1\":{\"113\":1}}],[\"概念上更依赖调用方\",{\"1\":{\"113\":1}}],[\"概览\",{\"0\":{\"122\":1,\"137\":1}}],[\"编码排序略有不同\",{\"1\":{\"892\":1}}],[\"编码排在\",{\"1\":{\"892\":1}}],[\"编码顺序先后出现\",{\"1\":{\"892\":1}}],[\"编码\",{\"1\":{\"881\":1,\"947\":1}}],[\"编号即被永久固定\",{\"1\":{\"857\":1}}],[\"编号不与公司业务架构\",{\"1\":{\"857\":1}}],[\"编写完成之后\",{\"1\":{\"990\":1}}],[\"编写测试方法\",{\"1\":{\"981\":2}}],[\"编写单元测试\",{\"0\":{\"973\":1}}],[\"编写单元测试代码遵守bcde原则\",{\"1\":{\"860\":1}}],[\"编写制作豆浆的程序\",{\"1\":{\"802\":1}}],[\"编写制作披萨的过程类\",{\"1\":{\"609\":1}}],[\"编写软件过程中\",{\"1\":{\"797\":1}}],[\"编写代码的应用实例\",{\"1\":{\"723\":1}}],[\"编写\",{\"1\":{\"609\":1}}],[\"编写程序展示一个学校院系结构\",{\"1\":{\"572\":1}}],[\"编辑器以及构建知识系统的框架\",{\"1\":{\"432\":1}}],[\"编辑此页链接\",{\"1\":{\"6\":1}}],[\"编程实践\",{\"0\":{\"948\":1}}],[\"编程风格指定了以下\",{\"1\":{\"947\":1}}],[\"编程风格指南\",{\"0\":{\"875\":1}}],[\"编程风格不同\",{\"1\":{\"907\":1}}],[\"编程规范中却不是必须的\",{\"1\":{\"912\":1}}],[\"编程规范性\",{\"1\":{\"797\":1}}],[\"编程规约\",{\"0\":{\"844\":1}}],[\"编程的\",{\"1\":{\"835\":1}}],[\"编程能力和设计能力\",{\"1\":{\"797\":1}}],[\"编程中遵循其它原则\",{\"1\":{\"736\":1}}],[\"编程中如何选择代理模式\",{\"1\":{\"702\":1}}],[\"编程复杂度\",{\"1\":{\"614\":1}}],[\"编程方式操作字节码的开发库\",{\"1\":{\"386\":1}}],[\"编程思想\",{\"1\":{\"153\":1,\"155\":3,\"219\":1}}],[\"编译期没法确定泛型参数化类型\",{\"1\":{\"293\":1}}],[\"编译期保留\",{\"1\":{\"228\":1}}],[\"编译错误\",{\"1\":{\"285\":3,\"289\":1,\"290\":7,\"291\":1,\"294\":3,\"296\":2,\"297\":2}}],[\"编译仍能顺利通过\",{\"1\":{\"252\":1}}],[\"编译异常\",{\"1\":{\"248\":1}}],[\"编译通过\",{\"1\":{\"236\":1,\"290\":4}}],[\"编译器是允许非泛型集合与泛型集合互相赋值\",{\"1\":{\"850\":1}}],[\"编译器生成工具\",{\"0\":{\"389\":1}}],[\"编译器知道类型参数的范围\",{\"1\":{\"284\":1}}],[\"编译器不要求强制处置的异常\",{\"1\":{\"249\":1}}],[\"编译器要求必须处置的异常\",{\"1\":{\"249\":1}}],[\"编译器分别使用了\",{\"1\":{\"228\":1}}],[\"编译器并没有记录下\",{\"1\":{\"228\":1}}],[\"编译器会检查类型\",{\"1\":{\"279\":1}}],[\"编译器会自动继承java\",{\"1\":{\"237\":1}}],[\"编译器会自动进行这个优化\",{\"1\":{\"139\":1}}],[\"编译器会对此做出检查\",{\"1\":{\"223\":1}}],[\"编译器会在缓冲池范围内的基本类型自动装箱过程调用\",{\"1\":{\"120\":1}}],[\"编译时注入框架\",{\"1\":{\"397\":1}}],[\"编译时由编译器生成的桥方法\",{\"1\":{\"291\":2}}],[\"编译时擦除到类型a\",{\"1\":{\"284\":1}}],[\"编译时通过代码里标识的元数据动态处理\",{\"1\":{\"221\":1}}],[\"编译时动态处理\",{\"1\":{\"221\":1}}],[\"编译时多态主要指方法的重载\",{\"1\":{\"211\":1}}],[\"编译检查\",{\"1\":{\"221\":1}}],[\"79301241\",{\"1\":{\"1000\":1}}],[\"748\",{\"1\":{\"980\":1}}],[\"74a14482\",{\"1\":{\"127\":1}}],[\"78\",{\"1\":{\"979\":1}}],[\"7868820\",{\"1\":{\"299\":1}}],[\"768\",{\"1\":{\"978\":1}}],[\"75\",{\"1\":{\"850\":1}}],[\"71\",{\"1\":{\"979\":1}}],[\"71799078\",{\"1\":{\"314\":1}}],[\"71860633\",{\"1\":{\"243\":1}}],[\"7中引入的\",{\"1\":{\"259\":1}}],[\"70037927\",{\"1\":{\"219\":1}}],[\"7开始支持\",{\"1\":{\"193\":1}}],[\"7\",{\"0\":{\"186\":1},\"1\":{\"120\":1,\"125\":1,\"130\":1,\"150\":2,\"170\":1,\"186\":1,\"228\":1,\"259\":1,\"264\":1,\"275\":10,\"291\":1,\"440\":1,\"466\":1,\"481\":1,\"798\":2,\"845\":1,\"848\":1,\"872\":3,\"978\":1}}],[\"多块语句\",{\"1\":{\"902\":1}}],[\"多表关联中存在多\",{\"1\":{\"874\":1}}],[\"多表关联查询时\",{\"1\":{\"864\":1}}],[\"多见于数据迁移场景中\",{\"1\":{\"868\":1}}],[\"多层条件语句建议使用卫语句\",{\"1\":{\"860\":1}}],[\"多层级嵌套使用\",{\"1\":{\"680\":1}}],[\"多线程并行处理定时任务时\",{\"1\":{\"851\":1}}],[\"多线程中的线程池\",{\"1\":{\"750\":1}}],[\"多重条件语句不易维护\",{\"1\":{\"783\":1}}],[\"多用组合少用继承\",{\"0\":{\"811\":1},\"1\":{\"811\":1,\"814\":1,\"818\":1}}],[\"多用组合\",{\"1\":{\"783\":1,\"791\":1}}],[\"多用于在多系统集成时\",{\"1\":{\"253\":1}}],[\"多例模式创建的对象都是同一个类的对象\",{\"1\":{\"773\":1}}],[\"多例\",{\"1\":{\"773\":1}}],[\"多途加密开发库\",{\"1\":{\"427\":1}}],[\"多协议\",{\"1\":{\"419\":1}}],[\"多播消息传递工具\",{\"1\":{\"414\":1}}],[\"多语言事件驱动应用框架\",{\"1\":{\"398\":1}}],[\"多个注解\",{\"1\":{\"930\":1}}],[\"多个连续的空行是允许的\",{\"1\":{\"910\":1}}],[\"多个构造方法次序\",{\"1\":{\"872\":1}}],[\"多个参数逗号后面必须加空格\",{\"1\":{\"847\":1}}],[\"多个对象间存在一对多关系\",{\"1\":{\"798\":1}}],[\"多个对象可以处理一个请求\",{\"1\":{\"712\":1}}],[\"多个类只区别在表现行为不同\",{\"1\":{\"792\":1}}],[\"多个部件或零件\",{\"1\":{\"558\":1}}],[\"多个限制\",{\"1\":{\"284\":1}}],[\"多个并发多线程使用\",{\"1\":{\"115\":1}}],[\"多元泛型\",{\"1\":{\"281\":1}}],[\"多对多这种关联关系来表示\",{\"1\":{\"217\":1}}],[\"多对\",{\"1\":{\"217\":1}}],[\"多态特性我们可以利用接口来实现\",{\"1\":{\"813\":1}}],[\"多态特性的支持也不友好\",{\"1\":{\"764\":1}}],[\"多态都支持得不好\",{\"1\":{\"764\":1}}],[\"多态等\",{\"1\":{\"545\":1}}],[\"多态性\",{\"1\":{\"287\":1}}],[\"多态在新窗口打开\",{\"1\":{\"219\":1}}],[\"多态分为编译时多态和运行时多态\",{\"1\":{\"211\":1}}],[\"多态\",{\"0\":{\"211\":1},\"1\":{\"187\":1,\"764\":1}}],[\"多次调用\",{\"1\":{\"138\":1}}],[\"多次调用会取得同一个对象的引用\",{\"1\":{\"120\":1}}],[\"基类\",{\"1\":{\"738\":2,\"739\":1}}],[\"基本格式总是可以接受的\",{\"1\":{\"955\":1}}],[\"基本数据类型不能使用\",{\"1\":{\"848\":1}}],[\"基本工作原理是\",{\"1\":{\"837\":1}}],[\"基本构件\",{\"0\":{\"824\":1}}],[\"基本思想是\",{\"1\":{\"804\":1}}],[\"基本思路和类的适配器模式相同\",{\"1\":{\"527\":1}}],[\"基本方法\",{\"1\":{\"801\":1}}],[\"基本介绍\",{\"0\":{\"518\":1,\"616\":1,\"716\":1,\"721\":1,\"725\":1,\"732\":1,\"736\":1,\"741\":1,\"822\":1},\"1\":{\"523\":1}}],[\"基本上功能代码开发完\",{\"1\":{\"991\":1}}],[\"基本上不需要做维护\",{\"1\":{\"810\":1}}],[\"基本上每一个\",{\"1\":{\"459\":1}}],[\"基本上imagemagick能够支持的图片格式和处理方式都能够处理\",{\"1\":{\"408\":1}}],[\"基本类型boolean\",{\"1\":{\"302\":1}}],[\"基本类型\",{\"1\":{\"298\":1}}],[\"基本类型没有\",{\"1\":{\"138\":1}}],[\"基本类型对应的缓冲池如下\",{\"1\":{\"120\":1}}],[\"基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成\",{\"1\":{\"119\":1}}],[\"基本类型都有对应的包装类型\",{\"1\":{\"119\":1}}],[\"基于soa的理念\",{\"1\":{\"845\":1}}],[\"基于spring\",{\"1\":{\"398\":1}}],[\"基于抽象而非实现编程\",{\"1\":{\"808\":1}}],[\"基于接口编程各种功能\",{\"1\":{\"789\":1}}],[\"基于接口而非实现编程能通过接口这样一个中间层\",{\"1\":{\"818\":1}}],[\"基于接口而非实现编程\",{\"0\":{\"807\":1},\"1\":{\"741\":1,\"808\":3,\"809\":1,\"818\":1}}],[\"基于新的使用方式\",{\"1\":{\"769\":1}}],[\"基于这个设计思想\",{\"1\":{\"614\":1}}],[\"基于这个小知识\",{\"1\":{\"90\":1}}],[\"基于类的最小设计原则\",{\"1\":{\"537\":1}}],[\"基于\",{\"1\":{\"472\":1}}],[\"基于gwt构建的事件驱动框架\",{\"1\":{\"434\":1}}],[\"基于组件的web应用框架\",{\"1\":{\"434\":1}}],[\"基于组件的框架\",{\"1\":{\"434\":1}}],[\"基于注解处理和编译时源码生成的框架\",{\"1\":{\"424\":1}}],[\"基于nio实现了阻塞和非阻塞api的web服务器\",{\"1\":{\"419\":1}}],[\"基于xmpp\",{\"1\":{\"414\":1}}],[\"基于xml的构建管理工具\",{\"1\":{\"384\":1}}],[\"基于kafka构建\",{\"1\":{\"414\":1}}],[\"基于jvm的语言\",{\"0\":{\"411\":1}}],[\"基于jackson流式api\",{\"1\":{\"409\":1}}],[\"基于imagemagick或graphicsmagick命令行的图片处理开发库\",{\"1\":{\"408\":1}}],[\"基于opengl技术开发的3d图形引擎\",{\"1\":{\"404\":1}}],[\"基于此我们如何通过反射获取class类对象以及类中的成员变量\",{\"1\":{\"304\":1}}],[\"基础知识体系的完备性\",{\"1\":{\"871\":1}}],[\"基础平台\",{\"1\":{\"868\":1}}],[\"基础类型集合\",{\"1\":{\"406\":2}}],[\"基础详解\",{\"0\":{\"335\":1}}],[\"基础\",{\"0\":{\"364\":1,\"365\":1,\"366\":1,\"374\":1,\"379\":1,\"381\":1},\"1\":{\"145\":1,\"146\":1,\"147\":1,\"148\":1,\"187\":1}}],[\"本章节介绍\",{\"1\":{\"932\":1}}],[\"本工程内部子项目模块依赖的库\",{\"1\":{\"873\":1}}],[\"本规约明确防止npe是调用者的责任\",{\"1\":{\"858\":1}}],[\"本姑娘是外貌协会的资深会员\",{\"1\":{\"852\":1}}],[\"本书紧扣学以致用\",{\"1\":{\"843\":1}}],[\"本身的组成和类\",{\"1\":{\"826\":1}}],[\"本身是一套符号的规定\",{\"1\":{\"822\":1}}],[\"本类内部创建对象实例\",{\"1\":{\"752\":1,\"753\":1}}],[\"本内容讲解的重点也不是原理和实现\",{\"1\":{\"606\":1}}],[\"本应该使用if语句进行条件判断的情况下\",{\"1\":{\"272\":1}}],[\"本文档其它章节中所要求的\",{\"1\":{\"910\":1}}],[\"本文档中的示例代是\",{\"1\":{\"878\":1}}],[\"本文档侧重于讨论我们普遍遵循的\",{\"1\":{\"876\":1}}],[\"本文档讨论的不仅涉及代码对齐的美观问题\",{\"1\":{\"876\":1}}],[\"本文档是\",{\"1\":{\"876\":1}}],[\"本文泛指ibatis\",{\"1\":{\"873\":1}}],[\"本文泛指类\",{\"1\":{\"873\":1}}],[\"本文是开发手册\",{\"1\":{\"860\":1}}],[\"本文mysql规约中的建表约定第\",{\"1\":{\"845\":1}}],[\"本文综合多篇文章后\",{\"1\":{\"244\":1,\"278\":1,\"300\":1}}],[\"本文主要针对junit4要点进行梳理总结\",{\"1\":{\"968\":1}}],[\"本文主要综合了网络上比较好的文章\",{\"1\":{\"299\":1}}],[\"本文主要介绍java\",{\"1\":{\"207\":1}}],[\"本文主要对java基础知识体系小结\",{\"1\":{\"154\":1}}],[\"本文主要对java基础知识点进行总结\",{\"1\":{\"117\":1}}],[\"本质this指向本对象的指针\",{\"1\":{\"200\":1}}],[\"本质上是将对象的地址以值的方式传递到形参中\",{\"1\":{\"127\":1}}],[\"本页面就是一个示例\",{\"1\":{\"6\":1}}],[\"z比较结果相同\",{\"1\":{\"850\":1}}],[\"z比较结果和y\",{\"1\":{\"850\":1}}],[\"zone\",{\"1\":{\"618\":9}}],[\"zookeeper\",{\"1\":{\"399\":1}}],[\"zero\",{\"1\":{\"979\":1}}],[\"zeromq的纯java实现\",{\"1\":{\"414\":1}}],[\"zero=integer\",{\"1\":{\"90\":1}}],[\"zxing\",{\"1\":{\"408\":1}}],[\"z\",{\"1\":{\"120\":2,\"133\":1,\"134\":4,\"138\":8,\"139\":1,\"181\":2,\"312\":2,\"637\":2,\"850\":2}}],[\"zhaoguhong\",{\"1\":{\"314\":1}}],[\"zhihu\",{\"1\":{\"116\":1,\"243\":1}}],[\"zhuanlan\",{\"1\":{\"116\":1}}],[\"应以\",{\"1\":{\"934\":1}}],[\"应以原文档为标准\",{\"1\":{\"875\":1}}],[\"应当至于此处\",{\"1\":{\"887\":1}}],[\"应当遵守的原则\",{\"1\":{\"714\":1}}],[\"应直接返回\",{\"1\":{\"865\":1}}],[\"应使用有业务含义的自定义异常\",{\"1\":{\"858\":1}}],[\"应使用常量或确定有值的对象来调用equals\",{\"1\":{\"848\":1}}],[\"应用到测试类的所有测试用例\",{\"1\":{\"980\":1}}],[\"应用分层\",{\"0\":{\"868\":1}}],[\"应用中的扩展日志\",{\"1\":{\"859\":1}}],[\"应用中不可直接使用日志系统\",{\"1\":{\"859\":1}}],[\"应用名\",{\"1\":{\"859\":2}}],[\"应用内部推荐异常抛出\",{\"1\":{\"858\":1}}],[\"应用内共享常量\",{\"1\":{\"846\":2}}],[\"应用工具类包名为com\",{\"1\":{\"845\":1}}],[\"应用这条原则\",{\"1\":{\"808\":1}}],[\"应用的配置对象\",{\"1\":{\"750\":1}}],[\"应用的源码分析\",{\"0\":{\"618\":1}}],[\"应用示例\",{\"0\":{\"738\":1}}],[\"应用实例改进\",{\"0\":{\"739\":1,\"743\":1}}],[\"应用实例\",{\"0\":{\"718\":1,\"723\":1,\"734\":1,\"742\":1},\"1\":{\"650\":1}}],[\"应用实例说明\",{\"1\":{\"524\":1,\"528\":1}}],[\"应用场景\",{\"0\":{\"823\":1},\"1\":{\"614\":1}}],[\"应用\",{\"0\":{\"556\":1},\"1\":{\"868\":1}}],[\"应用监控工具\",{\"0\":{\"416\":1}}],[\"应用服务器\",{\"0\":{\"429\":1},\"1\":{\"384\":1}}],[\"应用该方法可在运行时发现一个对象完整的继承结构\",{\"1\":{\"305\":1}}],[\"应用程序中的部分对象可能会根据不同的情况做出不同的行为\",{\"1\":{\"775\":1}}],[\"应用程序中的对话框\",{\"1\":{\"750\":1}}],[\"应用程序的日志对象\",{\"1\":{\"750\":1}}],[\"应用程序的开发库\",{\"1\":{\"423\":1}}],[\"应用程序不应该去处理此类错误\",{\"1\":{\"247\":1}}],[\"应用程序类路径中的服务提供者将被忽略\",{\"1\":{\"114\":1}}],[\"应该出现在每个\",{\"1\":{\"959\":1}}],[\"应该在注释中说明正当的理由\",{\"1\":{\"950\":1}}],[\"应该选择json作为通信中使用的标准数据交换格式\",{\"1\":{\"854\":1}}],[\"应该显示成中划线\",{\"1\":{\"848\":1}}],[\"应该使用双参数\",{\"1\":{\"848\":1}}],[\"应该尽量少用\",{\"1\":{\"812\":1}}],[\"应该改为去掉\",{\"1\":{\"809\":1}}],[\"应该将父类的方法\",{\"1\":{\"748\":1}}],[\"应该避免类中出现这样非直接朋友关系的耦合\",{\"1\":{\"743\":1}}],[\"应该创建弱耦合的类\",{\"1\":{\"741\":1}}],[\"应该像其他\",{\"1\":{\"458\":1}}],[\"应该如何做呢\",{\"1\":{\"293\":1}}],[\"应该会有会心一笑\",{\"1\":{\"275\":1}}],[\"应该继续抛出\",{\"1\":{\"252\":1}}],[\"应该捕获那些知道如何处理的异常\",{\"1\":{\"252\":1}}],[\"应该注意的是\",{\"1\":{\"135\":1,\"141\":1}}],[\"应该都能知道大概的流程了\",{\"1\":{\"108\":1}}],[\"kname\",{\"1\":{\"937\":1}}],[\"knowledge\",{\"1\":{\"812\":1}}],[\"known\",{\"1\":{\"618\":1}}],[\"knowntonotexist\",{\"1\":{\"310\":1}}],[\"knownproviders\",{\"1\":{\"114\":4}}],[\"kkb\",{\"1\":{\"850\":1}}],[\"kunlun\",{\"1\":{\"845\":1}}],[\"kpi考核\",{\"1\":{\"591\":1}}],[\"kryo\",{\"1\":{\"428\":1}}],[\"kaikeba等bu一级\",{\"1\":{\"869\":1}}],[\"kaikeba\",{\"1\":{\"845\":1}}],[\"kamon用来监测在jvm上运行的应用程序\",{\"1\":{\"416\":1}}],[\"kamon\",{\"1\":{\"416\":1}}],[\"kafka\",{\"1\":{\"414\":1}}],[\"king\",{\"1\":{\"636\":1}}],[\"kind\",{\"1\":{\"310\":1,\"312\":2}}],[\"kibana\",{\"1\":{\"412\":1}}],[\"kotlin\",{\"1\":{\"411\":1}}],[\"koloboke\",{\"1\":{\"406\":1}}],[\"kyro\",{\"1\":{\"409\":1}}],[\"kernighan\",{\"1\":{\"901\":1}}],[\"kele\",{\"1\":{\"728\":5}}],[\"kept\",{\"1\":{\"145\":1}}],[\"keyset\",{\"1\":{\"850\":1}}],[\"keyset其实是遍历了\",{\"1\":{\"850\":1}}],[\"key=c\",{\"1\":{\"644\":1}}],[\"key=b\",{\"1\":{\"644\":1}}],[\"key=a\",{\"1\":{\"644\":1}}],[\"key=value1\",{\"1\":{\"106\":1}}],[\"keycloak\",{\"1\":{\"427\":1}}],[\"keyboard\",{\"1\":{\"215\":2}}],[\"key\",{\"1\":{\"104\":2,\"123\":1,\"281\":5,\"632\":13,\"644\":6,\"771\":1,\"779\":5,\"846\":4,\"850\":1,\"863\":2,\"874\":1}}],[\"keyword\",{\"1\":{\"96\":3,\"134\":1}}],[\"k++\",{\"1\":{\"120\":1}}],[\"k\",{\"0\":{\"901\":1},\"1\":{\"120\":5,\"133\":1,\"281\":3,\"902\":1,\"903\":1}}],[\"保持对齐\",{\"1\":{\"933\":1}}],[\"保持除功能点之外的其它jar包仲裁结果不变\",{\"1\":{\"869\":1}}],[\"保持完全兼容性\",{\"1\":{\"869\":1}}],[\"保持相对兼容性\",{\"1\":{\"869\":1}}],[\"保持单元测试的独立性\",{\"1\":{\"860\":1}}],[\"保持代码的简洁性\",{\"1\":{\"845\":1}}],[\"保持不变\",{\"1\":{\"790\":1}}],[\"保护当前系统主干功能可用\",{\"1\":{\"871\":1}}],[\"保护方法虽然只是子类关心\",{\"1\":{\"848\":1}}],[\"保护\",{\"1\":{\"308\":1}}],[\"保证核心系统正常可用\",{\"1\":{\"871\":1}}],[\"保证被关联的字段需要有索引\",{\"1\":{\"864\":1}}],[\"保证代码松耦合\",{\"1\":{\"816\":1}}],[\"保证独一无二\",{\"1\":{\"589\":1}}],[\"保证一个类仅有一个实例\",{\"1\":{\"589\":1}}],[\"保证内存可用\",{\"1\":{\"310\":1}}],[\"保证锁一定被释放\",{\"1\":{\"258\":1}}],[\"保证程序代码更加优雅\",{\"1\":{\"244\":1}}],[\"保证等价的两个对象散列值也相等\",{\"1\":{\"139\":1}}],[\"保证能让你写出同事看不懂的代码~\",{\"1\":{\"88\":1}}],[\"保存日期\",{\"1\":{\"859\":1}}],[\"保存游戏角色的状态\",{\"1\":{\"667\":1}}],[\"保存状态\",{\"1\":{\"664\":1}}],[\"保存中介者对象\",{\"1\":{\"656\":1}}],[\"保存当前数组的对象个数\",{\"1\":{\"650\":1}}],[\"保存在\",{\"1\":{\"859\":1}}],[\"保存在连接对象中的用户名\",{\"1\":{\"631\":1}}],[\"保存在堆中\",{\"1\":{\"125\":1}}],[\"保存对象的状态\",{\"1\":{\"591\":1}}],[\"保存反射信息\",{\"1\":{\"310\":1}}],[\"保存\",{\"1\":{\"242\":1}}],[\"保存数据库\",{\"1\":{\"242\":1}}],[\"保存实现类的全名\",{\"1\":{\"114\":1}}],[\"保存实现类的url\",{\"1\":{\"114\":1}}],[\"类在设计与实现时要符合单一原则\",{\"1\":{\"871\":1}}],[\"类在第一次使用时才动态加载到\",{\"1\":{\"145\":1}}],[\"类方法的注释必须使用javadoc规范\",{\"1\":{\"853\":1}}],[\"类方法当中的一个参数\",{\"1\":{\"218\":1}}],[\"类属性\",{\"1\":{\"853\":1}}],[\"类第一次被使用时装载\",{\"1\":{\"851\":1}}],[\"类static成员变量如果仅在本类使用\",{\"1\":{\"848\":1}}],[\"类非static成员变量并且仅在本类使用\",{\"1\":{\"848\":1}}],[\"类非static成员变量并且与子类共享\",{\"1\":{\"848\":1}}],[\"类内容顺序\",{\"0\":{\"896\":1}}],[\"类内方法定义的顺序依次是\",{\"1\":{\"848\":1}}],[\"类内共享常量\",{\"1\":{\"846\":2}}],[\"类提到了\",{\"1\":{\"839\":1}}],[\"类提供了一个\",{\"1\":{\"686\":1}}],[\"类提供了特殊的构造函数方法\",{\"1\":{\"271\":1}}],[\"类调用作为参数的\",{\"1\":{\"839\":1}}],[\"类关系记忆技巧总结如下表所示\",{\"1\":{\"835\":1}}],[\"类关系图\",{\"0\":{\"319\":1}}],[\"类实现\",{\"1\":{\"834\":1}}],[\"类实现了接口\",{\"1\":{\"834\":1}}],[\"类之间的关系\",{\"0\":{\"827\":1},\"1\":{\"826\":1}}],[\"类之间各司其职\",{\"1\":{\"655\":1}}],[\"类派生出两个更加细分的抽象类\",{\"1\":{\"812\":1}}],[\"类呢\",{\"1\":{\"809\":1}}],[\"类对象\",{\"1\":{\"809\":1}}],[\"类对象的全局唯一性可以通过多种不同的方式来保证\",{\"1\":{\"769\":1}}],[\"类比一下\",{\"1\":{\"771\":1}}],[\"类被装载时并不会立即实例化\",{\"1\":{\"758\":1}}],[\"类并不一定具有继承关系\",{\"1\":{\"814\":1}}],[\"类并不是\",{\"1\":{\"743\":1}}],[\"类并且告诉\",{\"1\":{\"466\":1}}],[\"类粒度比较大\",{\"1\":{\"741\":1}}],[\"类相关方法\",{\"1\":{\"734\":1}}],[\"类不再继承a类\",{\"1\":{\"734\":1}}],[\"类继承同一个父类\",{\"1\":{\"814\":1}}],[\"类继承了\",{\"1\":{\"734\":2}}],[\"类继承抽象类\",{\"1\":{\"732\":1}}],[\"类需要设计实现哪些方法\",{\"1\":{\"809\":1}}],[\"类需要\",{\"1\":{\"732\":1}}],[\"类与类箭头技巧\",{\"0\":{\"835\":1}}],[\"类与类之间的依赖关系画出来\",{\"1\":{\"817\":1}}],[\"类与类之间的依赖关系简单清晰\",{\"1\":{\"741\":1}}],[\"类与类之间的耦合越弱\",{\"1\":{\"741\":1}}],[\"类与类之间不建议之间互相引用\",{\"1\":{\"725\":1}}],[\"类与类关系越密切\",{\"1\":{\"741\":1}}],[\"类与接口\",{\"1\":{\"727\":1}}],[\"类与实现\",{\"1\":{\"702\":1}}],[\"类通过接口去依赖\",{\"1\":{\"723\":2}}],[\"类通过接口\",{\"1\":{\"723\":4}}],[\"类分解\",{\"1\":{\"718\":1}}],[\"类负责一个表的增删改查\",{\"1\":{\"716\":1}}],[\"类就使用到职责链模式\",{\"1\":{\"710\":1}}],[\"类就使用了观察者模式\",{\"1\":{\"679\":1}}],[\"类等等的设计\",{\"1\":{\"818\":1}}],[\"类等\",{\"1\":{\"689\":1}}],[\"类必须要实现一个接口\",{\"1\":{\"686\":1}}],[\"类代码\",{\"1\":{\"685\":2}}],[\"类代码保持不变\",{\"1\":{\"610\":1}}],[\"类做成抽象类\",{\"1\":{\"739\":1}}],[\"类做成抽象\",{\"1\":{\"613\":1}}],[\"类交互\",{\"1\":{\"603\":1}}],[\"类有\",{\"1\":{\"585\":1}}],[\"类爆炸\",{\"1\":{\"541\":1,\"582\":1}}],[\"类适配器\",{\"1\":{\"534\":1}}],[\"类适配器模式注意事项和细节\",{\"0\":{\"525\":1}}],[\"类适配器模式应用实例\",{\"0\":{\"524\":1}}],[\"类适配器模式介绍\",{\"0\":{\"523\":1}}],[\"类适配器模式\",{\"0\":{\"522\":1},\"1\":{\"518\":1,\"524\":1}}],[\"类接口\",{\"1\":{\"527\":1}}],[\"类作修改\",{\"1\":{\"527\":1}}],[\"类这一点算是一个缺点\",{\"1\":{\"525\":1}}],[\"类汇总和学习指南\",{\"0\":{\"499\":1}}],[\"类可以通过\",{\"1\":{\"532\":1}}],[\"类可以用来用分隔符把字符串拼接起来\",{\"1\":{\"466\":1}}],[\"类可见表示其它类可以用这个类创建实例对象\",{\"1\":{\"132\":1}}],[\"类应该声明不可变的字段\",{\"1\":{\"451\":1}}],[\"类重载代理\",{\"1\":{\"398\":1}}],[\"类重写\",{\"1\":{\"180\":1}}],[\"类似块状结构\",{\"1\":{\"920\":1}}],[\"类似赋值操作符\",{\"1\":{\"907\":1}}],[\"类似操作符\",{\"1\":{\"907\":1,\"911\":1}}],[\"类似于httpclient的超时设置需要自己明确去设置timeout\",{\"1\":{\"870\":1}}],[\"类似于科学计数法的\",{\"1\":{\"848\":1}}],[\"类似于常写的\",{\"1\":{\"689\":1}}],[\"类似\",{\"1\":{\"756\":1}}],[\"类似前面的\",{\"1\":{\"585\":1}}],[\"类似我们前面的\",{\"1\":{\"585\":2}}],[\"类似我们前面讲的\",{\"1\":{\"585\":1}}],[\"类似命令接口\",{\"1\":{\"563\":1}}],[\"类似curses的简单console文本gui函数库\",{\"1\":{\"415\":1}}],[\"类似scala的条件类\",{\"1\":{\"398\":1}}],[\"类似的还有getdeclaredmethods和getdeclaredconstructors\",{\"1\":{\"305\":1}}],[\"类似的还有getmethods和getconstructors\",{\"1\":{\"305\":1}}],[\"类字节码详解\",{\"0\":{\"365\":1},\"1\":{\"303\":1}}],[\"类名通常是名词或者名词短语\",{\"1\":{\"940\":1}}],[\"类名以\",{\"1\":{\"940\":1}}],[\"类名为messageutils\",{\"1\":{\"845\":1}}],[\"类名可以使用复数形式\",{\"1\":{\"845\":1}}],[\"类名使用uppercamelcase风格\",{\"1\":{\"845\":1}}],[\"类名打印\",{\"1\":{\"305\":1}}],[\"类名\",{\"0\":{\"940\":1},\"1\":{\"302\":1,\"305\":1,\"946\":1}}],[\"类库\",{\"1\":{\"819\":1}}],[\"类库提供的\",{\"1\":{\"808\":1}}],[\"类库中定义的可以通过预检查方式规避的runtimeexception异常不应该通过catch\",{\"1\":{\"263\":1}}],[\"类库主要包含了以下三个类\",{\"1\":{\"145\":1}}],[\"类定义错误\",{\"1\":{\"247\":1}}],[\"类及其子类\",{\"1\":{\"247\":1}}],[\"类成员方法只对继承类公开\",{\"1\":{\"848\":1}}],[\"类成员方法只供类内部调用\",{\"1\":{\"848\":1}}],[\"类成员与方法访问控制从严\",{\"1\":{\"848\":1}}],[\"类成员\",{\"1\":{\"227\":1}}],[\"类发生变化\",{\"1\":{\"218\":1}}],[\"类发送消息\",{\"1\":{\"218\":1}}],[\"类向\",{\"1\":{\"218\":1}}],[\"类中连续的成员或初始化方法之间\",{\"1\":{\"910\":1}}],[\"类中关于\",{\"1\":{\"872\":1}}],[\"类中用到了对方\",{\"1\":{\"829\":1}}],[\"类中有些函数命名暴露了实现细节\",{\"1\":{\"809\":1}}],[\"类中都逐一定义并重新实现一遍\",{\"1\":{\"809\":1}}],[\"类中所定义的所有\",{\"1\":{\"809\":1}}],[\"类中已经实现了核心的方法\",{\"1\":{\"679\":1}}],[\"类中\",{\"1\":{\"618\":1,\"791\":1,\"809\":1}}],[\"类中做成一个抽象方法\",{\"1\":{\"582\":1}}],[\"类中的操作实现了接口中所声明的所有的抽象操作\",{\"1\":{\"834\":1}}],[\"类中的几个方法定义得都很干净\",{\"1\":{\"809\":1}}],[\"类中的\",{\"1\":{\"218\":1}}],[\"类中定义\",{\"1\":{\"163\":1}}],[\"类是所有类的根类\",{\"1\":{\"686\":1}}],[\"类是核心\",{\"1\":{\"678\":1}}],[\"类是\",{\"1\":{\"218\":2}}],[\"类是依赖关系主要有三种形式\",{\"1\":{\"218\":1}}],[\"类和成员如果存在修饰符的话\",{\"1\":{\"934\":1}}],[\"类和接口的增多也就或多或少地增加代码的复杂程度和维护成本\",{\"1\":{\"814\":1}}],[\"类和集合应该设置为不可变的\",{\"1\":{\"451\":1}}],[\"类和\",{\"1\":{\"218\":1,\"788\":1,\"814\":3,\"839\":1}}],[\"类图像建筑领域的施工图\",{\"1\":{\"871\":1}}],[\"类图中\",{\"1\":{\"826\":1,\"830\":1,\"831\":1,\"832\":1,\"833\":1,\"834\":1}}],[\"类图中的类可以通过某种编程语言直接实现\",{\"1\":{\"826\":1}}],[\"类图用\",{\"1\":{\"826\":1}}],[\"类图用于描述系统中的类\",{\"1\":{\"826\":1}}],[\"类图简单举例\",{\"1\":{\"826\":1}}],[\"类图在软件系统开发的整个生命周期都是有效的\",{\"1\":{\"826\":1}}],[\"类图是描述类与类之间的关系的\",{\"1\":{\"822\":1}}],[\"类图分析\",{\"1\":{\"789\":1}}],[\"类图设计\",{\"1\":{\"738\":1}}],[\"类图和时序图在新窗口打开\",{\"1\":{\"219\":1}}],[\"类图\",{\"0\":{\"212\":1,\"826\":1,\"828\":1,\"830\":1,\"831\":1,\"832\":1,\"833\":1,\"834\":1},\"1\":{\"524\":1,\"528\":1,\"555\":1,\"573\":1,\"574\":1,\"575\":1,\"582\":1,\"609\":1,\"636\":1,\"651\":1,\"678\":1,\"695\":1,\"700\":1,\"786\":1,\"822\":1,\"826\":1,\"833\":1}}],[\"类封装\",{\"1\":{\"209\":1}}],[\"类的主体时\",{\"1\":{\"901\":1}}],[\"类的成员和初始化方法的顺序对代码可读性有着很重要的影响\",{\"1\":{\"896\":1}}],[\"类的所有最顶层内容\",{\"1\":{\"877\":1}}],[\"类的反应\",{\"1\":{\"839\":1}}],[\"类的继承层次会越来越深\",{\"1\":{\"812\":1}}],[\"类的使用举例\",{\"1\":{\"809\":1}}],[\"类的地方\",{\"1\":{\"764\":1}}],[\"类的静态属性只会在第一次加载类的时候初始化\",{\"1\":{\"758\":1}}],[\"类的内部创建对象\",{\"1\":{\"752\":1}}],[\"类的内容\",{\"1\":{\"742\":1,\"743\":1}}],[\"类的直接朋友\",{\"1\":{\"743\":1}}],[\"类的直接朋友类有哪些\",{\"1\":{\"742\":1}}],[\"类的粒度比较小\",{\"1\":{\"741\":1}}],[\"类的某些方法\",{\"1\":{\"732\":1}}],[\"类的\",{\"1\":{\"727\":1,\"872\":1}}],[\"类的父接口\",{\"1\":{\"699\":1}}],[\"类的实现类\",{\"1\":{\"644\":1}}],[\"类的实例\",{\"1\":{\"527\":1}}],[\"类的实例是不安全的\",{\"1\":{\"115\":1}}],[\"类的个数将急剧增加\",{\"1\":{\"641\":1}}],[\"类的个数容易过多\",{\"1\":{\"612\":1}}],[\"类的动作放在一个工厂的方法中\",{\"1\":{\"619\":1}}],[\"类的数量就会倍增\",{\"1\":{\"582\":1}}],[\"类的全限定名\",{\"1\":{\"305\":1}}],[\"类的加载\",{\"1\":{\"303\":1}}],[\"类的方法完全不兼容\",{\"1\":{\"788\":1}}],[\"类的方法在\",{\"1\":{\"525\":1}}],[\"类的方法\",{\"1\":{\"211\":1,\"525\":1,\"734\":3}}],[\"类的接口\",{\"1\":{\"185\":1}}],[\"类加载机制流程\",{\"1\":{\"303\":1}}],[\"类加载机制\",{\"0\":{\"366\":1},\"1\":{\"303\":2}}],[\"类加载机制和类字节码技术可以参考如下两篇文章\",{\"1\":{\"303\":1}}],[\"类加载\",{\"0\":{\"303\":1}}],[\"类加载相当于\",{\"1\":{\"145\":1}}],[\"类加载器\",{\"1\":{\"114\":1,\"699\":1}}],[\"类所有的实例都共享静态变量\",{\"1\":{\"144\":1}}],[\"类\",{\"0\":{\"268\":1},\"1\":{\"143\":1,\"220\":1,\"221\":1,\"227\":2,\"236\":1,\"451\":1,\"519\":2,\"523\":1,\"525\":1,\"527\":2,\"532\":2,\"553\":3,\"555\":2,\"583\":1,\"603\":1,\"613\":1,\"619\":1,\"636\":1,\"675\":1,\"687\":2,\"689\":3,\"694\":3,\"718\":1,\"721\":3,\"723\":10,\"727\":1,\"732\":1,\"734\":3,\"738\":2,\"739\":1,\"758\":1,\"776\":2,\"784\":3,\"788\":2,\"790\":1,\"809\":2,\"812\":1,\"813\":3,\"814\":1,\"828\":1,\"838\":4,\"845\":1,\"850\":1,\"853\":1,\"877\":1,\"959\":1,\"972\":1,\"981\":1}}],[\"类型约束中的\",{\"1\":{\"907\":1,\"911\":1}}],[\"类型为bigint\",{\"1\":{\"863\":1}}],[\"类型进行严格检查和控制\",{\"1\":{\"861\":1}}],[\"类型与中括号紧挨相连来定义数组\",{\"1\":{\"845\":1}}],[\"类型数量稳定\",{\"1\":{\"841\":1}}],[\"类型可选\",{\"1\":{\"411\":1}}],[\"类型推断优化\",{\"0\":{\"358\":1}}],[\"类型变量名以如下两者之一方式编写\",{\"1\":{\"946\":1}}],[\"类型变量名\",{\"0\":{\"946\":1}}],[\"类型变量\",{\"1\":{\"298\":1}}],[\"类型变量擦除\",{\"1\":{\"289\":1}}],[\"类型检测是根据引用来决定的\",{\"1\":{\"290\":1}}],[\"类型检查就是针对引用的\",{\"1\":{\"290\":1}}],[\"类型实参只准传入某种类型的父类或某种类型的子类\",{\"1\":{\"284\":1}}],[\"类型安全的rest客户端\",{\"1\":{\"424\":1}}],[\"类型安全\",{\"1\":{\"279\":1}}],[\"类型擦除就和多态有了冲突\",{\"1\":{\"291\":1}}],[\"类型擦除会造成多态的冲突\",{\"1\":{\"291\":1}}],[\"类型擦除后\",{\"1\":{\"290\":1,\"291\":1}}],[\"类型擦除\",{\"1\":{\"278\":1,\"287\":1}}],[\"类型转换异常类\",{\"1\":{\"261\":1}}],[\"类型上都属于exception类及其子类\",{\"1\":{\"248\":1}}],[\"类型注解\",{\"0\":{\"357\":1},\"1\":{\"236\":1}}],[\"类型参数声明\",{\"1\":{\"236\":1}}],[\"类型参数\",{\"1\":{\"227\":1}}],[\"类型更广\",{\"1\":{\"166\":1}}],[\"类型赋值给\",{\"1\":{\"165\":1}}],[\"类型的变量\",{\"1\":{\"166\":1}}],[\"类型的变量吗\",{\"0\":{\"161\":1,\"166\":1}}],[\"类型的高\",{\"1\":{\"161\":1}}],[\"类型的范围比\",{\"1\":{\"166\":1}}],[\"类型的范围是从\",{\"1\":{\"161\":1}}],[\"类型的范围\",{\"0\":{\"161\":1}}],[\"类型的\",{\"1\":{\"133\":1,\"925\":1}}],[\"类型下转型为\",{\"1\":{\"129\":1}}],[\"类型精度要高\",{\"1\":{\"129\":1}}],[\"类型信息被擦除后\",{\"1\":{\"297\":1}}],[\"类型信息\",{\"1\":{\"125\":3}}],[\"类型\",{\"0\":{\"160\":1},\"1\":{\"105\":1,\"128\":2,\"129\":2,\"158\":1,\"165\":2,\"224\":1,\"302\":1,\"450\":1,\"636\":1,\"637\":2,\"773\":2,\"863\":1}}],[\"号代表注释行\",{\"1\":{\"114\":1}}],[\"读取文件等\",{\"1\":{\"972\":1}}],[\"读取状态\",{\"1\":{\"776\":1}}],[\"读取享元模式的外部状态会使得运行时间稍微变长\",{\"1\":{\"629\":1}}],[\"读取\",{\"1\":{\"164\":1}}],[\"读取一行\",{\"1\":{\"114\":1}}],[\"读书\",{\"1\":{\"36\":1}}],[\"返回至上一级别的缩进\",{\"1\":{\"903\":1}}],[\"返回为\",{\"1\":{\"865\":2}}],[\"返回n行\",{\"1\":{\"864\":1}}],[\"返回类型为基本数据类型\",{\"1\":{\"858\":1}}],[\"返回类型就是object\",{\"1\":{\"290\":1}}],[\"返回类型就是string\",{\"1\":{\"290\":2}}],[\"返回给前端的响应信息必须包含http状态码\",{\"1\":{\"854\":1}}],[\"返回collections\",{\"1\":{\"850\":1}}],[\"返回class对象\",{\"1\":{\"305\":1}}],[\"返回class对象数组\",{\"1\":{\"305\":1}}],[\"返回集合对象时\",{\"1\":{\"850\":1}}],[\"返回string对象\",{\"1\":{\"848\":1}}],[\"返回结果为\",{\"1\":{\"848\":1}}],[\"返回图片的ur\",{\"1\":{\"809\":1}}],[\"返回图片在阿里云上的地址\",{\"1\":{\"809\":1}}],[\"返回图片存储在阿里云上的地址\",{\"1\":{\"809\":1}}],[\"返回实例对象\",{\"1\":{\"752\":1,\"753\":1}}],[\"返回学校总部的员工\",{\"1\":{\"742\":1,\"743\":1}}],[\"返回学院的所有员工\",{\"1\":{\"742\":1,\"743\":1}}],[\"返回两个数的差\",{\"1\":{\"734\":2}}],[\"返回前\",{\"1\":{\"689\":1}}],[\"返回对应值\",{\"1\":{\"644\":1}}],[\"返回对象\",{\"1\":{\"241\":2}}],[\"返回产品\",{\"1\":{\"555\":2}}],[\"返回构造器的实例后\",{\"1\":{\"310\":1}}],[\"返回表示由此\",{\"1\":{\"308\":1}}],[\"返回表示类或接口的\",{\"1\":{\"307\":1}}],[\"返回表示该对象的实际类型的class引用\",{\"1\":{\"305\":1}}],[\"返回此\",{\"1\":{\"307\":1}}],[\"返回一个代理对象\",{\"1\":{\"703\":1}}],[\"返回一个迭代器对象\",{\"1\":{\"651\":1}}],[\"返回一个迭代器\",{\"1\":{\"650\":1}}],[\"返回一个具体迭代器的实例\",{\"1\":{\"649\":1}}],[\"返回一个网站\",{\"1\":{\"636\":1}}],[\"返回一个对应\",{\"1\":{\"583\":1}}],[\"返回一个包含某些\",{\"1\":{\"308\":1}}],[\"返回一个指定参数的method对象\",{\"1\":{\"308\":1}}],[\"返回一个描述此\",{\"1\":{\"307\":1}}],[\"返回一个\",{\"1\":{\"307\":1,\"308\":2}}],[\"返回一个oject对象\",{\"1\":{\"305\":1}}],[\"返回指定对象上此\",{\"1\":{\"307\":1}}],[\"返回指定参数类型\",{\"1\":{\"306\":2}}],[\"返回描述此\",{\"1\":{\"306\":2,\"308\":1}}],[\"返回\",{\"1\":{\"306\":1,\"308\":2,\"555\":1,\"790\":1}}],[\"返回所有声明的\",{\"1\":{\"306\":1}}],[\"返回所有具有public访问权限的构造函数的constructor对象数组\",{\"1\":{\"306\":1}}],[\"返回所属类型\",{\"1\":{\"298\":1}}],[\"返回与带有给定字符串名的类或接口相关联的\",{\"1\":{\"306\":1}}],[\"返回更容易理解的表示\",{\"1\":{\"305\":1}}],[\"返回当前class或interface声明的类型\",{\"1\":{\"298\":1}}],[\"返回确切的泛型参数\",{\"1\":{\"298\":2}}],[\"返回泛型数组\",{\"1\":{\"285\":2}}],[\"返回值为\",{\"1\":{\"981\":2}}],[\"返回值\",{\"1\":{\"853\":1}}],[\"返回值的意义\",{\"1\":{\"853\":1}}],[\"返回值的类型由外部决定\",{\"1\":{\"281\":1}}],[\"返回值不是try或catch中保存的返回值\",{\"1\":{\"197\":1}}],[\"返回值不同\",{\"1\":{\"135\":1}}],[\"返回error字符串\",{\"1\":{\"275\":1}}],[\"返回ok字符串\",{\"1\":{\"275\":1}}],[\"返回的结果是\",{\"1\":{\"858\":1}}],[\"返回的结果是2\",{\"1\":{\"273\":1}}],[\"返回的是k\",{\"1\":{\"850\":1}}],[\"返回的是k值集合\",{\"1\":{\"850\":1}}],[\"返回的是v值集合\",{\"1\":{\"850\":1}}],[\"返回的是arraylist的内部类sublist\",{\"1\":{\"850\":1}}],[\"返回的是默认值\",{\"1\":{\"848\":1}}],[\"返回的却是\",{\"1\":{\"849\":1}}],[\"返回的yyyy就是下一年\",{\"1\":{\"849\":1}}],[\"返回的就参数类型信息\",{\"1\":{\"308\":1}}],[\"返回的就是\",{\"1\":{\"306\":1}}],[\"返回的都是string类型的对象\",{\"1\":{\"290\":1}}],[\"返回的class<t>就是何种类型\",{\"1\":{\"283\":1}}],[\"返回的值都不会改变\",{\"1\":{\"197\":1}}],[\"返回参数\",{\"1\":{\"242\":1}}],[\"返回字符串\",{\"1\":{\"241\":2}}],[\"返回直接存在于此元素上的所有注解及注解对应的重复注解容器\",{\"1\":{\"233\":1}}],[\"返回直接存在于此元素上的所有注解\",{\"1\":{\"233\":2}}],[\"返回长度为0的数组\",{\"1\":{\"233\":2}}],[\"返回该程序元素上存在的所有注解\",{\"1\":{\"233\":1}}],[\"返回该程序元素上存在的\",{\"1\":{\"233\":2}}],[\"返回该对象的一个拷贝\",{\"1\":{\"173\":1}}],[\"返回散列值\",{\"1\":{\"139\":1}}],[\"返回遍历服务提供者的迭代器\",{\"1\":{\"114\":1}}],[\"返回下一行行号\",{\"1\":{\"114\":1}}],[\"返回顶部按钮\",{\"1\":{\"6\":1,\"34\":1}}],[\"解释成\",{\"1\":{\"853\":1}}],[\"解释公式和数值\",{\"1\":{\"644\":1}}],[\"解释方法\",{\"1\":{\"642\":1}}],[\"解释器类\",{\"1\":{\"644\":1}}],[\"解释器模式在实际的软件开发中使用比较少\",{\"1\":{\"646\":1}}],[\"解释器模式采用递归调用方法\",{\"1\":{\"645\":1}}],[\"解释器模式会引起类膨胀\",{\"1\":{\"645\":1}}],[\"解释器模式的应用场景\",{\"0\":{\"646\":1}}],[\"解释器模式的注意事项和细节\",{\"0\":{\"645\":1}}],[\"解释器模式的结构图如下图所示\",{\"1\":{\"642\":1}}],[\"解释器模式的结构与\",{\"1\":{\"642\":1}}],[\"解释器模式的结构与实现\",{\"0\":{\"642\":1}}],[\"解释器模式来实现四则\",{\"0\":{\"644\":1}}],[\"解释器模式包含以下主要角色\",{\"1\":{\"642\":1}}],[\"解释器模式中的每条规则至少需要定义一个类\",{\"1\":{\"641\":1}}],[\"解释器模式中通常使用大量的循环和递归调用\",{\"1\":{\"641\":1}}],[\"解释器模式是一种类行为型模式\",{\"1\":{\"641\":1}}],[\"解释器模式基本介绍\",{\"0\":{\"641\":1}}],[\"解释器模式\",{\"1\":{\"591\":1,\"641\":1,\"798\":1}}],[\"解释器或编译器的框架\",{\"1\":{\"389\":1}}],[\"解码方法\",{\"1\":{\"465\":1}}],[\"解决多线程并行情况下使用锁造成性能损耗的一种机制\",{\"1\":{\"873\":1}}],[\"解决资源不足的问题\",{\"1\":{\"851\":1}}],[\"解决这个问题的根本方法就是\",{\"1\":{\"809\":1}}],[\"解决了什么问题\",{\"1\":{\"796\":1}}],[\"解决了\",{\"1\":{\"755\":1}}],[\"解决了目标类和适配者类接口不一致的问题\",{\"1\":{\"518\":1}}],[\"解决线程安全问题\",{\"1\":{\"755\":1,\"756\":1,\"757\":1}}],[\"解决方法\",{\"1\":{\"734\":1}}],[\"解决方案\",{\"1\":{\"541\":1,\"554\":1,\"573\":1,\"666\":1,\"709\":1,\"796\":1}}],[\"解决方案就是虚拟机不初始化\",{\"1\":{\"205\":1}}],[\"解决系统的性能问题\",{\"1\":{\"629\":1}}],[\"解决\",{\"1\":{\"612\":1}}],[\"解决思路\",{\"1\":{\"600\":1,\"635\":1,\"727\":1}}],[\"解决问题并且重新调用产生异常的方法\",{\"1\":{\"260\":1}}],[\"解析失败\",{\"1\":{\"874\":1}}],[\"解析失败处理的方法\",{\"1\":{\"114\":1}}],[\"解析成biginteger\",{\"1\":{\"866\":1}}],[\"解析为统一的\",{\"1\":{\"625\":1}}],[\"解析出要创建的两个对象\",{\"1\":{\"622\":1}}],[\"解析库\",{\"1\":{\"467\":1}}],[\"解析\",{\"1\":{\"433\":1}}],[\"解析指定的url配置文件\",{\"1\":{\"114\":1}}],[\"解析配置文件和实例化服务提供者的工作由迭代器本身完成\",{\"1\":{\"114\":1}}],[\"解析配置文件\",{\"1\":{\"114\":1}}],[\"解析服务提供者配置文件中的一行\",{\"1\":{\"114\":1}}],[\"解耦为没有依赖关系\",{\"1\":{\"818\":1}}],[\"解耦为了弱依赖关系\",{\"1\":{\"818\":1}}],[\"解耦为何如此重要\",{\"0\":{\"816\":1}}],[\"解耦数据结构和数据操作\",{\"1\":{\"591\":1}}],[\"解耦观察者与被观察者\",{\"1\":{\"591\":1}}],[\"解耦请求与处理\",{\"1\":{\"708\":1}}],[\"解耦请求与实现\",{\"1\":{\"560\":1}}],[\"解耦请求和处理\",{\"1\":{\"591\":1}}],[\"解耦处理逻辑\",{\"1\":{\"591\":1}}],[\"解耦\",{\"1\":{\"95\":1,\"603\":1}}],[\"该操作中的参数类型标识了被访问的具体元素\",{\"1\":{\"838\":1}}],[\"该为某个类定义接口\",{\"1\":{\"810\":1}}],[\"该策略类并没有提供实现类\",{\"1\":{\"789\":1}}],[\"该原则提出对象不应该承担太多职责\",{\"1\":{\"716\":1}}],[\"该请求可能一直传到链的末端都得不到处理\",{\"1\":{\"707\":1}}],[\"该模式的不足之处\",{\"1\":{\"804\":1}}],[\"该模式定义了一系列算法\",{\"1\":{\"783\":1}}],[\"该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构\",{\"1\":{\"707\":1}}],[\"该模式对外有一个统一接口\",{\"1\":{\"593\":1}}],[\"该接口表示该类能够复制且具有复制的能力\",{\"1\":{\"686\":1}}],[\"该接口解释一个特定的上下文\",{\"1\":{\"641\":1}}],[\"该超级工厂又称为其他工厂的工厂\",{\"1\":{\"606\":1}}],[\"该对象描述了此\",{\"1\":{\"308\":1}}],[\"该对象反映此\",{\"1\":{\"308\":1}}],[\"该对象表示声明由此\",{\"1\":{\"306\":1}}],[\"该类提供了一个全局访问点供外部获取该实例\",{\"1\":{\"798\":1}}],[\"该类的所有方法\",{\"1\":{\"779\":1}}],[\"该类的第一个对象没有生成\",{\"1\":{\"305\":1}}],[\"该类中有一个静态属性\",{\"1\":{\"758\":1}}],[\"该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类\",{\"1\":{\"586\":1}}],[\"该类或接口声明由此\",{\"1\":{\"307\":1}}],[\"该方法没有参数\",{\"1\":{\"981\":1}}],[\"该方法必须返回collection类型\",{\"1\":{\"981\":1}}],[\"该方法必须为public\",{\"1\":{\"981\":1}}],[\"该方法必须由parameters注解修饰\",{\"1\":{\"981\":1}}],[\"该方法最终都会被执行\",{\"1\":{\"976\":1}}],[\"该方法要用static修饰\",{\"1\":{\"976\":2}}],[\"该方法称为\",{\"1\":{\"803\":1}}],[\"该方法完成输出学校总部和学院员工信息\",{\"1\":{\"742\":1,\"743\":1}}],[\"该方法可以将一个\",{\"1\":{\"686\":1}}],[\"该方法无法获取继承自父类的method\",{\"1\":{\"308\":2}}],[\"该方法是私有构造private\",{\"1\":{\"306\":1}}],[\"该方法的名字不做要求\",{\"1\":{\"981\":1}}],[\"该方法的几种类型必须是该泛型的实例的类型或者其子类\",{\"1\":{\"289\":1}}],[\"该方法的调用者才必须处理或者重新抛出该异常\",{\"1\":{\"252\":1}}],[\"该方法的调用者可以随意修改返回的数组\",{\"1\":{\"233\":2}}],[\"该方法将忽略继承的注解\",{\"1\":{\"233\":1}}],[\"该方法将忽略继承的注释\",{\"1\":{\"233\":2}}],[\"该方法会返回一个\",{\"1\":{\"145\":1}}],[\"该注解才能是运行时可见\",{\"1\":{\"233\":1}}],[\"该条可以归为第一条中的一个特例\",{\"1\":{\"173\":1}}],[\"该文件内容保存着\",{\"1\":{\"145\":1}}],[\"该数组被声明为\",{\"1\":{\"122\":1}}],[\"该迭代器会从头查找和实例化服务提供者\",{\"1\":{\"114\":1}}],[\"该目录下会有一个名字为java\",{\"1\":{\"100\":1}}],[\"重构时单测的改动不大\",{\"1\":{\"991\":1}}],[\"重构成本也会因历史数据迁移和系统平滑过渡而陡然增加\",{\"1\":{\"871\":1}}],[\"重构跟开发冲突的概率也变小了\",{\"1\":{\"818\":1}}],[\"重构后的代码如下所示\",{\"1\":{\"809\":1}}],[\"重构工具那是相当有帮助\",{\"1\":{\"480\":1}}],[\"重用性\",{\"1\":{\"797\":1}}],[\"重用现有的异常有几个好处\",{\"1\":{\"265\":1}}],[\"重新创建大小等于size的数组\",{\"1\":{\"850\":1}}],[\"重新拷贝一份到新进程的地址空间中\",{\"1\":{\"770\":1}}],[\"重新加载配置文件可使用reload方法\",{\"1\":{\"114\":1}}],[\"重新加载\",{\"1\":{\"114\":1}}],[\"重量级对象\",{\"1\":{\"761\":1}}],[\"重点讲解原理\",{\"1\":{\"624\":1}}],[\"重点还是要搞清楚应用场景\",{\"1\":{\"606\":1}}],[\"重点看下泛型的方法\",{\"1\":{\"283\":1}}],[\"重做\",{\"1\":{\"560\":1}}],[\"重置建造者\",{\"1\":{\"555\":1}}],[\"重要\",{\"1\":{\"960\":1}}],[\"重要的是\",{\"1\":{\"896\":1}}],[\"重要的内容\",{\"1\":{\"19\":1}}],[\"重要特性必读\",{\"0\":{\"340\":1,\"360\":1}}],[\"重复这两个过程\",{\"1\":{\"991\":1}}],[\"重复注解\",{\"0\":{\"347\":1},\"1\":{\"187\":1,\"231\":1,\"236\":1}}],[\"重复的配置项和已经被实例化的配置项不会被保存\",{\"1\":{\"114\":1}}],[\"重载父类的test方法\",{\"1\":{\"222\":1}}],[\"重载\",{\"1\":{\"135\":1}}],[\"重写了\",{\"1\":{\"734\":2}}],[\"重写remove\",{\"1\":{\"574\":1}}],[\"重写有以下两个限制\",{\"1\":{\"135\":1}}],[\"重写\",{\"0\":{\"961\":1},\"1\":{\"135\":1,\"141\":1,\"211\":1,\"574\":3,\"689\":2,\"703\":1,\"814\":1,\"952\":1}}],[\"重写与重载\",{\"0\":{\"135\":1}}],[\"迭代器模式通常在以下几种情况使用\",{\"1\":{\"653\":1}}],[\"迭代器模式提供了一种\",{\"1\":{\"652\":1}}],[\"迭代器模式提供一个统一的方法遍历对象\",{\"1\":{\"652\":1}}],[\"迭代器模式隐藏了聚合的内部结构\",{\"1\":{\"652\":1}}],[\"迭代器模式的应用场景\",{\"0\":{\"653\":1}}],[\"迭代器模式的注意事项和细节\",{\"0\":{\"652\":1}}],[\"迭代器模式的结构与实现\",{\"0\":{\"649\":1}}],[\"迭代器模式解决了不同集合\",{\"1\":{\"651\":1}}],[\"迭代器模式应用实例\",{\"0\":{\"650\":1}}],[\"迭代器模式主要包含以下角色\",{\"1\":{\"649\":1}}],[\"迭代器模式是通过将聚合对象的遍历行为分离出来\",{\"1\":{\"649\":1}}],[\"迭代器模式在生活中应用的比较广泛\",{\"1\":{\"648\":1}}],[\"迭代器模式基本介绍\",{\"0\":{\"648\":1}}],[\"迭代器模式\",{\"1\":{\"591\":1,\"648\":2,\"798\":1}}],[\"迭代器返回的元素属于\",{\"1\":{\"284\":1}}],[\"迭代器中下一个实现类的全名\",{\"1\":{\"114\":1}}],[\"迭代器\",{\"1\":{\"114\":1}}],[\"设备和镜像\",{\"1\":{\"461\":1}}],[\"设置新状态\",{\"1\":{\"776\":1}}],[\"设置回调\",{\"1\":{\"703\":1}}],[\"设置回调函数\",{\"1\":{\"703\":1}}],[\"设置回调方法\",{\"1\":{\"702\":1}}],[\"设置父类\",{\"1\":{\"703\":1}}],[\"设置要生成代理对象的目标对象的类\",{\"1\":{\"702\":1}}],[\"设置华为路由器\",{\"1\":{\"617\":1}}],[\"设置小米路由器\",{\"1\":{\"617\":1}}],[\"设置可访问\",{\"1\":{\"307\":1}}],[\"设置第二个内容\",{\"1\":{\"281\":1}}],[\"设置第一个内容\",{\"1\":{\"281\":1}}],[\"设置字符串\",{\"1\":{\"281\":1}}],[\"设置的类型也由外部决定\",{\"1\":{\"281\":1}}],[\"设置操作人类别\",{\"1\":{\"242\":1}}],[\"设置标题\",{\"1\":{\"242\":1}}],[\"设置action动作\",{\"1\":{\"242\":1}}],[\"设置请求方式\",{\"1\":{\"242\":1}}],[\"设置方法名称\",{\"1\":{\"242\":1}}],[\"设置它没有任何效果\",{\"1\":{\"29\":1}}],[\"设计的本质就是识别和表达系统难点\",{\"1\":{\"871\":1}}],[\"设计的程序结构\",{\"1\":{\"554\":1}}],[\"设计文档的作用是明确需求\",{\"1\":{\"871\":1}}],[\"设计规约\",{\"0\":{\"871\":1}}],[\"设计规约七个维度\",{\"1\":{\"843\":1}}],[\"设计也更加抽象\",{\"1\":{\"800\":1}}],[\"设计一个系统时知道了算法所需的关键步骤\",{\"1\":{\"800\":1}}],[\"设计思想\",{\"0\":{\"806\":1},\"1\":{\"652\":1}}],[\"设计思路分析\",{\"1\":{\"650\":1}}],[\"设计较复杂\",{\"1\":{\"567\":1}}],[\"设计为易于使用\",{\"1\":{\"431\":1}}],[\"设计模式比框架更小且更抽象\",{\"1\":{\"819\":1}}],[\"设计模式类型\",{\"0\":{\"798\":1}}],[\"设计模式包含了面向对象的精髓\",{\"1\":{\"797\":1}}],[\"设计模式从来都不是单个设计模式独立使用的\",{\"1\":{\"797\":1}}],[\"设计模式要活学活用\",{\"1\":{\"797\":1}}],[\"设计模式只是一个引导\",{\"1\":{\"797\":1}}],[\"设计模式解决的是设计不足的问题\",{\"1\":{\"797\":1}}],[\"设计模式是为了让程序\",{\"1\":{\"797\":1}}],[\"设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验\",{\"1\":{\"795\":1}}],[\"设计模式在软件中哪里\",{\"1\":{\"796\":1}}],[\"设计模式并不局限于某种语言\",{\"1\":{\"795\":1}}],[\"设计模式介绍\",{\"0\":{\"795\":1}}],[\"设计模式概述\",{\"0\":{\"793\":1}}],[\"设计模式常用的七大原则有\",{\"1\":{\"714\":1}}],[\"设计模式为什么\",{\"1\":{\"714\":1}}],[\"设计模式原则\",{\"1\":{\"714\":1}}],[\"设计模式七大原则\",{\"0\":{\"714\":1}}],[\"设计模式的本质是面向对象设计原则的实际运用\",{\"1\":{\"797\":1}}],[\"设计模式的本质提高\",{\"1\":{\"795\":1}}],[\"设计模式的目的\",{\"0\":{\"797\":1}}],[\"设计模式的重要性\",{\"0\":{\"796\":1}}],[\"设计模式的依赖抽象原则\",{\"1\":{\"619\":1}}],[\"设计模式的问题\",{\"1\":{\"187\":1}}],[\"设计模式总结\",{\"0\":{\"587\":1}}],[\"设计模式中一些问题的有趣的讨论\",{\"1\":{\"447\":1}}],[\"设计模式\",{\"0\":{\"328\":1},\"1\":{\"589\":1,\"590\":1,\"591\":1,\"606\":1,\"795\":2,\"796\":2,\"808\":1}}],[\"设计良好的模块会隐藏所有的实现细节\",{\"1\":{\"132\":1}}],[\"设计原则核心思想\",{\"0\":{\"746\":1}}],[\"设计原则\",{\"1\":{\"113\":1,\"748\":1}}],[\"参见定义pojo类以及数据库字段定义规定\",{\"1\":{\"866\":1}}],[\"参见第六条\",{\"1\":{\"189\":1}}],[\"参加抽奖\",{\"1\":{\"778\":1}}],[\"参数和\",{\"1\":{\"979\":1}}],[\"参数和值\",{\"1\":{\"242\":1}}],[\"参数化测试允许开发人员使用不同的值反复运行同\",{\"1\":{\"981\":1}}],[\"参数化测试\",{\"0\":{\"981\":1}}],[\"参数化运行器\",{\"1\":{\"972\":1,\"981\":1}}],[\"参数化类型\",{\"1\":{\"298\":1}}],[\"参数格式不匹配\",{\"1\":{\"874\":1}}],[\"参数可以使用枚举类型\",{\"1\":{\"869\":1}}],[\"参数异常说明外\",{\"1\":{\"853\":1}}],[\"参数错误不太可能到底层才会暴露问题\",{\"1\":{\"852\":1}}],[\"参数校验时间几乎可以忽略不计\",{\"1\":{\"852\":1}}],[\"参数mergefunction的作用是当出现key重复时\",{\"1\":{\"850\":1}}],[\"参数很多的方法调用可能超过\",{\"1\":{\"847\":1}}],[\"参数名以\",{\"1\":{\"944\":1}}],[\"参数名为mergefunction的方法\",{\"1\":{\"850\":1}}],[\"参数名\",{\"0\":{\"944\":1},\"1\":{\"845\":1}}],[\"参数名称与类成员变量名称一致\",{\"1\":{\"848\":1}}],[\"参数名称\",{\"1\":{\"306\":3}}],[\"参数名称tp\",{\"1\":{\"306\":3}}],[\"参数多\",{\"1\":{\"558\":1}}],[\"参数类型避免定义为object\",{\"1\":{\"848\":1}}],[\"参数类型\",{\"1\":{\"306\":4}}],[\"参数类型不一样\",{\"1\":{\"291\":1}}],[\"参数的状态不合适\",{\"1\":{\"265\":1}}],[\"参数的值不合适\",{\"1\":{\"265\":1}}],[\"参数的构造器来进行转换\",{\"1\":{\"159\":1}}],[\"参数不能为0\",{\"1\":{\"253\":1}}],[\"参数\",{\"1\":{\"224\":1,\"225\":2,\"644\":1,\"658\":1,\"848\":1,\"853\":1,\"859\":1}}],[\"参数传递等方式声明的类之间的依赖关系\",{\"1\":{\"765\":1}}],[\"参数传递\",{\"0\":{\"127\":1}}],[\"参数等\",{\"1\":{\"105\":1}}],[\"参考jdk原生注释\",{\"1\":{\"849\":1}}],[\"参考示例\",{\"1\":{\"847\":1}}],[\"参考自\",{\"1\":{\"287\":1}}],[\"参考下方代码\",{\"1\":{\"271\":1}}],[\"参考文末附表\",{\"1\":{\"857\":1}}],[\"参考文档\",{\"0\":{\"155\":1}}],[\"参考文章\",{\"0\":{\"116\":1,\"243\":1,\"277\":1,\"299\":1,\"314\":1,\"984\":1,\"1000\":1}}],[\"参考资料\",{\"0\":{\"153\":1,\"219\":1}}],[\"参考\",{\"1\":{\"113\":1,\"843\":1,\"845\":2,\"850\":2,\"851\":3,\"852\":2,\"853\":4,\"854\":2,\"857\":4,\"858\":1,\"860\":2,\"863\":1,\"864\":1,\"865\":2,\"866\":2,\"868\":2,\"869\":1,\"870\":1,\"871\":5}}],[\"常常会出现好多对象之间存在复杂的交互关系\",{\"1\":{\"655\":1}}],[\"常常存在办事较复杂的例子\",{\"1\":{\"593\":1}}],[\"常常需要对现有产品增加新的功能或美化其外观\",{\"1\":{\"579\":1}}],[\"常常被代码生成工具使用\",{\"1\":{\"232\":1}}],[\"常见于机密信息或复制其它登录用户链接访问服务器的情况\",{\"1\":{\"854\":1}}],[\"常见对于需要登录而用户未登录的情况\",{\"1\":{\"854\":1}}],[\"常见类使用\",{\"0\":{\"329\":1}}],[\"常见的运行器有\",{\"1\":{\"972\":1,\"981\":1}}],[\"常见的http状态码如下\",{\"1\":{\"854\":1}}],[\"常见的请求方法如下\",{\"1\":{\"854\":1}}],[\"常见的方法内变量为int\",{\"1\":{\"845\":1}}],[\"常见的应用场景\",{\"0\":{\"546\":1}}],[\"常见的runtime\",{\"1\":{\"198\":1}}],[\"常见的checked\",{\"1\":{\"198\":1}}],[\"常见的例子是\",{\"1\":{\"113\":1}}],[\"常用注解\",{\"0\":{\"972\":1}}],[\"常用于系统底层开发\",{\"1\":{\"629\":1}}],[\"常用于回收资源\",{\"1\":{\"260\":1}}],[\"常用的方法\",{\"1\":{\"305\":1}}],[\"常用的异常\",{\"0\":{\"261\":1}}],[\"常用搜索\",{\"0\":{\"38\":1}}],[\"常规语法\",{\"1\":{\"257\":1}}],[\"常量的内容是深不可变的\",{\"1\":{\"942\":1}}],[\"常量的复用层次有五层\",{\"1\":{\"846\":1}}],[\"常量是\",{\"1\":{\"942\":1}}],[\"常量使用\",{\"1\":{\"942\":1}}],[\"常量名通常是名词或者名词短语\",{\"1\":{\"942\":1}}],[\"常量名\",{\"0\":{\"942\":1}}],[\"常量定义\",{\"0\":{\"846\":1}}],[\"常量命名应该全部大写\",{\"1\":{\"845\":1}}],[\"常量池\",{\"1\":{\"629\":1,\"638\":1}}],[\"常量保存在本地内存的元空间\",{\"1\":{\"125\":1}}],[\"常量\",{\"1\":{\"125\":2,\"865\":1,\"869\":1}}],[\"组件图\",{\"1\":{\"822\":1}}],[\"组件间紧密的耦合\",{\"1\":{\"819\":1}}],[\"组件\",{\"1\":{\"818\":1}}],[\"组装责任链\",{\"1\":{\"708\":1}}],[\"组装类并提供执行入口\",{\"1\":{\"625\":1}}],[\"组装数据\",{\"1\":{\"106\":1}}],[\"组建一个家庭影院\",{\"1\":{\"597\":1}}],[\"组织在一起\",{\"1\":{\"770\":1}}],[\"组织架构树\",{\"1\":{\"590\":1}}],[\"组织上位于实现方所在的包中\",{\"1\":{\"113\":1}}],[\"组织上位于调用方所在的包中\",{\"1\":{\"113\":1}}],[\"组合的方式来实现\",{\"1\":{\"871\":1}}],[\"组合是直接\",{\"1\":{\"832\":1}}],[\"组合并不完美\",{\"1\":{\"814\":1}}],[\"组合相比继承有哪些优势\",{\"0\":{\"813\":1},\"1\":{\"811\":1}}],[\"组合优于继承\",{\"1\":{\"811\":1}}],[\"组合图\",{\"1\":{\"745\":1}}],[\"组合或者聚合\",{\"1\":{\"745\":1}}],[\"组合等\",{\"1\":{\"734\":1}}],[\"组合键\",{\"1\":{\"669\":1}}],[\"组合键时能撤销当前操作\",{\"1\":{\"663\":1}}],[\"组合\",{\"1\":{\"584\":1,\"732\":1,\"741\":1,\"745\":1,\"813\":2,\"814\":2,\"822\":1,\"832\":1,\"835\":2}}],[\"组合能让客户以一致的方式处理个别对象以及组合对象\",{\"1\":{\"567\":1}}],[\"组合模式的应用场景\",{\"0\":{\"577\":1}}],[\"组合模式的注意事项和细节\",{\"0\":{\"576\":1}}],[\"组合模式解决学校院系展示\",{\"0\":{\"574\":1}}],[\"组合模式分为透明式的组合模式和安全式的组合模式\",{\"1\":{\"568\":1}}],[\"组合模式结构与实现\",{\"0\":{\"568\":1}}],[\"组合模式使得客户端代码可以一致地处理单个对象和组合对象\",{\"1\":{\"567\":1}}],[\"组合模式使得用户对单个对象和组合对象的访问具有一致性\",{\"1\":{\"567\":1}}],[\"组合模式依据树形结构来组合对象\",{\"1\":{\"567\":1}}],[\"组合模式基本介绍\",{\"0\":{\"567\":1}}],[\"组合模式\",{\"1\":{\"560\":1,\"567\":1,\"573\":1,\"590\":1,\"642\":1,\"798\":1,\"814\":1}}],[\"组合品牌\",{\"1\":{\"542\":1}}],[\"组合中整体和部分是强依赖的\",{\"1\":{\"216\":1}}],[\"组合关系用\",{\"1\":{\"832\":1}}],[\"组合关系是一种弱依赖关系\",{\"1\":{\"818\":1}}],[\"组合关系\",{\"0\":{\"216\":1,\"832\":1},\"1\":{\"827\":1}}],[\"所提倡的\",{\"1\":{\"991\":1}}],[\"所提出的\",{\"1\":{\"796\":1}}],[\"所请求的资源发送到客户端\",{\"1\":{\"854\":1}}],[\"所谓\",{\"1\":{\"997\":1}}],[\"所谓双分派是指不管类怎么变化\",{\"1\":{\"839\":1}}],[\"所谓类的\",{\"1\":{\"750\":1}}],[\"所谓松耦合是说\",{\"1\":{\"741\":1}}],[\"所谓高内聚\",{\"1\":{\"741\":1}}],[\"所做的\",{\"1\":{\"482\":1}}],[\"所反映的方法可能是类方法或实例方法\",{\"1\":{\"308\":1}}],[\"所有非静态导入归一组\",{\"1\":{\"892\":1}}],[\"所有静态导入归一组\",{\"1\":{\"892\":1}}],[\"所有可交互的控件元素必须能被tab键聚焦\",{\"1\":{\"871\":1}}],[\"所有版本仲裁放在<dependencymanagement>语句块中\",{\"1\":{\"869\":1}}],[\"所有pom文件中的依赖声明放在<dependencies>语句块中\",{\"1\":{\"869\":1}}],[\"所有此类的对象\",{\"1\":{\"851\":1}}],[\"所有此类实例共享此静态变量\",{\"1\":{\"851\":1}}],[\"所有service和dao的getter\",{\"1\":{\"848\":1}}],[\"所有整型包装类对象之间值的比较\",{\"1\":{\"848\":1}}],[\"所有编程相关的命名严禁使用拼音与英文混合的方式\",{\"1\":{\"845\":1}}],[\"所有编程相关的命名均不能以下划线或美元符号开始\",{\"1\":{\"845\":1}}],[\"所有调用这个接口的代码都要做相应的改动\",{\"1\":{\"818\":1}}],[\"所有更细分的鸟\",{\"1\":{\"812\":1}}],[\"所有引用基类的地方必须能透明地使用其子类的对象\",{\"1\":{\"732\":1}}],[\"所有涉及到子类的功能都有可能产生故障\",{\"1\":{\"731\":1}}],[\"所有依赖于它的对象都得到通知并被自动更新\",{\"1\":{\"671\":1}}],[\"所有状态信息都保存在备忘录中\",{\"1\":{\"663\":1}}],[\"所有这些都可以考虑使用职责链模式来实现\",{\"1\":{\"707\":1}}],[\"所有这些都可以釆用装饰器模式来实现\",{\"1\":{\"579\":1}}],[\"所有这些\",{\"1\":{\"655\":1}}],[\"所有朋友的电话\",{\"1\":{\"655\":1}}],[\"所有声明的\",{\"1\":{\"306\":1}}],[\"所有具有相同元素类型和维数的数组都共享该\",{\"1\":{\"302\":1}}],[\"所有的字符存储与表示\",{\"1\":{\"865\":1}}],[\"所有的key必须为小写字母开始的lowercamelcase风格\",{\"1\":{\"854\":1}}],[\"所有的枚举类型字段必须要有注释\",{\"1\":{\"853\":1}}],[\"所有的类都必须添加创建者和创建日期\",{\"1\":{\"853\":1}}],[\"所有的抽象方法\",{\"1\":{\"853\":1}}],[\"所有的局部变量使用基本数据类型\",{\"1\":{\"848\":1}}],[\"所有的pojo类属性必须使用包装数据类型\",{\"1\":{\"848\":1}}],[\"所有的覆写方法\",{\"1\":{\"848\":1}}],[\"所有的描述由事物\",{\"1\":{\"824\":1}}],[\"所有的工厂类都需要进行修改\",{\"1\":{\"616\":1}}],[\"所有的对象都继承自\",{\"1\":{\"151\":1}}],[\"所有的配置文件只会加载一次\",{\"1\":{\"114\":1}}],[\"所花费时间大约是建立异常对象的4倍\",{\"1\":{\"276\":1}}],[\"所在的\",{\"1\":{\"113\":2}}],[\"所以围绕着单元测试\",{\"1\":{\"988\":1}}],[\"所以也没有必要人工梳理测试结果的报告\",{\"1\":{\"970\":1}}],[\"所以此处的注释是不必要的\",{\"1\":{\"950\":1}}],[\"所以方法名\",{\"1\":{\"947\":1}}],[\"所以设计结果需要进行分类归档保存\",{\"1\":{\"871\":1}}],[\"所以设置为静态变量\",{\"1\":{\"851\":1}}],[\"所以字段名称需要慎重考虑\",{\"1\":{\"863\":1}}],[\"所以dao的参数校验\",{\"1\":{\"852\":1}}],[\"所以赋值语句需要清晰地单独成为一行\",{\"1\":{\"852\":1}}],[\"所以资金相关的金融敏感信息不建议使用乐观锁更新\",{\"1\":{\"851\":1}}],[\"所以set存储的对象必须覆写这两种方法\",{\"1\":{\"850\":1}}],[\"所以包装数据类型的null值\",{\"1\":{\"848\":1}}],[\"所以本手册以java开发者为中心视角\",{\"1\":{\"843\":1}}],[\"所以他具有关联的\",{\"1\":{\"831\":1}}],[\"所以之前的代码现在看上去可能会显得很糟糕\",{\"1\":{\"820\":1}}],[\"所以解决思路\",{\"1\":{\"788\":1}}],[\"所以北京鸭类为了改进不能飞问题\",{\"1\":{\"788\":1}}],[\"所以每个类被依赖的类就会比较少\",{\"1\":{\"741\":1}}],[\"所以告诉我们什么时候应该使用继承\",{\"1\":{\"732\":1}}],[\"所以需要在服务器上调小此等待值\",{\"1\":{\"870\":1}}],[\"所以需要在<resultmap>设置从is\",{\"1\":{\"845\":1}}],[\"所以需要将类\",{\"1\":{\"716\":1}}],[\"所以需要用\",{\"1\":{\"284\":1}}],[\"所以职责链将请求的发送者和请求的处理者解耦了\",{\"1\":{\"707\":1}}],[\"所以会有很多代理类\",{\"1\":{\"696\":1}}],[\"所以会使用独立的类加载器\",{\"1\":{\"313\":1}}],[\"所以大多数语言在实现聚合类时都提供了迭代器类\",{\"1\":{\"653\":1}}],[\"所以实现其文法较为容易\",{\"1\":{\"641\":1}}],[\"所以应当在有足够多的享元实例时才值得使用享元模式\",{\"1\":{\"639\":1}}],[\"所以以下几种情形适合采用享元模式\",{\"1\":{\"639\":1}}],[\"所以棋子坐标就是棋子的外部状态\",{\"1\":{\"631\":1}}],[\"所以棋子颜色就是棋子的内部状态\",{\"1\":{\"631\":1}}],[\"所以这与单纯的按\",{\"1\":{\"892\":1}}],[\"所以这种复用又称为\",{\"1\":{\"747\":2}}],[\"所以这种模式很少被使用到\",{\"1\":{\"641\":1}}],[\"所以这里我只给出两个类的大致设计思路\",{\"1\":{\"626\":1}}],[\"所以这里我们需要借助一把神兵利器\",{\"1\":{\"275\":1}}],[\"所以这个框架才被称为\",{\"1\":{\"621\":1}}],[\"所以取月份要+1\",{\"1\":{\"618\":1}}],[\"所以取同一父类的最小级\",{\"1\":{\"289\":2}}],[\"所以经常被使用\",{\"1\":{\"610\":1}}],[\"所以工厂模式只被分成了工厂方法和抽象工厂两类\",{\"1\":{\"606\":1}}],[\"所以有必要为多个子系统提供一个统一的接口\",{\"1\":{\"593\":1}}],[\"所以失去了透明性\",{\"1\":{\"570\":1}}],[\"所以客户端无须区别树叶对象和树枝对象\",{\"1\":{\"569\":1}}],[\"所以它解决了类适配器必须继承\",{\"1\":{\"529\":1}}],[\"所以它可以根据需求重写\",{\"1\":{\"525\":1}}],[\"所以它有迭代器的属性\",{\"1\":{\"114\":1}}],[\"所以类适配器需要继承\",{\"1\":{\"525\":1}}],[\"所以我们可以使用\",{\"1\":{\"677\":1}}],[\"所以我们可以看到\",{\"1\":{\"242\":1}}],[\"所以我们可以看到serviceloader不是实例化以后\",{\"1\":{\"114\":1}}],[\"所以我写了很多\",{\"1\":{\"474\":1}}],[\"所以对\",{\"1\":{\"450\":1}}],[\"所以对于频繁改变内容的字符串避免使用string\",{\"1\":{\"192\":1}}],[\"所以在这里\",{\"1\":{\"758\":1}}],[\"所以在多线程环境下不可使用这种方式\",{\"1\":{\"754\":1}}],[\"所以在运行时不可能发生变化\",{\"1\":{\"747\":1}}],[\"所以在\",{\"1\":{\"449\":1}}],[\"所以在取出集合元素时需要人为的强制类型转化到具体的目标类型\",{\"1\":{\"279\":1}}],[\"所以推荐使用我所说的建议的某些部分\",{\"1\":{\"443\":1}}],[\"所以查找性能会随类的大小方法多少而变化\",{\"1\":{\"313\":1}}],[\"所以使用框架还是很有帮助的\",{\"1\":{\"457\":1}}],[\"所以使用其独立的类加载器\",{\"1\":{\"312\":1}}],[\"所以使用反射来初始化泛型数组算是优雅实现\",{\"1\":{\"295\":1}}],[\"所以反射是保证线程安全的\",{\"1\":{\"310\":1}}],[\"所以java为了避免这样的情况\",{\"1\":{\"297\":1}}],[\"所以java不允许这么干\",{\"1\":{\"290\":1}}],[\"所以当然是错误的\",{\"1\":{\"296\":1}}],[\"所以如果你还没有用\",{\"1\":{\"470\":1}}],[\"所以如果\",{\"1\":{\"294\":1}}],[\"所以就会出现\",{\"1\":{\"294\":1}}],[\"所以上面代码可以给\",{\"1\":{\"294\":1}}],[\"所以自然就不行了\",{\"1\":{\"293\":1}}],[\"所以编译器为了实现泛型的多态允许自己做这个看起来\",{\"1\":{\"291\":1}}],[\"所以父类编译之后会变成下面的样子\",{\"1\":{\"291\":1}}],[\"所以为了避免这种极易出现的错误\",{\"1\":{\"290\":1}}],[\"所以不要省略它的文档\",{\"1\":{\"960\":1}}],[\"所以不能保证它一定会被处理\",{\"1\":{\"707\":1}}],[\"所以不可避免地会使对象数量多且性质相近\",{\"1\":{\"631\":1}}],[\"所以不行\",{\"1\":{\"290\":1}}],[\"所以不满足if中的任意一个条件\",{\"1\":{\"92\":1}}],[\"所以list1引用能完成泛型类型的检查\",{\"1\":{\"290\":1}}],[\"所以可以愉快地将string对象作为key来使用\",{\"1\":{\"850\":1}}],[\"所以可以为integer和float\",{\"1\":{\"289\":1}}],[\"所以可以用于两个不同对象\",{\"1\":{\"180\":1}}],[\"所以只能为integer类型或者其子类\",{\"1\":{\"289\":1}}],[\"所以t为integer类型\",{\"1\":{\"289\":1}}],[\"所以通过反射我们就可以存储字符串了\",{\"1\":{\"289\":1}}],[\"所以通常需要重写该方法来提供逻辑一致性的比较\",{\"1\":{\"180\":1}}],[\"所以用object替换\",{\"1\":{\"289\":1}}],[\"所以很少会会jvm实现试图对它们的性能进行优化\",{\"1\":{\"263\":1}}],[\"所以一般都是捕获异常或者再往上抛\",{\"1\":{\"253\":1}}],[\"所以程序通过反射获取了某个类的annotatedelement对象之后\",{\"1\":{\"233\":1}}],[\"所以函数返回值是在finally执行前确定的\",{\"1\":{\"197\":1}}],[\"所以占用的空间更少\",{\"1\":{\"168\":1}}],[\"所以必须要进行强制转换\",{\"1\":{\"166\":1}}],[\"所以将\",{\"1\":{\"165\":1}}],[\"所以静态方法必须有实现\",{\"1\":{\"144\":1}}],[\"所以从这个角度\",{\"1\":{\"125\":1}}],[\"所以获取unsafe实例也比较麻烦\",{\"1\":{\"93\":1}}],[\"所以最终会得到0\",{\"1\":{\"90\":1}}],[\"所以\",{\"1\":{\"90\":1,\"161\":1,\"263\":1,\"264\":1,\"268\":1,\"275\":1,\"284\":1,\"290\":1,\"291\":2,\"310\":1,\"311\":1,\"606\":1,\"622\":2,\"624\":1,\"741\":1,\"764\":1,\"766\":2,\"769\":1,\"770\":1,\"771\":1,\"788\":1,\"812\":1,\"813\":1,\"814\":1,\"818\":1,\"863\":1,\"871\":1}}],[\"所以说精度损失是一个概率问题\",{\"1\":{\"854\":1}}],[\"所以说采用通配符的方式初始化泛型数组是允许的\",{\"1\":{\"294\":1}}],[\"所以说\",{\"1\":{\"89\":1,\"291\":1}}],[\"厂商或者框架开发者开发具体的实现\",{\"1\":{\"110\":1}}],[\"取决于\",{\"1\":{\"885\":1}}],[\"取决于具体实现类\",{\"1\":{\"851\":2}}],[\"取反逻辑不利于快速理解\",{\"1\":{\"852\":1}}],[\"取反混合运算\",{\"1\":{\"852\":1}}],[\"取对应的形容词为接口名\",{\"1\":{\"845\":1}}],[\"取款或者转账等\",{\"1\":{\"800\":1}}],[\"取号\",{\"1\":{\"800\":1}}],[\"取出的数据元素也可能为null\",{\"1\":{\"858\":1}}],[\"取出一个学院\",{\"1\":{\"650\":1}}],[\"取出所有学院\",{\"1\":{\"650\":1}}],[\"取出右表达式\",{\"1\":{\"644\":1}}],[\"取出\",{\"1\":{\"644\":1}}],[\"取代这样的写法\",{\"1\":{\"455\":1}}],[\"取代你亲手去写构建器的方式\",{\"1\":{\"446\":1}}],[\"取全限定的类名\",{\"1\":{\"305\":1}}],[\"取得指定带int和string参数构造函数\",{\"1\":{\"306\":1}}],[\"取得信息\",{\"1\":{\"281\":2}}],[\"取得字符串的长度\",{\"1\":{\"281\":1}}],[\"取得资源文件的url\",{\"1\":{\"106\":1}}],[\"取值为string\",{\"1\":{\"225\":1}}],[\"取消永久代\",{\"1\":{\"125\":1}}],[\"取他人之长\",{\"1\":{\"36\":1}}],[\"加剧代码合并的冲突\",{\"1\":{\"912\":1}}],[\"加上两个有意义的变量名称elephant和fridge\",{\"1\":{\"853\":1}}],[\"加上访问修饰符\",{\"1\":{\"132\":1}}],[\"加\",{\"1\":{\"848\":1}}],[\"加减乘除符号等\",{\"1\":{\"847\":1}}],[\"加大维护难度\",{\"1\":{\"780\":1}}],[\"加强程序的健壮性\",{\"1\":{\"733\":1}}],[\"加法解释器\",{\"1\":{\"644\":1}}],[\"加入自己的理解的error\",{\"1\":{\"858\":1}}],[\"加入上好的花生\",{\"1\":{\"803\":1}}],[\"加入上好的红豆\",{\"1\":{\"803\":1}}],[\"加入双重检查代码\",{\"1\":{\"757\":1}}],[\"加入同步处理的代码\",{\"1\":{\"755\":1,\"756\":1}}],[\"加入新的第三方\",{\"1\":{\"676\":1,\"678\":1}}],[\"加入到集合中\",{\"1\":{\"659\":1}}],[\"加入\",{\"1\":{\"644\":1}}],[\"加入2份巧克力\",{\"1\":{\"584\":2}}],[\"加入两份巧克力\",{\"1\":{\"584\":1}}],[\"加入一份巧克力\",{\"1\":{\"584\":3}}],[\"加入一份牛奶\",{\"1\":{\"584\":9}}],[\"加码\",{\"1\":{\"579\":1}}],[\"加密解密\",{\"1\":{\"432\":1}}],[\"加密和会话管理\",{\"1\":{\"427\":1}}],[\"加密展示\",{\"1\":{\"5\":1}}],[\"加深印象\",{\"1\":{\"284\":1}}],[\"加载类则是回调\",{\"1\":{\"310\":1}}],[\"加载类对象\",{\"1\":{\"114\":1}}],[\"加载\",{\"1\":{\"114\":1}}],[\"加载到系统里就好了\",{\"1\":{\"105\":1}}],[\"只声明一个变量\",{\"1\":{\"917\":1}}],[\"只依赖日志框架\",{\"1\":{\"869\":1}}],[\"只包含service\",{\"1\":{\"869\":1}}],[\"只分配一块存储空间\",{\"1\":{\"851\":1}}],[\"只可以被子类实现\",{\"1\":{\"825\":1}}],[\"只让会飞的鸟去实现这个接口\",{\"1\":{\"813\":1}}],[\"只和朋友交流\",{\"1\":{\"748\":1}}],[\"只会影响到一个依赖类的代码改动\",{\"1\":{\"741\":1}}],[\"只与直接的朋友通信\",{\"1\":{\"741\":1}}],[\"只羊\",{\"1\":{\"684\":1}}],[\"只影响到了迭代器\",{\"1\":{\"652\":1}}],[\"只影响到聚合对象\",{\"1\":{\"652\":1}}],[\"只关心产品的品牌\",{\"1\":{\"614\":1}}],[\"只关心什么产品由什么工厂生产即可\",{\"1\":{\"557\":1}}],[\"只对结果负责\",{\"1\":{\"591\":1}}],[\"只需增加一个\",{\"1\":{\"839\":1}}],[\"只需分发广播\",{\"1\":{\"680\":1}}],[\"只需多写一个相应的工厂类\",{\"1\":{\"612\":1}}],[\"只需知道参数即可\",{\"1\":{\"608\":1}}],[\"只需要在方法前加上\",{\"1\":{\"972\":1}}],[\"只需要在启动的时候根据配置文件解析\",{\"1\":{\"105\":1}}],[\"只需要让新的图形类继承\",{\"1\":{\"739\":1}}],[\"只需要修改该类就可\",{\"1\":{\"609\":1}}],[\"只需要知道抽象部分和实现部分的接口就可以了\",{\"1\":{\"544\":1}}],[\"只需要去覆盖我们\",{\"1\":{\"532\":1}}],[\"只需修改适配器即可\",{\"1\":{\"528\":1}}],[\"只是new自定义异常\",{\"1\":{\"858\":1}}],[\"只是转换接口\",{\"1\":{\"850\":1}}],[\"只是因为\",{\"1\":{\"814\":1}}],[\"只是简单替换而已\",{\"1\":{\"809\":1}}],[\"只是实现起来会非常奇怪\",{\"1\":{\"764\":1}}],[\"只是增加方法\",{\"1\":{\"718\":1}}],[\"只是\",{\"1\":{\"679\":1,\"823\":1}}],[\"只是不能实例化\",{\"1\":{\"556\":1}}],[\"只是将实现类的方法搬移到接口定义中的时候\",{\"1\":{\"809\":1}}],[\"只是将\",{\"1\":{\"527\":1}}],[\"只是在内存中开辟了一个存储空间\",{\"1\":{\"290\":1}}],[\"只不过将类实例化的过程放在了静态代码块中\",{\"1\":{\"753\":1}}],[\"只不过享元模式为工厂方法模式增加了缓存这一功能\",{\"1\":{\"639\":1}}],[\"只不过实现方式不同\",{\"1\":{\"529\":1}}],[\"只不过前者返回的class类型后者返回的type\",{\"1\":{\"308\":1}}],[\"只不过这个时候的泛型为object\",{\"1\":{\"289\":1}}],[\"只不过这个文件只会在classpath下的jar包中\",{\"1\":{\"106\":1}}],[\"只获取当前类的字段\",{\"1\":{\"307\":1}}],[\"只获取类名\",{\"1\":{\"305\":1}}],[\"只保留了原始类型\",{\"1\":{\"288\":1}}],[\"只保留一些对外接口使之与外部发生联系\",{\"1\":{\"209\":1}}],[\"只剩下原始类型\",{\"1\":{\"288\":1}}],[\"只针对不正常的情况才使用异常\",{\"0\":{\"263\":1}}],[\"只展示主要代码\",{\"1\":{\"242\":1}}],[\"只要在每个测试方法标注\",{\"1\":{\"998\":1}}],[\"只要在网上建立一个每个朋友都可以访问的\",{\"1\":{\"655\":1}}],[\"只要涉及多个表\",{\"1\":{\"865\":1}}],[\"只要没有唯一索引\",{\"1\":{\"864\":1}}],[\"只要受害者用户一访问\",{\"1\":{\"861\":1}}],[\"只要其中之一没有捕获抛出的异常\",{\"1\":{\"851\":1}}],[\"只要覆写equals\",{\"1\":{\"850\":1}}],[\"只要本周跨年\",{\"1\":{\"849\":1}}],[\"只要是合法的\",{\"1\":{\"949\":1}}],[\"只要是这个线程内定义的\",{\"1\":{\"851\":1}}],[\"只要是在类中用到了对方\",{\"1\":{\"828\":1}}],[\"只要是高层模块需要调度多个子系统\",{\"1\":{\"593\":1}}],[\"只要我们控制好它们的副作用\",{\"1\":{\"814\":1}}],[\"只要搞清楚了这条原则是为了解决什么样的问题而产生的\",{\"1\":{\"810\":1}}],[\"只要修改父类的模板方法或者已经实现的某些步骤\",{\"1\":{\"804\":1}}],[\"只要添加一种策略\",{\"1\":{\"791\":1}}],[\"只要两个对象之间有耦合关系\",{\"1\":{\"741\":1}}],[\"只要把命令对象放到列队\",{\"1\":{\"564\":1}}],[\"只要x\",{\"1\":{\"181\":1}}],[\"只要大家了解布尔类型就知道这不符合逻辑\",{\"1\":{\"91\":1}}],[\"只在集合中添加一个对象\",{\"1\":{\"139\":1}}],[\"只有对需求有一定的理解后才能知道什么是代码的正确性\",{\"1\":{\"991\":1}}],[\"只有类中方法数量足够少\",{\"1\":{\"719\":1}}],[\"只有逻辑足够简单\",{\"1\":{\"719\":1}}],[\"只有建造者模式可以很好地描述该类产品的创建\",{\"1\":{\"549\":1}}],[\"只有自己类声明的字段\",{\"1\":{\"305\":1}}],[\"只有jvm才能调用创建class对象\",{\"1\":{\"302\":1}}],[\"只有arraylist<integer>\",{\"1\":{\"292\":1}}],[\"只有匹配异常的第一个\",{\"1\":{\"267\":1}}],[\"只有没有异常抛出的时候\",{\"1\":{\"264\":1}}],[\"只有这样\",{\"1\":{\"262\":1}}],[\"只有finally块\",{\"1\":{\"251\":1}}],[\"只有注解被定义为runtime后\",{\"1\":{\"233\":1}}],[\"只有在语句组之后才需要使用注释\",{\"1\":{\"924\":1}}],[\"只有在运行时才会出错\",{\"1\":{\"294\":1}}],[\"只有在特殊情况下\",{\"1\":{\"204\":1}}],[\"只有在方法中使用\",{\"1\":{\"204\":1}}],[\"只有当开发人员和评审人员都同意\",{\"1\":{\"913\":1}}],[\"只有当\",{\"1\":{\"180\":1}}],[\"只有\",{\"1\":{\"123\":1,\"125\":1}}],[\"只能直接抛错给用户\",{\"1\":{\"871\":1}}],[\"只能有一个版本号出现在最后的lib目录中\",{\"1\":{\"869\":1}}],[\"只能为名词\",{\"1\":{\"854\":1}}],[\"只能应用于类\",{\"1\":{\"853\":1}}],[\"只能采用继承来实现\",{\"1\":{\"814\":1}}],[\"只能说我们把简单问题复杂化了\",{\"1\":{\"797\":1}}],[\"只能是通配符的形式\",{\"1\":{\"294\":1}}],[\"只能是try\",{\"1\":{\"260\":1}}],[\"只能引用integer的值\",{\"1\":{\"292\":1}}],[\"只能变为了重载\",{\"1\":{\"291\":1}}],[\"只能将类型擦除掉\",{\"1\":{\"291\":1}}],[\"只能存储整数\",{\"1\":{\"288\":1}}],[\"只能存储字符串\",{\"1\":{\"288\":1}}],[\"只能存活在源码时\",{\"1\":{\"225\":1}}],[\"只能接收string或object类型的泛型\",{\"1\":{\"284\":1}}],[\"只能访问外部类的静态成员\",{\"1\":{\"201\":1}}],[\"只能访问所属类的静态字段和静态方法\",{\"1\":{\"144\":1}}],[\"只能通过实现多个接口来达到相同目的\",{\"1\":{\"151\":1}}],[\"只能通过\",{\"1\":{\"115\":1}}],[\"只能找到并加载已经安装到当前java虚拟机中的服务提供者\",{\"1\":{\"114\":1}}],[\"扫描每个插件的清单文件manifest\",{\"1\":{\"105\":1}}],[\"源文件按以下\",{\"1\":{\"886\":1}}],[\"源文件结构\",{\"0\":{\"886\":1},\"1\":{\"910\":1}}],[\"源文件使用\",{\"1\":{\"881\":1}}],[\"源文件的名称包含了区分大小写的\",{\"1\":{\"880\":1}}],[\"源文件准则\",{\"0\":{\"879\":1}}],[\"源文件当且仅当遵守本规范时\",{\"1\":{\"876\":1}}],[\"源文件保留\",{\"1\":{\"228\":1}}],[\"源于java\",{\"1\":{\"873\":1}}],[\"源码在哪里\",{\"1\":{\"869\":1}}],[\"源码编译时会跳过此目录\",{\"1\":{\"860\":1}}],[\"源码中建造者模式角色分析\",{\"1\":{\"556\":1}}],[\"源码分析的类图\",{\"1\":{\"543\":1}}],[\"源码\",{\"0\":{\"326\":1,\"327\":1}}],[\"源码解析\",{\"0\":{\"315\":1,\"318\":1,\"320\":1,\"322\":1}}],[\"源码实现\",{\"0\":{\"103\":1}}],[\"源代码生成器集合\",{\"1\":{\"398\":1}}],[\"源代码通过编译器编译为字节码\",{\"1\":{\"303\":1}}],[\"源代码路径\",{\"1\":{\"105\":1}}],[\"包名只使用小写字母和数字\",{\"1\":{\"939\":1}}],[\"包名\",{\"0\":{\"939\":1}}],[\"包名统一使用单数形式\",{\"1\":{\"845\":1}}],[\"包名统一使用小写\",{\"1\":{\"845\":1}}],[\"包内共享常量\",{\"1\":{\"846\":2}}],[\"包图\",{\"1\":{\"822\":1}}],[\"包裹老的接口\",{\"1\":{\"818\":1}}],[\"包裹住它们\",{\"1\":{\"450\":1}}],[\"包的底层是通过使用字节码处理框架\",{\"1\":{\"702\":1}}],[\"包部署更简单一点\",{\"1\":{\"457\":1}}],[\"包部署会比复杂的\",{\"1\":{\"457\":1}}],[\"包或者\",{\"1\":{\"457\":1,\"461\":1}}],[\"包或者库\",{\"1\":{\"452\":1}}],[\"包等等信息\",{\"1\":{\"301\":1}}],[\"包装数据类型不能使用equals进行判断\",{\"1\":{\"848\":1}}],[\"包装数据是最简单的事情之一\",{\"1\":{\"445\":1}}],[\"包装异常时不要抛弃原始的异常\",{\"0\":{\"271\":1}}],[\"包装类型\",{\"0\":{\"119\":1}}],[\"包\",{\"1\":{\"113\":2,\"224\":1,\"227\":1,\"308\":1,\"461\":2}}],[\"包括首字母缩略词\",{\"1\":{\"947\":1}}],[\"包括do\",{\"1\":{\"873\":1}}],[\"包括其它部门rpc服务接口\",{\"1\":{\"868\":1}}],[\"包括其一般类型\",{\"1\":{\"307\":1}}],[\"包括缓存回滚\",{\"1\":{\"866\":1}}],[\"包括循环边界\",{\"1\":{\"860\":1}}],[\"包括请求和响应\",{\"1\":{\"854\":1}}],[\"包括接口中的方法\",{\"1\":{\"853\":1}}],[\"包括赋值运算符\",{\"1\":{\"847\":1}}],[\"包括用于判断的逻辑方法和需要子类重写的空方法两种\",{\"1\":{\"801\":1}}],[\"包括对象的引用类型\",{\"1\":{\"689\":1}}],[\"包括注释标记\",{\"1\":{\"955\":1}}],[\"包括注册\",{\"1\":{\"678\":1}}],[\"包括注解类型\",{\"1\":{\"236\":1}}],[\"包括若干前端组件\",{\"1\":{\"434\":1}}],[\"包括清理\",{\"1\":{\"415\":1}}],[\"包括从预处理到可视化的各个层次\",{\"1\":{\"413\":1}}],[\"包括svg解析器\",{\"1\":{\"408\":1}}],[\"包括java\",{\"1\":{\"407\":1}}],[\"包括类型参数\",{\"1\":{\"308\":1}}],[\"包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口\",{\"1\":{\"308\":1}}],[\"包括公共\",{\"1\":{\"308\":1}}],[\"包括抽象方法\",{\"1\":{\"308\":1}}],[\"包括private\",{\"1\":{\"306\":2}}],[\"包括继承自父类的所有公共字段\",{\"1\":{\"305\":1}}],[\"包括包名\",{\"1\":{\"305\":2}}],[\"包括需要处理哪些异常\",{\"1\":{\"262\":1}}],[\"包括运行时异常\",{\"1\":{\"249\":1}}],[\"包括字符串常量池\",{\"1\":{\"125\":1}}],[\"包括\",{\"1\":{\"105\":1,\"221\":2,\"222\":1,\"227\":1,\"886\":1,\"910\":1}}],[\"包含测试用例\",{\"1\":{\"970\":1}}],[\"包含违禁敏感词\",{\"1\":{\"874\":1}}],[\"包含非法恶意跳转\",{\"1\":{\"874\":1}}],[\"包含以下几种类型\",{\"1\":{\"801\":1}}],[\"包含以下主要角色\",{\"1\":{\"519\":1}}],[\"包含抽象处理方法和一个后继连接\",{\"1\":{\"708\":1}}],[\"包含最新的天气情况信息\",{\"1\":{\"678\":1}}],[\"包含的学院\",{\"1\":{\"574\":2}}],[\"包含在客户端将java代码转为javascript的编译器\",{\"1\":{\"434\":1}}],[\"包含继承自父类的方法\",{\"1\":{\"308\":1}}],[\"包含继承字段\",{\"1\":{\"307\":2}}],[\"包含父类字段\",{\"1\":{\"307\":1}}],[\"包含private字段\",{\"1\":{\"307\":1}}],[\"包含private修饰的\",{\"1\":{\"307\":2}}],[\"包含private\",{\"1\":{\"304\":2}}],[\"包含两个子类\",{\"1\":{\"246\":1}}],[\"包含了关键字\",{\"1\":{\"632\":1}}],[\"包含了其线程创建时线程执行堆栈的快照\",{\"1\":{\"246\":1}}],[\"包含了elementtype\",{\"1\":{\"236\":1}}],[\"包含了与类有关的信息\",{\"1\":{\"145\":1}}],[\"包含弹出菜单及点击菜单后对应的操作执行类等\",{\"1\":{\"105\":1}}],[\"包含\",{\"1\":{\"14\":1}}],[\"启动一个服务器\",{\"1\":{\"484\":1}}],[\"启动器等\",{\"1\":{\"105\":1}}],[\"启用\",{\"1\":{\"13\":1}}],[\"项目中的这个模块实现就会使用到状态模式\",{\"1\":{\"779\":1}}],[\"项目解决了这个问题\",{\"1\":{\"468\":1}}],[\"项目\",{\"1\":{\"465\":1}}],[\"项目都应该包含你的根\",{\"1\":{\"458\":1}}],[\"项目一样采用版本控制和发布的方式\",{\"1\":{\"458\":1}}],[\"项目对象模型\",{\"1\":{\"458\":1}}],[\"项目的编译配置信息\",{\"1\":{\"105\":1}}],[\"项目基本配置信息\",{\"1\":{\"105\":1}}],[\"项目主页配置\",{\"1\":{\"0\":1}}],[\"项目主页\",{\"0\":{\"0\":1}}],[\"必要时抽取共性方法\",{\"1\":{\"871\":1}}],[\"必要时插入强制类型转换代码\",{\"1\":{\"287\":1}}],[\"必要的领域模型对象\",{\"1\":{\"869\":1}}],[\"必然会导致代码的重复\",{\"1\":{\"871\":1}}],[\"必然会出现如下的情况\",{\"1\":{\"290\":1}}],[\"必然有脏数据产生\",{\"1\":{\"864\":1}}],[\"必然可以构建一个松耦合的日志系统\",{\"1\":{\"104\":1}}],[\"必执行的代码\",{\"1\":{\"257\":1}}],[\"必为true\",{\"1\":{\"181\":1}}],[\"必须符合里氏代换原则\",{\"1\":{\"871\":1}}],[\"必须采取相应降级措施\",{\"1\":{\"871\":1}}],[\"必须定义一个统一的版本变量\",{\"1\":{\"869\":1}}],[\"必须明确评估和验证\",{\"1\":{\"869\":1}}],[\"必须记录出错日志到磁盘\",{\"1\":{\"868\":1}}],[\"必须同时更新记录对应的update\",{\"1\":{\"866\":1}}],[\"必须指定索引长度\",{\"1\":{\"864\":1}}],[\"必须使用is\",{\"1\":{\"863\":1}}],[\"必须使用集合的toarray\",{\"1\":{\"850\":1}}],[\"必须实现防刷\",{\"1\":{\"861\":1}}],[\"必须实现正确的防重放的机制\",{\"1\":{\"861\":1}}],[\"必须对展示数据进行脱敏\",{\"1\":{\"861\":1}}],[\"必须进行日志级别的开关判断\",{\"1\":{\"859\":1}}],[\"必须考虑到远程调用失败\",{\"1\":{\"858\":1}}],[\"必须考虑到所有的子类\",{\"1\":{\"731\":1}}],[\"必须添加注释充分说明什么情况下会返回null值\",{\"1\":{\"858\":1}}],[\"必须处理异常\",{\"1\":{\"858\":1}}],[\"必须控制长度\",{\"1\":{\"854\":1}}],[\"必须要用javadoc注释\",{\"1\":{\"853\":1}}],[\"必须要记住使用相应的获取对象的方法\",{\"1\":{\"761\":1}}],[\"必须先进行null判断\",{\"1\":{\"852\":1}}],[\"必须先判断当前线程是否持有锁\",{\"1\":{\"851\":1}}],[\"必须在try代码块之外\",{\"1\":{\"851\":1}}],[\"必须在返回值前边加一个<t>\",{\"1\":{\"283\":1}}],[\"必须回收自定义的threadlocal变量\",{\"1\":{\"851\":1}}],[\"必须是public\",{\"1\":{\"972\":1}}],[\"必须是private\",{\"1\":{\"848\":3}}],[\"必须是protected\",{\"1\":{\"848\":1}}],[\"必须是unsigned\",{\"1\":{\"863\":1}}],[\"必须是完全匹配\",{\"1\":{\"858\":1}}],[\"必须是接口\",{\"1\":{\"525\":1,\"529\":1}}],[\"必须自己显式地进行赋值\",{\"1\":{\"848\":1}}],[\"必须加锁\",{\"1\":{\"851\":1}}],[\"必须加\",{\"1\":{\"848\":1}}],[\"必须勾选insert\",{\"1\":{\"847\":1}}],[\"必须设置\",{\"1\":{\"847\":1}}],[\"必须阅读父类的代码\",{\"1\":{\"812\":1}}],[\"必须根据设计的应用系统的特点和要求来恰当选择\",{\"1\":{\"797\":1}}],[\"必须去实现他们不需要的方法\",{\"1\":{\"721\":1,\"723\":1}}],[\"必须让其他所有的朋友一起修改\",{\"1\":{\"655\":1}}],[\"必须用getname\",{\"1\":{\"305\":1}}],[\"必须带有无参的构造器\",{\"1\":{\"305\":1}}],[\"必须声明方法可抛出的任何可查异常\",{\"1\":{\"252\":1}}],[\"必须初始化\",{\"1\":{\"205\":1}}],[\"必须写在子类构造方法的第一行\",{\"1\":{\"200\":1}}],[\"必须true\",{\"1\":{\"181\":1}}],[\"必须具有相同的\",{\"1\":{\"181\":1}}],[\"必须有相同的hashcode\",{\"1\":{\"175\":1}}],[\"必会经历失败\",{\"1\":{\"36\":1}}],[\"查询的表别名限定\",{\"1\":{\"872\":1}}],[\"查询信息后\",{\"1\":{\"852\":1}}],[\"查看每个构造方法需要的参数\",{\"1\":{\"306\":1}}],[\"查看详情\",{\"1\":{\"14\":1,\"15\":1,\"16\":1,\"17\":1,\"18\":1,\"19\":1,\"20\":1,\"21\":1,\"22\":1,\"23\":1,\"24\":1,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":1}}],[\"查找无参构造器\",{\"1\":{\"310\":1}}],[\"查找异常表\",{\"1\":{\"275\":1}}],[\"查找配置文件的目录\",{\"1\":{\"114\":1}}],[\"查找classpath根目录commons\",{\"1\":{\"104\":1}}],[\"第七章\",{\"1\":{\"952\":1}}],[\"第四阶段\",{\"1\":{\"818\":1}}],[\"第四步\",{\"1\":{\"803\":1}}],[\"第\",{\"1\":{\"778\":1,\"794\":5,\"843\":1,\"849\":3,\"857\":2}}],[\"第2次调用b\",{\"1\":{\"632\":1}}],[\"第2次调用a\",{\"1\":{\"632\":1}}],[\"第1次调用b\",{\"1\":{\"632\":1}}],[\"第1次调用a\",{\"1\":{\"632\":1}}],[\"第3次调用a\",{\"1\":{\"632\":1}}],[\"第一行\",{\"1\":{\"908\":1}}],[\"第一\",{\"1\":{\"853\":1}}],[\"第一次分派\",{\"1\":{\"839\":1}}],[\"第一阶段\",{\"1\":{\"818\":1}}],[\"第一步点击扣除积分\",{\"1\":{\"778\":1}}],[\"第一步\",{\"1\":{\"311\":1,\"803\":1}}],[\"第一种情况\",{\"1\":{\"849\":1,\"850\":1}}],[\"第一种解决思路是\",{\"1\":{\"768\":1}}],[\"第一种方法\",{\"1\":{\"306\":1}}],[\"第一种\",{\"1\":{\"290\":1}}],[\"第一个参数是一个可选字符串消息\",{\"1\":{\"978\":1}}],[\"第一个参数代表调用的对象\",{\"1\":{\"308\":1}}],[\"第一个\",{\"1\":{\"267\":1}}],[\"第一个spi和api的区别\",{\"1\":{\"113\":1}}],[\"第一点\",{\"1\":{\"192\":1}}],[\"第三方功能降级\",{\"1\":{\"874\":1}}],[\"第三方系统限流\",{\"1\":{\"874\":1}}],[\"第三方系统执行超时\",{\"1\":{\"874\":1}}],[\"第三方容灾系统被\",{\"1\":{\"874\":1}}],[\"第三方服务\",{\"1\":{\"868\":1}}],[\"第三阶段\",{\"1\":{\"818\":1}}],[\"第三步\",{\"1\":{\"803\":1}}],[\"第三种解决思路是\",{\"1\":{\"768\":1}}],[\"第三\",{\"1\":{\"104\":1}}],[\"第二行相对第一行缩进\",{\"1\":{\"847\":1}}],[\"第二阶段\",{\"1\":{\"818\":1}}],[\"第二次的参数\",{\"1\":{\"768\":1}}],[\"第二步抽奖\",{\"1\":{\"778\":1}}],[\"第二步\",{\"1\":{\"311\":1}}],[\"第二种情况\",{\"1\":{\"849\":1,\"850\":1}}],[\"第二种解决思路是\",{\"1\":{\"768\":1}}],[\"第二种则没有效果\",{\"1\":{\"290\":1}}],[\"第二种\",{\"1\":{\"290\":1}}],[\"第二个参数传递的调用方法的参数\",{\"1\":{\"308\":1}}],[\"第二个处理所有非\",{\"1\":{\"267\":1}}],[\"第二个什么时候用api\",{\"1\":{\"113\":1}}],[\"第二点\",{\"1\":{\"192\":1}}],[\"第二\",{\"1\":{\"104\":1,\"853\":1}}],[\"第二天就会精神饱满\",{\"1\":{\"36\":1}}],[\"8209\",{\"1\":{\"1000\":1}}],[\"8的运行器\",{\"1\":{\"972\":1,\"981\":1}}],[\"8f\",{\"1\":{\"848\":2}}],[\"80\",{\"1\":{\"847\":2}}],[\"8080\",{\"1\":{\"773\":3}}],[\"8=\",{\"1\":{\"734\":3}}],[\"8462\",{\"1\":{\"591\":1}}],[\"8152\",{\"1\":{\"485\":2}}],[\"8发布前\",{\"1\":{\"396\":1}}],[\"8新增\",{\"1\":{\"308\":1}}],[\"88243278\",{\"1\":{\"984\":1}}],[\"88\",{\"1\":{\"307\":2}}],[\"857722\",{\"1\":{\"276\":1}}],[\"8中提供了两个元注解\",{\"1\":{\"226\":1}}],[\"8及之后\",{\"1\":{\"125\":1}}],[\"8\",{\"0\":{\"187\":1,\"347\":1,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":1,\"353\":1,\"354\":1,\"355\":1,\"356\":1,\"357\":1,\"358\":1,\"360\":1,\"881\":1},\"1\":{\"104\":1,\"114\":1,\"119\":1,\"120\":1,\"133\":4,\"150\":3,\"161\":1,\"186\":1,\"187\":2,\"188\":1,\"227\":2,\"231\":1,\"236\":2,\"259\":1,\"275\":12,\"291\":2,\"312\":56,\"403\":1,\"438\":1,\"443\":1,\"450\":1,\"455\":1,\"466\":1,\"469\":1,\"470\":2,\"472\":1,\"734\":5,\"790\":1,\"847\":1,\"848\":2,\"850\":2,\"863\":1,\"881\":1,\"974\":1}}],[\"载meta\",{\"1\":{\"104\":1}}],[\"尝试从classpath根目录下的commons\",{\"1\":{\"104\":1}}],[\"尝试使用java\",{\"1\":{\"104\":1}}],[\"尝试查找vm系统属性org\",{\"1\":{\"104\":1}}],[\"尝试静下心来读书吧\",{\"1\":{\"36\":1}}],[\"分组括号\",{\"0\":{\"913\":1}}],[\"分组配置文件\",{\"1\":{\"432\":1}}],[\"分隔任何的保留关键字\",{\"1\":{\"911\":2}}],[\"分隔开来以提升可读性\",{\"1\":{\"847\":1}}],[\"分层领域模型规约\",{\"1\":{\"868\":1}}],[\"分层异常处理规约\",{\"1\":{\"868\":1}}],[\"分层和模块化合理\",{\"1\":{\"816\":1}}],[\"分成两个部分\",{\"1\":{\"857\":1}}],[\"分开维护\",{\"1\":{\"846\":1}}],[\"分为一般关联关系\",{\"1\":{\"830\":1}}],[\"分为两种\",{\"1\":{\"146\":2}}],[\"分享金句\",{\"1\":{\"797\":1}}],[\"分解成不同类即可\",{\"1\":{\"718\":1}}],[\"分钟后下课\",{\"1\":{\"695\":1}}],[\"分支\",{\"0\":{\"925\":1}}],[\"分支判断\",{\"1\":{\"620\":1}}],[\"分支逻辑\",{\"1\":{\"614\":1}}],[\"分支逻辑的实现方式\",{\"1\":{\"614\":1}}],[\"分\",{\"1\":{\"618\":1}}],[\"分离变化部分\",{\"1\":{\"789\":1}}],[\"分离了创建与表示\",{\"1\":{\"558\":1}}],[\"分离开来\",{\"1\":{\"537\":1}}],[\"分词等一系列工具类\",{\"1\":{\"432\":1}}],[\"分布式多线程深度学习开发库\",{\"1\":{\"413\":1}}],[\"分布式数据库\",{\"0\":{\"400\":1}}],[\"分布式应用\",{\"0\":{\"399\":1}}],[\"分片\",{\"1\":{\"394\":1}}],[\"分类\",{\"0\":{\"325\":1},\"1\":{\"589\":1,\"590\":1,\"591\":1,\"835\":1}}],[\"分类为\",{\"1\":{\"32\":1}}],[\"分三步\",{\"1\":{\"310\":1}}],[\"分析项目中变化部分与不变部分\",{\"1\":{\"791\":1}}],[\"分析问题\",{\"1\":{\"742\":1,\"743\":1}}],[\"分析得出在\",{\"1\":{\"585\":1}}],[\"分析及可视化日志文件\",{\"1\":{\"412\":1}}],[\"分析\",{\"1\":{\"291\":1,\"573\":1,\"609\":1,\"742\":1,\"743\":1}}],[\"分析其factory\",{\"1\":{\"104\":1}}],[\"分别用于存放期望值和测试所用数据\",{\"1\":{\"981\":1}}],[\"分别用于标明重写某个方法\",{\"1\":{\"221\":1}}],[\"分别是\",{\"1\":{\"857\":1}}],[\"分别封装行为接口\",{\"1\":{\"789\":1}}],[\"分别与他们需要的接口建立依赖关系\",{\"1\":{\"721\":1,\"723\":1}}],[\"分别输入\",{\"1\":{\"643\":1}}],[\"分别控制\",{\"1\":{\"562\":1}}],[\"分别为\",{\"1\":{\"280\":1}}],[\"分别被称为泛型类\",{\"1\":{\"279\":1}}],[\"分别使用三种策略各定义一个注解类做测试\",{\"1\":{\"228\":1}}],[\"遍历对象集合\",{\"1\":{\"652\":1}}],[\"遍历所有学院\",{\"1\":{\"650\":1}}],[\"遍历所有的观察者\",{\"1\":{\"678\":1}}],[\"遍历所有的url\",{\"1\":{\"106\":1}}],[\"遍历所有的驱动实现\",{\"1\":{\"103\":1}}],[\"遍历的位置\",{\"1\":{\"650\":1}}],[\"遍历任务交由迭代器完成\",{\"1\":{\"648\":1}}],[\"遍历我们的字符数组\",{\"1\":{\"644\":1}}],[\"遍历组织机构\",{\"1\":{\"576\":1}}],[\"遍历等\",{\"1\":{\"573\":1}}],[\"遍历\",{\"1\":{\"111\":1,\"234\":1,\"574\":2,\"650\":1}}],[\"遍历使用spi获取到的具体实现\",{\"1\":{\"103\":2}}],[\"实心菱形\",{\"1\":{\"835\":1}}],[\"实打实的关系\",{\"1\":{\"835\":1}}],[\"实线表示关联关系\",{\"1\":{\"835\":1}}],[\"实线表示继承\",{\"1\":{\"835\":1}}],[\"实体中定义了对\",{\"1\":{\"832\":1}}],[\"实体的行为来实现变化\",{\"1\":{\"736\":1}}],[\"实体工厂\",{\"1\":{\"589\":1}}],[\"实体名识别和情感分析这样的任务\",{\"1\":{\"418\":1}}],[\"实践和工具等相关资料\",{\"1\":{\"443\":1}}],[\"实时和嵌入式系统的开发库\",{\"1\":{\"406\":1}}],[\"实时和历史olap数据存储\",{\"1\":{\"400\":1}}],[\"实时计算系统\",{\"1\":{\"399\":1}}],[\"实参则用自身的值更改形参的值\",{\"1\":{\"204\":1}}],[\"实参\",{\"0\":{\"204\":1}}],[\"实际接到的是铅球\",{\"1\":{\"858\":1}}],[\"实际类对象属性为integer\",{\"1\":{\"848\":1}}],[\"实际是空心的虚线\",{\"1\":{\"834\":1}}],[\"实际是空心的\",{\"1\":{\"833\":1}}],[\"实际访问的对象\",{\"1\":{\"695\":1}}],[\"实际开发中\",{\"1\":{\"534\":1}}],[\"实际上是保障公众的人身安全\",{\"1\":{\"843\":1}}],[\"实际上是在设定规范和契约\",{\"1\":{\"731\":1}}],[\"实际上是这样的吗\",{\"1\":{\"291\":1}}],[\"实际上就是在原代码逻辑前后增加一些代码逻辑\",{\"1\":{\"694\":1}}],[\"实际上并不会\",{\"1\":{\"622\":1}}],[\"实际上我们的要求是\",{\"1\":{\"573\":1}}],[\"实际上\",{\"1\":{\"290\":1,\"291\":2,\"606\":1,\"621\":1,\"627\":1,\"741\":2,\"748\":1,\"766\":2,\"768\":1,\"769\":3,\"771\":2,\"773\":3,\"808\":2,\"809\":1,\"813\":1,\"816\":1,\"818\":2,\"996\":1}}],[\"实际上差距会比这个数字更大一些\",{\"1\":{\"276\":1}}],[\"实际上这些变量在编译时会被替换掉\",{\"1\":{\"183\":1}}],[\"实际上hashcode扮演的角色就是寻址\",{\"1\":{\"181\":1}}],[\"实际的存储值为\",{\"1\":{\"848\":1}}],[\"实际的存储位置是有差异的\",{\"1\":{\"125\":1}}],[\"实际的文章内容\",{\"1\":{\"7\":1}}],[\"实例初始化代码块\",{\"1\":{\"910\":1}}],[\"实例\",{\"1\":{\"528\":1,\"637\":3}}],[\"实例这里开始\",{\"1\":{\"458\":1}}],[\"实例变量\",{\"1\":{\"144\":5}}],[\"实例使用自动装箱来创建并且值相同\",{\"1\":{\"120\":1}}],[\"实例化对象\",{\"1\":{\"757\":1}}],[\"实例化代码只用执行一次\",{\"1\":{\"757\":1}}],[\"实例化默认构造方法\",{\"1\":{\"306\":1}}],[\"实例化\",{\"1\":{\"305\":2}}],[\"实例化服务提供者\",{\"1\":{\"114\":1}}],[\"实例化各个实现类\",{\"1\":{\"103\":2}}],[\"实现注释\",{\"1\":{\"877\":1,\"932\":1}}],[\"实现或者mock实现\",{\"1\":{\"860\":1}}],[\"实现什么功能\",{\"1\":{\"853\":1}}],[\"实现延迟初始化需要将目标属性声明为volatile型\",{\"1\":{\"851\":1}}],[\"实现基于接口的编程\",{\"1\":{\"810\":1}}],[\"实现降序排序\",{\"1\":{\"790\":1}}],[\"实现算法族\",{\"1\":{\"789\":1}}],[\"实现对总接口的定义\",{\"1\":{\"722\":1}}],[\"实现对公网的访问\",{\"1\":{\"704\":1}}],[\"实现任何的接口\",{\"1\":{\"702\":1}}],[\"实现代理只需要使用\",{\"1\":{\"699\":1}}],[\"实现深拷贝\",{\"1\":{\"689\":1}}],[\"实现一个克隆自己的操作\",{\"1\":{\"683\":1}}],[\"实现原型接口的原型类\",{\"1\":{\"683\":1}}],[\"实现起来会比较麻烦\",{\"1\":{\"682\":1}}],[\"实现起来不拘泥于我们讲解的三种经典形式\",{\"1\":{\"534\":1}}],[\"实现观察者模式时要注意具体目标对象和具体观察者对象之间不能直接调用\",{\"1\":{\"672\":1}}],[\"实现其他业务功能\",{\"1\":{\"664\":1}}],[\"实现所有相互影响的同事类的公共功能\",{\"1\":{\"656\":1}}],[\"实现中介者接口\",{\"1\":{\"656\":1}}],[\"实现类要单一\",{\"1\":{\"748\":1}}],[\"实现类似广播机制的功能\",{\"1\":{\"680\":1}}],[\"实现类\",{\"1\":{\"626\":1}}],[\"实现系统的部分功能\",{\"1\":{\"595\":1}}],[\"实现特定语法解析\",{\"1\":{\"591\":1}}],[\"实现抽象元素角色提供的\",{\"1\":{\"838\":1}}],[\"实现抽象访问者角色中声明的各个访问操作\",{\"1\":{\"838\":1}}],[\"实现抽象类中所定义的抽象方法和钩子方法\",{\"1\":{\"801\":1}}],[\"实现抽象状态所对应的行为\",{\"1\":{\"776\":1}}],[\"实现抽象处理者的处理方法\",{\"1\":{\"708\":1}}],[\"实现抽象观察者中定义的抽象方法\",{\"1\":{\"672\":1}}],[\"实现抽象迭代器接口中所定义的方法\",{\"1\":{\"649\":1}}],[\"实现抽象聚合类\",{\"1\":{\"649\":1}}],[\"实现抽象享元角色中所规定的接口\",{\"1\":{\"632\":1}}],[\"实现抽象装饰的相关方法\",{\"1\":{\"580\":1}}],[\"实现抽象构件\",{\"1\":{\"580\":1}}],[\"实现者\",{\"1\":{\"561\":1}}],[\"实现命令的撤销与恢复\",{\"1\":{\"560\":1}}],[\"实现解耦\",{\"1\":{\"560\":1,\"711\":1}}],[\"实现接口\",{\"1\":{\"550\":1,\"695\":1}}],[\"实现化角色\",{\"1\":{\"538\":1}}],[\"实现化\",{\"1\":{\"538\":1}}],[\"实现父类中的业务方法\",{\"1\":{\"538\":1}}],[\"实现和其他根本框架不同\",{\"1\":{\"472\":1}}],[\"实现和接口在一个包中\",{\"1\":{\"113\":1}}],[\"实现把网络访问\",{\"1\":{\"466\":1}}],[\"实现并解释了最常见的设计模式\",{\"1\":{\"415\":1}}],[\"实现jms的开源消息代理\",{\"1\":{\"414\":1}}],[\"实现了简单功能的一个假对象\",{\"1\":{\"996\":1}}],[\"实现了最大化代码复用\",{\"1\":{\"804\":1}}],[\"实现了二者的分离\",{\"1\":{\"783\":1}}],[\"实现了内部状态的封装\",{\"1\":{\"663\":1}}],[\"实现了抽象策略定义的接口\",{\"1\":{\"784\":1}}],[\"实现了抽象主题中的具体业务\",{\"1\":{\"694\":1}}],[\"实现了抽象产品角色所定义的接口\",{\"1\":{\"612\":1,\"616\":1}}],[\"实现了抽象和实现部分的分离\",{\"1\":{\"544\":1}}],[\"实现了命令接口\",{\"1\":{\"563\":1}}],[\"实现了\",{\"1\":{\"420\":1,\"469\":1,\"556\":1,\"560\":1,\"651\":1,\"723\":16,\"790\":1,\"813\":3}}],[\"实现了多种基础和高级编程抽象\",{\"1\":{\"403\":1}}],[\"实现了数据同步\",{\"1\":{\"394\":1}}],[\"实现多态\",{\"1\":{\"291\":1}}],[\"实现继承中的多态\",{\"1\":{\"291\":1}}],[\"实现日志的切面\",{\"1\":{\"242\":1}}],[\"实现ut\",{\"1\":{\"241\":2}}],[\"实现关系实际上就是\",{\"1\":{\"834\":1}}],[\"实现关系使用\",{\"1\":{\"834\":1}}],[\"实现关系\",{\"0\":{\"214\":1,\"834\":1}}],[\"实现\",{\"1\":{\"138\":1,\"451\":1,\"472\":1,\"523\":1,\"527\":1,\"534\":1,\"551\":1,\"822\":1,\"826\":1,\"834\":1,\"835\":1}}],[\"实现方法拦截\",{\"1\":{\"702\":1}}],[\"实现方\",{\"1\":{\"113\":1}}],[\"实现位于独立的包中\",{\"1\":{\"113\":1}}],[\"+4\",{\"0\":{\"908\":1},\"1\":{\"908\":2}}],[\"+2\",{\"0\":{\"903\":1},\"1\":{\"923\":2}}],[\"+heapdumponoutofmemoryerror参数\",{\"1\":{\"870\":1}}],[\"+whatfeatureofgroup\",{\"1\":{\"851\":1}}],[\"+1\",{\"1\":{\"773\":1}}],[\"+m\",{\"1\":{\"308\":2}}],[\"+method1\",{\"1\":{\"308\":1}}],[\"+method\",{\"1\":{\"308\":1}}],[\"+f\",{\"1\":{\"307\":2}}],[\"+field2\",{\"1\":{\"307\":1}}],[\"+field\",{\"1\":{\"307\":1}}],[\"+college\",{\"1\":{\"650\":1}}],[\"+count\",{\"1\":{\"308\":2}}],[\"+cons\",{\"1\":{\"306\":1}}],[\"+cs3\",{\"1\":{\"306\":2}}],[\"+claz\",{\"1\":{\"306\":1}}],[\"+tp\",{\"1\":{\"306\":1}}],[\"+uclazz\",{\"1\":{\"306\":1}}],[\"+user2\",{\"1\":{\"306\":1}}],[\"+user1\",{\"1\":{\"306\":1}}],[\"+i+\",{\"1\":{\"306\":2}}],[\"++index\",{\"1\":{\"649\":1}}],[\"++i\",{\"1\":{\"627\":1,\"644\":2}}],[\"++numnewmembers\",{\"1\":{\"311\":1}}],[\"++numinvocations\",{\"1\":{\"310\":1,\"312\":2}}],[\"++x\",{\"1\":{\"273\":2,\"858\":2}}],[\"++\",{\"0\":{\"164\":1}}],[\"+=\",{\"0\":{\"165\":1},\"1\":{\"114\":1,\"129\":3,\"165\":2,\"312\":3,\"650\":3,\"980\":2}}],[\"+\",{\"0\":{\"165\":1},\"1\":{\"103\":4,\"104\":36,\"114\":16,\"120\":2,\"129\":3,\"132\":1,\"133\":1,\"139\":3,\"152\":1,\"165\":1,\"209\":2,\"234\":3,\"242\":9,\"269\":1,\"276\":3,\"279\":28,\"281\":2,\"282\":1,\"284\":1,\"285\":1,\"305\":10,\"306\":7,\"308\":2,\"309\":1,\"310\":2,\"311\":3,\"312\":36,\"420\":1,\"524\":2,\"528\":3,\"542\":1,\"571\":4,\"574\":4,\"581\":1,\"582\":1,\"583\":1,\"584\":18,\"618\":7,\"625\":2,\"627\":2,\"632\":7,\"636\":4,\"637\":1,\"643\":3,\"644\":11,\"649\":2,\"650\":1,\"664\":3,\"667\":3,\"676\":6,\"678\":12,\"685\":6,\"687\":20,\"689\":12,\"700\":2,\"703\":1,\"710\":16,\"718\":7,\"734\":15,\"742\":2,\"743\":2,\"752\":2,\"753\":2,\"754\":2,\"755\":2,\"756\":2,\"757\":2,\"758\":2,\"778\":3,\"779\":1,\"790\":1,\"796\":1,\"838\":4,\"846\":3,\"847\":1,\"848\":2,\"850\":1,\"851\":2,\"854\":1,\"885\":1,\"975\":1,\"981\":1}}],[\"+keyword\",{\"1\":{\"96\":2}}],[\"62\",{\"1\":{\"979\":1,\"980\":1}}],[\"628\",{\"1\":{\"852\":4}}],[\"68\",{\"1\":{\"979\":1}}],[\"6f\",{\"1\":{\"848\":1}}],[\"666\",{\"1\":{\"845\":1}}],[\"6937364\",{\"1\":{\"314\":1}}],[\"69912579\",{\"1\":{\"116\":1}}],[\"6155636\",{\"1\":{\"277\":1}}],[\"63\",{\"1\":{\"270\":1}}],[\"65535\",{\"1\":{\"863\":1}}],[\"65\",{\"1\":{\"270\":2,\"743\":1}}],[\"6012105\",{\"1\":{\"219\":1}}],[\"6及之前\",{\"1\":{\"125\":1}}],[\"6475334\",{\"1\":{\"219\":1}}],[\"64\",{\"1\":{\"119\":2,\"869\":1}}],[\"6\",{\"1\":{\"100\":2,\"103\":2,\"144\":1,\"275\":13,\"285\":1,\"440\":1,\"466\":1,\"584\":1,\"741\":1,\"779\":1,\"827\":1,\"845\":1,\"848\":1,\"850\":1,\"858\":1,\"872\":3,\"911\":2,\"981\":1}}],[\"通配符导入\",{\"1\":{\"890\":1}}],[\"通配符类型\",{\"1\":{\"298\":1}}],[\"通知服务出错\",{\"1\":{\"874\":1}}],[\"通知\",{\"1\":{\"680\":1}}],[\"通知各个注册的观察者\",{\"1\":{\"678\":2}}],[\"通知所有的\",{\"1\":{\"678\":1}}],[\"通知所有注册过的观察者对象\",{\"1\":{\"672\":1}}],[\"通知观察者方法\",{\"1\":{\"672\":1}}],[\"通知的发布会花费很多时间\",{\"1\":{\"671\":1}}],[\"通信录\",{\"1\":{\"655\":1}}],[\"通信工程不好学\",{\"1\":{\"574\":1}}],[\"通信工程\",{\"1\":{\"574\":1}}],[\"通向全世界\",{\"1\":{\"590\":1}}],[\"通俗易懂的理解\",{\"1\":{\"560\":1}}],[\"通用业务处理层\",{\"1\":{\"868\":1}}],[\"通用性和扩展性\",{\"1\":{\"795\":1}}],[\"通用的做法是\",{\"1\":{\"734\":1}}],[\"通用注解\",{\"1\":{\"432\":1}}],[\"通用工具类函数库\",{\"1\":{\"432\":1}}],[\"通用工具库\",{\"0\":{\"432\":1}}],[\"通用测试框架\",{\"1\":{\"431\":1}}],[\"通用模板引擎\",{\"1\":{\"430\":1}}],[\"通用底层字节码操作和分析开发库\",{\"1\":{\"386\":1}}],[\"通用方法\",{\"0\":{\"136\":1}}],[\"通常只有一个\",{\"1\":{\"915\":1}}],[\"通常命名为sync\",{\"1\":{\"873\":1}}],[\"通常在订单号或交易号大于等于\",{\"1\":{\"854\":1}}],[\"通常在以下情况可以考虑使用访问者\",{\"1\":{\"841\":1}}],[\"通常在以下情况下可以考虑使用状态模式\",{\"1\":{\"781\":1}}],[\"通常在以下情况下可以考虑使用外观模式\",{\"1\":{\"604\":1}}],[\"通常在以下几种情况中使用策略模式较多\",{\"1\":{\"792\":1}}],[\"通常是连字符\",{\"1\":{\"947\":1}}],[\"通常是web向模板渲染引擎层传输的对象\",{\"1\":{\"868\":1,\"873\":1}}],[\"通常是子模块中的constant目录下\",{\"1\":{\"846\":1}}],[\"通常是client\",{\"1\":{\"846\":1}}],[\"通常是\",{\"1\":{\"845\":1}}],[\"通常由\",{\"1\":{\"838\":1}}],[\"通常多个设计模式混合使用\",{\"1\":{\"797\":1}}],[\"通常通过\",{\"1\":{\"779\":1}}],[\"通常类的复用分为继承复用和合成复用两种\",{\"1\":{\"747\":1}}],[\"通常每个接收者都包含对另一个接收者的引用\",{\"1\":{\"707\":1}}],[\"通常情况下\",{\"1\":{\"580\":1,\"719\":1}}],[\"通常包含各个解释器需要的数据或是公共的功能\",{\"1\":{\"642\":1}}],[\"通常包含\",{\"1\":{\"568\":1,\"649\":1}}],[\"通常都是使用工厂模式进行创建\",{\"1\":{\"558\":1}}],[\"通常还包含一个返回复杂产品的方法\",{\"1\":{\"551\":1}}],[\"通常适用于以下场景\",{\"1\":{\"535\":1}}],[\"通常使用spring\",{\"1\":{\"449\":1}}],[\"通常会提示编码人员\",{\"1\":{\"912\":1}}],[\"通常会有多种有效可行的换行方法\",{\"1\":{\"906\":1}}],[\"通常会嵌入到项目中\",{\"1\":{\"429\":1}}],[\"通常会用class\",{\"1\":{\"98\":1}}],[\"通常用来对资源进行释放\",{\"1\":{\"976\":1}}],[\"通常用来为后面测试方法的准备工作\",{\"1\":{\"976\":1}}],[\"通常用作开源项目的托管服务\",{\"1\":{\"392\":1}}],[\"通常用于定义用户定制的顺序\",{\"1\":{\"178\":1}}],[\"通常\",{\"1\":{\"252\":1}}],[\"通常有\",{\"1\":{\"247\":1}}],[\"通过模块或类的扩展来实现\",{\"1\":{\"871\":1}}],[\"通过dao层向上传输数据源对象\",{\"1\":{\"868\":1,\"873\":2}}],[\"通过web封装成http接口\",{\"1\":{\"868\":1}}],[\"通过文件名就可知道日志文件属于什么应用\",{\"1\":{\"859\":1}}],[\"通过accept头表达即可\",{\"1\":{\"854\":1}}],[\"通过标记扫描\",{\"1\":{\"853\":1}}],[\"通过双重检查锁\",{\"1\":{\"851\":1}}],[\"通过封装\",{\"0\":{\"815\":1}}],[\"通过组合\",{\"1\":{\"813\":1}}],[\"通过组合和委托技术来消除代码重复\",{\"1\":{\"813\":1}}],[\"通过添加不同的配料\",{\"1\":{\"802\":1}}],[\"通过这种方式去除对象之间的耦合\",{\"1\":{\"798\":1}}],[\"通过对其进行复制而克隆出多个和原型类似的新实例\",{\"1\":{\"798\":1}}],[\"通过对象的序列化实现\",{\"1\":{\"689\":1}}],[\"通过编译\",{\"1\":{\"770\":1}}],[\"通过修改\",{\"1\":{\"736\":1}}],[\"通过修改jvm在运行时支持对已加载的类进行无限次重定义\",{\"1\":{\"398\":1}}],[\"通过扩展软件\",{\"1\":{\"736\":1}}],[\"通过代理对象\",{\"1\":{\"695\":1,\"700\":1}}],[\"通过代码里标识的元数据让编译器在编译期间进行检查验证\",{\"1\":{\"221\":1}}],[\"通过代码里标识的元数据生成javadoc文档\",{\"1\":{\"221\":1}}],[\"通过接口传递实现依赖\",{\"1\":{\"728\":1}}],[\"通过接口\",{\"1\":{\"721\":2,\"723\":4,\"748\":1}}],[\"通过接口来聚合\",{\"1\":{\"695\":1}}],[\"通过接口或抽象类声明真实主题和代理对象实现的业务方法\",{\"1\":{\"694\":1}}],[\"通过将一个原型对象传给那个要发动创建的对象\",{\"1\":{\"682\":1}}],[\"通过前面的分析与应用实例可知观察者模式适合以下几种情形\",{\"1\":{\"680\":1}}],[\"通过刚刚的最小原型使用示例代码\",{\"1\":{\"625\":1}}],[\"通过合理的使用外观模式\",{\"1\":{\"603\":1}}],[\"通过一个外观角色访问各个子系统的功能\",{\"1\":{\"595\":1}}],[\"通过拷贝原型创建新的对象\",{\"1\":{\"589\":1}}],[\"通过装饰角色为其添加一些职责\",{\"1\":{\"580\":1}}],[\"通过使用不用装饰类及这些装饰类的排列组合\",{\"1\":{\"579\":1}}],[\"通过使用封装\",{\"1\":{\"537\":1}}],[\"通过引入中间件\",{\"1\":{\"560\":1}}],[\"通过构造函数\",{\"1\":{\"765\":1}}],[\"通过构造方法依赖传递\",{\"1\":{\"728\":1}}],[\"通过构造方法设置属性内容\",{\"1\":{\"282\":1}}],[\"通过构造器进行依赖传递\",{\"1\":{\"728\":1}}],[\"通过构造器\",{\"1\":{\"528\":1}}],[\"通过不可变性保证线程安全\",{\"1\":{\"469\":1}}],[\"通过企业级整合模式\",{\"1\":{\"414\":1}}],[\"通过jvm可观察序列\",{\"1\":{\"423\":1}}],[\"通过jvm或者缓存\",{\"1\":{\"310\":1}}],[\"通过jmx或http发布参数\",{\"1\":{\"412\":1}}],[\"通过groovy提供很多有趣的选项\",{\"1\":{\"412\":1}}],[\"通过插件集成其它分析组件\",{\"1\":{\"388\":1}}],[\"通过字节码静态分析查找隐藏bug\",{\"1\":{\"388\":1}}],[\"通过上面\",{\"1\":{\"310\":1}}],[\"通过上面的例子\",{\"1\":{\"290\":1}}],[\"通过上面的解析\",{\"1\":{\"115\":1}}],[\"通过上面的知识\",{\"1\":{\"90\":1}}],[\"通过method对象的invoke\",{\"1\":{\"308\":1}}],[\"通过它可以把远程对象当本地对象来调用\",{\"1\":{\"704\":1}}],[\"通过它可以动态调用对象的方法\",{\"1\":{\"304\":1}}],[\"通过它可以在运行时动态修改成员变量的属性值\",{\"1\":{\"304\":1}}],[\"通过反射机制来调用方法\",{\"1\":{\"858\":1}}],[\"通过反射添加其它类型元素\",{\"1\":{\"288\":1}}],[\"通过反射方法class\",{\"1\":{\"114\":1}}],[\"通过子类实例化对象\",{\"1\":{\"282\":1}}],[\"通过泛型\",{\"1\":{\"279\":1}}],[\"通过泛型指定的不同类型来控制形参具体限制的类型\",{\"1\":{\"279\":1}}],[\"通过finally可以保证锁会被释放\",{\"1\":{\"258\":1}}],[\"通过注解+aop最终的目标是为了实现模块的解耦\",{\"1\":{\"242\":1}}],[\"通过切面实现解耦\",{\"0\":{\"242\":1}}],[\"通过定义新的子类很容易地增加新的状态和转换\",{\"1\":{\"775\":1}}],[\"通过定义\",{\"1\":{\"241\":1}}],[\"通过继承来实现观察者模式\",{\"1\":{\"679\":1}}],[\"通过继承或引用适配者的对象\",{\"1\":{\"519\":1}}],[\"通过继承\",{\"1\":{\"241\":1,\"523\":1}}],[\"通过执行\",{\"1\":{\"228\":1}}],[\"通过集成的面向对象的例外处理机制\",{\"1\":{\"206\":1}}],[\"通过迭代使用equals方法来判断\",{\"1\":{\"181\":1}}],[\"通过虚拟机从而实现跨平台特性\",{\"1\":{\"151\":1}}],[\"通过reallocatememory方法重新分配了一块8字节长度的内存空间\",{\"1\":{\"93\":1}}],[\"通过setmemory方法向每个字节写入byte类型的1\",{\"1\":{\"93\":1}}],[\"通过\",{\"1\":{\"10\":1,\"13\":1,\"151\":1,\"310\":1,\"451\":1,\"469\":2,\"555\":1,\"625\":1,\"644\":1,\"675\":1,\"689\":1,\"728\":2,\"999\":3}}],[\"先写少量功能代码\",{\"1\":{\"991\":1}}],[\"先到中央仓库去查证一下\",{\"1\":{\"869\":1}}],[\"先到缓存代理取\",{\"1\":{\"704\":1}}],[\"先查后插\",{\"1\":{\"864\":1}}],[\"先快速定位需要获取的id段\",{\"1\":{\"864\":1}}],[\"先直接手动增加一行作为删除目标\",{\"1\":{\"860\":1}}],[\"先把实现类写好\",{\"1\":{\"809\":1}}],[\"先\",{\"1\":{\"768\":1}}],[\"先输入表达式的形式\",{\"1\":{\"643\":1}}],[\"先判断值是否在\",{\"1\":{\"637\":1}}],[\"先尝试从缓存中获取\",{\"1\":{\"310\":1}}],[\"先使用cas更新\",{\"1\":{\"310\":1}}],[\"先获取\",{\"1\":{\"311\":1}}],[\"先获取所有的constructors\",{\"1\":{\"310\":1}}],[\"先获取锁\",{\"1\":{\"310\":1}}],[\"先通过反射\",{\"1\":{\"310\":1}}],[\"先来创建几个测试类\",{\"1\":{\"982\":1}}],[\"先来分析setvalue方法\",{\"1\":{\"291\":1}}],[\"先来看下它的定义\",{\"1\":{\"225\":1}}],[\"先看一张图\",{\"1\":{\"721\":1}}],[\"先看一下怎样获取类声明的所有方法\",{\"1\":{\"311\":1}}],[\"先看一个简单的\",{\"1\":{\"275\":1}}],[\"先看个例子\",{\"1\":{\"309\":1}}],[\"先看下如下的代码\",{\"1\":{\"284\":1}}],[\"先看下下面的代码\",{\"1\":{\"222\":1,\"279\":1}}],[\"先定义好接口\",{\"1\":{\"96\":1}}],[\"先检查出自己身上的缺点\",{\"1\":{\"36\":1}}],[\"其方法体通常都是\",{\"1\":{\"838\":1}}],[\"其目的是为了使某些单词\",{\"1\":{\"912\":1}}],[\"其目的是在不暴露聚合对象的内部结构的情况下\",{\"1\":{\"649\":1}}],[\"其目的非常明显\",{\"1\":{\"819\":1}}],[\"其每个子类可以生产一系列相关的产品\",{\"1\":{\"798\":1}}],[\"其拓展是有限多例模式\",{\"1\":{\"798\":1}}],[\"其子类\",{\"1\":{\"779\":1}}],[\"其行为也随之改变\",{\"1\":{\"776\":1}}],[\"其意图是让一个对象在其内部状态改变的时候\",{\"1\":{\"776\":1}}],[\"其内部状态就会发生改变\",{\"1\":{\"775\":1}}],[\"其内部含有对真实主题的引用\",{\"1\":{\"694\":1}}],[\"其稳定性高和延续性强\",{\"1\":{\"737\":1}}],[\"其作用如下\",{\"1\":{\"737\":1}}],[\"其作用是在运行时识别一个对象的类型和类的信息\",{\"1\":{\"301\":1}}],[\"其逻辑肯定要比负责多项职责简单得多\",{\"1\":{\"717\":1}}],[\"其下载要花很多时间\",{\"1\":{\"692\":1}}],[\"其运行速度很慢\",{\"1\":{\"641\":1}}],[\"其好处是可以使系统在不修改原来代码的情况下引进新的产品\",{\"1\":{\"612\":1}}],[\"其对应的树状图如图所示\",{\"1\":{\"571\":1}}],[\"其对应的原生态类型\",{\"1\":{\"278\":1,\"287\":1}}],[\"其结构图如图下所示\",{\"1\":{\"784\":1}}],[\"其结构图如图所示\",{\"1\":{\"569\":1,\"570\":1}}],[\"其结构图如下图所示\",{\"1\":{\"708\":1,\"776\":1}}],[\"其结构图如下所示\",{\"1\":{\"612\":1}}],[\"其结果就是一个普通的类\",{\"1\":{\"289\":1}}],[\"其组成部分相似\",{\"1\":{\"557\":1}}],[\"其性别\",{\"1\":{\"549\":1}}],[\"其具体结构图如下图所示\",{\"1\":{\"547\":1}}],[\"其别名为包装器\",{\"1\":{\"518\":1}}],[\"其算法可从数据中学习\",{\"1\":{\"413\":1}}],[\"其依据的都是用一个class对象\",{\"1\":{\"302\":1}}],[\"其表示的是创建的类的类型信息\",{\"1\":{\"302\":1}}],[\"其必须被try\",{\"1\":{\"198\":1}}],[\"其他设计思想和原则\",{\"1\":{\"818\":1}}],[\"其他第三方接入气象站获取数据的问题\",{\"1\":{\"677\":1}}],[\"其他对象都不能够访问这些状态信息\",{\"1\":{\"663\":1}}],[\"其他方法与前面的field和constructor是类似的\",{\"1\":{\"308\":1}}],[\"其他可查api\",{\"1\":{\"306\":1}}],[\"其他的全部属于对象行为型模式\",{\"1\":{\"798\":1}}],[\"其他的全部属于对象结构型模式\",{\"1\":{\"798\":1}}],[\"其他的全部属于对象创建型模式\",{\"1\":{\"798\":1}}],[\"其他的类\",{\"1\":{\"744\":1,\"748\":1}}],[\"其他的catch语句块将不会被执行\",{\"1\":{\"257\":1}}],[\"其他的exception类及其子类都属于可查异常\",{\"1\":{\"249\":1}}],[\"其他\",{\"0\":{\"855\":1},\"1\":{\"181\":1,\"261\":1,\"766\":1}}],[\"其他本地语言实现的\",{\"1\":{\"163\":1}}],[\"其他不同厂商可以针对同一接口做出不同的实现\",{\"1\":{\"95\":1}}],[\"其它块级元素的\",{\"1\":{\"956\":1}}],[\"其它可选的花括号\",{\"1\":{\"900\":1}}],[\"其它出现在本文档中的术语将另作说明\",{\"1\":{\"877\":1}}],[\"其它公司的http接口\",{\"1\":{\"868\":1}}],[\"其它任务便会自动终止运行\",{\"1\":{\"851\":1}}],[\"其它任何修饰符都会引起编译器错误\",{\"1\":{\"204\":1}}],[\"其它维度的知识点也会影响到软件的最终交付质量\",{\"1\":{\"843\":1}}],[\"其它属性\",{\"1\":{\"789\":1}}],[\"其它克隆对象的也会发生相应的变化\",{\"1\":{\"690\":1}}],[\"其它有创建到\",{\"1\":{\"609\":1}}],[\"其它的类和成员根据实际需要或者期望来编写\",{\"1\":{\"962\":1}}],[\"其它的部分由具体业务来完成\",{\"1\":{\"544\":1}}],[\"其它的异常也可以被重用\",{\"1\":{\"265\":1}}],[\"其它更新\",{\"0\":{\"353\":1}}],[\"其它类就不能直接去调用该类实例的\",{\"1\":{\"141\":1}}],[\"其它都相同不算是重载\",{\"1\":{\"135\":1}}],[\"其中测试方法就是用\",{\"1\":{\"972\":1,\"981\":1}}],[\"其中验证码实现语音验证方式\",{\"1\":{\"871\":1}}],[\"其中id必为主键\",{\"1\":{\"863\":1}}],[\"其中输出给用户的提示信息要求\",{\"1\":{\"854\":1}}],[\"其中卫语句示例如下\",{\"1\":{\"852\":1}}],[\"其中的方法也要保证线程安全\",{\"1\":{\"851\":1}}],[\"其中的set\",{\"1\":{\"307\":1}}],[\"其中c为输入集合参数\",{\"1\":{\"850\":1}}],[\"其中成员对象是整体对象的一部分\",{\"1\":{\"831\":1}}],[\"其中泛化和实现的耦合度相等\",{\"1\":{\"827\":1}}],[\"其中最常用的是建立软件系统的模型\",{\"1\":{\"823\":1}}],[\"其中定义了\",{\"1\":{\"819\":1}}],[\"其中取号\",{\"1\":{\"800\":1}}],[\"其中用到了设计模式\",{\"1\":{\"794\":1}}],[\"其中一个方面依赖于另一方面时\",{\"1\":{\"680\":1}}],[\"其中一个对象的行为发生改变可能会导致一个或者多个其他对象的行为也发生改变\",{\"1\":{\"671\":1}}],[\"其中有几个角色\",{\"1\":{\"560\":1}}],[\"其中包括类型参数\",{\"1\":{\"306\":2}}],[\"其中\",{\"1\":{\"140\":1,\"146\":1,\"283\":1,\"298\":1,\"303\":1,\"310\":1,\"312\":1,\"563\":1,\"625\":1,\"632\":1,\"741\":1,\"771\":1,\"800\":1,\"814\":1,\"819\":1}}],[\"其次才考虑使用继承关系来实现\",{\"1\":{\"745\":1}}],[\"其次\",{\"1\":{\"114\":1,\"622\":1,\"809\":1,\"820\":1}}],[\"其是否指定factory\",{\"1\":{\"104\":1}}],[\"其核心思想就是\",{\"1\":{\"95\":1}}],[\"其实现方式是在数据库取到statementname对应的sql语句的所有记录\",{\"1\":{\"866\":1}}],[\"其实现类会马上编译报错\",{\"1\":{\"848\":1}}],[\"其实现细节对客户透明\",{\"1\":{\"537\":1}}],[\"其实很多应用软件都提供了这项功能\",{\"1\":{\"663\":1}}],[\"其实\",{\"1\":{\"562\":1}}],[\"其实可以从现实语义进行思考\",{\"1\":{\"545\":1}}],[\"其实就是程序员在编程时\",{\"1\":{\"714\":1}}],[\"其实就是新new一个\",{\"1\":{\"310\":1}}],[\"其实就是比较类型完成相等就完了\",{\"1\":{\"310\":1}}],[\"其实就是返回真实类型\",{\"1\":{\"306\":1}}],[\"其实相当于调用类的无参构造函数\",{\"1\":{\"310\":1}}],[\"其实这种方案跟第一种已经很接近\",{\"1\":{\"991\":1}}],[\"其实这在普通的类继承中也是普遍存在的重写\",{\"1\":{\"291\":1}}],[\"其实这里不仅仅是会去classpath路径下查找\",{\"1\":{\"106\":1}}],[\"其实不用惊奇\",{\"1\":{\"291\":1}}],[\"其实在泛型类中\",{\"1\":{\"289\":1}}],[\"其实在前面的31位高位全部是0\",{\"1\":{\"90\":1}}],[\"其实最具spi思想的应该属于插件开发\",{\"1\":{\"105\":1}}],[\"其实它能够执行的秘密就在if的判断条件中\",{\"1\":{\"92\":1}}],[\"其实原理也很简单\",{\"1\":{\"90\":1,\"91\":1}}],[\"其实原理就在于大家熟悉的unicode编码\",{\"1\":{\"89\":1}}],[\"其实都是在刷手机\",{\"1\":{\"36\":1}}],[\"可运行的\",{\"1\":{\"990\":1}}],[\"可选地跟随着一个数字\",{\"1\":{\"946\":1}}],[\"可选花括号的使用\",{\"0\":{\"900\":1}}],[\"可选的\",{\"1\":{\"183\":1}}],[\"可供公司内部其它应用依赖的库\",{\"1\":{\"873\":1}}],[\"可直接封装service接口暴露成rpc接口\",{\"1\":{\"868\":1}}],[\"可直接使用的约束满足问题求解程序\",{\"1\":{\"391\":1}}],[\"可重用度高的service\",{\"1\":{\"860\":1}}],[\"可重复\",{\"1\":{\"860\":1}}],[\"可重复执行的特点\",{\"1\":{\"860\":1}}],[\"可快速判断是谁的问题\",{\"1\":{\"857\":1}}],[\"可视同英文\",{\"1\":{\"845\":1}}],[\"可视化跨平台网络图形化操作程序\",{\"1\":{\"432\":1}}],[\"可使用策略模式来隐藏与算法相关的数据结构\",{\"1\":{\"792\":1}}],[\"可使用观察者模式松耦合联动双方\",{\"1\":{\"680\":1}}],[\"可读性可维护性就比较差\",{\"1\":{\"991\":1}}],[\"可读性可维护性都比较好\",{\"1\":{\"991\":1}}],[\"可读性太差\",{\"1\":{\"885\":1}}],[\"可读性和可维护性肯定不是太好\",{\"1\":{\"817\":1}}],[\"可读性强\",{\"1\":{\"797\":1}}],[\"可读性\",{\"1\":{\"796\":1,\"797\":1}}],[\"可读性差\",{\"1\":{\"775\":1}}],[\"可读性提高\",{\"1\":{\"717\":1}}],[\"可执行文件实际上就是代码被翻译成操作系统可理解的一组指令\",{\"1\":{\"770\":1}}],[\"可执行文件\",{\"1\":{\"770\":1}}],[\"可测性不友好等问题\",{\"1\":{\"769\":1}}],[\"可乐电视机\",{\"1\":{\"728\":2}}],[\"可动态指定一组对象处理请求\",{\"1\":{\"712\":1}}],[\"可批假的领导有部门负责人\",{\"1\":{\"707\":1}}],[\"可达的所有对象\",{\"1\":{\"689\":1}}],[\"可辅助实现撤销操作\",{\"1\":{\"682\":1}}],[\"可将每个条件分支移入它们各自的策略类中以代替这些条件语句\",{\"1\":{\"792\":1}}],[\"可将每个算法封装到策略类中\",{\"1\":{\"792\":1}}],[\"可将请求沿着这条链传递\",{\"1\":{\"707\":1}}],[\"可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用\",{\"1\":{\"680\":1}}],[\"可将该对象恢复到原先保存的状态\",{\"1\":{\"663\":1}}],[\"可将该语言中的句子表示为一个抽象语法树\",{\"1\":{\"645\":1}}],[\"可将同步通讯转为异步通讯\",{\"1\":{\"414\":1}}],[\"可应用的场景比较少\",{\"1\":{\"641\":1}}],[\"可维护性和可扩展性极差\",{\"1\":{\"871\":1}}],[\"可维护性上都不友好\",{\"1\":{\"816\":1}}],[\"可维护性最有效的手段之一\",{\"1\":{\"808\":1}}],[\"可维护性强\",{\"1\":{\"797\":1}}],[\"可维护性\",{\"1\":{\"719\":1}}],[\"可维护\",{\"1\":{\"614\":1}}],[\"可维护的和高性能负载测试工具\",{\"1\":{\"431\":1}}],[\"可扩展性的本质是找到系统的变化点\",{\"1\":{\"871\":1}}],[\"可扩展性等\",{\"1\":{\"871\":1}}],[\"可扩展性下降\",{\"1\":{\"871\":1}}],[\"可扩展性和可维护性\",{\"1\":{\"748\":1}}],[\"可扩展性\",{\"1\":{\"733\":1,\"796\":1,\"797\":2}}],[\"可扩展性并不是特别好\",{\"1\":{\"613\":1}}],[\"可扩展且测试完备的http应用程序\",{\"1\":{\"434\":1}}],[\"可先设计一个抽象类实现接口\",{\"1\":{\"531\":1}}],[\"可伸缩的网络爬虫\",{\"1\":{\"433\":1}}],[\"可发起\",{\"1\":{\"419\":1}}],[\"可插入式crud\",{\"1\":{\"415\":1}}],[\"可靠性高\",{\"1\":{\"797\":1}}],[\"可靠性\",{\"1\":{\"797\":2}}],[\"可靠的消息代理\",{\"1\":{\"414\":1}}],[\"可靠的大规模数据处理引擎\",{\"1\":{\"413\":1}}],[\"可靠地构建代码\",{\"1\":{\"385\":1}}],[\"可看做现代版lisp的动态类型语言\",{\"1\":{\"411\":1}}],[\"可根据需要构建maven\",{\"1\":{\"401\":1}}],[\"可用性\",{\"1\":{\"871\":1}}],[\"可用性高且没有单点故障\",{\"1\":{\"400\":1}}],[\"可用\",{\"1\":{\"752\":1}}],[\"可用于生产环境的高度可扩展\",{\"1\":{\"433\":1}}],[\"可用于修饰\",{\"1\":{\"227\":1}}],[\"可用来灵活创建意图\",{\"1\":{\"431\":1}}],[\"可用来快速应用开发\",{\"1\":{\"415\":1}}],[\"可通过类名\",{\"1\":{\"302\":1}}],[\"可通过反射去获取注解信息\",{\"1\":{\"228\":1}}],[\"可是一个public的service成员方法或成员变量\",{\"1\":{\"848\":1}}],[\"可是如果是常规的两个方法\",{\"1\":{\"291\":1}}],[\"可是它能直接实现吗\",{\"1\":{\"291\":1}}],[\"可是它里面实际上已经被我们存放了object类型的对象\",{\"1\":{\"290\":1}}],[\"可是类型擦除后\",{\"1\":{\"291\":1}}],[\"可是由于种种原因\",{\"1\":{\"291\":1}}],[\"可是我们发现\",{\"1\":{\"291\":1}}],[\"可是\",{\"1\":{\"290\":1}}],[\"可实际上却不是这样的\",{\"1\":{\"290\":1}}],[\"可能包含多个测试类\",{\"1\":{\"972\":1,\"981\":1}}],[\"可能不需要\",{\"1\":{\"871\":1}}],[\"可能不够灵活\",{\"1\":{\"283\":1}}],[\"可能无法建立新的连接\",{\"1\":{\"870\":1}}],[\"可能抛出因自动拆箱导致的npe异常\",{\"1\":{\"852\":1}}],[\"可能抛出异常的代码\",{\"1\":{\"251\":1}}],[\"可能由于其它方法抛出异常\",{\"1\":{\"851\":1}}],[\"可能导致比较时的意外结果\",{\"1\":{\"849\":1}}],[\"可能导致某些系统有过多的具体命令类\",{\"1\":{\"564\":1}}],[\"可能是需求的改变\",{\"1\":{\"820\":1}}],[\"可能是在你掌控之外的某些事情发生了变化\",{\"1\":{\"820\":1}}],[\"可能是无意识\",{\"1\":{\"734\":2}}],[\"可能并不是完全一致的\",{\"1\":{\"809\":1}}],[\"可能\",{\"1\":{\"752\":1}}],[\"可能造成职责\",{\"1\":{\"716\":1}}],[\"可能造成逻辑过于复杂\",{\"1\":{\"608\":1}}],[\"可能这个系统已经变得非常难以维护和扩展\",{\"1\":{\"603\":1}}],[\"可能产生大量具体的命令类\",{\"1\":{\"560\":1}}],[\"可能会在数据准备或其它前期准备中执行一些相同的命令\",{\"1\":{\"972\":1}}],[\"可能会有参数\",{\"1\":{\"930\":1}}],[\"可能会影响后续业务逻辑和造成内存泄露等问题\",{\"1\":{\"851\":1}}],[\"可能会创建大量的线程\",{\"1\":{\"851\":1}}],[\"可能会堆积大量的请求\",{\"1\":{\"851\":2}}],[\"可能会由于职责链的错误设置而导致系统出错\",{\"1\":{\"707\":1}}],[\"可能会导致需要定义很多具体建造者类来实现这种变化\",{\"1\":{\"557\":1}}],[\"可能会增加系统的复杂性\",{\"1\":{\"518\":1}}],[\"可能会出现异常\",{\"1\":{\"257\":1}}],[\"可能发生异常的结束点\",{\"1\":{\"275\":1}}],[\"可能发生异常的起始点\",{\"1\":{\"275\":1}}],[\"可能存在数字格式错误\",{\"1\":{\"263\":1,\"858\":1}}],[\"可能效果更佳\",{\"1\":{\"94\":1}}],[\"可查异常虽然是异常状况\",{\"1\":{\"249\":1}}],[\"可查异常\",{\"1\":{\"249\":1}}],[\"可查的异常\",{\"0\":{\"249\":1}}],[\"可被保留到何时\",{\"1\":{\"228\":1}}],[\"可变参数必须放置在参数列表的最后\",{\"1\":{\"848\":1}}],[\"可变和适用范围\",{\"1\":{\"192\":1}}],[\"可变\",{\"1\":{\"124\":1}}],[\"可变性\",{\"1\":{\"124\":1}}],[\"可以包装一个真实的\",{\"1\":{\"996\":1}}],[\"可以随时随地地快速运行测试\",{\"1\":{\"990\":1}}],[\"可以随机测试特定代码\",{\"1\":{\"476\":1}}],[\"可以抛出异常\",{\"1\":{\"972\":1}}],[\"可以转换为\",{\"1\":{\"947\":1}}],[\"可以转成\",{\"1\":{\"700\":1}}],[\"可以写在一行的时候\",{\"1\":{\"955\":1}}],[\"可以写在同一行上\",{\"1\":{\"930\":1}}],[\"可以写成块状结构\",{\"0\":{\"920\":1}}],[\"可以写出很简洁的代码\",{\"1\":{\"187\":1}}],[\"可以准确描述每种场景下该如何进行换行\",{\"1\":{\"906\":1}}],[\"可以简洁\",{\"0\":{\"902\":1}}],[\"可以出现一组语句\",{\"1\":{\"901\":1}}],[\"可以定义一个变量来保存版本\",{\"1\":{\"869\":1}}],[\"可以由service层输出的封装业务逻辑的对象\",{\"1\":{\"868\":1,\"873\":1}}],[\"可以向受害者发起钓鱼攻击\",{\"1\":{\"861\":1}}],[\"可以设定自动回滚机制\",{\"1\":{\"860\":1}}],[\"可以设计为\",{\"1\":{\"583\":1}}],[\"可以调大服务器端的限制\",{\"1\":{\"854\":1}}],[\"可以调用\",{\"1\":{\"259\":1,\"311\":1}}],[\"可以省略\",{\"1\":{\"852\":1,\"949\":1}}],[\"可以省掉对空判断\",{\"1\":{\"562\":1}}],[\"可以先交往一段时间看看\",{\"1\":{\"852\":1}}],[\"可以做报表\",{\"1\":{\"840\":1}}],[\"可以做具体的业务逻辑\",{\"1\":{\"111\":1}}],[\"可以选择提前换行\",{\"1\":{\"905\":1}}],[\"可以选择开源许可\",{\"1\":{\"392\":1}}],[\"可以选用访问者模式解决\",{\"1\":{\"837\":1}}],[\"可以明确解决问题所需的抽象概念\",{\"1\":{\"819\":1}}],[\"可以复用类\",{\"1\":{\"819\":1}}],[\"可以应用在很多设计场景中\",{\"1\":{\"818\":1}}],[\"可以制作出不同口味的豆浆\",{\"1\":{\"802\":1}}],[\"可以延迟到子类中实现\",{\"1\":{\"800\":1}}],[\"可以有效提升性能\",{\"1\":{\"859\":1}}],[\"可以有效加快正则匹配速度\",{\"1\":{\"855\":1}}],[\"可以有选择的进行重写\",{\"1\":{\"779\":1}}],[\"可以有一个或多个行为\",{\"1\":{\"776\":1}}],[\"可以抽奖的状态\",{\"1\":{\"778\":1}}],[\"可以抽奖\",{\"1\":{\"777\":1,\"778\":1}}],[\"可以抽取出共性创建过程\",{\"1\":{\"558\":1}}],[\"可以理解为编程语言中的接口或者抽象类\",{\"1\":{\"808\":1}}],[\"可以理解操作系统为进程分配的内存存储区\",{\"1\":{\"770\":1}}],[\"可以理解成是我们气象局的网站\",{\"1\":{\"675\":1}}],[\"可以解决代码复用的问题\",{\"1\":{\"812\":1}}],[\"可以解决单例隐藏类之间依赖关系的问题\",{\"1\":{\"769\":1}}],[\"可以解决这个问题\",{\"1\":{\"478\":1}}],[\"可以优化和共享资源的访问\",{\"1\":{\"750\":1}}],[\"可以避免对资源的多重占用\",{\"1\":{\"750\":1}}],[\"可以提高程序员的思维能力\",{\"1\":{\"797\":1}}],[\"可以提高软件的可维护性\",{\"1\":{\"737\":1}}],[\"可以提高代码的可复用性\",{\"1\":{\"737\":1}}],[\"可以预防外来变更的扩散\",{\"1\":{\"722\":1}}],[\"可以显著降低对其他功能的影响\",{\"1\":{\"717\":1}}],[\"可以动态地改变链内的成员或者调动它们的次序\",{\"1\":{\"707\":1}}],[\"可以动态地扩展其功能\",{\"1\":{\"579\":1}}],[\"可以利用原型模式简化对象的创建过程\",{\"1\":{\"690\":1}}],[\"可以从备忘录对象里获取原来的数据进行恢复操作\",{\"1\":{\"663\":1}}],[\"可以从缓冲池里拿\",{\"1\":{\"629\":1}}],[\"可以这里理解备忘录模式\",{\"1\":{\"663\":1}}],[\"可以这样用\",{\"1\":{\"467\":1}}],[\"可以找\",{\"1\":{\"655\":2}}],[\"可以找到meta\",{\"1\":{\"100\":1}}],[\"可以获取到变量的值\",{\"1\":{\"644\":1}}],[\"可以把这些信息封装到一个对象中\",{\"1\":{\"639\":1}}],[\"可以创建多个不同等级的产品\",{\"1\":{\"616\":1}}],[\"可以创建一个合适的异常类实例并抛出它\",{\"1\":{\"253\":1}}],[\"可以点不同口味的披萨\",{\"1\":{\"613\":1}}],[\"可以决定在什么时候创建哪一个产品的实例\",{\"1\":{\"608\":1}}],[\"可以考虑使用迭代器模式解决\",{\"1\":{\"648\":1}}],[\"可以考虑使用\",{\"1\":{\"603\":1}}],[\"可以考虑下在众多的库中选择一个来帮你生成构建器\",{\"1\":{\"446\":1}}],[\"可以帮我们更好的\",{\"1\":{\"603\":1}}],[\"可以控制类的数量\",{\"1\":{\"583\":1}}],[\"可以实现单例\",{\"1\":{\"759\":1}}],[\"可以实现不同效果\",{\"1\":{\"579\":1}}],[\"可以实现宏命令\",{\"1\":{\"560\":1}}],[\"可以实现与完全使用泛型参数一样的效果\",{\"1\":{\"290\":1}}],[\"可以更加轻松地实现线程唯一单例\",{\"1\":{\"771\":1}}],[\"可以更加精细地控制产品的创建过程\",{\"1\":{\"557\":1}}],[\"可以更好的实现管理操作\",{\"1\":{\"573\":1}}],[\"可以更容易被程序员理解\",{\"1\":{\"209\":1}}],[\"可以减少子类的个数\",{\"1\":{\"544\":1}}],[\"可以充电~~\",{\"1\":{\"524\":1,\"528\":1}}],[\"可以买个多功能转换插头\",{\"1\":{\"521\":1}}],[\"可以完成这个功能并且能够实现更多的东西\",{\"1\":{\"483\":1}}],[\"可以很灵活地配置所调用的方法所产生的行为\",{\"1\":{\"996\":1}}],[\"可以很方便的用\",{\"1\":{\"459\":1}}],[\"可以很好地集成atlassian的其他产品\",{\"1\":{\"392\":1}}],[\"可以很好地与maven依赖管理配合工作\",{\"1\":{\"385\":1}}],[\"可以自动生成这些代码\",{\"1\":{\"445\":1}}],[\"可以一边编程一边听的东西\",{\"1\":{\"439\":1}}],[\"可以处理类似标签\",{\"1\":{\"418\":1}}],[\"可以处理非常高的复杂和大量的用户数\",{\"1\":{\"414\":1}}],[\"可以方便嵌入的消息工具\",{\"1\":{\"414\":1}}],[\"可以集成使用也可以单独使用\",{\"1\":{\"408\":1}}],[\"可以于maven或gradle一起配合使用\",{\"1\":{\"401\":1}}],[\"可以即时重新加载代码与配置的商业软件\",{\"1\":{\"398\":1}}],[\"可以匹敌dagger的轻量级注入框架\",{\"1\":{\"397\":1}}],[\"可以免费试用\",{\"1\":{\"392\":2}}],[\"可以执行minizinc模型\",{\"1\":{\"391\":1}}],[\"可以快速对一个集合进行去重操作\",{\"1\":{\"850\":1}}],[\"可以快速\",{\"1\":{\"385\":1}}],[\"可以过滤指定的方法\",{\"1\":{\"311\":1}}],[\"可以是一个空引用\",{\"1\":{\"996\":1}}],[\"可以是一个类甚至是一整个系统\",{\"1\":{\"994\":1}}],[\"可以是任意修饰符的自动\",{\"1\":{\"307\":1}}],[\"可以是编译时常量\",{\"1\":{\"143\":1}}],[\"可以存储任何类型对象\",{\"1\":{\"290\":1}}],[\"可以指定泛型\",{\"1\":{\"289\":1}}],[\"可以保证资源在使用后被关闭\",{\"1\":{\"258\":1}}],[\"可以保证相同内容的字符串变量引用同一的内存对象\",{\"1\":{\"125\":1}}],[\"可以直接使用一级宏观错误码\",{\"1\":{\"857\":1}}],[\"可以直接使用api\",{\"1\":{\"851\":1}}],[\"可以直接调用pojo的tostring\",{\"1\":{\"848\":1}}],[\"可以直接用try\",{\"1\":{\"258\":1}}],[\"可以直接通过类名来访问它\",{\"1\":{\"144\":1}}],[\"可以对任何具有静态结构和动态行为的系统进行建模\",{\"1\":{\"823\":1}}],[\"可以对类本身使用\",{\"1\":{\"451\":1}}],[\"可以对类或类中的成员\",{\"1\":{\"132\":1}}],[\"可以对包\",{\"1\":{\"220\":1,\"221\":1}}],[\"可以当做\",{\"1\":{\"210\":1}}],[\"可以继承自\",{\"1\":{\"210\":1}}],[\"可以通过独立配置线程池\",{\"1\":{\"870\":1}}],[\"可以通过访问者来定义整个对象结构通用的功能\",{\"1\":{\"837\":1}}],[\"可以通过聚合\",{\"1\":{\"732\":1}}],[\"可以通过代理对象来间接访问\",{\"1\":{\"705\":1}}],[\"可以通过\",{\"1\":{\"692\":1}}],[\"可以通过其子类扩展具体构件的功能\",{\"1\":{\"580\":1}}],[\"可以通过命令模式解耦请求与实现\",{\"1\":{\"565\":1}}],[\"可以通过反射\",{\"1\":{\"298\":1}}],[\"可以通过反射实现\",{\"1\":{\"293\":1}}],[\"可以通过剖析确定哪些模块影响了系统的性能\",{\"1\":{\"209\":1}}],[\"可以通过使用\",{\"1\":{\"134\":1}}],[\"可以独立地开发\",{\"1\":{\"209\":1}}],[\"可以重载\",{\"1\":{\"195\":1}}],[\"可以修饰变量\",{\"1\":{\"182\":1}}],[\"可以\",{\"1\":{\"151\":1,\"162\":1,\"258\":1,\"477\":1}}],[\"可以用一棵语法树来直观地描述语言中的句子\",{\"1\":{\"641\":1}}],[\"可以用于动态加载class对象\",{\"1\":{\"305\":1}}],[\"可以用统一的异常类型向外暴露\",{\"1\":{\"253\":1}}],[\"可以用来检查是否为\",{\"1\":{\"450\":1}}],[\"可以用来编写jvm应用程序的编程语言\",{\"1\":{\"411\":1}}],[\"可以用来创建泛型类的对象\",{\"1\":{\"283\":1}}],[\"可以用来表示任何可以作为异常抛出的类\",{\"1\":{\"146\":1}}],[\"可以用来启用框架扩展和替换组件\",{\"1\":{\"95\":2}}],[\"可以用\",{\"1\":{\"145\":1}}],[\"可以将公用的部分提取出来\",{\"1\":{\"972\":1}}],[\"可以将接口和实现相分离\",{\"1\":{\"808\":1}}],[\"可以将其提取出来并集中到一个公共父类中以避免代码重复\",{\"1\":{\"805\":1}}],[\"可以将已有对象纳入新对象中\",{\"1\":{\"747\":1}}],[\"可以将\",{\"1\":{\"583\":1}}],[\"可以将命令对象存储起来\",{\"1\":{\"565\":1}}],[\"可以将系统中的相关操作抽象成命令\",{\"1\":{\"561\":1}}],[\"可以将每个域都当成\",{\"1\":{\"139\":1}}],[\"可以将原有的一段串行逻辑改写成判断逻辑中的不同分支\",{\"1\":{\"92\":1}}],[\"可以让第三方接入\",{\"1\":{\"675\":1}}],[\"可以让你更快地发现代码中的错误\",{\"1\":{\"484\":1}}],[\"可以让你少写很多样板代码\",{\"1\":{\"476\":1}}],[\"可以让你的用户使用他们喜欢的方式去处理异常\",{\"1\":{\"448\":1}}],[\"可以让编译器帮忙检查是否满足上面的两个限制条件\",{\"1\":{\"135\":1}}],[\"可以让if和else中的语句都能执行\",{\"1\":{\"92\":1}}],[\"可以使用如下方式来避免sum的npe问题\",{\"1\":{\"865\":1}}],[\"可以使用count\",{\"1\":{\"864\":1}}],[\"可以使用warn日志级别来记录用户输入参数错误的情况\",{\"1\":{\"859\":1}}],[\"可以使用try\",{\"1\":{\"858\":1}}],[\"可以使用其他方案比如springbeanutils\",{\"1\":{\"855\":1}}],[\"可以使用instant代替date\",{\"1\":{\"851\":1}}],[\"可以使用访问者模式方便地实现对该类型所有数据结构的不同操作\",{\"1\":{\"841\":1}}],[\"可以使用策略模式\",{\"1\":{\"792\":1}}],[\"可以使用多种策略\",{\"1\":{\"789\":2}}],[\"可以使用深克隆方式保存对象的状态\",{\"1\":{\"682\":1}}],[\"可以使用户能够比较方便地回到某个历史的状态\",{\"1\":{\"668\":1}}],[\"可以使用命令模式来进行设计\",{\"1\":{\"560\":1}}],[\"可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象\",{\"1\":{\"141\":1}}],[\"可以使用\",{\"1\":{\"134\":1,\"145\":3,\"151\":1,\"159\":1,\"997\":1}}],[\"可以使用公有的\",{\"1\":{\"132\":1}}],[\"可以灵活地为一个类添加行为\",{\"1\":{\"133\":1}}],[\"可以在方法前加上这个注解\",{\"1\":{\"972\":1}}],[\"可以在方法级别保持单一职责原则\",{\"1\":{\"719\":1}}],[\"可以在左花括号开始之后立即使用右花括号结束\",{\"1\":{\"902\":1}}],[\"可以在前端输出到type=\",{\"1\":{\"854\":1}}],[\"可以在父类中实现\",{\"1\":{\"800\":1}}],[\"可以在不修改原代码的情况下\",{\"1\":{\"783\":1}}],[\"可以在内存动态的创建对象\",{\"1\":{\"692\":1}}],[\"可以在目标对象实现的基础上\",{\"1\":{\"692\":1}}],[\"可以在类的内部对产品族中相关联的多等级产品共同管理\",{\"1\":{\"616\":1}}],[\"可以在现有命令的基础上\",{\"1\":{\"560\":1}}],[\"可以在二者中间定义一个适配器将二者连接起来\",{\"1\":{\"547\":1}}],[\"可以在\",{\"1\":{\"130\":1,\"917\":1}}],[\"可以在多个线程中安全地使用\",{\"1\":{\"123\":1}}],[\"可以缓存\",{\"1\":{\"123\":1}}],[\"可以发现很多代码甚至类库中都会有捕获异常\",{\"1\":{\"270\":1}}],[\"可以发现\",{\"1\":{\"115\":1}}],[\"可以遍历所有的服务实现者\",{\"1\":{\"114\":1}}],[\"可以确定\",{\"1\":{\"104\":1}}],[\"可以看这篇文章\",{\"1\":{\"241\":1}}],[\"可以看出\",{\"1\":{\"104\":1}}],[\"可以看下截图\",{\"1\":{\"103\":1}}],[\"可以看到黑色的箭头是组合关系\",{\"1\":{\"832\":1}}],[\"可以看到处理器的类型不同\",{\"1\":{\"533\":1}}],[\"可以看到桥方法的参数类型都是object\",{\"1\":{\"291\":1}}],[\"可以看到此时迭代器中有两个驱动\",{\"1\":{\"103\":1}}],[\"可以看到是加载实例化驱动的\",{\"1\":{\"103\":1}}],[\"可以看到输出结果\",{\"1\":{\"96\":1}}],[\"可以根据实际需要\",{\"1\":{\"910\":1}}],[\"可以根据需要增加新的请求处理类\",{\"1\":{\"707\":1}}],[\"可以根据需要进行水平扩展\",{\"1\":{\"414\":1}}],[\"可以根据需要添加其他参数\",{\"1\":{\"283\":1}}],[\"可以根据外部进行进行类型转换\",{\"1\":{\"310\":1}}],[\"可以根据自己的需求定义注解\",{\"1\":{\"221\":1}}],[\"可以根据这个类名进行加载实例化\",{\"1\":{\"95\":1}}],[\"可以根据文件结构将它们转换为不同的页面\",{\"1\":{\"8\":1}}],[\"可以不精致\",{\"1\":{\"36\":1}}],[\"跌打损伤酒一起使用\",{\"1\":{\"94\":1}}],[\"搭配红花油\",{\"1\":{\"94\":1}}],[\"写单元测试的时机不外乎三种情况\",{\"1\":{\"991\":1}}],[\"写法类似于\",{\"1\":{\"911\":2}}],[\"写的是数字的\",{\"1\":{\"846\":1}}],[\"写的最好的部分是\",{\"1\":{\"453\":1}}],[\"写一个静态内部类\",{\"1\":{\"758\":1}}],[\"写入\",{\"1\":{\"164\":1}}],[\"写具体的实现me\",{\"1\":{\"110\":1}}],[\"写出不一样的拉轰代码\",{\"1\":{\"94\":1}}],[\"写作日期为\",{\"1\":{\"32\":1}}],[\"并帮助我们改进设计方案等等\",{\"1\":{\"990\":1}}],[\"并为这个方法注解\",{\"1\":{\"972\":1}}],[\"并为该接口中每个方法提供一个默认实现\",{\"1\":{\"531\":1}}],[\"并能提高质量\",{\"1\":{\"970\":1}}],[\"并增加\",{\"1\":{\"923\":1}}],[\"并需要被\",{\"1\":{\"885\":1}}],[\"并需要表示复杂的处理流程\",{\"1\":{\"871\":1}}],[\"并隔离变化点\",{\"1\":{\"871\":1}}],[\"并针对性地设计降级和应急预案\",{\"1\":{\"871\":1}}],[\"并沉淀成为文档\",{\"1\":{\"871\":1}}],[\"并默认被所有的子项目继承\",{\"1\":{\"869\":1}}],[\"并throw\",{\"1\":{\"868\":1}}],[\"并造成短信平台资源浪费\",{\"1\":{\"861\":1}}],[\"并得到预期的结果\",{\"1\":{\"860\":2}}],[\"并得到相关信息\",{\"1\":{\"675\":1}}],[\"并记得及时删除这些观察日志\",{\"1\":{\"859\":1}}],[\"并记录下来\",{\"1\":{\"591\":1}}],[\"并清晰地说明采用的新接口或者新服务是什么\",{\"1\":{\"848\":1}}],[\"并最终到达框架的过程中\",{\"1\":{\"819\":1}}],[\"并用对应的图形类表示\",{\"1\":{\"827\":1}}],[\"并用它替换掉项目中所有的\",{\"1\":{\"809\":1}}],[\"并用newinstance方法将类实例化\",{\"1\":{\"114\":1}}],[\"并封装为\",{\"1\":{\"809\":2}}],[\"并降低软件的复杂度\",{\"1\":{\"795\":1}}],[\"并改变它\",{\"1\":{\"791\":1}}],[\"并分别封装起来\",{\"1\":{\"783\":1}}],[\"并委派给不同的对象对这些算法进行管理\",{\"1\":{\"783\":1}}],[\"并负责具体状态的切换\",{\"1\":{\"776\":1}}],[\"并负责创建\",{\"1\":{\"750\":1}}],[\"并反序列化成对象\",{\"1\":{\"772\":1}}],[\"并加上有效的javadoc注释\",{\"1\":{\"845\":1}}],[\"并加快对象访问速度\",{\"1\":{\"762\":1}}],[\"并加入到\",{\"1\":{\"677\":1}}],[\"并提示给用户\",{\"1\":{\"858\":1}}],[\"并提供一个抽象的\",{\"1\":{\"739\":1}}],[\"并提高程序健壮性\",{\"1\":{\"244\":1}}],[\"并允许节点自身决定是否进行请求处理或转发\",{\"1\":{\"708\":1}}],[\"并向链头的具体处理者对象提交请求\",{\"1\":{\"708\":1}}],[\"并复制每个引用数据类型成员变量所引用的对象\",{\"1\":{\"689\":1}}],[\"并通知\",{\"1\":{\"678\":1}}],[\"并通过\",{\"1\":{\"999\":1}}],[\"并通过访问命令对象来执行相关请求\",{\"1\":{\"561\":1}}],[\"并通过调用接收者的功能来完成命令要执行的操作\",{\"1\":{\"561\":1}}],[\"并通过组合关系调用实现化角色中的业务方法\",{\"1\":{\"538\":1}}],[\"并由管理者进行管理\",{\"1\":{\"663\":1}}],[\"并在此方法中初始化所有需要测试的参数对\",{\"1\":{\"981\":2}}],[\"并在其中为第二个环节中声明的几个变量赋值\",{\"1\":{\"981\":1}}],[\"并在该对象之外保存这个状态\",{\"1\":{\"663\":1}}],[\"并在保持真实对象的类结构不变的前提下\",{\"1\":{\"580\":1}}],[\"并\",{\"1\":{\"644\":1,\"659\":1}}],[\"并解析\",{\"1\":{\"644\":1}}],[\"并放入到池中\",{\"1\":{\"636\":2}}],[\"并访问具体享元的相关方法\",{\"1\":{\"632\":1}}],[\"并未给出具体的实现代码\",{\"1\":{\"626\":1}}],[\"并直接去调用子系统\",{\"1\":{\"600\":1}}],[\"并使得子系统使用起来更加容易\",{\"1\":{\"593\":1}}],[\"并使用其限定类型\",{\"1\":{\"289\":1}}],[\"并定义一个解释器\",{\"1\":{\"591\":1,\"641\":1}}],[\"并给具体构件对象添加附加的责任\",{\"1\":{\"580\":1}}],[\"并包含具体构件的实例\",{\"1\":{\"580\":1}}],[\"并包含一个对实现化对象的引用\",{\"1\":{\"538\":1}}],[\"并实现\",{\"1\":{\"582\":1,\"739\":1}}],[\"并实现它们的默认行为\",{\"1\":{\"568\":1}}],[\"并实例化\",{\"1\":{\"115\":1}}],[\"并调用对应方法\",{\"1\":{\"562\":2}}],[\"并发修改同一记录时\",{\"1\":{\"851\":1}}],[\"并发处理\",{\"0\":{\"851\":1}}],[\"并发与多线程\",{\"1\":{\"843\":1}}],[\"并发\",{\"0\":{\"514\":1,\"515\":1,\"516\":1}}],[\"并发函数库\",{\"1\":{\"432\":1}}],[\"并可以根据需要增加新的处理方法\",{\"1\":{\"837\":1}}],[\"并可利用web界面进行管理\",{\"1\":{\"414\":1}}],[\"并可用元注解对自定义注解进行注解\",{\"1\":{\"221\":1}}],[\"并基于jvm运行\",{\"1\":{\"411\":1}}],[\"并作用到其他实例身上\",{\"1\":{\"313\":1}}],[\"并存入缓存\",{\"1\":{\"310\":1}}],[\"并重复上面的操作\",{\"1\":{\"275\":1}}],[\"并不实现引入\",{\"1\":{\"869\":1}}],[\"并不能确定哪个方法一定是被优先调用到\",{\"1\":{\"848\":1}}],[\"并不能解决我们之前提到的问题\",{\"1\":{\"769\":1}}],[\"并不会复用已有对象\",{\"1\":{\"848\":1}}],[\"并不推荐使用\",{\"1\":{\"763\":1}}],[\"并不是一种逻辑顺序\",{\"1\":{\"896\":1}}],[\"并不是arraylist本身\",{\"1\":{\"850\":1}}],[\"并不是强制性标准\",{\"1\":{\"823\":1}}],[\"并不是轻量级的\",{\"1\":{\"750\":1}}],[\"并不是要求完全没有依赖关系\",{\"1\":{\"744\":1}}],[\"并不马上返回\",{\"1\":{\"273\":1,\"858\":1}}],[\"并不要求接口和实现接口的类具有\",{\"1\":{\"133\":1}}],[\"并将这组算法封装到一系列的策略类里面\",{\"1\":{\"784\":1}}],[\"并将每个算法封装起来\",{\"1\":{\"783\":1,\"798\":1}}],[\"并将其状态保存起来\",{\"1\":{\"682\":1}}],[\"并将其缓存起来\",{\"1\":{\"310\":1}}],[\"并将接入方\",{\"1\":{\"676\":1}}],[\"并将不太具体的\",{\"1\":{\"267\":1}}],[\"并将它们添加到\",{\"1\":{\"139\":1}}],[\"并与catch语句块逐一匹配\",{\"1\":{\"257\":1}}],[\"并对不同类型的异常做出不同的处理\",{\"1\":{\"256\":1}}],[\"并进行实例化\",{\"1\":{\"114\":1}}],[\"并把实例化后的类缓存到providers对象中\",{\"1\":{\"114\":1}}],[\"并把addr开头的4字节内存空间分两次进复制到addr2的内存空间中\",{\"1\":{\"93\":1}}],[\"并返回一个包装后的新对象\",{\"1\":{\"996\":1}}],[\"并返回\",{\"1\":{\"106\":1,\"619\":1,\"636\":1}}],[\"并建立一个内部模型来记录它所找到的每个插件的信息\",{\"1\":{\"105\":1}}],[\"并且应该被修正为\",{\"1\":{\"958\":1}}],[\"并且删除任何的撇号\",{\"1\":{\"947\":1}}],[\"并且常量的方法是没有副作用的\",{\"1\":{\"942\":1}}],[\"并且每个注解都列在自己的一行上\",{\"1\":{\"928\":1}}],[\"并且该块的左花括号前面有一个换行符\",{\"1\":{\"901\":1}}],[\"并且该类只提供一个取得其对象实例的方法\",{\"1\":{\"750\":1}}],[\"并且强烈反对在字符串和注释之外使用\",{\"1\":{\"885\":1}}],[\"并且焦点顺序需符合自然操作逻辑\",{\"1\":{\"871\":1}}],[\"并且以t1\",{\"1\":{\"865\":1}}],[\"并且操作列在多个表中存在时\",{\"1\":{\"865\":1}}],[\"并且放在索引组合顺序的最后\",{\"1\":{\"864\":1}}],[\"并且远程执行\",{\"1\":{\"861\":1}}],[\"并且非交互式的\",{\"1\":{\"860\":1}}],[\"并且进行网络多机备份\",{\"1\":{\"859\":1}}],[\"并且还会带来url维护不一致的问题\",{\"1\":{\"854\":1}}],[\"并且还需要类型转换\",{\"1\":{\"141\":1}}],[\"并且对超出最大长度的处理逻辑也有差异\",{\"1\":{\"854\":1}}],[\"并且对象的状态大部分可以外部化时\",{\"1\":{\"638\":1}}],[\"并且取反逻辑写法一般都存在对应的正向逻辑写法\",{\"1\":{\"852\":1}}],[\"并且根据外部特征进行分组\",{\"1\":{\"851\":1}}],[\"并且方法前的点号一起换行\",{\"1\":{\"847\":1}}],[\"并且是\",{\"1\":{\"880\":1}}],[\"并且是整个应用的基础常量\",{\"1\":{\"845\":1}}],[\"并且是写死在工厂类代码中的\",{\"1\":{\"622\":1}}],[\"并且能够校验对这个\",{\"1\":{\"996\":1}}],[\"并且能够领会设计模式的精妙和带来的\",{\"1\":{\"794\":1}}],[\"并且能紧随着\",{\"1\":{\"907\":1}}],[\"并且能维护得了\",{\"1\":{\"818\":1}}],[\"并且实现逻辑是一样的\",{\"1\":{\"813\":1}}],[\"并且熟练的写了出来\",{\"1\":{\"794\":1}}],[\"并且发现了一些新的模式挺好用的\",{\"1\":{\"794\":1}}],[\"并且一旦没有处理某个状态\",{\"1\":{\"779\":1}}],[\"并且具备良好的扩展力\",{\"1\":{\"775\":1}}],[\"并且释放对对象的加锁\",{\"1\":{\"772\":1}}],[\"并且将不同之处分离为新的操作\",{\"1\":{\"805\":1}}],[\"并且将不同状态的行为分割开来\",{\"1\":{\"775\":1}}],[\"并且将老进程地址空间的所有内容\",{\"1\":{\"770\":1}}],[\"并且将目标对象传递给代理对象\",{\"1\":{\"703\":1}}],[\"并且父类修改后\",{\"1\":{\"731\":1}}],[\"并且通过拷贝这些原型\",{\"1\":{\"682\":1}}],[\"并且加入到\",{\"1\":{\"659\":2}}],[\"并且有一个统一的二维码\",{\"1\":{\"648\":1}}],[\"并且语言中的句子可以表示为一个抽象语法树的时候\",{\"1\":{\"646\":1}}],[\"并且就是通过工厂方法模式生成对象的\",{\"1\":{\"639\":1}}],[\"并且需要有一个工厂类加以控制\",{\"1\":{\"638\":1}}],[\"并且需要知道\",{\"1\":{\"163\":1}}],[\"并且得到两者的依赖关系\",{\"1\":{\"622\":1}}],[\"并且沿着这条链传递请求\",{\"1\":{\"591\":1}}],[\"并且提供一个全局访问点\",{\"1\":{\"589\":1}}],[\"并且随着扩展功能的增多\",{\"1\":{\"580\":1}}],[\"并且把assertissatisfied\",{\"1\":{\"477\":1}}],[\"并且会被调用\",{\"1\":{\"477\":1}}],[\"并且很容易测试\",{\"1\":{\"470\":1}}],[\"并且不应该以常量的风格命名\",{\"1\":{\"945\":1}}],[\"并且不会随环境的改变而改变\",{\"1\":{\"631\":1}}],[\"并且不用\",{\"1\":{\"469\":1}}],[\"并且不允许定义为\",{\"1\":{\"133\":1}}],[\"并且支持\",{\"1\":{\"460\":1}}],[\"并且支持存储到数据库\",{\"1\":{\"412\":1}}],[\"并且这四种类型的块标签不会与空的描述一起出现\",{\"1\":{\"957\":1}}],[\"并且这些行为在这个类的操作中以多个条件语句的形式出现\",{\"1\":{\"792\":1}}],[\"并且这些分支决定于对象的状态时\",{\"1\":{\"781\":1}}],[\"并且这些第三方\",{\"1\":{\"459\":1}}],[\"并且这个类可以在运行时才加载进来\",{\"1\":{\"145\":1}}],[\"并且可以断言调用这段代码的行为\",{\"1\":{\"477\":1}}],[\"并且可以用忽略的方式来处理打断程序的数据\",{\"1\":{\"466\":1}}],[\"并且可以从异常中恢复\",{\"1\":{\"146\":1}}],[\"并且可读性更强\",{\"1\":{\"466\":1}}],[\"并且可读性更高\",{\"1\":{\"455\":1}}],[\"并且给出你的变量\",{\"1\":{\"454\":1}}],[\"并且它可以追踪方法调用\",{\"1\":{\"996\":1}}],[\"并且它保持最新\",{\"1\":{\"990\":1}}],[\"并且它必须在运行时根据状态改变它的行为时\",{\"1\":{\"781\":1}}],[\"并且它会给你不可变的对象和非常好用的接口\",{\"1\":{\"446\":1}}],[\"并且它只在编译时有效\",{\"1\":{\"223\":1}}],[\"并且更加简单\",{\"1\":{\"444\":1}}],[\"并且type也匹配\",{\"1\":{\"275\":1}}],[\"并且异常符合处理者的from和to节点\",{\"1\":{\"275\":1}}],[\"并且描述抛出异常的场景\",{\"1\":{\"266\":1}}],[\"并且转载这些类的时间开销也越小\",{\"1\":{\"265\":1}}],[\"并且资源可以正常关闭\",{\"1\":{\"264\":1}}],[\"并且在少数情况中可以使用下划线\",{\"1\":{\"937\":1}}],[\"并且在错误信息上带上原有的第三方错误码\",{\"1\":{\"857\":1}}],[\"并且在加锁方法与try代码块之间没有任何可能抛出异常的方法调用\",{\"1\":{\"851\":1}}],[\"并且在需要的情况下进行状态切换\",{\"1\":{\"776\":1}}],[\"并且在需要修改\",{\"1\":{\"209\":1}}],[\"并且在造出的过程添加新的功能\",{\"1\":{\"699\":1,\"702\":1}}],[\"并且在\",{\"1\":{\"211\":1}}],[\"并且在调试的时候可以不影响其他模块\",{\"1\":{\"209\":1}}],[\"并且知道这些变量在运行时不能改变\",{\"1\":{\"183\":1}}],[\"并且从\",{\"1\":{\"133\":1}}],[\"并且\",{\"1\":{\"122\":1,\"291\":1,\"445\":1,\"907\":1}}],[\"并且使用继承自org\",{\"1\":{\"104\":1}}],[\"并且保证最后能够正常执行\",{\"1\":{\"92\":1}}],[\"并找到文件中的实现类的名字\",{\"1\":{\"103\":1}}],[\"并初始化了一个迭代器\",{\"1\":{\"103\":1}}],[\"并没有实现集合的修改方法\",{\"1\":{\"850\":1}}],[\"并没有\",{\"1\":{\"702\":1}}],[\"并没有发挥它的全部潜力\",{\"1\":{\"476\":1}}],[\"并没有退出for循环\",{\"1\":{\"311\":1}}],[\"并没有将实现留给了java\",{\"1\":{\"310\":1}}],[\"并没有涉及到spi的东西\",{\"1\":{\"103\":1}}],[\"并没有具体的实现\",{\"1\":{\"99\":1}}],[\"并添加进相应的实现类内容就好\",{\"1\":{\"96\":1}}],[\"像一个盛东西的器皿\",{\"1\":{\"835\":1}}],[\"像数据库连接池\",{\"1\":{\"629\":1}}],[\"像这样使用\",{\"1\":{\"477\":1}}],[\"像这样\",{\"1\":{\"459\":1,\"471\":1}}],[\"像\",{\"1\":{\"445\":1,\"624\":1}}],[\"像下面这样的代码就可以自动实现线程安全\",{\"1\":{\"469\":1}}],[\"像下面这样绕一个弯子\",{\"1\":{\"93\":1}}],[\"像下面形式的引用传递是不允许的\",{\"1\":{\"290\":1}}],[\"像是文件结构\",{\"1\":{\"105\":1}}],[\"像医生一样\",{\"1\":{\"36\":1}}],[\"来代替它们\",{\"1\":{\"996\":1}}],[\"来编写\",{\"1\":{\"962\":1}}],[\"来编写单元测试\",{\"1\":{\"860\":1}}],[\"来判断是否为null值\",{\"1\":{\"865\":1}}],[\"来替代count\",{\"1\":{\"865\":1}}],[\"来替代继承\",{\"1\":{\"527\":1}}],[\"来保存\",{\"1\":{\"859\":1}}],[\"来保证\",{\"1\":{\"769\":1}}],[\"来表达x小于\",{\"1\":{\"852\":2}}],[\"来表示\",{\"1\":{\"828\":1,\"830\":2,\"831\":1,\"832\":1,\"833\":1,\"834\":1}}],[\"来排查问题时\",{\"1\":{\"851\":1}}],[\"来定义\",{\"1\":{\"845\":1}}],[\"来定义对象的顺序\",{\"1\":{\"178\":1}}],[\"来处理比较方便\",{\"1\":{\"837\":1}}],[\"来提醒你\",{\"1\":{\"972\":1}}],[\"来提高我们软件开发的水平\",{\"1\":{\"823\":1}}],[\"来提供遗留系统的比较清晰简单的接口\",{\"1\":{\"603\":1}}],[\"来具体选择该用继承还是组合\",{\"1\":{\"814\":1}}],[\"来详细讲解一下这条设计原则\",{\"1\":{\"811\":1}}],[\"来存储对象\",{\"1\":{\"771\":1}}],[\"来负责\",{\"1\":{\"769\":1}}],[\"来降低类与类之间的依赖\",{\"1\":{\"748\":1}}],[\"来绘制不同的图形\",{\"1\":{\"738\":2}}],[\"来对不同的采购请求处理\",{\"1\":{\"709\":1}}],[\"来转换字节码并生成新的类\",{\"1\":{\"702\":1}}],[\"来调用\",{\"1\":{\"676\":1,\"678\":2}}],[\"来实现\",{\"1\":{\"655\":1,\"678\":1}}],[\"来管理同事对象\",{\"1\":{\"656\":1}}],[\"来管理具体享元\",{\"1\":{\"632\":1}}],[\"来管理所有用到的外部依赖\",{\"1\":{\"458\":1}}],[\"来区分这两种不同类型的对象\",{\"1\":{\"622\":1}}],[\"来封装对象复杂的创建过程\",{\"1\":{\"620\":1}}],[\"来创建产品\",{\"1\":{\"612\":1}}],[\"来创建对象\",{\"1\":{\"606\":1,\"625\":1,\"627\":1}}],[\"来自百度百科\",{\"1\":{\"989\":1}}],[\"来自官网https\",{\"1\":{\"978\":1}}],[\"来自同一机房的调用\",{\"1\":{\"851\":1}}],[\"来自\",{\"1\":{\"591\":1}}],[\"来自google的构建工具\",{\"1\":{\"385\":1}}],[\"来包裹真实对象\",{\"1\":{\"580\":1}}],[\"来完成\",{\"1\":{\"555\":1}}],[\"来完成这项功能\",{\"1\":{\"291\":1}}],[\"来命名的\",{\"1\":{\"534\":1}}],[\"来进行判断是哪一种子类然后执行\",{\"1\":{\"533\":1}}],[\"来说明注释掉代码的理由\",{\"1\":{\"855\":1}}],[\"来说不是最小接口\",{\"1\":{\"721\":1,\"723\":1}}],[\"来说\",{\"1\":{\"463\":1,\"762\":1}}],[\"来看执行流程\",{\"1\":{\"309\":1}}],[\"来解决了类型擦除和多态的冲突\",{\"1\":{\"291\":1}}],[\"来解析\",{\"1\":{\"11\":1}}],[\"来声明这是一个泛型方法\",{\"1\":{\"283\":1}}],[\"来引用\",{\"1\":{\"211\":1}}],[\"来使用\",{\"1\":{\"210\":1}}],[\"来加载驱动了\",{\"1\":{\"102\":1}}],[\"来加载驱动\",{\"1\":{\"98\":1}}],[\"来在java中操作一把内存\",{\"1\":{\"93\":1}}],[\"釜底抽薪\",{\"0\":{\"93\":1}}],[\"伍\",{\"0\":{\"93\":1}}],[\"让jvm碰到oom场景时输出dump信息\",{\"1\":{\"870\":1}}],[\"让二方库使用者去依赖具体版本号\",{\"1\":{\"869\":1}}],[\"让访问者可以访问\",{\"1\":{\"839\":1}}],[\"让整个系统有效运转\",{\"1\":{\"818\":1}}],[\"让不同的人负责不同的模块\",{\"1\":{\"818\":1}}],[\"让代码结构更加清晰\",{\"1\":{\"818\":1}}],[\"让代码更加清晰\",{\"1\":{\"620\":1}}],[\"让依赖关系变得清晰\",{\"1\":{\"817\":1}}],[\"让我们的焦点不至于过于发散\",{\"1\":{\"816\":1}}],[\"让鸵鸟\",{\"1\":{\"812\":1}}],[\"让麻雀\",{\"1\":{\"812\":1}}],[\"让它抛出\",{\"1\":{\"812\":1}}],[\"让所有子类都会飞了\",{\"1\":{\"788\":1}}],[\"让他们之间可以互相替换\",{\"1\":{\"783\":1}}],[\"让子类去实现即可\",{\"1\":{\"739\":1}}],[\"让子系统内部的模块更易维护和扩展\",{\"1\":{\"603\":1}}],[\"让请求在处理链中能进行传递与被处理\",{\"1\":{\"708\":1}}],[\"让父亲和母亲造出新的对象\",{\"1\":{\"702\":1}}],[\"让一个原型对象克隆自己\",{\"1\":{\"683\":1}}],[\"让\",{\"1\":{\"678\":1}}],[\"让闹钟发出消息\",{\"1\":{\"659\":1}}],[\"让外部代码透明地访问聚合的内部数据\",{\"1\":{\"649\":1}}],[\"让程序具有优秀的扩展性\",{\"1\":{\"840\":1}}],[\"让程序具有更高的效率和扩展性\",{\"1\":{\"687\":1}}],[\"让程序具有良好的扩展性\",{\"1\":{\"645\":1}}],[\"让程序具有搞好的扩展性\",{\"1\":{\"542\":1}}],[\"让应用告知\",{\"1\":{\"622\":1}}],[\"让每个工厂类都不至于过于复杂\",{\"1\":{\"614\":1}}],[\"让各个工厂子类自己实现\",{\"1\":{\"613\":1}}],[\"让新系统与\",{\"1\":{\"603\":1}}],[\"让高层模块可以更加容易地间接调用这些子系统的功能\",{\"1\":{\"593\":1}}],[\"让客户端能够以一种的方式对其进行处理\",{\"1\":{\"590\":1}}],[\"让客户按目标接口的格式访问适配者\",{\"1\":{\"519\":1}}],[\"让对象之间的调用关系更加灵活\",{\"1\":{\"560\":1}}],[\"让抽象部分和实现部分独立开来\",{\"1\":{\"544\":1}}],[\"让原本接口不兼容的类可以兼容\",{\"1\":{\"520\":1}}],[\"让原本因接口不匹配不能一起工作的两个类可以协同工作\",{\"1\":{\"518\":1}}],[\"让你可以用很简单的方法\",{\"1\":{\"466\":1}}],[\"让你的同事迷惑去吧\",{\"1\":{\"92\":1}}],[\"让类库和程序更安全\",{\"1\":{\"260\":1}}],[\"让书籍的知识慢慢渗透\",{\"1\":{\"36\":1}}],[\"用代码处理提供了一个追踪异常的选项\",{\"1\":{\"979\":1}}],[\"用例遗漏\",{\"1\":{\"972\":1}}],[\"用例图\",{\"1\":{\"822\":1}}],[\"用空行去创建字段之间的\",{\"1\":{\"910\":1}}],[\"用explain的结果\",{\"1\":{\"864\":1}}],[\"用主键来对应\",{\"1\":{\"863\":1}}],[\"用词似乎精准\",{\"1\":{\"857\":1}}],[\"用法如下\",{\"1\":{\"854\":1}}],[\"用基本数据类型接收有npe风险\",{\"1\":{\"848\":1}}],[\"用菱形表示\",{\"1\":{\"835\":1}}],[\"用线条连接两个类\",{\"1\":{\"835\":2}}],[\"用组合代替继承\",{\"1\":{\"814\":1}}],[\"用起来也很清晰\",{\"1\":{\"809\":1}}],[\"用设计模式来组织代码显然更好\",{\"1\":{\"797\":1}}],[\"用行为类组合\",{\"1\":{\"791\":1}}],[\"用以封装环境对象中的特定状态所对应的行为\",{\"1\":{\"776\":1}}],[\"用以屏蔽内部子系统的细节\",{\"1\":{\"600\":1}}],[\"用各个不同的类进行表示\",{\"1\":{\"775\":1}}],[\"用静态方法实现一下\",{\"1\":{\"769\":1}}],[\"用实现扩展细节\",{\"1\":{\"736\":1}}],[\"用抽象构建框架\",{\"1\":{\"736\":1}}],[\"用原型实例指定创建对象的种类\",{\"1\":{\"682\":1}}],[\"用原型模式生成对象就很高效\",{\"1\":{\"682\":1}}],[\"用一个调用这些新的操作的模板方法来替换这些不同的代码\",{\"1\":{\"805\":1}}],[\"用一个\",{\"1\":{\"655\":1}}],[\"用一致的方法遍历集合元素\",{\"1\":{\"648\":1}}],[\"用唯一标识码判断\",{\"1\":{\"638\":1}}],[\"用工厂模式来创建究竟有什么好处呢\",{\"1\":{\"606\":1}}],[\"用计算机访问照相机的\",{\"1\":{\"518\":1}}],[\"用直流电的笔记本电脑接交流电源时需要一个电源适配器\",{\"1\":{\"518\":1}}],[\"用户扬声器异常\",{\"1\":{\"874\":1}}],[\"用户听筒异常\",{\"1\":{\"874\":1}}],[\"用户麦克风异常\",{\"1\":{\"874\":1}}],[\"用户相机异常\",{\"1\":{\"874\":1}}],[\"用户相机未授权\",{\"1\":{\"874\":1}}],[\"用户设备异常\",{\"1\":{\"874\":1}}],[\"用户通讯录未授权\",{\"1\":{\"874\":1}}],[\"用户位置信息未授权\",{\"1\":{\"874\":1}}],[\"用户文件未授权\",{\"1\":{\"874\":1}}],[\"用户图片库未授权\",{\"1\":{\"874\":1}}],[\"用户摄像头未授权\",{\"1\":{\"874\":1}}],[\"用户隐私未签署\",{\"1\":{\"874\":1}}],[\"用户隐私未授权\",{\"1\":{\"874\":1}}],[\"用户安装版本已过期\",{\"1\":{\"874\":1}}],[\"用户安装版本过高\",{\"1\":{\"874\":1}}],[\"用户安装版本过低\",{\"1\":{\"857\":1,\"874\":1}}],[\"用户安装版本与系统\",{\"1\":{\"874\":1}}],[\"用户当前版本异常\",{\"1\":{\"874\":1}}],[\"用户上传压缩文件太\",{\"1\":{\"874\":1}}],[\"用户上传视频太大\",{\"1\":{\"874\":1}}],[\"用户上传图片太大\",{\"1\":{\"874\":1}}],[\"用户上传文件太大\",{\"1\":{\"874\":1}}],[\"用户上传文件类型不\",{\"1\":{\"874\":1}}],[\"用户上传文件异常\",{\"1\":{\"874\":1}}],[\"用户配额已用光\",{\"1\":{\"874\":1}}],[\"用户内存空间不足\",{\"1\":{\"874\":1}}],[\"用户磁盘空间不足\",{\"1\":{\"874\":1}}],[\"用户资源异常\",{\"1\":{\"874\":1}}],[\"用户重复请求\",{\"1\":{\"874\":1}}],[\"用户操作请等待\",{\"1\":{\"874\":1}}],[\"用户操作异常\",{\"1\":{\"874\":1}}],[\"用户支付超时\",{\"1\":{\"874\":1}}],[\"用户支付超时等问题\",{\"1\":{\"857\":1}}],[\"用户订单号为空\",{\"1\":{\"874\":1}}],[\"用户请求服务异常\",{\"1\":{\"874\":1}}],[\"用户请求参数错误\",{\"1\":{\"874\":1}}],[\"用户请求传入的任何参数必须做有效性验证\",{\"1\":{\"861\":1}}],[\"用户签名异常\",{\"1\":{\"874\":1}}],[\"用户访问被拦截\",{\"1\":{\"874\":1}}],[\"用户访问虚拟硬盘时实际访问的是网盘空间\",{\"1\":{\"705\":1}}],[\"用户授权申请被拒\",{\"1\":{\"874\":1}}],[\"用户验证码尝试次数\",{\"1\":{\"874\":1}}],[\"用户验证码错误\",{\"1\":{\"874\":1}}],[\"用户登录已过期\",{\"1\":{\"874\":1}}],[\"用户登录异常\",{\"1\":{\"874\":1}}],[\"用户未获得第三方登\",{\"1\":{\"874\":1}}],[\"用户未同意隐私协议\",{\"1\":{\"874\":1}}],[\"用户面容识别失败\",{\"1\":{\"874\":1}}],[\"用户指纹识别失败\",{\"1\":{\"874\":1}}],[\"用户身份校验失败\",{\"1\":{\"874\":1}}],[\"用户密码错误\",{\"1\":{\"874\":1}}],[\"用户账户已作废\",{\"1\":{\"874\":1}}],[\"用户账户被冻结\",{\"1\":{\"874\":1}}],[\"用户账户不存在\",{\"1\":{\"874\":1}}],[\"用户基本信息校验失\",{\"1\":{\"874\":1}}],[\"用户证件类型未选择\",{\"1\":{\"874\":1}}],[\"用户证件异常\",{\"1\":{\"874\":1}}],[\"用户名包含特殊字符\",{\"1\":{\"874\":1}}],[\"用户名包含敏感词\",{\"1\":{\"874\":1}}],[\"用户名已存在\",{\"1\":{\"874\":1}}],[\"用户名校验失败\",{\"1\":{\"874\":1}}],[\"用户注册错误\",{\"1\":{\"874\":1}}],[\"用户注册的场景中\",{\"1\":{\"858\":1}}],[\"用户输入内容非法\",{\"1\":{\"874\":1}}],[\"用户输入密码错误次\",{\"1\":{\"874\":1}}],[\"用户输入的sql参数严格使用参数绑定或者metadata字段值限定\",{\"1\":{\"861\":1}}],[\"用户输入参数的小于\",{\"1\":{\"854\":1}}],[\"用户敏感数据禁止直接展示\",{\"1\":{\"861\":1}}],[\"用户端错误\",{\"1\":{\"857\":1,\"874\":1}}],[\"用户\",{\"1\":{\"854\":1,\"874\":5}}],[\"用户提示信息四个部分\",{\"1\":{\"854\":1}}],[\"用户申请某些网盘空间时\",{\"1\":{\"705\":1}}],[\"用户只需要知道具体工厂的名称就可得到所要的产品\",{\"1\":{\"612\":1}}],[\"用户可以用统一的接口使用组合结构中的所有对象的场合\",{\"1\":{\"577\":1}}],[\"用户使用不同的具体建造者即可得到不同的产品对象\",{\"1\":{\"557\":1}}],[\"用户不需要知道内部的具体构建细节\",{\"1\":{\"549\":1}}],[\"用户收到反馈结果\",{\"1\":{\"520\":1}}],[\"用户调用适配器转化出来的目标接口方法\",{\"1\":{\"520\":1}}],[\"用户手册\",{\"1\":{\"467\":1}}],[\"用户无需知道对象内部的细节\",{\"1\":{\"209\":1}}],[\"用作数据挖掘的算法集合\",{\"1\":{\"413\":1}}],[\"用作大数据统计的分析引擎\",{\"1\":{\"413\":1}}],[\"用简单的脚本就能设置pipeline\",{\"1\":{\"392\":1}}],[\"用几句话总结反射的实现原理\",{\"1\":{\"313\":1}}],[\"用别的数据进行计算\",{\"1\":{\"260\":1}}],[\"用\",{\"1\":{\"256\":1,\"623\":1,\"638\":1,\"702\":2,\"972\":1}}],[\"用在方法签名中\",{\"1\":{\"251\":1}}],[\"用在方法签名上\",{\"1\":{\"196\":1}}],[\"用反射接口获取注解信息\",{\"1\":{\"234\":1}}],[\"用定义好的三个注解类分别去注解一个方法\",{\"1\":{\"228\":1}}],[\"用这个引用调用泛型方法\",{\"1\":{\"290\":1}}],[\"用这些注解标明后编译器就会进行检查\",{\"1\":{\"221\":1}}],[\"用这种方式把一段整体的逻辑拆成两块\",{\"1\":{\"92\":1}}],[\"用于模拟实际的对象\",{\"1\":{\"996\":1}}],[\"用于使用参数化功能\",{\"1\":{\"972\":1}}],[\"用于兼容junit3\",{\"1\":{\"972\":1,\"981\":1}}],[\"用于编写和运行测试\",{\"1\":{\"970\":1}}],[\"用于编写和运行可重复的自动化测试\",{\"1\":{\"968\":1,\"969\":1}}],[\"用于确认被测试的代码确实抛出了预期类型的异常\",{\"1\":{\"950\":1}}],[\"用于产生小驼峰形式\",{\"1\":{\"947\":1}}],[\"用于产生大驼峰形式\",{\"1\":{\"947\":1}}],[\"用于分隔命名上的逻辑组件\",{\"1\":{\"941\":1}}],[\"用于分析网站内容的函数库\",{\"1\":{\"433\":1}}],[\"用于参数和局部变量的注解没有特定的格式化规则\",{\"1\":{\"931\":1}}],[\"用于参数和局部变量的注解\",{\"0\":{\"931\":1}}],[\"用于字段的注解也出现在文档之后\",{\"1\":{\"930\":1}}],[\"用于字段的注解\",{\"0\":{\"930\":1}}],[\"用于方法和构造方法的注解的使用规则与\",{\"1\":{\"929\":1}}],[\"用于方法和构造方法的注解\",{\"0\":{\"929\":1}}],[\"用于类的注解出现在文档之后\",{\"1\":{\"928\":1}}],[\"用于类的注解\",{\"0\":{\"928\":1}}],[\"用于类型的注解出现在被标记的类型之前\",{\"1\":{\"927\":1}}],[\"用于类型的注解\",{\"0\":{\"927\":1}}],[\"用于登录校验和请求拦截的验证码均需提供图形验证以外的其它方式\",{\"1\":{\"871\":1}}],[\"用于表示一类对象与另一类对象之间的联系\",{\"1\":{\"830\":1}}],[\"用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务\",{\"1\":{\"798\":1}}],[\"用于描述如何将类或对象按某种布局组成更大的结构\",{\"1\":{\"798\":1}}],[\"用于描述\",{\"1\":{\"798\":1}}],[\"用于创建相关或有依赖关系的对象簇\",{\"1\":{\"616\":1}}],[\"用于继承和实现抽象构件\",{\"1\":{\"568\":1}}],[\"用于继承或实现抽象构件\",{\"1\":{\"568\":1}}],[\"用于撤销\",{\"1\":{\"562\":2}}],[\"用于初始化每个按钮\",{\"1\":{\"562\":1}}],[\"用于构建快速\",{\"1\":{\"434\":1}}],[\"用于处理一些测试后续工作\",{\"1\":{\"972\":1}}],[\"用于处理web应用程序不同层次间通讯的框架\",{\"1\":{\"434\":1}}],[\"用于处理安全\",{\"1\":{\"427\":1}}],[\"用于搜索和分析\",{\"1\":{\"426\":1}}],[\"用于科学计算\",{\"1\":{\"425\":1}}],[\"用于科学计算和分析的函数库\",{\"1\":{\"425\":1}}],[\"用于商业用途时需要许可证\",{\"1\":{\"421\":1}}],[\"用于长时间运行服务和定时任务\",{\"1\":{\"387\":1}}],[\"用于设置字段的值\",{\"1\":{\"307\":1}}],[\"用于声明该方法可能抛出的异常\",{\"1\":{\"251\":1}}],[\"用于抛出异常\",{\"1\":{\"251\":1}}],[\"用于捕获异常\",{\"1\":{\"251\":1}}],[\"用于监听\",{\"1\":{\"251\":1}}],[\"用于controller层注解\",{\"1\":{\"242\":1}}],[\"用于对代码进行说明\",{\"1\":{\"220\":1,\"221\":1}}],[\"用于检测包住的语句块\",{\"1\":{\"196\":1}}],[\"用于引用类型的比较时\",{\"1\":{\"191\":1}}],[\"用于基本类型的变量比较时\",{\"1\":{\"191\":1}}],[\"用于泛型推断\",{\"1\":{\"186\":1}}],[\"用于一些工具在编译\",{\"1\":{\"148\":1}}],[\"用于修饰成员\",{\"1\":{\"132\":1}}],[\"用于新的服务提供者安装到正在运行的java虚拟机中的情况\",{\"1\":{\"114\":1}}],[\"用做\",{\"1\":{\"123\":1}}],[\"用来确定这个类怎么运行的\",{\"1\":{\"972\":1,\"981\":1}}],[\"用来存储代码和数据\",{\"1\":{\"770\":1}}],[\"用来实现文法中与非终结符相关的操作\",{\"1\":{\"642\":1}}],[\"用来实现文法中与终结符相关的操作\",{\"1\":{\"642\":1}}],[\"用来实现一个接口\",{\"1\":{\"214\":1}}],[\"用来生产同一等级结构中的固定产品\",{\"1\":{\"606\":1}}],[\"用来生产同一等级结构中的任意产品\",{\"1\":{\"606\":1}}],[\"用来访问子系统中的一群接口\",{\"1\":{\"600\":1}}],[\"用来像不戴套做爱那么爽的工具\",{\"1\":{\"480\":1}}],[\"用来模拟静态\",{\"1\":{\"431\":1}}],[\"用来同步异步操作的dsl\",{\"1\":{\"431\":1}}],[\"用来部署应用程序的服务器\",{\"1\":{\"429\":1}}],[\"用来高效处理序列化的函数库\",{\"1\":{\"428\":1}}],[\"用来进行科学测量和单位的一组类\",{\"1\":{\"425\":1}}],[\"用来进行特定平台开发的原生开发库\",{\"1\":{\"417\":1}}],[\"用来构建web应用程序\",{\"1\":{\"424\":1}}],[\"用来开发响应式应用程序的开发库\",{\"1\":{\"423\":1}}],[\"用来编写稳定且可读的ui测试\",{\"1\":{\"431\":1}}],[\"用来编写分布式容错并发事件驱动应用程序的工具和运行时\",{\"1\":{\"399\":1}}],[\"用来编写分布式容错应用的开发库和框架\",{\"1\":{\"399\":1}}],[\"用来编程创建pdf文件\",{\"1\":{\"421\":1}}],[\"用来创建复杂的复合对象\",{\"1\":{\"589\":1}}],[\"用来创建restful\",{\"1\":{\"424\":1}}],[\"用来创建和操作pdf的工具集\",{\"1\":{\"421\":1}}],[\"用来创建解析器\",{\"1\":{\"389\":1}}],[\"用来帮助创建pdf文件的资源\",{\"1\":{\"421\":1}}],[\"用来专门处理文本的函数库\",{\"1\":{\"418\":1}}],[\"用来处理混乱数据的工具\",{\"1\":{\"415\":1}}],[\"用来辅助面向组合开发\",{\"1\":{\"403\":1}}],[\"用来捕获处理一个潜在的空指针异常\",{\"1\":{\"275\":1}}],[\"用来描述继承关系\",{\"1\":{\"213\":1}}],[\"用来表示类之间的\",{\"1\":{\"812\":1}}],[\"用来表示部分以及整体层次\",{\"1\":{\"567\":1}}],[\"用来表示\",{\"1\":{\"146\":1}}],[\"用来获取数据库连接\",{\"1\":{\"103\":1}}],[\"用来掩人耳目了\",{\"1\":{\"89\":1}}],[\"用unsafe搞起来也是信手拈来\",{\"1\":{\"93\":1}}],[\"惊不惊喜\",{\"1\":{\"92\":1}}],[\"运用共享技术来有效地支持大量细粒度对象的复用\",{\"1\":{\"798\":1}}],[\"运用共享技术有效地支持大量细粒度的对象\",{\"1\":{\"629\":1}}],[\"运筹帷幄之中\",{\"1\":{\"591\":1}}],[\"运算符的优先级表\",{\"1\":{\"913\":1}}],[\"运算符的左右必须有一个空格\",{\"1\":{\"847\":1}}],[\"运算符与下文一起换行\",{\"1\":{\"847\":1}}],[\"运算符可以执行隐式类型转换\",{\"1\":{\"129\":1}}],[\"运算结果\",{\"1\":{\"643\":1,\"644\":1}}],[\"运算\",{\"0\":{\"126\":1}}],[\"运行而添加的对象\",{\"1\":{\"996\":1}}],[\"运行一次\",{\"1\":{\"972\":1}}],[\"运行一次这个方法\",{\"1\":{\"972\":1}}],[\"运行结果\",{\"1\":{\"276\":1}}],[\"运行期保留\",{\"1\":{\"228\":1}}],[\"运行时类型识别\",{\"1\":{\"301\":1}}],[\"运行时想办法\",{\"1\":{\"295\":1}}],[\"运行时潜在的风险需要我们自己来承担\",{\"1\":{\"295\":1}}],[\"运行时会把对象当做a的实例看待\",{\"1\":{\"284\":1}}],[\"运行时通过代码里标识的元数据动态处理\",{\"1\":{\"221\":1}}],[\"运行时动态处理\",{\"1\":{\"221\":1}}],[\"运行时多态有三个条件\",{\"1\":{\"211\":1}}],[\"运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定\",{\"1\":{\"211\":1}}],[\"运行时异常等场景返回null的情况\",{\"1\":{\"858\":1}}],[\"运行时异常的特点是java编译器不会检查它\",{\"1\":{\"248\":1}}],[\"运行时异常和编译时异常\",{\"1\":{\"248\":1}}],[\"运行时异常\",{\"1\":{\"198\":1,\"248\":1,\"850\":1}}],[\"运行时进行解析和使用\",{\"1\":{\"148\":1}}],[\"运行时常量池\",{\"1\":{\"125\":2}}],[\"运行后控制台打印了\",{\"1\":{\"92\":1}}],[\"运动是治愈一切的良药\",{\"1\":{\"36\":1}}],[\"判断表达式\",{\"1\":{\"872\":1}}],[\"判断剩余奖品数量等于\",{\"1\":{\"852\":1}}],[\"判断作为中断或退出的条件\",{\"1\":{\"852\":1}}],[\"判断所有集合内部的元素是否为空\",{\"1\":{\"850\":1}}],[\"判断订单的状态\",{\"1\":{\"779\":1}}],[\"判断逻辑\",{\"1\":{\"775\":2}}],[\"判断语句块\",{\"1\":{\"754\":1}}],[\"判断能否处理本次请求\",{\"1\":{\"708\":1}}],[\"判断\",{\"1\":{\"650\":1,\"757\":1}}],[\"判断是否还有下一个元素\",{\"1\":{\"650\":1}}],[\"判断方法是否带可变参数\",{\"1\":{\"308\":1}}],[\"判断class对象是否是表示一个接口\",{\"1\":{\"305\":1}}],[\"判断该程序元素上是否包含指定类型的注解\",{\"1\":{\"233\":1}}],[\"判断每个关键域是否相等\",{\"1\":{\"138\":1}}],[\"判断引用的对象是否等价\",{\"1\":{\"138\":1}}],[\"判断两个变量是否引用同一个对象\",{\"1\":{\"138\":1}}],[\"判断两个值是否相等\",{\"1\":{\"138\":1}}],[\"判断条件\",{\"1\":{\"92\":1}}],[\"判断一个int型数字的正负时明明可以写成这样\",{\"1\":{\"90\":1}}],[\"有哪些单元测试相关的概念\",{\"0\":{\"993\":1}}],[\"有差别\",{\"1\":{\"975\":1}}],[\"有且仅有一个顶级类的声明\",{\"0\":{\"895\":1}}],[\"有且只有一个的顶级\",{\"1\":{\"886\":1}}],[\"有且不可变\",{\"1\":{\"872\":1}}],[\"有缺陷的底层数据结构容易导致系统风险上升\",{\"1\":{\"871\":1}}],[\"有依赖\",{\"1\":{\"860\":1}}],[\"有依赖关系的类之间\",{\"1\":{\"818\":1}}],[\"有选择地输出info日志\",{\"1\":{\"859\":1}}],[\"有异常也要做try\",{\"1\":{\"858\":1}}],[\"有序性是指遍历的结果是按某种比较规则依次排列的\",{\"1\":{\"850\":1}}],[\"有效数字+指数\",{\"1\":{\"848\":1}}],[\"有效地调节性能\",{\"1\":{\"209\":1}}],[\"有义务去考证过时方法的新实现是什么\",{\"1\":{\"848\":1}}],[\"有经验的开发者都会尽量选择支持未来任何可能变更的方式\",{\"1\":{\"820\":1}}],[\"有关这一部分的内容\",{\"1\":{\"818\":1}}],[\"有关组织或者公司定义标准\",{\"1\":{\"108\":1}}],[\"有各种鸭子\",{\"1\":{\"785\":1}}],[\"有流程图来决定\",{\"1\":{\"779\":1}}],[\"有审核\",{\"1\":{\"779\":1}}],[\"有利于扩展与维护\",{\"1\":{\"871\":1}}],[\"有利于维护和各个类的日志处理方式统一\",{\"1\":{\"859\":1}}],[\"有利于向前兼容\",{\"1\":{\"854\":1}}],[\"有利于代码阅读时重点关注\",{\"1\":{\"852\":1}}],[\"有利于阅读者快速理解架构设计思想\",{\"1\":{\"845\":1}}],[\"有利于程序的扩展\",{\"1\":{\"775\":1}}],[\"有利于系统的解耦\",{\"1\":{\"549\":1}}],[\"有何替代解决方案\",{\"0\":{\"769\":1}}],[\"有助于精确定位问题\",{\"1\":{\"860\":1}}],[\"有助于\",{\"1\":{\"741\":1}}],[\"有助于后面实现多态机制\",{\"1\":{\"189\":1}}],[\"有校长审批\",{\"1\":{\"709\":1}}],[\"有\",{\"1\":{\"679\":1,\"996\":1}}],[\"有观察者来实现\",{\"1\":{\"678\":1}}],[\"有数组\",{\"1\":{\"648\":1}}],[\"有客户希望以微信公众号的形式发布\",{\"1\":{\"633\":1}}],[\"有客户人要求以博客的形式发布\",{\"1\":{\"633\":1}}],[\"有客户要求以新闻的形式发布\",{\"1\":{\"633\":1}}],[\"有些正则写法验证普通用户输入没有问题\",{\"1\":{\"861\":1}}],[\"有些数值会产生精度损失\",{\"1\":{\"854\":1}}],[\"有些集合对象存在多种不同的元素\",{\"1\":{\"837\":1}}],[\"有些\",{\"1\":{\"835\":1}}],[\"有些人认为单例是一种反模式\",{\"1\":{\"763\":1}}],[\"有些人早餐可能会吃煎饼\",{\"1\":{\"579\":1}}],[\"有些书也将\",{\"1\":{\"702\":1}}],[\"有些现代的jvm实现会将它们优化掉\",{\"1\":{\"263\":1}}],[\"有照明灯\",{\"1\":{\"562\":1}}],[\"有多重实现方式\",{\"1\":{\"533\":1}}],[\"有多慢\",{\"1\":{\"276\":1}}],[\"有几种方法可以获取到\",{\"1\":{\"485\":1}}],[\"有两大主要阵营\",{\"1\":{\"472\":1}}],[\"有两个子类\",{\"1\":{\"211\":1}}],[\"有一定的性能损耗\",{\"1\":{\"859\":1}}],[\"有一定局限性\",{\"1\":{\"525\":1}}],[\"有一套标准来描述设计\",{\"1\":{\"823\":1}}],[\"有一条非常经典的设计原则\",{\"1\":{\"811\":1}}],[\"有一些\",{\"1\":{\"469\":1}}],[\"有一个学校\",{\"1\":{\"742\":1}}],[\"有一个原则为优先使用组合\",{\"1\":{\"545\":1}}],[\"有一个自己的项目\",{\"1\":{\"458\":1}}],[\"有一个不相等则返回false\",{\"1\":{\"310\":1}}],[\"有一个稳定\",{\"1\":{\"187\":1}}],[\"有fileutils\",{\"1\":{\"465\":1}}],[\"有许多关于字符串的操作和创建\",{\"1\":{\"465\":1}}],[\"有很长时间的编程经验\",{\"1\":{\"794\":1}}],[\"有很多内容文字是无法表达的\",{\"1\":{\"823\":1}}],[\"有很多\",{\"1\":{\"473\":1}}],[\"有很多的使用示例\",{\"1\":{\"467\":1}}],[\"有很多不错的替代工具\",{\"1\":{\"458\":1}}],[\"有很多不同的情况需要考虑\",{\"1\":{\"262\":1}}],[\"有很棒的\",{\"1\":{\"455\":1}}],[\"有如\",{\"1\":{\"450\":1}}],[\"有基于代码的和基于\",{\"1\":{\"449\":1}}],[\"有常见的\",{\"1\":{\"447\":1}}],[\"有影响力的书\",{\"0\":{\"438\":1}}],[\"有免费版\",{\"1\":{\"392\":1}}],[\"有时会面临要创建大量相同或相似对象实例的问题\",{\"1\":{\"629\":1}}],[\"有时要同多个部门联系\",{\"1\":{\"593\":1}}],[\"有时想用一些现存的组件\",{\"1\":{\"579\":1}}],[\"有时桥接\",{\"1\":{\"547\":1}}],[\"有时候我们想暂时不运行某些测试方法\",{\"1\":{\"972\":1}}],[\"有时候我们不想实现\",{\"1\":{\"532\":1}}],[\"有时候会有多种合理的方式用于将英语短语转换为驼峰形式\",{\"1\":{\"947\":1}}],[\"有时候可能用了就可以卸载了\",{\"1\":{\"312\":1}}],[\"有时我们会从\",{\"1\":{\"253\":1}}],[\"有限制类型擦除\",{\"1\":{\"287\":1}}],[\"有三条数据\",{\"1\":{\"275\":1}}],[\"有三种存在方式\",{\"0\":{\"199\":1}}],[\"有的时候\",{\"1\":{\"814\":1}}],[\"有的书上说\",{\"1\":{\"619\":1}}],[\"有的是由java虚拟机自动进行捕获处理\",{\"1\":{\"261\":1}}],[\"有的需要程序员进行捕获处理或声明抛出\",{\"1\":{\"261\":1}}],[\"有别于junit3的使用\",{\"1\":{\"241\":1}}],[\"有什么关系\",{\"0\":{\"181\":1}}],[\"有什么用\",{\"0\":{\"181\":1}}],[\"有什么区别\",{\"0\":{\"180\":1}}],[\"有什么不同\",{\"0\":{\"178\":1}}],[\"有可能造成事故\",{\"1\":{\"865\":1}}],[\"有可能造成系统创建大量同类线程而导致消耗完内存或者\",{\"1\":{\"851\":1}}],[\"有可能导致死循环的结果\",{\"1\":{\"861\":1}}],[\"有可能是try部分\",{\"1\":{\"275\":1}}],[\"有可能\",{\"1\":{\"175\":1}}],[\"有没有做过同时使用\",{\"1\":{\"473\":1}}],[\"有没有可能两个不相等的对象有相同的\",{\"0\":{\"175\":1}}],[\"有没有一种方法\",{\"1\":{\"92\":1}}],[\"有永久代\",{\"1\":{\"125\":2}}],[\"有人居然会在注释里下了毒\",{\"1\":{\"89\":1}}],[\"接单有人支付失效\",{\"1\":{\"779\":1}}],[\"接单\",{\"1\":{\"779\":1}}],[\"接入方的\",{\"1\":{\"678\":1}}],[\"接入方\",{\"1\":{\"678\":1}}],[\"接住异常\",{\"1\":{\"276\":1}}],[\"接住一个异常对象\",{\"1\":{\"276\":1}}],[\"接收接口\",{\"1\":{\"728\":1}}],[\"接收到一个采购请求后\",{\"1\":{\"709\":1}}],[\"接收消息\",{\"1\":{\"659\":1,\"727\":1}}],[\"接收方与抽象命令呈现弱耦合\",{\"1\":{\"565\":1}}],[\"接收者元素\",{\"1\":{\"838\":2}}],[\"接收者的action\",{\"1\":{\"561\":1}}],[\"接收者\",{\"1\":{\"561\":2}}],[\"接收泛型数组\",{\"1\":{\"285\":1}}],[\"接收可变参数\",{\"1\":{\"285\":1}}],[\"接收\",{\"1\":{\"159\":1,\"738\":2,\"739\":1}}],[\"接口名可能也是名词或名词短语\",{\"1\":{\"940\":1}}],[\"接口或\",{\"1\":{\"877\":1}}],[\"接口或抽象类\",{\"1\":{\"725\":1}}],[\"接口不存在\",{\"1\":{\"874\":1}}],[\"接口提供方既然明确是过时接口\",{\"1\":{\"848\":1}}],[\"接口过时必须加\",{\"1\":{\"848\":1}}],[\"接口基础常量string\",{\"1\":{\"845\":1}}],[\"接口类中的方法和属性不要加任何修饰符号\",{\"1\":{\"845\":1}}],[\"接口使用一个带有名称的小圆圈来进行表示\",{\"1\":{\"825\":1}}],[\"接口表示具有某种行为特性\",{\"1\":{\"813\":1}}],[\"接口满天飞\",{\"1\":{\"810\":1}}],[\"接口意识\",{\"1\":{\"809\":1}}],[\"接口语法\",{\"1\":{\"808\":1}}],[\"接口有扣除积分方法\",{\"1\":{\"778\":1}}],[\"接口要精简单一\",{\"1\":{\"748\":1}}],[\"接口传递\",{\"1\":{\"728\":1}}],[\"接口就好了\",{\"1\":{\"727\":1}}],[\"接口隔离\",{\"1\":{\"741\":1}}],[\"接口隔离提高了系统的内聚性\",{\"1\":{\"722\":1}}],[\"接口隔离原则是为了约束接口\",{\"1\":{\"722\":1}}],[\"接口隔离原则的优点\",{\"0\":{\"722\":1}}],[\"接口隔离原则主要约束接口\",{\"1\":{\"721\":1}}],[\"接口隔离原则和单一职责都是为了提高类的内聚性\",{\"1\":{\"721\":1}}],[\"接口隔离原则\",{\"0\":{\"720\":1},\"1\":{\"714\":1,\"721\":1,\"748\":2}}],[\"接口里的方法不应该囤积许多类需要的不同方法\",{\"1\":{\"721\":1}}],[\"接口代理\",{\"1\":{\"692\":1,\"698\":1}}],[\"接口系统提供\",{\"1\":{\"651\":1}}],[\"接口和方法\",{\"1\":{\"853\":1}}],[\"接口和方法中\",{\"1\":{\"279\":1}}],[\"接口和实现类的命名有两套规则\",{\"1\":{\"845\":1}}],[\"接口和\",{\"1\":{\"626\":1}}],[\"接口定义了多个\",{\"1\":{\"556\":1}}],[\"接口适配器\",{\"1\":{\"534\":1}}],[\"接口适配器模式应用实例\",{\"0\":{\"532\":1}}],[\"接口适配器模式介绍\",{\"0\":{\"531\":1}}],[\"接口适配器模式\",{\"0\":{\"530\":1},\"1\":{\"518\":1}}],[\"接口方法定义public\",{\"1\":{\"845\":1}}],[\"接口方法签名void\",{\"1\":{\"845\":1}}],[\"接口方法\",{\"1\":{\"532\":1,\"556\":1}}],[\"接口方法在jdk8之前只有public\",{\"1\":{\"194\":1}}],[\"接口在jdk8之前不能有静态方法\",{\"1\":{\"194\":1}}],[\"接口在jdk8之前都是抽象方法\",{\"1\":{\"194\":1}}],[\"接口只声明方法\",{\"1\":{\"813\":1}}],[\"接口只能public\",{\"1\":{\"194\":1}}],[\"接口只是规定\",{\"1\":{\"141\":1}}],[\"接口没有普通成员变量\",{\"1\":{\"194\":1}}],[\"接口没有构造方法\",{\"1\":{\"194\":1}}],[\"接口与抽象类\",{\"0\":{\"194\":1}}],[\"接口用于定义\",{\"1\":{\"188\":1}}],[\"接口用于定义对象的自然顺序\",{\"1\":{\"178\":1}}],[\"接口中获取商品价格数据\",{\"1\":{\"996\":1}}],[\"接口中不允许普通方法\",{\"1\":{\"188\":1}}],[\"接口中可以有静态\",{\"1\":{\"187\":1}}],[\"接口中的\",{\"1\":{\"133\":1}}],[\"接口是所有程序元素\",{\"1\":{\"233\":1}}],[\"接口是什么\",{\"0\":{\"188\":1}}],[\"接口是一个序列化\",{\"1\":{\"185\":1}}],[\"接口是抽象类的延伸\",{\"1\":{\"133\":1}}],[\"接口又调用了\",{\"1\":{\"141\":1}}],[\"接口也可以有默认的方法实现\",{\"1\":{\"133\":1}}],[\"接口也可以拥有默认的方法实现\",{\"1\":{\"133\":1}}],[\"接口优先于抽象类\",{\"1\":{\"133\":1}}],[\"接口的定义只表明做什么\",{\"1\":{\"809\":1}}],[\"接口的所有方法\",{\"1\":{\"779\":1}}],[\"接口的对象\",{\"1\":{\"550\":1,\"563\":1}}],[\"接口的全部方法\",{\"1\":{\"532\":1}}],[\"接口的类\",{\"1\":{\"259\":1}}],[\"接口的方法\",{\"1\":{\"141\":1}}],[\"接口的字段只能是\",{\"1\":{\"133\":1}}],[\"接口的字段默认都是\",{\"1\":{\"133\":1}}],[\"接口的成员只能是\",{\"1\":{\"133\":1}}],[\"接口的成员\",{\"1\":{\"133\":1}}],[\"接口的实现由provider实现\",{\"1\":{\"96\":1}}],[\"接口\",{\"0\":{\"808\":1,\"825\":1},\"1\":{\"113\":2,\"133\":1,\"141\":1,\"187\":1,\"188\":1,\"220\":1,\"221\":1,\"227\":2,\"236\":1,\"264\":1,\"305\":1,\"519\":1,\"542\":1,\"543\":1,\"551\":1,\"560\":1,\"563\":1,\"619\":1,\"678\":1,\"695\":1,\"700\":1,\"702\":1,\"723\":5,\"728\":2,\"790\":1,\"808\":9,\"813\":5,\"818\":1,\"822\":1,\"825\":1,\"826\":1,\"834\":1,\"845\":1}}],[\"接着写else的业务逻辑代码\",{\"1\":{\"852\":1}}],[\"接着\",{\"1\":{\"770\":1}}],[\"接着看第三步\",{\"1\":{\"103\":1}}],[\"接着看loadinitialdrivers方法\",{\"1\":{\"103\":1}}],[\"接着看下面的解析\",{\"1\":{\"102\":1}}],[\"接着使用反射\",{\"1\":{\"91\":1}}],[\"接下来就只需调用其相应构造器的\",{\"1\":{\"310\":1}}],[\"接下来我们看下异常使用的基础\",{\"1\":{\"250\":1}}],[\"接下来我们通过这个分类角度来理解注解\",{\"1\":{\"221\":1}}],[\"接下来\",{\"1\":{\"107\":1,\"235\":1,\"621\":1,\"763\":1,\"973\":1}}],[\"接下来可以在resources下新建meta\",{\"1\":{\"96\":1}}],[\"接下来要介绍的这个技巧就有点厉害了\",{\"1\":{\"92\":1}}],[\"化整为零\",{\"0\":{\"92\":1}}],[\"肆\",{\"0\":{\"92\":1}}],[\"最低限度不要再增加配置项\",{\"1\":{\"869\":1}}],[\"最多\",{\"1\":{\"869\":1}}],[\"最多有两层继承关系\",{\"1\":{\"814\":1}}],[\"最近在某个表中增加一个同名字段\",{\"1\":{\"865\":1}}],[\"最外层的业务使用者\",{\"1\":{\"858\":1}}],[\"最下面的部分标识类的方法\",{\"1\":{\"826\":1}}],[\"最上面的部分标识类的名称\",{\"1\":{\"826\":1}}],[\"最主要的原因就是将系统划分成各个独立的模块\",{\"1\":{\"818\":1}}],[\"最关键的就是解耦\",{\"1\":{\"816\":1}}],[\"最大的挑战之一就是需求的不断变化\",{\"1\":{\"808\":1}}],[\"最大的二进制组件仓库\",{\"1\":{\"401\":1}}],[\"最少知道原则\",{\"1\":{\"741\":1}}],[\"最重要\",{\"1\":{\"736\":1}}],[\"最基础\",{\"1\":{\"736\":1}}],[\"最小接口指\",{\"1\":{\"721\":1}}],[\"最小原型的使用方式跟\",{\"1\":{\"624\":1}}],[\"最小原型设计\",{\"0\":{\"624\":1}}],[\"最好\",{\"1\":{\"885\":1}}],[\"最好确定该常量与接口的方法相关\",{\"1\":{\"845\":1}}],[\"最好还是不要设计成单例类\",{\"1\":{\"766\":1}}],[\"最好的资料依然在junit官方网站\",{\"1\":{\"971\":1}}],[\"最好的\",{\"1\":{\"480\":1}}],[\"最好的一方面就是拥有大量的第三方库可以做任何事\",{\"1\":{\"459\":1}}],[\"最好的两个框架是\",{\"1\":{\"457\":1}}],[\"最好不要捕获\",{\"1\":{\"268\":1}}],[\"最好不要去使用\",{\"1\":{\"141\":1}}],[\"最优匹配\",{\"1\":{\"311\":1}}],[\"最起码\",{\"1\":{\"290\":1}}],[\"最为常见的就是使用spring\",{\"1\":{\"242\":1}}],[\"最常见的例子就是对象中包含一个日期对象的引用\",{\"1\":{\"174\":1}}],[\"最后通过tostring\",{\"1\":{\"848\":1}}],[\"最后构建成该复杂对象\",{\"1\":{\"798\":1}}],[\"最后将表达式\",{\"1\":{\"644\":1}}],[\"最后求出结果\",{\"1\":{\"643\":1}}],[\"最后最小原型设计那里再调用\",{\"1\":{\"627\":1}}],[\"最后被委托到\",{\"1\":{\"312\":1}}],[\"最后的两个方法\",{\"1\":{\"291\":1}}],[\"最后在字节码中的类型变量的真正类型\",{\"1\":{\"289\":1}}],[\"最后发现结果为true\",{\"1\":{\"288\":1}}],[\"最后执行finally语句块后的语句\",{\"1\":{\"257\":1}}],[\"最后我们再看看实际开发中注解的一些应用场景\",{\"1\":{\"239\":1}}],[\"最后才是构造函数的初始化\",{\"1\":{\"144\":1}}],[\"最后总结一下jdk\",{\"1\":{\"112\":1}}],[\"最后建议大家\",{\"1\":{\"94\":1}}],[\"最后\",{\"0\":{\"94\":1},\"1\":{\"104\":1,\"114\":1,\"265\":1,\"288\":1,\"310\":2,\"311\":1,\"313\":1,\"622\":1,\"627\":1,\"741\":1,\"805\":1,\"820\":1,\"947\":1}}],[\"最后调用getint方法一次性读取4个字节作为一个int型变量的值\",{\"1\":{\"93\":1}}],[\"最后再将它的值设为false\",{\"1\":{\"91\":1}}],[\"最终给客户端调用\",{\"1\":{\"784\":1}}],[\"最终形成一颗抽象的语法分析树\",{\"1\":{\"641\":1}}],[\"最终你需要把你的代码从开发环境部署到生产环境了\",{\"1\":{\"462\":1}}],[\"最终是由jvm执行invoke0\",{\"1\":{\"313\":1}}],[\"最终方法不能被重写\",{\"1\":{\"195\":1}}],[\"最终类不能被继承\",{\"1\":{\"195\":1}}],[\"最终类可以没有最终方法\",{\"1\":{\"195\":1}}],[\"最终\",{\"1\":{\"187\":1}}],[\"最终导致集合添加了两个等价的对象\",{\"1\":{\"139\":1}}],[\"最终会加载meta\",{\"1\":{\"106\":1}}],[\"最终会返回false\",{\"1\":{\"91\":1}}],[\"最终实现了把1赋值给a的操作\",{\"1\":{\"93\":1}}],[\"最难的\",{\"1\":{\"36\":1}}],[\"||\",{\"1\":{\"92\":1,\"103\":1,\"114\":2,\"138\":1,\"310\":1,\"311\":2,\"650\":1,\"850\":1,\"852\":1}}],[\"|\",{\"1\":{\"91\":1,\"234\":1,\"256\":2,\"312\":1,\"438\":3,\"627\":4,\"907\":2,\"911\":2}}],[\"|this\",{\"1\":{\"62\":1}}],[\"没那么复杂\",{\"1\":{\"970\":1}}],[\"没必要对全字段建立索引\",{\"1\":{\"864\":1}}],[\"没中奖\",{\"1\":{\"778\":1}}],[\"没有的特性\",{\"1\":{\"996\":1}}],[\"没有这层含义\",{\"1\":{\"996\":1}}],[\"没有方法和注释的枚举常量可以写成数组初始化的方式\",{\"1\":{\"915\":1}}],[\"没有分组括号时代码的阅读者不会想当然地错误理解\",{\"1\":{\"913\":1}}],[\"没有使用空格\",{\"1\":{\"911\":1}}],[\"没有使用接口隔离原则代码\",{\"1\":{\"723\":1}}],[\"没有全面和明确的准则\",{\"1\":{\"906\":1}}],[\"没有注释也十分清晰\",{\"1\":{\"885\":1}}],[\"没有注解对应类型的注解时\",{\"1\":{\"233\":1}}],[\"没有进行转义\",{\"1\":{\"861\":1}}],[\"没有必要插入多个空行进行隔开\",{\"1\":{\"847\":1}}],[\"没有必要增加若干空格来使变量的赋值等号与上一行对应位置的等号对齐\",{\"1\":{\"847\":1}}],[\"没有红绿灯\",{\"1\":{\"843\":1}}],[\"没有鉴权的漏洞代码容易被黑客攻击等\",{\"1\":{\"843\":1}}],[\"没有实心箭头\",{\"1\":{\"835\":1}}],[\"没有实现\",{\"1\":{\"139\":1,\"141\":1}}],[\"没有了头\",{\"1\":{\"832\":1}}],[\"没有规定在软件开发中一定要用\",{\"1\":{\"823\":1}}],[\"没有人能掌控所有的细节\",{\"1\":{\"818\":1}}],[\"没有人处理该请求\",{\"1\":{\"708\":2}}],[\"没有起作用\",{\"1\":{\"768\":1}}],[\"没有达到\",{\"1\":{\"752\":1}}],[\"没有第二种途径\",{\"1\":{\"750\":1}}],[\"没有清晰的过程\",{\"1\":{\"600\":1}}],[\"没有资源没时间\",{\"1\":{\"590\":2}}],[\"没有集合\",{\"1\":{\"574\":1}}],[\"没有任何命令\",{\"1\":{\"562\":1}}],[\"没有设计缓存层对象\",{\"1\":{\"554\":1}}],[\"没有xml并支持混入\",{\"1\":{\"434\":1}}],[\"没有保证\",{\"1\":{\"182\":1}}],[\"没有指针\",{\"1\":{\"151\":1}}],[\"没用的知识介绍环节就此结束\",{\"1\":{\"94\":1}}],[\"没错\",{\"1\":{\"91\":1,\"92\":1,\"290\":1}}],[\"没个几十年的功力真看不出来这里执行的是sleep\",{\"1\":{\"89\":1}}],[\"下划线可以出现在\",{\"1\":{\"941\":1}}],[\"下单\",{\"1\":{\"861\":1}}],[\"下列情形\",{\"1\":{\"852\":2}}],[\"下列情况使用final关键字\",{\"1\":{\"848\":1}}],[\"下例中没有处理相等的情况\",{\"1\":{\"850\":1}}],[\"下例中实参的args1逗号后边必须要有一个空格\",{\"1\":{\"847\":1}}],[\"下图完整地描述了所有构件的关系\",{\"1\":{\"824\":1}}],[\"下载量已达到\",{\"1\":{\"843\":1}}],[\"下载图片的时候\",{\"1\":{\"809\":1}}],[\"下载一幅很大的图像需要很长时间\",{\"1\":{\"705\":1}}],[\"下的核心方法\",{\"1\":{\"848\":1}}],[\"下的\",{\"1\":{\"770\":1}}],[\"下属有各个学院和总部\",{\"1\":{\"742\":1}}],[\"下方代码\",{\"1\":{\"718\":1}}],[\"下一章会继续讲解七大设计原则\",{\"1\":{\"818\":1}}],[\"下一个处理者\",{\"1\":{\"710\":2}}],[\"下一篇\",{\"1\":{\"6\":1}}],[\"下次再请求此对象的时候\",{\"1\":{\"627\":1}}],[\"下限\",{\"1\":{\"284\":1}}],[\"下标越界\",{\"1\":{\"265\":1}}],[\"下标越界异常\",{\"1\":{\"248\":1}}],[\"下述包含\",{\"1\":{\"187\":1}}],[\"下面正例中的数字就是延伸信息\",{\"1\":{\"846\":1}}],[\"下面根据类与类之间的耦合度从弱到强排列\",{\"1\":{\"827\":1}}],[\"下面这张图是引入中间层前后的依赖关系对比图\",{\"1\":{\"818\":1}}],[\"下面这些软件包能够让你更容易地测试\",{\"1\":{\"475\":1}}],[\"下面这些一小部分的扩展库对大部分人来说很适用的\",{\"1\":{\"463\":1}}],[\"下面代码的修改方法没有对原来的类做大的修改\",{\"1\":{\"718\":1}}],[\"下面代码虽然遵守单一职责原则\",{\"1\":{\"718\":1}}],[\"下面分析其以下应用场景\",{\"1\":{\"661\":1}}],[\"下面分析它的应用场景\",{\"1\":{\"646\":1}}],[\"下面分析它适用的应用场景\",{\"1\":{\"639\":1}}],[\"下面分析它适用的以下应用场景\",{\"1\":{\"577\":1}}],[\"下面介绍其应用场景\",{\"1\":{\"653\":1}}],[\"下面享元模式的结构图\",{\"1\":{\"632\":1}}],[\"下面来分析其基本结构和实现方法\",{\"1\":{\"580\":1}}],[\"下面来看一下\",{\"1\":{\"310\":1}}],[\"下面为安全的组合模式的实现代码\",{\"1\":{\"571\":1}}],[\"下面为透明式的组合模式的实现代码\",{\"1\":{\"571\":1}}],[\"下面我们使用建造者模式\",{\"1\":{\"555\":1}}],[\"下面可以有\",{\"1\":{\"543\":1}}],[\"下面是核心方式使用\",{\"1\":{\"728\":1}}],[\"下面是一个典型的\",{\"1\":{\"622\":1}}],[\"下面是选出的最流行的一部分工具\",{\"1\":{\"484\":1}}],[\"下面是传统的通过定义一个\",{\"1\":{\"445\":1}}],[\"下面是获取构造器的过程\",{\"1\":{\"310\":1}}],[\"下面是class类获取method对象相关的方法\",{\"1\":{\"308\":1}}],[\"下面将演示通过method对象调用指定类的方法\",{\"1\":{\"308\":1}}],[\"下面将通过field类本身的方法对指定类属性赋值\",{\"1\":{\"307\":1}}],[\"下面将对这几个重要类进行分别说明\",{\"1\":{\"304\":1}}],[\"下面看一个简单例子来了解constructor对象的使用\",{\"1\":{\"306\":1}}],[\"下面方法是合法的\",{\"1\":{\"297\":1}}],[\"下面的测试类也没有实际使用到该类\",{\"1\":{\"789\":1}}],[\"下面的测试用例简单的测试了建立对象\",{\"1\":{\"276\":1}}],[\"下面的定义呢\",{\"1\":{\"297\":1}}],[\"下面的定义将不会通过编译\",{\"1\":{\"297\":1}}],[\"下面的代码演示了上述方法的使用过程\",{\"1\":{\"307\":1}}],[\"下面的代码中\",{\"1\":{\"139\":1,\"211\":1}}],[\"下面的代码\",{\"1\":{\"91\":1}}],[\"下面\",{\"1\":{\"187\":1}}],[\"下面示例中\",{\"1\":{\"125\":1}}],[\"陷入云里雾里\",{\"1\":{\"91\":1}}],[\"今天\",{\"1\":{\"811\":1}}],[\"今天给大家分享一波\",{\"1\":{\"88\":1}}],[\"今有码农颠倒真假\",{\"1\":{\"91\":1}}],[\"颠倒黑白\",{\"0\":{\"91\":1}}],[\"叁\",{\"0\":{\"91\":1}}],[\"一条语句占一行\",{\"0\":{\"904\":1}}],[\"一部分的时候\",{\"1\":{\"902\":1}}],[\"一级宏观错误码\",{\"1\":{\"874\":3}}],[\"一对应\",{\"1\":{\"873\":2}}],[\"一对应的pojo类\",{\"1\":{\"873\":2}}],[\"一对多的关系\",{\"1\":{\"591\":1}}],[\"一直默默\",{\"1\":{\"869\":1}}],[\"一直追溯到最顶层父类的代码\",{\"1\":{\"812\":1}}],[\"一律不要使用\",{\"1\":{\"866\":1}}],[\"一律要求进行空指针判断\",{\"1\":{\"858\":1}}],[\"一样感觉不到\",{\"1\":{\"860\":1}}],[\"一样的大版本\",{\"1\":{\"186\":1}}],[\"一样的指针\",{\"1\":{\"151\":1}}],[\"一连串调用\",{\"1\":{\"858\":1}}],[\"一年之后\",{\"1\":{\"871\":1}}],[\"一年半载后\",{\"1\":{\"860\":1}}],[\"一年后的那一天不可能是\",{\"1\":{\"849\":1}}],[\"一年有效期的会员制\",{\"1\":{\"849\":1}}],[\"一周从周日开始\",{\"1\":{\"849\":1}}],[\"一份典型的建模图表通常包含几个块或框\",{\"1\":{\"823\":1}}],[\"一份牛奶的\",{\"1\":{\"584\":1}}],[\"一块儿来解决刚刚继承存在的问题\",{\"1\":{\"813\":1}}],[\"一方库\",{\"1\":{\"873\":1}}],[\"一方面\",{\"1\":{\"809\":1,\"812\":2}}],[\"一方改变其所指向对象的内容对另一方没有影响\",{\"1\":{\"127\":1}}],[\"一线\",{\"1\":{\"796\":1}}],[\"一台服务器很难支持更多的玩家玩围棋游戏\",{\"1\":{\"631\":1}}],[\"一下就可以\",{\"1\":{\"614\":1}}],[\"一旦整体对象不存在\",{\"1\":{\"832\":1}}],[\"一旦父类代码修改\",{\"1\":{\"812\":1}}],[\"一旦接口增加方法\",{\"1\":{\"696\":1}}],[\"一旦中介者出现了问题\",{\"1\":{\"660\":1}}],[\"一旦增加新产品不得不修改工厂逻辑\",{\"1\":{\"608\":1}}],[\"一旦异常\",{\"1\":{\"608\":1}}],[\"一旦你选择将某个类设计成到单例类\",{\"1\":{\"764\":1}}],[\"一旦你将你的服务器和你的\",{\"1\":{\"482\":1}}],[\"一旦你执行了\",{\"1\":{\"451\":1}}],[\"一书中提出的\",{\"1\":{\"716\":1}}],[\"一书中\",{\"1\":{\"606\":1}}],[\"一书第十四章中有提到\",{\"1\":{\"301\":1}}],[\"一切\",{\"1\":{\"874\":1}}],[\"一切外键概念必须在应用层解决\",{\"1\":{\"865\":1}}],[\"一切解释权都归我\",{\"1\":{\"591\":1}}],[\"一切就搞定了\",{\"1\":{\"466\":1}}],[\"一句话归纳\",{\"1\":{\"589\":1,\"590\":1,\"591\":1,\"748\":1}}],[\"一是在具体实现代码之前\",{\"1\":{\"991\":1}}],[\"一是易出错\",{\"1\":{\"866\":1}}],[\"一是保护目标对象\",{\"1\":{\"705\":1}}],[\"一是\",{\"1\":{\"550\":1}}],[\"一些其它运行器具备更多功能\",{\"1\":{\"972\":1,\"981\":1}}],[\"一些带连字符的单词在英语中含糊不清的\",{\"1\":{\"947\":1}}],[\"一些开源的数据库连接池\",{\"1\":{\"766\":1}}],[\"一些书籍称为\",{\"1\":{\"531\":1}}],[\"一些非常棒的代码生成库如\",{\"1\":{\"447\":1}}],[\"一些例子可以参考\",{\"1\":{\"280\":1}}],[\"一组java开发函数库\",{\"1\":{\"434\":1}}],[\"一组web开发工具集\",{\"1\":{\"434\":1}}],[\"一组可以处理各种任务的工具集\",{\"1\":{\"418\":1}}],[\"一种\",{\"1\":{\"996\":1}}],[\"一种动态加载类和创建对象的机制\",{\"1\":{\"627\":1}}],[\"一种高效的二进制序列化格式\",{\"1\":{\"428\":1}}],[\"一种静态编程语言\",{\"1\":{\"411\":1}}],[\"一种是每次都返回新创建的对象\",{\"1\":{\"622\":1}}],[\"一种是创建过程涉及复杂的\",{\"1\":{\"620\":1}}],[\"一种是\",{\"1\":{\"301\":1}}],[\"一款基于eclipse开源平台打造的spring应用开发环境\",{\"1\":{\"407\":1}}],[\"一款基于eclipse开源平台打造的scala集成开发环境\",{\"1\":{\"407\":1}}],[\"一定要注意日志输出量的问题\",{\"1\":{\"859\":1}}],[\"一定要注意手动回滚事务\",{\"1\":{\"858\":1}}],[\"一定要注意当value为null时会抛npe异常\",{\"1\":{\"850\":1}}],[\"一定要使用参数类型\",{\"1\":{\"850\":1}}],[\"一定要有抽象意识\",{\"1\":{\"809\":1}}],[\"一定要牢记简洁原则\",{\"1\":{\"797\":1}}],[\"一定要清楚\",{\"1\":{\"265\":1}}],[\"一定是子类在前面\",{\"1\":{\"297\":1}}],[\"一点问题也没有\",{\"1\":{\"291\":1}}],[\"一共有三种策略\",{\"1\":{\"228\":1}}],[\"一起删除\",{\"1\":{\"832\":1}}],[\"一起用于异常的处理\",{\"1\":{\"182\":1}}],[\"一起对反射提供了支持\",{\"1\":{\"145\":1}}],[\"一致性\",{\"1\":{\"138\":1,\"181\":1}}],[\"一\",{\"0\":{\"844\":1,\"845\":1,\"857\":1,\"863\":1,\"868\":1},\"1\":{\"138\":1}}],[\"一个实际的系统会依赖多个外部对象\",{\"1\":{\"996\":1}}],[\"一个产品里最核心最有业务价值的代码应该要有较高的单元测试覆盖率\",{\"1\":{\"992\":1}}],[\"一个产品家族是这样的一系列产品\",{\"1\":{\"557\":1}}],[\"一个测试\",{\"1\":{\"981\":1}}],[\"一个典型的阅读者可能不知道术语\",{\"1\":{\"960\":1}}],[\"一个常见的错误是用以下形式编写简单的\",{\"1\":{\"958\":1}}],[\"一个常见的错误就是在try块的最后关闭资源\",{\"1\":{\"264\":1}}],[\"一个大写字母\",{\"1\":{\"946\":1}}],[\"一个单独的没有参数的注解可以和方法签名的第一行一起出现\",{\"1\":{\"929\":1}}],[\"一个包含多块的语句\",{\"1\":{\"902\":1}}],[\"一个空对象或者是一个常量等\",{\"1\":{\"996\":1}}],[\"一个空的语句块或者块状结构可以遵循\",{\"1\":{\"902\":1}}],[\"一个空行\",{\"1\":{\"886\":1,\"956\":1}}],[\"一个\",{\"1\":{\"876\":1}}],[\"一个五位数字\",{\"1\":{\"857\":1}}],[\"一个人每天会起床\",{\"1\":{\"800\":1}}],[\"一个系统需要动态地在几种算法中选择一种时\",{\"1\":{\"792\":1}}],[\"一个操作中含有庞大的分支结构\",{\"1\":{\"781\":1}}],[\"一个进程在获取到对象之后\",{\"1\":{\"772\":1}}],[\"一个进程只能有一个单例对象\",{\"1\":{\"771\":1}}],[\"一个线程进入了\",{\"1\":{\"754\":1}}],[\"一个项目通常只需要一个\",{\"1\":{\"750\":1}}],[\"一个接口的方法重新定义了父接口的方法\",{\"1\":{\"949\":1}}],[\"一个接口的所有抽象方法能被一个类全部实现\",{\"1\":{\"748\":1}}],[\"一个接口只干一件事\",{\"1\":{\"748\":1}}],[\"一个软件实体如类\",{\"1\":{\"736\":1}}],[\"一个缓冲层\",{\"1\":{\"729\":1}}],[\"一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力\",{\"1\":{\"716\":1}}],[\"一个事件需要经过多个对象处理是很常见的场景\",{\"1\":{\"707\":1}}],[\"一个客户不能或者不想直接访问另一个对象\",{\"1\":{\"692\":1}}],[\"一个对象应该对其他对象保持最少的了解\",{\"1\":{\"741\":1}}],[\"一个对象更加优良\",{\"1\":{\"682\":1}}],[\"一个对象的状态发生改变会影响其他对象\",{\"1\":{\"680\":1}}],[\"一个对象的内部状态\",{\"1\":{\"663\":1}}],[\"一个对象\",{\"1\":{\"666\":1}}],[\"一个对象就可以提供给多出需要使用的地方\",{\"1\":{\"639\":1}}],[\"一个算术表达式通过词法分析器形成词法单元\",{\"1\":{\"641\":1}}],[\"一个简单的\",{\"1\":{\"621\":1,\"622\":1}}],[\"一个简化字节码编辑尝试\",{\"1\":{\"386\":1}}],[\"一个工厂类只负责某个类对象或者某一组相关类对象\",{\"1\":{\"621\":1}}],[\"一个学院有多个系\",{\"1\":{\"572\":1,\"573\":1,\"650\":1}}],[\"一个学校有多个学院\",{\"1\":{\"572\":1,\"573\":1,\"650\":1}}],[\"一个学校可以有很多学生\",{\"1\":{\"217\":1}}],[\"一个具体的产品对象\",{\"1\":{\"550\":1}}],[\"一个静态代码分析工具\",{\"1\":{\"484\":1}}],[\"一个全新函数式集合库\",{\"1\":{\"469\":1}}],[\"一个很好的\",{\"1\":{\"460\":1}}],[\"一个比较漂亮的绝招是在你的方法异常声明中声明\",{\"1\":{\"448\":1}}],[\"一个可扩展的java爬虫框架\",{\"1\":{\"433\":1}}],[\"一个分布式\",{\"1\":{\"426\":1}}],[\"一个完全的企业搜索引擎\",{\"1\":{\"426\":1}}],[\"一个完整的例子\",{\"1\":{\"257\":1}}],[\"一个java工具集\",{\"1\":{\"432\":1}}],[\"一个java类型安全的rest客户端\",{\"1\":{\"424\":1}}],[\"一个java语言编写的高性能功能完善的json库\",{\"1\":{\"409\":1}}],[\"一个复杂的报表引擎\",{\"1\":{\"421\":1}}],[\"一个易于使用的pdf函数库\",{\"1\":{\"421\":1}}],[\"一个android和java应用的http+spdy客户端\",{\"1\":{\"419\":1}}],[\"一个函数式组件库\",{\"1\":{\"403\":1}}],[\"一个是数字的\",{\"1\":{\"848\":1}}],[\"一个是字母的o\",{\"1\":{\"848\":1}}],[\"一个是date类型\",{\"1\":{\"291\":1}}],[\"一个是参数object类型\",{\"1\":{\"291\":1}}],[\"一个是string\",{\"1\":{\"289\":1}}],[\"一个是float\",{\"1\":{\"289\":1}}],[\"一个是arraylist<integer>泛型类型的\",{\"1\":{\"288\":1}}],[\"一个用来拆解class文件的工具\",{\"1\":{\"275\":1}}],[\"一个团队必须要制定出一个最佳实践和规则\",{\"1\":{\"262\":1}}],[\"一个无参构造函数和一个带有详细描述信息的构造函数\",{\"1\":{\"254\":1}}],[\"一个模块或者类的改动\",{\"1\":{\"818\":1}}],[\"一个模块的封装大多数人都是通过继承和组合等模式来实现的\",{\"1\":{\"241\":1}}],[\"一个模块不需要知道其他模块的内部工作情况\",{\"1\":{\"132\":1}}],[\"一个方法内的内部类如果使用了这个方法的参数或者局部变量的话\",{\"1\":{\"204\":1}}],[\"一个方法的形参不用final修饰\",{\"1\":{\"204\":1}}],[\"一个子类只能继承一个抽象类\",{\"1\":{\"194\":1}}],[\"一个嵌套类位于顶级类内部\",{\"1\":{\"184\":1}}],[\"一个公共的顶级类的源文件名称与类名相同\",{\"1\":{\"184\":1}}],[\"一个类中有多个public方法\",{\"1\":{\"871\":1}}],[\"一个类需要借助另一个类来实现功能一般一个类将另一个类作为参数使用\",{\"1\":{\"835\":1}}],[\"一个类定义了多种行为\",{\"1\":{\"792\":1}}],[\"一个类型只能对应一个对象\",{\"1\":{\"773\":1}}],[\"一个类可以创建多个对象\",{\"1\":{\"773\":2}}],[\"一个类可以实现多个接口\",{\"1\":{\"133\":1}}],[\"一个类应该保持对其它对象最少的了解\",{\"1\":{\"748\":1}}],[\"一个类只能创建一个对象\",{\"1\":{\"773\":1}}],[\"一个类只允许创建唯一一个对象\",{\"1\":{\"770\":2}}],[\"一个类只干一件事\",{\"1\":{\"748\":1}}],[\"一个类只负责一项职责\",{\"1\":{\"717\":1,\"719\":1}}],[\"一个类或一个方法只负责一件事情\",{\"1\":{\"748\":1}}],[\"一个类的方法实现了接口的方法\",{\"1\":{\"949\":1}}],[\"一个类的修改\",{\"1\":{\"741\":1}}],[\"一个类的代码改动不会或者很少导致依赖类的代码改动\",{\"1\":{\"741\":1}}],[\"一个类对另一个类的依赖应该建立在最小的接口上\",{\"1\":{\"721\":1}}],[\"一个类\",{\"1\":{\"609\":1}}],[\"一个类有\",{\"1\":{\"301\":1}}],[\"一个类不显式去重写\",{\"1\":{\"141\":1}}],[\"一个数与\",{\"1\":{\"139\":1}}],[\"一般形式\",{\"0\":{\"955\":1},\"1\":{\"962\":1}}],[\"一般是数字\",{\"1\":{\"866\":1}}],[\"一般是方法级别\",{\"1\":{\"860\":1}}],[\"一般对字符串类型数据\",{\"1\":{\"864\":1}}],[\"一般dao层与service层都在同一个应用中\",{\"1\":{\"852\":1}}],[\"一般不要定义为static变量\",{\"1\":{\"851\":1}}],[\"一般模板方法都加上\",{\"1\":{\"804\":1}}],[\"一般使用接口或抽象类实现\",{\"1\":{\"784\":1}}],[\"一般通过在\",{\"1\":{\"711\":1}}],[\"一般代理会被理解为代码增强\",{\"1\":{\"694\":1}}],[\"一般用来传递被所有解释器共享的数据\",{\"1\":{\"642\":1}}],[\"一般情况下\",{\"1\":{\"606\":1,\"750\":1,\"819\":1}}],[\"一般情况下不自定义检查异常\",{\"1\":{\"248\":1}}],[\"一般选择有\",{\"1\":{\"461\":1}}],[\"一般为空\",{\"1\":{\"311\":1}}],[\"一般调用一个或多个可能抛出异常的方法\",{\"1\":{\"264\":1}}],[\"一般取\",{\"1\":{\"139\":1}}],[\"一般来说\",{\"1\":{\"105\":1,\"908\":1,\"989\":1}}],[\"一般都是以jar包做依赖\",{\"1\":{\"95\":1}}],[\"一次是转为iterator对象\",{\"1\":{\"850\":1}}],[\"一次实例化代码就够了\",{\"1\":{\"755\":1}}],[\"一次\",{\"1\":{\"92\":1}}],[\"一次性右移32位呢\",{\"1\":{\"90\":1}}],[\"一键启用\",{\"1\":{\"13\":1}}],[\"以助你完善体系\",{\"1\":{\"988\":1}}],[\"以它只会说\",{\"1\":{\"960\":1}}],[\"以空格和任何剩余的标点符号\",{\"1\":{\"947\":1}}],[\"以类名的方式命名\",{\"1\":{\"946\":1}}],[\"以类给到\",{\"1\":{\"534\":1}}],[\"以t1\",{\"1\":{\"865\":1}}],[\"以test结尾\",{\"1\":{\"845\":1}}],[\"以保证被测试模块的交付质量\",{\"1\":{\"860\":1}}],[\"以保证擦除类型后的代码仍然具有泛型的\",{\"1\":{\"287\":1}}],[\"以mppserver应用为例\",{\"1\":{\"859\":1}}],[\"以先到先得的原则在统一平台上进行\",{\"1\":{\"857\":1}}],[\"以提高查询性能\",{\"1\":{\"863\":1}}],[\"以提高可读性\",{\"1\":{\"852\":1}}],[\"以提升辨识度\",{\"1\":{\"845\":1}}],[\"以一种普遍认可的统一方式一起做事\",{\"1\":{\"843\":1}}],[\"以一个简单的crud操作为例\",{\"1\":{\"242\":1}}],[\"以后不会改\",{\"1\":{\"748\":1}}],[\"以抽象为基础搭建的架构比以细节为基础的架构要稳定的多\",{\"1\":{\"725\":1}}],[\"以控制对这个对象的访问\",{\"1\":{\"692\":1}}],[\"以防忘记了\",{\"1\":{\"663\":1}}],[\"以前开发的系统存在满足新系统功能需求的类\",{\"1\":{\"535\":1}}],[\"以前的写法\",{\"1\":{\"290\":1}}],[\"以接口给到\",{\"1\":{\"534\":1}}],[\"以对象给到\",{\"1\":{\"534\":1}}],[\"以解决兼容性的问题\",{\"1\":{\"527\":1}}],[\"以生活中充电器的例子来讲解适配器\",{\"1\":{\"524\":1,\"528\":1}}],[\"以注解的方式来实现接口及其实现的结合\",{\"1\":{\"472\":1}}],[\"以java和\",{\"1\":{\"442\":1}}],[\"以本机格式发布应用程序的工具\",{\"1\":{\"401\":1}}],[\"以磁盘或堆内存中并发集合为基础的嵌入式数据库引擎\",{\"1\":{\"394\":1}}],[\"以可以作为内存数据库使用著称\",{\"1\":{\"394\":1}}],[\"以字符串形式返回此构造方法的名称\",{\"1\":{\"306\":2}}],[\"以上每个部分间隔\",{\"1\":{\"886\":1}}],[\"以上述实例为例\",{\"1\":{\"839\":1}}],[\"以上问题如果采用\",{\"1\":{\"775\":1}}],[\"以上\",{\"1\":{\"709\":1,\"798\":3,\"864\":1}}],[\"以上所有这些产品都是由多个部件构成的\",{\"1\":{\"549\":1}}],[\"以上这些类型都实现type接口\",{\"1\":{\"298\":1}}],[\"以上就是jvm处理异常的一些机制\",{\"1\":{\"275\":1}}],[\"以上抛出了\",{\"1\":{\"141\":1}}],[\"以代替方法预计会返回的值\",{\"1\":{\"260\":1}}],[\"以lock加锁为例\",{\"1\":{\"258\":1}}],[\"以下列举了一些我为什么使用单元测试的好处\",{\"1\":{\"990\":1}}],[\"以下我帮你总结下junit相关的官方网址\",{\"1\":{\"971\":1}}],[\"以下示例包括了原始类型\",{\"1\":{\"942\":1}}],[\"以下例子都是合法的\",{\"1\":{\"920\":1}}],[\"以下是一个很常见的惯用语法\",{\"1\":{\"950\":1}}],[\"以下是一种可能的例子\",{\"1\":{\"915\":1}}],[\"以下是一部分我参考的链接\",{\"1\":{\"299\":1}}],[\"以下操作尽量移至循环体外处理\",{\"1\":{\"852\":1}}],[\"以下两种场景会触发类型对齐的拆箱操作\",{\"1\":{\"852\":1}}],[\"以下情形例外\",{\"1\":{\"845\":1}}],[\"以下称为异常表\",{\"1\":{\"275\":1}}],[\"以下代码在使用javadoc工具可以生成\",{\"1\":{\"229\":1}}],[\"以下代码中\",{\"1\":{\"127\":1}}],[\"以下类图使用\",{\"1\":{\"212\":1}}],[\"以下\",{\"1\":{\"209\":1}}],[\"以消除错误的产生\",{\"1\":{\"206\":1}}],[\"以确保这个规则得到遵守\",{\"1\":{\"198\":1}}],[\"以此来降低单元测试的复杂性和可实现性\",{\"1\":{\"996\":1}}],[\"以此来降低代码间的耦合性\",{\"1\":{\"810\":1}}],[\"以此来降低耦合性\",{\"1\":{\"808\":1}}],[\"以此来保证抽象\",{\"1\":{\"188\":1}}],[\"以此来限制子类继承父类\",{\"1\":{\"173\":1}}],[\"以避免子类改变了父类的immutable特性\",{\"1\":{\"173\":1}}],[\"以及本地变量\",{\"1\":{\"848\":1}}],[\"以及真实的错误案例\",{\"1\":{\"843\":1}}],[\"以及处理复杂数据的信息系统\",{\"1\":{\"823\":1}}],[\"以及对语言句子的解释方法\",{\"1\":{\"798\":1}}],[\"以及对它的动态访问权限\",{\"1\":{\"307\":1}}],[\"以及怎样分配职责\",{\"1\":{\"798\":1}}],[\"以及今天讲的迪米特法则\",{\"1\":{\"741\":1}}],[\"以及使用设计模式的目的就是遵循\",{\"1\":{\"736\":1,\"739\":1}}],[\"以及其中蕴含的原理\",{\"1\":{\"732\":1}}],[\"以及通知所有观察者的抽象方法\",{\"1\":{\"672\":1}}],[\"以及如何实现一个简单的\",{\"1\":{\"620\":1}}],[\"以及如何访问该方法\",{\"1\":{\"308\":1}}],[\"以及软件的可维护性\",{\"1\":{\"613\":1}}],[\"以及厨房中的锅碗瓢盆等\",{\"1\":{\"567\":1}}],[\"以及所有正确的\",{\"1\":{\"458\":1}}],[\"以及这些项目的所有版本信息\",{\"1\":{\"458\":1}}],[\"以及ole2规范\",{\"1\":{\"402\":1}}],[\"以及类的加载机制\",{\"1\":{\"301\":1}}],[\"以及\",{\"1\":{\"132\":1,\"586\":2,\"771\":1}}],[\"以至于这个时期说方法区就是指永久代\",{\"1\":{\"125\":1}}],[\"以懒加载的方式加载可用的服务提供者\",{\"1\":{\"114\":1}}],[\"以动态的方式管理组件生命周期\",{\"1\":{\"105\":1}}],[\"以\",{\"1\":{\"90\":1,\"290\":1,\"308\":1,\"482\":1,\"859\":1,\"943\":1,\"958\":1}}],[\"以便构建工具和\",{\"1\":{\"975\":1}}],[\"以便以后恢复它\",{\"1\":{\"798\":1}}],[\"以便适时选择恰当的算法类\",{\"1\":{\"783\":1}}],[\"以便在需要的时候使用\",{\"1\":{\"682\":1}}],[\"以便在得到目标的更改通知时更新自身的状态\",{\"1\":{\"672\":1}}],[\"以便使用不同参数来表示不同的请求\",{\"1\":{\"560\":1}}],[\"以便于告知方法调用者此方法有异常\",{\"1\":{\"252\":1}}],[\"以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上\",{\"1\":{\"185\":1}}],[\"以便抛出的异常可以被调用者处理\",{\"1\":{\"196\":1}}],[\"以便\",{\"1\":{\"8\":1,\"626\":1}}],[\"例如我们调用一个\",{\"1\":{\"996\":1}}],[\"例如一个\",{\"1\":{\"996\":1}}],[\"例如进程\",{\"1\":{\"995\":1}}],[\"例如清理数据\",{\"1\":{\"972\":1}}],[\"例如创建数据库连接\",{\"1\":{\"972\":1}}],[\"例如当英语短语里出现首字母缩略词或者不寻常结构的单词\",{\"1\":{\"947\":1}}],[\"例如典型的\",{\"1\":{\"924\":1}}],[\"例如在类和方法的索引中\",{\"1\":{\"958\":1}}],[\"例如在将代码组织成一小块逻辑的语句之间\",{\"1\":{\"910\":1}}],[\"例如在\",{\"1\":{\"901\":1}}],[\"例如在作为网络连接参数的情况下如果\",{\"1\":{\"123\":1}}],[\"例如纯文本\",{\"1\":{\"854\":1}}],[\"例如容器和迭代器\",{\"1\":{\"819\":1}}],[\"例如公司\",{\"1\":{\"750\":1}}],[\"例如恢复到历史某一状态\",{\"1\":{\"682\":1}}],[\"例如class\",{\"1\":{\"305\":1}}],[\"例如io流中执行完相应操作后\",{\"1\":{\"258\":1}}],[\"例如使用反射注入实例\",{\"1\":{\"221\":1}}],[\"例如动态生成代码\",{\"1\":{\"221\":1}}],[\"例如除\",{\"1\":{\"146\":1}}],[\"例如不相关的类都可以实现\",{\"1\":{\"133\":1}}],[\"例如下面的例子中\",{\"1\":{\"132\":1}}],[\"例如写c的就看不起写java的\",{\"1\":{\"93\":1}}],[\"例如\",{\"1\":{\"90\":2,\"93\":1,\"123\":1,\"180\":1,\"210\":1,\"265\":2,\"272\":1,\"290\":1,\"297\":1,\"301\":1,\"518\":1,\"549\":1,\"560\":1,\"567\":2,\"586\":2,\"629\":1,\"641\":1,\"655\":2,\"671\":2,\"692\":2,\"702\":1,\"705\":4,\"707\":1,\"783\":1,\"800\":3,\"819\":1,\"831\":1,\"832\":1,\"837\":2,\"869\":1,\"884\":2,\"885\":3,\"896\":1,\"900\":1,\"901\":2,\"902\":2,\"905\":2,\"907\":2,\"910\":1,\"911\":2,\"917\":1,\"920\":1,\"924\":1,\"927\":1,\"928\":1,\"929\":2,\"930\":1,\"935\":1,\"937\":1,\"939\":1,\"940\":5,\"941\":2,\"942\":1,\"943\":1,\"946\":2,\"947\":5,\"956\":1,\"960\":1,\"972\":1,\"980\":1,\"981\":1,\"994\":1}}],[\"很好\",{\"1\":{\"885\":1}}],[\"很可能在比较值的时候\",{\"1\":{\"863\":1}}],[\"很结实\",{\"1\":{\"835\":1}}],[\"很复杂的继承关系\",{\"1\":{\"812\":1}}],[\"很遗憾\",{\"1\":{\"778\":1}}],[\"很遗憾没有抽中奖品\",{\"1\":{\"778\":1}}],[\"很难添加新的东西\",{\"1\":{\"699\":1,\"702\":1}}],[\"很方便的创建出相应的产品\",{\"1\":{\"608\":1}}],[\"很大概率都会使用外观模式\",{\"1\":{\"593\":1}}],[\"很棒\",{\"1\":{\"468\":1}}],[\"很愉悦\",{\"1\":{\"467\":1}}],[\"很明显\",{\"1\":{\"460\":1}}],[\"很明显是会报错的\",{\"1\":{\"284\":1}}],[\"很相似\",{\"1\":{\"311\":1,\"484\":1}}],[\"很多if语句内的逻辑表达式相当复杂\",{\"1\":{\"852\":1}}],[\"很多设计原则都以实现代码的\",{\"1\":{\"818\":1}}],[\"很多人错误地认为识别到系统难点在哪里\",{\"1\":{\"871\":1}}],[\"很多人认为concurrenthashmap是可以置入null值\",{\"1\":{\"850\":1}}],[\"很多人觉得继承是一种反模式\",{\"1\":{\"812\":1}}],[\"很多人在定义接口的时候\",{\"1\":{\"809\":1}}],[\"很多之前模棱两可的问题\",{\"1\":{\"810\":1}}],[\"很多这些工具都可以和流行的\",{\"1\":{\"484\":1}}],[\"很多时候\",{\"1\":{\"269\":1,\"545\":1,\"871\":1}}],[\"很多事没你想象的那么难\",{\"1\":{\"36\":1}}],[\"很容易带来未知风险\",{\"1\":{\"593\":1}}],[\"很容易被忽略\",{\"1\":{\"259\":1}}],[\"很容易出现的\",{\"1\":{\"249\":1}}],[\"很重要的一个小技巧就是把简单的东西复杂化\",{\"1\":{\"90\":1}}],[\"要根据实际情况去判定其具体含义\",{\"1\":{\"989\":1}}],[\"要先select\",{\"1\":{\"865\":1}}],[\"要先调用\",{\"1\":{\"768\":1}}],[\"要使用逻辑删除\",{\"1\":{\"863\":1}}],[\"要使用正确的箭头\",{\"1\":{\"835\":1}}],[\"要保证测试粒度足够小\",{\"1\":{\"860\":1}}],[\"要按常量功能进行归类\",{\"1\":{\"846\":1}}],[\"要杜绝继承\",{\"1\":{\"814\":1}}],[\"要有选择性的搬移\",{\"1\":{\"809\":1}}],[\"要遵从\",{\"1\":{\"809\":1}}],[\"要识别现有代码中的不同之处\",{\"1\":{\"805\":1}}],[\"要知道设计模式是为了使设计简单\",{\"1\":{\"797\":1}}],[\"要面向接口编程\",{\"1\":{\"748\":1}}],[\"要尽量先使用\",{\"1\":{\"745\":1}}],[\"要访问的远程对象比较大\",{\"1\":{\"692\":1}}],[\"要能实时的通知给第三方\",{\"1\":{\"673\":1}}],[\"要特别注意\",{\"1\":{\"660\":1}}],[\"要解决这个问题并不难\",{\"1\":{\"622\":1}}],[\"要创建哪些类对象\",{\"1\":{\"621\":1}}],[\"要便于维护\",{\"1\":{\"609\":1}}],[\"要便于披萨种类的扩展\",{\"1\":{\"609\":1}}],[\"要以让系统有层次\",{\"1\":{\"603\":1}}],[\"要求在resultmap中进行字段与属\",{\"1\":{\"866\":1}}],[\"要求在扩展新的咖啡种类时\",{\"1\":{\"581\":1}}],[\"要求是ref级别\",{\"1\":{\"864\":1}}],[\"要求设计代码时就把sut\",{\"1\":{\"860\":1}}],[\"要求\",{\"1\":{\"785\":1}}],[\"要求新的对象有旧的对象的所有功能\",{\"1\":{\"699\":1,\"702\":1}}],[\"要求表达式的字母不能重复\",{\"1\":{\"643\":1}}],[\"要求对用户隐藏组合对象与单个对象的不同\",{\"1\":{\"577\":1}}],[\"要求较高的抽象性\",{\"1\":{\"576\":1}}],[\"要求开发者针对抽象进行设计和编程\",{\"1\":{\"544\":1}}],[\"要求开发者针对抽象化进行设计与编程\",{\"1\":{\"537\":1}}],[\"要在一个页面中展示出学校的院系组成\",{\"1\":{\"572\":1}}],[\"要在表示\",{\"1\":{\"284\":1}}],[\"要实现一个\",{\"1\":{\"562\":1}}],[\"要实现不同类型的加法\",{\"1\":{\"279\":1}}],[\"要考虑是否选择建造者模式\",{\"1\":{\"557\":1}}],[\"要同时增加所有品牌的手机\",{\"1\":{\"541\":1}}],[\"要提到一点\",{\"1\":{\"291\":1}}],[\"要格外注意\",{\"1\":{\"290\":1}}],[\"要区分原始类型和泛型变量的类型\",{\"1\":{\"289\":1}}],[\"要对输入的集合参数进行npe判断\",{\"1\":{\"850\":1}}],[\"要对所有的状态进行判断\",{\"1\":{\"779\":1}}],[\"要对\",{\"1\":{\"284\":1}}],[\"要进行比较\",{\"1\":{\"284\":1}}],[\"要么会有注释标记着以指示\",{\"1\":{\"924\":1}}],[\"要么对超过特定阈值的页数进行sql改写\",{\"1\":{\"864\":1}}],[\"要么控制返回的总页数\",{\"1\":{\"864\":1}}],[\"要么注释说明程序将继续执行到哪一个case为止\",{\"1\":{\"852\":1}}],[\"要么在数据库层使用乐观锁\",{\"1\":{\"851\":1}}],[\"要么在缓存加锁\",{\"1\":{\"851\":1}}],[\"要么在应用层加锁\",{\"1\":{\"851\":1}}],[\"要么已声明异常\",{\"1\":{\"253\":1}}],[\"要么用throws子句声明将它抛出\",{\"1\":{\"252\":1}}],[\"要么用throws子句声明抛出它\",{\"1\":{\"249\":1}}],[\"要么用try\",{\"1\":{\"249\":1,\"252\":1}}],[\"要写出这样的类\",{\"1\":{\"173\":1}}],[\"要想写出别人看不懂的代码\",{\"1\":{\"90\":1}}],[\"要记得\",{\"1\":{\"36\":1}}],[\"舍近求远\",{\"0\":{\"90\":1}}],[\"贰\",{\"0\":{\"90\":1}}],[\"简写为fd\",{\"1\":{\"870\":1}}],[\"简洁易懂\",{\"1\":{\"865\":1}}],[\"简洁地写成\",{\"1\":{\"847\":1}}],[\"简要描述后端出错原因\",{\"1\":{\"854\":1}}],[\"简短清晰\",{\"1\":{\"854\":1}}],[\"简而言之\",{\"1\":{\"841\":1}}],[\"简历模板\",{\"1\":{\"800\":1}}],[\"简称单例模式\",{\"1\":{\"770\":1}}],[\"简称\",{\"1\":{\"620\":1}}],[\"简述\",{\"1\":{\"589\":1,\"590\":1,\"591\":1}}],[\"简化了创建对象的过程\",{\"1\":{\"682\":1}}],[\"简化了发起人类\",{\"1\":{\"663\":1}}],[\"简化了系统在不同平台之间的移植过程\",{\"1\":{\"593\":1}}],[\"简化了spring新程序的开发过程\",{\"1\":{\"434\":1}}],[\"简化客户端操作\",{\"1\":{\"576\":1}}],[\"简化json处理的开发库\",{\"1\":{\"409\":1}}],[\"简化开发的集成开发环境\",{\"1\":{\"407\":1}}],[\"简化数据库交互的相关工具\",{\"1\":{\"394\":1}}],[\"简化csv数据读写的框架与开发库\",{\"1\":{\"393\":1}}],[\"简介\",{\"0\":{\"876\":1},\"1\":{\"181\":1}}],[\"简直完美\",{\"1\":{\"89\":1}}],[\"简单例子\",{\"1\":{\"980\":1}}],[\"简单测试\",{\"1\":{\"978\":1}}],[\"简单测试下\",{\"1\":{\"305\":1}}],[\"简单说\",{\"1\":{\"800\":1}}],[\"简单应用实例\",{\"0\":{\"727\":1}}],[\"简单工厂模式有两种实现方式\",{\"1\":{\"622\":1}}],[\"简单工厂模式虽然违反了\",{\"1\":{\"610\":1}}],[\"简单工厂模式代码\",{\"1\":{\"610\":1}}],[\"简单工厂模式的设计方案\",{\"1\":{\"610\":1}}],[\"简单工厂模式的工厂类单一\",{\"1\":{\"608\":1}}],[\"简单工厂模式完成案例\",{\"0\":{\"610\":1}}],[\"简单工厂模式使用了\",{\"1\":{\"608\":1}}],[\"简单工厂模式是\",{\"1\":{\"608\":1}}],[\"简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例\",{\"1\":{\"608\":1}}],[\"简单工厂模式是属于\",{\"1\":{\"608\":1}}],[\"简单工厂模式基本介绍\",{\"0\":{\"608\":1}}],[\"简单工厂模式\",{\"1\":{\"606\":1,\"608\":2,\"609\":1,\"610\":1,\"614\":5,\"619\":1}}],[\"简单工厂\",{\"0\":{\"607\":1},\"1\":{\"606\":2,\"608\":1}}],[\"简单来说就是用来创建对象的\",{\"1\":{\"589\":1}}],[\"简单易操作\",{\"1\":{\"554\":1,\"609\":1,\"686\":1,\"738\":1}}],[\"简单\",{\"1\":{\"408\":1,\"470\":1,\"727\":1,\"817\":1,\"822\":1,\"960\":1}}],[\"简单二进制编码\",{\"1\":{\"395\":1}}],[\"简单的说\",{\"1\":{\"996\":1}}],[\"简单的轻量级网络爬虫\",{\"1\":{\"433\":1}}],[\"简单的数据库迁移工具\",{\"1\":{\"394\":1}}],[\"简单的泛型接口\",{\"1\":{\"282\":1}}],[\"简单的日期和时间库可供你使用\",{\"1\":{\"187\":1}}],[\"简单到main方法中只有一行注释\",{\"1\":{\"89\":1}}],[\"简单举几个例子\",{\"1\":{\"88\":1}}],[\"恕我直言\",{\"1\":{\"89\":1}}],[\"估计大家都看过下面这个笑话\",{\"1\":{\"89\":1}}],[\"同名的类方法应该在一个单独连续的组中出现\",{\"1\":{\"897\":1}}],[\"同一业务域内的需求变化\",{\"1\":{\"871\":1}}],[\"同一类型的只能创建一个对象\",{\"1\":{\"773\":1}}],[\"同一个线程只能对应一个对象\",{\"1\":{\"771\":1}}],[\"同一个\",{\"1\":{\"256\":1,\"773\":1}}],[\"同步调用应该去考量锁的性能损耗\",{\"1\":{\"851\":1}}],[\"同步代码块\",{\"0\":{\"756\":1},\"1\":{\"751\":1}}],[\"同步代理\",{\"1\":{\"704\":1}}],[\"同步方法\",{\"0\":{\"755\":1},\"1\":{\"751\":1,\"755\":1,\"756\":2,\"757\":1}}],[\"同步和名称注册\",{\"1\":{\"399\":1}}],[\"同事对象时\",{\"1\":{\"659\":1}}],[\"同事无法轻易修改你的代码\",{\"1\":{\"88\":1}}],[\"同宗同源\",{\"1\":{\"590\":1}}],[\"同样必须是public\",{\"1\":{\"972\":1}}],[\"同样无法解决线程安全问题\",{\"1\":{\"851\":1}}],[\"同样道理\",{\"1\":{\"823\":1}}],[\"同样如果我们增加一个手机品牌\",{\"1\":{\"541\":1}}],[\"同样通过案例演示上述方法\",{\"1\":{\"308\":1}}],[\"同样我们使用javap分析一下代码\",{\"1\":{\"275\":1}}],[\"同样的道理\",{\"1\":{\"307\":1}}],[\"同样的\",{\"1\":{\"242\":1}}],[\"同样在postgresql的jar包postgresql\",{\"1\":{\"101\":1}}],[\"同时包括对被测对象的配置\",{\"1\":{\"997\":1}}],[\"同时还包含其它类型约定和编码规范\",{\"1\":{\"876\":1}}],[\"同时触发成绩表中的student\",{\"1\":{\"865\":1}}],[\"同时存在对应属性xxx的isxxx\",{\"1\":{\"848\":1}}],[\"同时将自己\",{\"1\":{\"839\":1}}],[\"同时将被代理对象传递给代理对象\",{\"1\":{\"695\":1}}],[\"同时需要避免让这些操作\",{\"1\":{\"837\":1}}],[\"同时在专业水平上也有所提高\",{\"1\":{\"820\":1}}],[\"同时在工作中使用它\",{\"1\":{\"262\":1}}],[\"同时由子类提供部分步骤的实现\",{\"1\":{\"804\":1}}],[\"同时保证了效率\",{\"1\":{\"757\":1}}],[\"同时解决懒加载问题\",{\"1\":{\"757\":1}}],[\"同时变更时可以做到非常好的兼容性\",{\"1\":{\"733\":1}}],[\"同时修改和新增\",{\"1\":{\"718\":1}}],[\"同时添加新的功能\",{\"1\":{\"699\":1,\"702\":1}}],[\"同时也允许添加额外的空行\",{\"1\":{\"915\":1}}],[\"同时也能够提高效率\",{\"1\":{\"690\":1}}],[\"同时也充当命令接收者\",{\"1\":{\"563\":1}}],[\"同时提高效率\",{\"1\":{\"629\":1}}],[\"同时命令模式也支持可撤销的操作\",{\"1\":{\"560\":1}}],[\"同时充当了具体的建造者\",{\"1\":{\"556\":1}}],[\"同时会导致子类臃肿\",{\"1\":{\"545\":1}}],[\"同时能够和很多的日志框架想结合\",{\"1\":{\"473\":1}}],[\"同时支持tsv与固定宽度记录的读写\",{\"1\":{\"393\":1}}],[\"同时通过这几个内置注解中的元注解的定义来引出元注解\",{\"1\":{\"222\":1}}],[\"同时\",{\"1\":{\"188\":1,\"266\":1,\"727\":1,\"790\":1,\"816\":1,\"818\":1}}],[\"同时结合一些q\",{\"1\":{\"154\":1}}],[\"同时执行if和else中的语句块的功能\",{\"1\":{\"92\":1}}],[\"同理\",{\"1\":{\"89\":1,\"741\":1}}],[\"执行结果\",{\"1\":{\"975\":1,\"976\":1,\"977\":1,\"978\":1,\"979\":1,\"980\":2,\"981\":1,\"982\":1,\"983\":1}}],[\"执行结果会打印2\",{\"1\":{\"89\":1}}],[\"执行sql时\",{\"1\":{\"866\":1}}],[\"执行效率更快一些\",{\"1\":{\"865\":1}}],[\"执行效率较低\",{\"1\":{\"641\":1}}],[\"执行过程必须完全自动化才有意义\",{\"1\":{\"860\":1}}],[\"执行时间开销很大的方法\",{\"1\":{\"852\":1}}],[\"执行其它业务逻辑\",{\"1\":{\"848\":2}}],[\"执行错误\",{\"1\":{\"716\":1}}],[\"执行代理对象的方法\",{\"1\":{\"703\":1}}],[\"执行目标对象的方法\",{\"1\":{\"702\":1}}],[\"执行目标对象的方法时\",{\"1\":{\"700\":1}}],[\"执行生成目标对象\",{\"1\":{\"702\":1}}],[\"执行的是代理对象的方法\",{\"1\":{\"695\":1}}],[\"执行的顺序\",{\"1\":{\"257\":1}}],[\"执行速度比\",{\"1\":{\"637\":1}}],[\"执行入口那里调用\",{\"1\":{\"627\":1}}],[\"执行入口主要包含两部分\",{\"1\":{\"625\":1}}],[\"执行入口就是一组暴露给外部使用的接口和类\",{\"1\":{\"625\":1}}],[\"执行撤销的命令\",{\"1\":{\"562\":1}}],[\"执行动作\",{\"1\":{\"562\":1}}],[\"执行命令功能的相关操作\",{\"1\":{\"561\":1}}],[\"执行认证\",{\"1\":{\"427\":1}}],[\"执行\",{\"1\":{\"313\":1,\"755\":1,\"976\":1}}],[\"执行完finally的语句后\",{\"1\":{\"275\":1}}],[\"执行完成之后\",{\"1\":{\"251\":1}}],[\"执行返回操作\",{\"1\":{\"275\":2}}],[\"执行finally语句块里的语句\",{\"1\":{\"257\":1}}],[\"执行finally语句块和其后的语句\",{\"1\":{\"257\":1}}],[\"执行程序代码\",{\"1\":{\"257\":1}}],[\"执行第二句打印语句\",{\"1\":{\"92\":1}}],[\"执行后它居然会在控制台打印\",{\"1\":{\"89\":1}}],[\"那它是以该类的名称作为限定\",{\"1\":{\"951\":1}}],[\"那它就不属于常量\",{\"1\":{\"942\":1}}],[\"那它实际上相当于一种全局变量\",{\"1\":{\"767\":1}}],[\"那程序会直接\",{\"1\":{\"885\":1}}],[\"那当offset特别大的时候\",{\"1\":{\"864\":1}}],[\"那是测试同学干的事情\",{\"1\":{\"860\":1}}],[\"那是集成测试的领域\",{\"1\":{\"860\":1}}],[\"那是因为\",{\"1\":{\"808\":1}}],[\"那得不偿失\",{\"1\":{\"852\":1}}],[\"那\",{\"1\":{\"832\":1}}],[\"那依赖它的类和它依赖的类就会比较少\",{\"1\":{\"818\":1}}],[\"那开发就跟重构冲突了\",{\"1\":{\"818\":1}}],[\"那从代码结构上来讲\",{\"1\":{\"817\":1}}],[\"那现在问题来了\",{\"1\":{\"817\":1}}],[\"那代码整体的质量就不会差\",{\"1\":{\"816\":1}}],[\"那如何来控制代码的复杂性呢\",{\"1\":{\"816\":1}}],[\"那如何实现一个多例模式呢\",{\"1\":{\"773\":1}}],[\"那如何实现一个进程间也唯一的单例呢\",{\"1\":{\"772\":1}}],[\"那如何实现一个线程唯一的单例呢\",{\"1\":{\"771\":1}}],[\"那刚刚例子中继承存在的问题\",{\"1\":{\"812\":1}}],[\"那估计就要组合爆炸了\",{\"1\":{\"812\":1}}],[\"那鸵鸟就具有\",{\"1\":{\"812\":1}}],[\"那也没问题\",{\"1\":{\"809\":1}}],[\"那集群唯一的单例实现起来就有点难度了\",{\"1\":{\"772\":1}}],[\"那对象的唯一性的作用范围是什么呢\",{\"1\":{\"770\":1}}],[\"那对象创建之后会缓存在\",{\"1\":{\"627\":2}}],[\"那这个问题又该如何解决呢\",{\"1\":{\"813\":1}}],[\"那这个时候\",{\"1\":{\"812\":1}}],[\"那这个类就是一个单例类\",{\"1\":{\"770\":1}}],[\"那这两个问题该如何解决呢\",{\"1\":{\"809\":1}}],[\"那这种暴露实现细节的命名方式就不足为奇了\",{\"1\":{\"809\":1}}],[\"那这部分工作就没法让\",{\"1\":{\"627\":1}}],[\"那获取到的\",{\"1\":{\"768\":1}}],[\"那我们就需要考虑是否可以通过解耦的方法\",{\"1\":{\"817\":1}}],[\"那我们就没有必要为其扩展性\",{\"1\":{\"810\":1}}],[\"那我们就没有必要为其设计接口\",{\"1\":{\"810\":1}}],[\"那我们再通过\",{\"1\":{\"812\":1}}],[\"那我们可不可以在\",{\"1\":{\"812\":1}}],[\"那我们在编写单元测试的时候\",{\"1\":{\"767\":1}}],[\"那我们怎么去重写我们想要的date类型参数的方法啊\",{\"1\":{\"291\":1}}],[\"那就没用了\",{\"1\":{\"972\":1}}],[\"那就将它分解成它的组成部分\",{\"1\":{\"947\":1}}],[\"那就需要再定义四个抽象类\",{\"1\":{\"812\":1}}],[\"那就意味着\",{\"1\":{\"809\":1}}],[\"那就花时间来研究下设计模式是非常必要的\",{\"1\":{\"796\":1}}],[\"那就要对代码有比较大的改动\",{\"1\":{\"766\":1}}],[\"那就是把模块与模块之间\",{\"1\":{\"817\":1}}],[\"那就是桥方法\",{\"1\":{\"291\":1}}],[\"那就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法\",{\"1\":{\"223\":1}}],[\"那就是\",{\"1\":{\"204\":1,\"811\":1}}],[\"那到底什么是\",{\"1\":{\"741\":1}}],[\"那自然更容易维护了\",{\"1\":{\"717\":1}}],[\"那每次请求对象\",{\"1\":{\"627\":1}}],[\"那项目中类的个数会成倍增加\",{\"1\":{\"622\":1}}],[\"那何为\",{\"1\":{\"620\":1}}],[\"那工厂类\",{\"1\":{\"614\":1}}],[\"那你肯定没有遇到过为了排查依赖错误引起的问题\",{\"1\":{\"458\":1}}],[\"那样的适应性\",{\"1\":{\"458\":1}}],[\"那样的\",{\"1\":{\"449\":1}}],[\"那可能导致这些新创建的类一直无法被卸载\",{\"1\":{\"312\":1}}],[\"那为什么我们往\",{\"1\":{\"290\":1}}],[\"那使用通配符就没什么意义了\",{\"1\":{\"284\":1}}],[\"那占用时间的\",{\"1\":{\"276\":1}}],[\"那必须在方法头中显式声明该异常\",{\"1\":{\"252\":1}}],[\"那最后的输出结果就是两行了\",{\"1\":{\"96\":1}}],[\"那么junit将自动将它标记为失败\",{\"1\":{\"980\":1}}],[\"那么应使用\",{\"1\":{\"933\":1}}],[\"那么处理器会自动将该位置值更新为新值\",{\"1\":{\"873\":1}}],[\"那么选择utf8mb4来进行存储\",{\"1\":{\"865\":1}}],[\"那么选择排除的方案是不错的\",{\"1\":{\"459\":1}}],[\"那么字符计数方法需要注意\",{\"1\":{\"865\":1}}],[\"那么成绩表中的student\",{\"1\":{\"865\":1}}],[\"那么即使另一列有不同的值\",{\"1\":{\"865\":1}}],[\"那么即使c的区分度更高\",{\"1\":{\"864\":1}}],[\"那么只需要单建idx\",{\"1\":{\"864\":1}}],[\"那么只能存储整数数据\",{\"1\":{\"288\":1}}],[\"那么索引有序性无法利用\",{\"1\":{\"864\":1}}],[\"那么无法使用此索引\",{\"1\":{\"864\":1}}],[\"那么单元测试几乎处于废弃状态\",{\"1\":{\"860\":1}}],[\"那么通过dependency\",{\"1\":{\"869\":1}}],[\"那么通过关键字throws往上抛出\",{\"1\":{\"859\":1}}],[\"那么通常我们如何用呢\",{\"1\":{\"285\":1}}],[\"那么c会强制拆箱成int类型\",{\"1\":{\"852\":1}}],[\"那么线程二的加锁顺序也必须是a\",{\"1\":{\"851\":1}}],[\"那么指定默认值\",{\"1\":{\"850\":1}}],[\"那么试一下把\",{\"1\":{\"850\":1}}],[\"那么必须覆写hashcode和equals\",{\"1\":{\"850\":1}}],[\"那么你会担心的\",{\"1\":{\"848\":1}}],[\"那么限制为protected\",{\"1\":{\"848\":1}}],[\"那么构造方法必须是private\",{\"1\":{\"848\":1}}],[\"那么请修改serialversionuid值\",{\"1\":{\"848\":1}}],[\"那么请使用class类的getfield\",{\"1\":{\"307\":1}}],[\"那么有义务同时提供新的接口\",{\"1\":{\"848\":1}}],[\"那么他们之间就存在依赖关系\",{\"1\":{\"828\":1}}],[\"那么是\",{\"1\":{\"825\":1}}],[\"那么利用解耦的方法对代码重构\",{\"1\":{\"816\":1}}],[\"那么继承就影响非常大\",{\"1\":{\"788\":1}}],[\"那么类型\",{\"1\":{\"732\":1}}],[\"那么类\",{\"1\":{\"721\":1,\"723\":1}}],[\"那么它可以不加注释地被忽略\",{\"1\":{\"950\":1}}],[\"那么它可以省略\",{\"1\":{\"925\":1}}],[\"那么它就是用于类型的注解\",{\"1\":{\"927\":1}}],[\"那么它会把相同的请求传给下一个接收者\",{\"1\":{\"707\":1}}],[\"那么它的构建器看起来应该是这样的\",{\"1\":{\"446\":1}}],[\"那么再创键一个类\",{\"1\":{\"689\":1}}],[\"那么浅拷贝会进行引用传递\",{\"1\":{\"689\":1}}],[\"那么棋子对象就可以减少到只有两个实例\",{\"1\":{\"631\":1}}],[\"那么调用方式就不是确定的\",{\"1\":{\"533\":1}}],[\"那么常规写法如下\",{\"1\":{\"532\":1}}],[\"那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求\",{\"1\":{\"531\":1}}],[\"那么上面就违背了这个原则\",{\"1\":{\"297\":1}}],[\"那么如果后面要扩展\",{\"1\":{\"533\":1}}],[\"那么如果可以再catch子句中使用泛型变量\",{\"1\":{\"297\":1}}],[\"那么如何获取泛型的参数类型呢\",{\"1\":{\"298\":1}}],[\"那么如何进行擦除的呢\",{\"1\":{\"287\":1}}],[\"那么如何解决呢\",{\"1\":{\"284\":1}}],[\"那么也就是说\",{\"1\":{\"297\":1}}],[\"那么两个地方的catch都变为原始类型object\",{\"1\":{\"297\":1}}],[\"那么父类的getvalue方法如下\",{\"1\":{\"291\":1}}],[\"那么父类里面的两个方法的参数都为date类型\",{\"1\":{\"291\":1}}],[\"那么子类中两个setvalue方法\",{\"1\":{\"291\":1}}],[\"那么子类中该方法的访问级别不允许低于父类的访问级别\",{\"1\":{\"132\":1}}],[\"那么到时候取得时候\",{\"1\":{\"290\":1}}],[\"那么当我们使用list2引用用get\",{\"1\":{\"290\":1}}],[\"那么\",{\"1\":{\"290\":2,\"297\":3,\"832\":1,\"840\":1,\"855\":1}}],[\"那么原始类型就是comparable\",{\"1\":{\"289\":1}}],[\"那么原始类型就用第一个边界的类型变量类替换\",{\"1\":{\"289\":1}}],[\"那么还是使用上面的方法\",{\"1\":{\"275\":1}}],[\"那么还是用\",{\"1\":{\"130\":1}}],[\"那么finally导致会不会执行\",{\"1\":{\"275\":1}}],[\"那么异常表用在什么时候呢\",{\"1\":{\"275\":1}}],[\"那么可以用\",{\"1\":{\"972\":1}}],[\"那么可以利用此功能骚扰到其它用户\",{\"1\":{\"861\":1}}],[\"那么可以输出trace和debug级别的日志\",{\"1\":{\"859\":1}}],[\"那么可以将异常包装为自定义异常\",{\"1\":{\"270\":1}}],[\"那么可以不使用throws关键字来声明要抛出的异常\",{\"1\":{\"252\":1}}],[\"那么这些方法的实现其实都是调用的被包装的对象的方法\",{\"1\":{\"996\":1}}],[\"那么这些服务称为弱依赖\",{\"1\":{\"871\":1}}],[\"那么这个参数就是一个\",{\"1\":{\"996\":1}}],[\"那么这个default方法\",{\"1\":{\"845\":1}}],[\"那么这个arraylist可以存储任意的对象\",{\"1\":{\"289\":1}}],[\"那么这种情形既可以被解释为illegalargumentexception\",{\"1\":{\"265\":1}}],[\"那么这两个指针此时指向的是完全不同的对象\",{\"1\":{\"127\":1}}],[\"那么重用arithmeticexception和numberformatexception将是非常合适的\",{\"1\":{\"265\":1}}],[\"那么用起来会非常痛苦\",{\"1\":{\"260\":1}}],[\"那么返回给客户端的时候\",{\"1\":{\"173\":1}}],[\"那么要修改所有实现了该接口的类\",{\"1\":{\"133\":1}}],[\"那么直接暴露成员不会有特别大的影响\",{\"1\":{\"132\":1}}],[\"那么在网络连接过程中\",{\"1\":{\"123\":1}}],[\"那么就应该直接跳转到友好错误页面\",{\"1\":{\"868\":1}}],[\"那么就不会被拦截\",{\"1\":{\"703\":1}}],[\"那么就必须满足里式替换原则\",{\"1\":{\"133\":1}}],[\"那么就需要去修改所有的客户端代码\",{\"1\":{\"132\":1}}],[\"那么就会从\",{\"1\":{\"123\":1}}],[\"那么就会引用相同的对象\",{\"1\":{\"120\":1}}],[\"那么就可以把代码写成下面这个样子\",{\"1\":{\"89\":1}}],[\"那么我们今天就假装自己是一个c语言程序员\",{\"1\":{\"93\":1}}],[\"那么相当于什么都不做\",{\"1\":{\"90\":1}}],[\"那么问题来了\",{\"1\":{\"90\":1}}],[\"那些长期坚持运动的人\",{\"1\":{\"36\":1}}],[\"当块标签不能写在一行的时候\",{\"1\":{\"957\":1}}],[\"当整个\",{\"1\":{\"955\":1}}],[\"当父类方法是\",{\"1\":{\"949\":1}}],[\"当写多行注释的时候\",{\"1\":{\"933\":1}}],[\"当且仅当两行代码以平级的语法元素开头时\",{\"1\":{\"908\":1}}],[\"当进行连续换行时\",{\"1\":{\"908\":1}}],[\"当进程读到代码中的\",{\"1\":{\"770\":1}}],[\"当语句块结束时\",{\"1\":{\"903\":1}}],[\"当语言的文法较为简单\",{\"1\":{\"646\":1}}],[\"当它不是\",{\"1\":{\"902\":1}}],[\"当jvm没有足够的内存来为对象分配空间并且垃圾回收器也无法回收空间时\",{\"1\":{\"873\":1}}],[\"当调用链路中某个下游服务调用的平均响应时间或错误率超过阈值时\",{\"1\":{\"871\":1}}],[\"当调用空命令时\",{\"1\":{\"562\":1}}],[\"当并发连接数很大时很容易因为fd不足而出现\",{\"1\":{\"870\":1}}],[\"当某一列的值全是null时\",{\"1\":{\"865\":1}}],[\"当某个子系统故障\",{\"1\":{\"253\":1}}],[\"当用户浏览时\",{\"1\":{\"861\":1}}],[\"当用户在低版本与高版本之间反复切换工作时\",{\"1\":{\"854\":1}}],[\"当用户需要时能够比较方便地将数据恢复到某个历史的状态\",{\"1\":{\"663\":1}}],[\"当确实有业务需要传较大内容时\",{\"1\":{\"854\":1}}],[\"当一行代码的中断发生在\",{\"1\":{\"907\":2}}],[\"当一次退货商品数量过多时\",{\"1\":{\"854\":1}}],[\"当一个注解被元注解\",{\"1\":{\"927\":1}}],[\"当一个对象发生改变时\",{\"1\":{\"798\":1}}],[\"当一个对象的行为取决于它的状态\",{\"1\":{\"781\":1}}],[\"当一个对象的内在状态改变时\",{\"1\":{\"775\":1}}],[\"当一个对象的状态发生改变时\",{\"1\":{\"671\":1}}],[\"当一个项目开发完后\",{\"1\":{\"796\":1}}],[\"当一个抽象模型有两个方面\",{\"1\":{\"680\":1}}],[\"当一个语言需要解释执行\",{\"1\":{\"646\":1}}],[\"当一个复杂系统的子系统很多时\",{\"1\":{\"604\":1}}],[\"当一个系统的功能越来越强\",{\"1\":{\"593\":1}}],[\"当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时\",{\"1\":{\"545\":1}}],[\"当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时\",{\"1\":{\"545\":1}}],[\"当一个类有多个构造方法\",{\"1\":{\"848\":1}}],[\"当一个类存在两个独立变化的维度\",{\"1\":{\"545\":1}}],[\"当一个类内部具备两种或多种变化维度时\",{\"1\":{\"545\":1}}],[\"当一个异常发生时\",{\"1\":{\"275\":1}}],[\"当一个int类型的数字在无符号右移31位后\",{\"1\":{\"90\":1}}],[\"当方法的代码总行数超过\",{\"1\":{\"852\":1}}],[\"当方法的调用者无力处理该异常的时候\",{\"1\":{\"252\":1}}],[\"当switch括号内的变量类型为string并且此变量为外部参数时\",{\"1\":{\"852\":1}}],[\"当放置的集合元素个数达千万级时会影响程序性能\",{\"1\":{\"850\":1}}],[\"当入参是java\",{\"1\":{\"849\":1}}],[\"当看完某个歌手表演后\",{\"1\":{\"839\":1}}],[\"当给软件系统建模时\",{\"1\":{\"824\":1}}],[\"当多个子类存在公共的行为时\",{\"1\":{\"805\":1}}],[\"当策略过多是会导致类数目庞\",{\"1\":{\"791\":1}}],[\"当状态过多时会产生很多类\",{\"1\":{\"780\":1}}],[\"当控制一个对象状态转换的条件表达式过于复杂时\",{\"1\":{\"775\":1}}],[\"当想实例化一个单例类的时候\",{\"1\":{\"761\":1}}],[\"当想创建一个运行于多个类之间的对象\",{\"1\":{\"661\":1}}],[\"当使用到该方法时\",{\"1\":{\"754\":1}}],[\"当使用类似inputstream这种需要使用后关闭的资源时\",{\"1\":{\"264\":1}}],[\"当软件需要变化时\",{\"1\":{\"736\":1}}],[\"当实现某一个功能存在多种算法或者策略\",{\"1\":{\"783\":1}}],[\"当实现这个接口的时候\",{\"1\":{\"722\":1}}],[\"当实现深克隆时\",{\"1\":{\"682\":1}}],[\"当修改一个功能时\",{\"1\":{\"717\":1}}],[\"当职责\",{\"1\":{\"716\":1}}],[\"当工作流程发生变化\",{\"1\":{\"707\":1}}],[\"当有状态的对象与外部事件产生互动时\",{\"1\":{\"775\":1}}],[\"当有请求发生时\",{\"1\":{\"707\":1}}],[\"当有一个语言需要解释执行\",{\"1\":{\"645\":1}}],[\"当无法或不想直接引用某个对象或访问某个对象存在困难时\",{\"1\":{\"705\":1}}],[\"当请求图片文件等资源时\",{\"1\":{\"704\":1}}],[\"当增加一个第三方\",{\"1\":{\"677\":1}}],[\"当增加一个新的产品族时\",{\"1\":{\"616\":1}}],[\"当第三方再次获取时\",{\"1\":{\"675\":1}}],[\"当第一次调用judge\",{\"1\":{\"92\":1}}],[\"当数据有更新时\",{\"1\":{\"675\":1,\"676\":1,\"678\":2}}],[\"当接到具体主题的更改通知时被调用\",{\"1\":{\"672\":1}}],[\"当具体主题的内部状态发生改变时\",{\"1\":{\"672\":1}}],[\"当观察者对象很多时\",{\"1\":{\"671\":1}}],[\"当大战\",{\"1\":{\"665\":1}}],[\"当各电器对象有多种状态改变时\",{\"1\":{\"658\":1}}],[\"当同事类越多时\",{\"1\":{\"655\":1}}],[\"当访问一个聚合对象的内容而无须暴露其内部细节的表示时\",{\"1\":{\"653\":1}}],[\"当要做回退时\",{\"1\":{\"663\":1}}],[\"当要展示一组相似对象\",{\"1\":{\"652\":1}}],[\"当要解释的句子较复杂时\",{\"1\":{\"641\":1}}],[\"当问题重复出现\",{\"1\":{\"646\":1}}],[\"当遍历完整个\",{\"1\":{\"644\":1}}],[\"当包含的文法规则很多时\",{\"1\":{\"641\":1}}],[\"当客户端需要该对象的某一个职责时\",{\"1\":{\"716\":1}}],[\"当客户端要遍历这些集合元素的时候就要使用多种遍历方式\",{\"1\":{\"648\":1}}],[\"当客户端与多个子系统之间存在很大的联系时\",{\"1\":{\"604\":1}}],[\"当客户对象请求一个享元对象时\",{\"1\":{\"632\":1}}],[\"当创建对象是一个\",{\"1\":{\"620\":1}}],[\"当产品族中需要增加一个新的产品时\",{\"1\":{\"616\":1}}],[\"当对静态类的成员的引用必须是有所限定的时候\",{\"1\":{\"951\":1}}],[\"当对\",{\"1\":{\"950\":1}}],[\"当对已有类进行改造的时候\",{\"1\":{\"682\":1}}],[\"当对象需要被共享的场合\",{\"1\":{\"762\":1}}],[\"当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时\",{\"1\":{\"661\":1}}],[\"当对象的创建逻辑比较复杂\",{\"1\":{\"614\":1}}],[\"当对象的功能要求可以动态地添加\",{\"1\":{\"586\":1}}],[\"当对数组的索引值为负数或大于等于数组大小时抛出\",{\"1\":{\"261\":1}}],[\"当需要控制子类的扩展时\",{\"1\":{\"805\":1}}],[\"当需要增加新的功能时\",{\"1\":{\"797\":1}}],[\"当需要与其他同事对象交互时\",{\"1\":{\"656\":1}}],[\"当需要为遍历不同的聚合结构提供一个统一的接口时\",{\"1\":{\"653\":1}}],[\"当需要为聚合对象提供多种遍历方式时\",{\"1\":{\"653\":1}}],[\"当需要产品族时\",{\"1\":{\"616\":1}}],[\"当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时\",{\"1\":{\"586\":1}}],[\"当需要给一个现有类添加附加职责\",{\"1\":{\"586\":1}}],[\"当需要创建的产品具备复杂创建过程时\",{\"1\":{\"558\":1}}],[\"当系统弱依赖于多个外部服务时\",{\"1\":{\"871\":1}}],[\"当系统一方行为依赖另一方行为的变动时\",{\"1\":{\"680\":1}}],[\"当系统增加一个新的电器对象时\",{\"1\":{\"658\":1}}],[\"当系统中存在类型数量稳定\",{\"1\":{\"841\":1}}],[\"当系统中多处需要同一组信息时\",{\"1\":{\"639\":1}}],[\"当系统中有大量相似对象\",{\"1\":{\"629\":1}}],[\"当系统需要进行分层设计时\",{\"1\":{\"603\":1}}],[\"当系统需要支持命令的撤销\",{\"1\":{\"565\":1}}],[\"当系统需要执行一组操作时\",{\"1\":{\"565\":1}}],[\"当系统的某项操作具备命令语义\",{\"1\":{\"565\":1}}],[\"当桥接\",{\"1\":{\"547\":1}}],[\"当我们运行几个有关联的用例时\",{\"1\":{\"972\":1}}],[\"当我们\",{\"1\":{\"778\":1}}],[\"当我们使用命令行或者双击运行这个可执行文件的时候\",{\"1\":{\"770\":1}}],[\"当我们修改这个类的某一个功能代码的时候\",{\"1\":{\"741\":1}}],[\"当我们开车到交叉路口时\",{\"1\":{\"671\":1}}],[\"当我们落子后\",{\"1\":{\"631\":1}}],[\"当我们会用到大量的创建某种\",{\"1\":{\"608\":1}}],[\"当我们增加新的功能后\",{\"1\":{\"797\":2}}],[\"当我们增加一个单品咖啡\",{\"1\":{\"582\":1}}],[\"当我们增加手机样式时\",{\"1\":{\"541\":1}}],[\"当我们要更改组合对象时\",{\"1\":{\"576\":1}}],[\"当我们从纯代码角度无法看清问题时\",{\"1\":{\"545\":1}}],[\"当我们理解了内置注解\",{\"1\":{\"234\":1}}],[\"当做类\",{\"1\":{\"534\":1}}],[\"当不需要全部实现接口提供的方法时\",{\"1\":{\"531\":1}}],[\"当找到需要的方法\",{\"1\":{\"313\":1}}],[\"当类定义中的类型参数存在限制\",{\"1\":{\"287\":1}}],[\"当类定义中的类型参数没有任何限制时\",{\"1\":{\"287\":1}}],[\"当在方法上声明抛出异常时\",{\"1\":{\"266\":1}}],[\"当应用程序需要使用某个类对象的时候\",{\"1\":{\"621\":1}}],[\"当应用程序试图使用class类中的newinstance\",{\"1\":{\"261\":1}}],[\"当应用试图根据字符串形式的类名构造类\",{\"1\":{\"261\":1}}],[\"当应用试图在要求使用对象的地方使用了null时\",{\"1\":{\"261\":1}}],[\"当执行到某一条语句出现异常时\",{\"1\":{\"257\":1}}],[\"当前主要是velocity渲染\",{\"1\":{\"868\":1}}],[\"当前的最新版本是黄山版\",{\"1\":{\"843\":1}}],[\"当前的状态\",{\"1\":{\"779\":1}}],[\"当前状态\",{\"1\":{\"779\":1}}],[\"当前状态不能发奖品\",{\"1\":{\"778\":1}}],[\"当前状态不能抽奖\",{\"1\":{\"778\":1}}],[\"当前状态可以扣积分\",{\"1\":{\"778\":1}}],[\"当前状态是\",{\"1\":{\"776\":2}}],[\"当前这个对象以对象流的方式输出\",{\"1\":{\"689\":1}}],[\"当前系统业务所期待的接口\",{\"1\":{\"519\":1}}],[\"当前类型为o<t>\",{\"1\":{\"298\":1}}],[\"当前类上找不到注解\",{\"1\":{\"233\":1}}],[\"当前执行的语句必属于某个方法\",{\"1\":{\"252\":1}}],[\"当try语句块里的某条语句出现异常时\",{\"1\":{\"257\":1}}],[\"当try语句块内发生异常时\",{\"1\":{\"251\":1}}],[\"当try捕获到异常\",{\"1\":{\"257\":2}}],[\"当try没有捕获到异常时\",{\"1\":{\"257\":1}}],[\"当try和catch中有return时\",{\"1\":{\"197\":1}}],[\"当程序中可能出现这类异常\",{\"1\":{\"248\":1,\"249\":1}}],[\"当此类错误发生时\",{\"1\":{\"247\":1}}],[\"当条件生成时\",{\"1\":{\"245\":1}}],[\"当class文件被装载时被保存在class文件中的annotation才会被虚拟机读取\",{\"1\":{\"233\":1}}],[\"当编译一个新类时\",{\"1\":{\"145\":1}}],[\"当出现乘法溢出\",{\"1\":{\"139\":1}}],[\"当eclipse启动时\",{\"1\":{\"105\":1}}],[\"当其他的程序需要这个服务的时候\",{\"1\":{\"95\":1}}],[\"当服务的提供者提供了一种接口的实现之后\",{\"1\":{\"95\":1}}],[\"当然这也有好的一面\",{\"1\":{\"820\":1}}],[\"当然外界也会影响其情绪变化\",{\"1\":{\"775\":1}}],[\"当然也可以推送\",{\"1\":{\"675\":1}}],[\"当然也可以通过环境角色间接访问解释器的解释方法\",{\"1\":{\"642\":1}}],[\"当然后面看来\",{\"1\":{\"311\":1}}],[\"当然关于field类还有其他常用的方法如下\",{\"1\":{\"307\":1}}],[\"当然如果只是看简简单单的代码\",{\"1\":{\"275\":1}}],[\"当然了\",{\"1\":{\"93\":1,\"453\":1}}],[\"当然是用在某些不想让别人看懂的地方\",{\"1\":{\"89\":1}}],[\"当然\",{\"1\":{\"89\":1,\"283\":1,\"451\":1,\"462\":1,\"537\":1,\"797\":1,\"812\":1,\"817\":1,\"931\":1}}],[\"当你从类转向模式\",{\"1\":{\"819\":1}}],[\"当你从一个构造器中调用另一个构造器\",{\"1\":{\"171\":1}}],[\"当你想快速试验的时候它能为你节省大量的时间\",{\"1\":{\"482\":1}}],[\"当你拥有了旗舰版的\",{\"1\":{\"481\":1}}],[\"当你尝试首先捕获较不具体的异常时\",{\"1\":{\"267\":1}}],[\"当你在\",{\"1\":{\"264\":1}}],[\"当你在更新依赖\",{\"1\":{\"183\":1}}],[\"当你抛出或捕获异常的时候\",{\"1\":{\"262\":1}}],[\"当你开始着手想办法的时候\",{\"1\":{\"36\":1}}],[\"当你看到别人的缺点时\",{\"1\":{\"36\":1}}],[\"就没有这个限制了\",{\"1\":{\"998\":1}}],[\"就没有达到\",{\"1\":{\"752\":1}}],[\"就好像它是个完整的句子\",{\"1\":{\"958\":1}}],[\"就好像是在开始一段新的代码块\",{\"1\":{\"923\":1}}],[\"就重新抛出一个作为\",{\"1\":{\"950\":1}}],[\"就直接return\",{\"1\":{\"859\":1}}],[\"就直接从缓存池返回\",{\"1\":{\"637\":1}}],[\"就失去了导航的意义\",{\"1\":{\"853\":1}}],[\"就必须覆写hashcode\",{\"1\":{\"850\":1}}],[\"就必须采取某种方式进行处理\",{\"1\":{\"249\":1}}],[\"就隐藏了很多容易出问题的\",{\"1\":{\"809\":1}}],[\"就曾经说过\",{\"1\":{\"797\":1}}],[\"就构成了一个操作系统可以执行的文件\",{\"1\":{\"770\":1}}],[\"就行了\",{\"1\":{\"755\":1}}],[\"就执行静态代码块中的代码\",{\"1\":{\"753\":1}}],[\"就够\",{\"1\":{\"750\":1}}],[\"就越有利于实现可复用的目标\",{\"1\":{\"741\":1}}],[\"就存在\",{\"1\":{\"729\":1}}],[\"就存在强耦合关系\",{\"1\":{\"709\":1}}],[\"就看到最新的信息\",{\"1\":{\"678\":1}}],[\"就主动的调用\",{\"1\":{\"678\":1}}],[\"就调用\",{\"1\":{\"676\":1,\"678\":1}}],[\"就对应一个保存对象状态的对象\",{\"1\":{\"666\":1}}],[\"就解决了\",{\"1\":{\"655\":1}}],[\"就得到最后\",{\"1\":{\"644\":1}}],[\"就得修改原来的代码\",{\"1\":{\"533\":1}}],[\"就表示共享\",{\"1\":{\"638\":1}}],[\"就创建要给\",{\"1\":{\"644\":1}}],[\"就创建新的\",{\"1\":{\"637\":1}}],[\"就创建一个网站\",{\"1\":{\"636\":1}}],[\"就只能选择第一种包含\",{\"1\":{\"614\":1}}],[\"就只是去调用我们自己重写的那两个方法\",{\"1\":{\"291\":1}}],[\"就几行代码而已\",{\"1\":{\"614\":1}}],[\"就意味着\",{\"1\":{\"609\":1}}],[\"就需要在代理对象\",{\"1\":{\"695\":1}}],[\"就需要增加各个品牌手机的类\",{\"1\":{\"541\":1}}],[\"就需要提及exception\",{\"1\":{\"275\":1}}],[\"就无需多言了\",{\"1\":{\"476\":1}}],[\"就有可能导致接口定义不够抽象\",{\"1\":{\"809\":1}}],[\"就有\",{\"1\":{\"460\":1}}],[\"就成了很自然的选择\",{\"1\":{\"460\":1}}],[\"就要注意了\",{\"1\":{\"452\":1}}],[\"就不要用类锁\",{\"1\":{\"851\":1}}],[\"就不要用锁\",{\"1\":{\"851\":1}}],[\"就不要锁整个方法体\",{\"1\":{\"851\":1}}],[\"就不要为其写文档了\",{\"1\":{\"454\":1}}],[\"就不符合要求\",{\"1\":{\"809\":1}}],[\"就不需要去修改核心类\",{\"1\":{\"678\":1}}],[\"就不需要手动关闭\",{\"1\":{\"186\":1}}],[\"就不用写了\",{\"1\":{\"574\":1}}],[\"就不用再加载了\",{\"1\":{\"310\":1}}],[\"就加载了这个类\",{\"1\":{\"305\":1}}],[\"就相当于是进程内唯一\",{\"1\":{\"772\":1}}],[\"就相当于下面的这样\",{\"1\":{\"297\":1}}],[\"就相当于重新创建serviceloader了\",{\"1\":{\"114\":1}}],[\"就比如arraylist中\",{\"1\":{\"289\":1}}],[\"就使用到享元模式\",{\"1\":{\"637\":1}}],[\"就使用到了命令模式\",{\"1\":{\"563\":1}}],[\"就使用了策略模式\",{\"1\":{\"790\":1}}],[\"就使用了简单工厂模式\",{\"1\":{\"618\":1}}],[\"就使用了组合模式\",{\"1\":{\"575\":1}}],[\"就使用了适配器模式\",{\"1\":{\"533\":1}}],[\"就使用\",{\"1\":{\"284\":1}}],[\"就代表着我们不知道具体的类型是什么\",{\"1\":{\"283\":1}}],[\"就像康熙字典的生僻字一样\",{\"1\":{\"857\":1}}],[\"就像公路网与导航软件更新不同步一样\",{\"1\":{\"853\":1}}],[\"就像数学符号和化学符号一样\",{\"1\":{\"822\":1}}],[\"就像一个\",{\"1\":{\"716\":1}}],[\"就像孙悟空拔下猴毛轻轻一吹就变出很多孙悟空一样简单\",{\"1\":{\"682\":1}}],[\"就像完全没有泛型一样\",{\"1\":{\"278\":1,\"287\":1}}],[\"就像下面的这个例子中\",{\"1\":{\"92\":1}}],[\"就返回原对象的一个拷贝\",{\"1\":{\"174\":1}}],[\"就会抛异常\",{\"1\":{\"865\":1}}],[\"就会抛出\",{\"1\":{\"141\":1}}],[\"就会产生意外情况\",{\"1\":{\"858\":1}}],[\"就会触发unsupportedoperationexception异常\",{\"1\":{\"850\":1}}],[\"就会影响所有子类的逻辑\",{\"1\":{\"812\":1}}],[\"就会对整个继承体系造成破坏\",{\"1\":{\"731\":1}}],[\"就会对这个引用调用的方法进行类型检测\",{\"1\":{\"290\":1}}],[\"就会使用到工厂模式\",{\"1\":{\"608\":1}}],[\"就会出现\",{\"1\":{\"582\":1}}],[\"就会用方便的方式解决早餐问题\",{\"1\":{\"579\":1}}],[\"就会有编译错误\",{\"1\":{\"290\":1}}],[\"就会编译出错\",{\"1\":{\"165\":1}}],[\"就会创建对应的运行时常量池\",{\"1\":{\"125\":1}}],[\"就会发现\",{\"1\":{\"36\":1}}],[\"就去读取配置文件中的具体实现\",{\"1\":{\"114\":1}}],[\"就实现了动态添加新的插件\",{\"1\":{\"105\":1}}],[\"就是运行测试程序所需要的先决条件\",{\"1\":{\"997\":1}}],[\"就是那些没有使用到的\",{\"1\":{\"996\":1}}],[\"就是需求的新增\",{\"1\":{\"871\":1}}],[\"就是当对集合中的不同类型数据\",{\"1\":{\"841\":1}}],[\"就是聚合\",{\"1\":{\"832\":1}}],[\"就是组合了\",{\"1\":{\"832\":1}}],[\"就是组合\",{\"1\":{\"832\":1}}],[\"就是其中的一种标准\",{\"1\":{\"823\":1}}],[\"就是保证代码不至于复杂到无法控制的有效手段\",{\"1\":{\"816\":1}}],[\"就是理解其中的\",{\"1\":{\"808\":1}}],[\"就是实现了\",{\"1\":{\"790\":1}}],[\"就是刚刚说的\",{\"1\":{\"773\":1}}],[\"就是下面这个样子\",{\"1\":{\"769\":1,\"773\":1,\"813\":1}}],[\"就是经典的单例模式\",{\"1\":{\"760\":1}}],[\"就是在类装载的时候就完成实例化\",{\"1\":{\"752\":1}}],[\"就是在方法中不能对参数做任何修改\",{\"1\":{\"204\":1}}],[\"就是指相近的功能应该放到同一个类中\",{\"1\":{\"741\":1}}],[\"就是原型模式\",{\"1\":{\"688\":1}}],[\"就是要把\",{\"1\":{\"652\":1}}],[\"就是充当了聚合接口\",{\"1\":{\"651\":1}}],[\"就是\",{\"1\":{\"644\":1,\"750\":1,\"995\":1}}],[\"就是就是具体值\",{\"1\":{\"644\":1}}],[\"就是公式\",{\"1\":{\"644\":1}}],[\"就是使用享元模式返回\",{\"1\":{\"637\":1}}],[\"就是使用装饰者模式\",{\"1\":{\"585\":1}}],[\"就是单品咖啡\",{\"1\":{\"582\":2}}],[\"就是对咖啡的描述\",{\"1\":{\"582\":1}}],[\"就是输出\",{\"1\":{\"574\":2}}],[\"就是将\",{\"1\":{\"534\":1}}],[\"就是一组\",{\"1\":{\"808\":1}}],[\"就是一个类应该只有一个引起变化的原因\",{\"1\":{\"652\":1}}],[\"就是一个装饰者\",{\"1\":{\"585\":1}}],[\"就是一个接口\",{\"1\":{\"543\":1}}],[\"就是一个接口适配器\",{\"1\":{\"532\":1}}],[\"就是一种\",{\"1\":{\"210\":1}}],[\"就是为你而生\",{\"1\":{\"473\":1}}],[\"就是为了解决类型转换的问题\",{\"1\":{\"290\":2}}],[\"就是匹配到方法名\",{\"1\":{\"311\":1}}],[\"就是如何比较构造是否是要查找构造器\",{\"1\":{\"310\":1}}],[\"就是编译器自己生成的桥方法\",{\"1\":{\"291\":1}}],[\"就是擦除去了泛型信息\",{\"1\":{\"289\":1}}],[\"就是类似这样的代码\",{\"1\":{\"275\":1}}],[\"就是java\",{\"1\":{\"171\":1}}],[\"就是先判断值是否在缓存池中\",{\"1\":{\"120\":1}}],[\"就是应用类加载器\",{\"1\":{\"114\":1}}],[\"就是定义接口\",{\"1\":{\"109\":1}}],[\"就是我们普通的连接数据库的代码\",{\"1\":{\"103\":1}}],[\"就是让他在遇到条件判断时失去基本判断能力\",{\"1\":{\"91\":1}}],[\"就可以重定义该算法的某些特定步骤\",{\"1\":{\"800\":1}}],[\"就可以自动释放它\",{\"1\":{\"705\":1}}],[\"就可以了\",{\"1\":{\"655\":1}}],[\"就可以考虑使用状态模式\",{\"1\":{\"781\":1}}],[\"就可以考虑使用解释器模式\",{\"1\":{\"645\":1}}],[\"就可以考虑使用建造者模式\",{\"1\":{\"558\":1}}],[\"就可以多线程的执行命令\",{\"1\":{\"564\":1}}],[\"就可以控制全部智能家电\",{\"1\":{\"562\":1}}],[\"就可以控制对这些家电工作\",{\"1\":{\"562\":1}}],[\"就可以直接使用缓冲池中的对象\",{\"1\":{\"120\":1}}],[\"就可以使用该服务了\",{\"1\":{\"95\":1}}],[\"就可以通过查找这个jar包\",{\"1\":{\"95\":1}}],[\"就可以搞复杂点\",{\"1\":{\"93\":1}}],[\"就能很好地得到解决\",{\"1\":{\"775\":1}}],[\"就能很容易识别出来\",{\"1\":{\"765\":1}}],[\"就能实现该类的方法\",{\"1\":{\"727\":1}}],[\"就能使用该类的方法\",{\"1\":{\"725\":1}}],[\"就能得到最新数据\",{\"1\":{\"675\":1}}],[\"就能够实现上面提到的功能\",{\"1\":{\"92\":1}}],[\"就能同时输出if和else中的打印语句\",{\"1\":{\"92\":1}}],[\"就能解释为什么能够执行注释中的语句了\",{\"1\":{\"89\":1}}],[\"还必须指出该方法做什么事情\",{\"1\":{\"853\":1}}],[\"还能指导粗粒度的系统\",{\"1\":{\"816\":1}}],[\"还需要显式地将对象从内存中删除\",{\"1\":{\"772\":1}}],[\"还需要注意不同测试用例之间\",{\"1\":{\"767\":1}}],[\"还代表了线程内\",{\"1\":{\"771\":1}}],[\"还可以通过程序员自己来保证\",{\"1\":{\"769\":1}}],[\"还可以扩展自定义的svg标签\",{\"1\":{\"408\":1}}],[\"还未来得及往下执行\",{\"1\":{\"754\":1}}],[\"还为常见系统函数提供了接口\",{\"1\":{\"417\":1}}],[\"还会带来url维护不一致的问题\",{\"1\":{\"870\":1}}],[\"还会存在竞态条件\",{\"1\":{\"164\":1}}],[\"还会解析unicode编码将它替换成对应的字符\",{\"1\":{\"89\":1}}],[\"还是long型的\",{\"1\":{\"846\":1}}],[\"还是需要付出额外努力的\",{\"1\":{\"819\":1}}],[\"还是那句话\",{\"1\":{\"814\":1}}],[\"还是指进程内只允许创建一个对象\",{\"1\":{\"770\":1}}],[\"还是无法解决\",{\"1\":{\"769\":1}}],[\"还是直接调用模块好\",{\"1\":{\"603\":1}}],[\"还是组合对象\",{\"1\":{\"567\":1}}],[\"还是通过\",{\"1\":{\"311\":1}}],[\"还是object类型的呢\",{\"1\":{\"290\":1}}],[\"还是要回归到设计原则诞生的初衷上来\",{\"1\":{\"810\":1}}],[\"还是要自己强转\",{\"1\":{\"290\":1}}],[\"还是要使用java中的魔法类unsafe\",{\"1\":{\"93\":1}}],[\"还是有很多新的特性\",{\"1\":{\"186\":1}}],[\"还是\",{\"0\":{\"163\":1,\"167\":1}}],[\"还有顾客在商场购物时放在\",{\"1\":{\"837\":1}}],[\"还有另外一种使用方法\",{\"1\":{\"769\":1}}],[\"还有异常处理中\",{\"1\":{\"707\":1}}],[\"还有因为安全原因需要屏蔽客户端直接访问真实对象\",{\"1\":{\"692\":1}}],[\"还有数据库中事务操作\",{\"1\":{\"669\":1}}],[\"还有在\",{\"1\":{\"663\":1}}],[\"还有大家常用的\",{\"1\":{\"655\":1}}],[\"还有就是手机的重启功能\",{\"1\":{\"601\":1}}],[\"还有汽车中的方向盘\",{\"1\":{\"549\":1}}],[\"还有\",{\"1\":{\"476\":1,\"586\":1,\"616\":1,\"648\":1,\"671\":1,\"707\":1,\"750\":1}}],[\"还有一个中间层次\",{\"1\":{\"819\":1}}],[\"还有一个直接的衡量标准\",{\"1\":{\"817\":1}}],[\"还有一个点\",{\"1\":{\"310\":1}}],[\"还有一些设计模式也是为了解耦依赖\",{\"1\":{\"818\":1}}],[\"还有一些设计模式会固定使用继承或者组合\",{\"1\":{\"814\":1}}],[\"还有一些特殊的场景要求我们必须使用继承\",{\"1\":{\"814\":1}}],[\"还有一些其他的支持\",{\"1\":{\"460\":1}}],[\"还有一种理解方式\",{\"1\":{\"773\":1}}],[\"还有一点也许会有疑问\",{\"1\":{\"291\":1}}],[\"还有线程调度\",{\"1\":{\"93\":1}}],[\"还有很多高级一点的用法\",{\"1\":{\"93\":1}}],[\"还不会编写\",{\"1\":{\"9\":1}}],[\"而有时我们仅仅需要在测试前进行一次初始化\",{\"1\":{\"997\":1}}],[\"而能写出一些功能代码则说明对需求有一定理解了\",{\"1\":{\"991\":1}}],[\"而第三种方案写的单测\",{\"1\":{\"991\":1}}],[\"而第二个用例需要修改用户a\",{\"1\":{\"972\":1}}],[\"而线上由于数据库版本不一样\",{\"1\":{\"866\":1}}],[\"而线程间可以不唯一\",{\"1\":{\"771\":1}}],[\"而数据库字段必须加is\",{\"1\":{\"866\":1}}],[\"而isnull\",{\"1\":{\"865\":1}}],[\"而覆盖索引只是一种查询的一种效果\",{\"1\":{\"864\":1}}],[\"而单元测试框架默认是扫描此目录\",{\"1\":{\"860\":1}}],[\"而单例类这种硬编码式的使用方式\",{\"1\":{\"767\":1}}],[\"而应依赖使用日志框架\",{\"1\":{\"859\":1}}],[\"而应用内部推荐异常抛出\",{\"1\":{\"858\":1}}],[\"而应该提供相应的访问器\",{\"1\":{\"741\":1}}],[\"而日期\",{\"1\":{\"853\":1}}],[\"而eclipse的\",{\"1\":{\"853\":1}}],[\"而entryset只是遍历了一次就把key和value都放到了entry中\",{\"1\":{\"850\":1}}],[\"而return是退出方法体\",{\"1\":{\"852\":1}}],[\"而事实上\",{\"1\":{\"850\":1}}],[\"而<dependencies>所有声明在主pom的<dependencies>里的依赖都会自动引入\",{\"1\":{\"869\":1}}],[\"而<\",{\"1\":{\"850\":1}}],[\"而大写的yyyy代表是week\",{\"1\":{\"849\":1}}],[\"而私有方法外部一般不需要特别关心\",{\"1\":{\"848\":1}}],[\"而私有云不需要\",{\"1\":{\"809\":1}}],[\"而double的tostring按double的实际能表达的精度对尾数进行了截断\",{\"1\":{\"848\":1}}],[\"而count\",{\"1\":{\"865\":1}}],[\"而compareto\",{\"1\":{\"848\":1}}],[\"而class\",{\"1\":{\"283\":1}}],[\"而class<t>类型的变量c\",{\"1\":{\"283\":1}}],[\"而左大括号前需要加空格\",{\"1\":{\"847\":1}}],[\"而局部变量在同一方法内的不同代码块中同名也是合法的\",{\"1\":{\"845\":1}}],[\"而又不会对数据产生任何副作用\",{\"1\":{\"841\":1}}],[\"而又不能采用生成子类的方法进行扩充时\",{\"1\":{\"586\":1}}],[\"而没有依赖抽象类\",{\"1\":{\"837\":1}}],[\"而没有处理此异常的catch语句块时\",{\"1\":{\"257\":1}}],[\"而收银员关心的是商品的价格和数量\",{\"1\":{\"837\":1}}],[\"而相对于代码结构的调整\",{\"1\":{\"816\":1}}],[\"而入参又非接口\",{\"1\":{\"814\":1}}],[\"而父类中定义的却只是\",{\"1\":{\"814\":1}}],[\"而模板模式\",{\"1\":{\"814\":1}}],[\"而这三个作用都可以通过其他技术手段来达成\",{\"1\":{\"813\":1}}],[\"而这种层次很深\",{\"1\":{\"812\":1}}],[\"而这样做就会存在一些问题\",{\"1\":{\"809\":1}}],[\"而我们把这种包含\",{\"1\":{\"809\":1}}],[\"而我们仅仅捕获了一个exception\",{\"1\":{\"275\":1}}],[\"而把可变部分算法由子类继承实现\",{\"1\":{\"800\":1}}],[\"而把影响对象行为的一个或多个动态变化的属性称为状态\",{\"1\":{\"775\":1}}],[\"而将一些步骤延迟到子类中\",{\"1\":{\"800\":1}}],[\"而算法的实现移到具体策略类中\",{\"1\":{\"783\":1}}],[\"而工厂模式创建的是不同子类的对象\",{\"1\":{\"773\":1}}],[\"而构建的过程也没有给与提示\",{\"1\":{\"768\":1}}],[\"而非\",{\"1\":{\"764\":1}}],[\"而非简单工厂模式呢\",{\"0\":{\"614\":1}}],[\"而其实这个方法只执行\",{\"1\":{\"755\":1}}],[\"而出现在局部变量中的类不是直接的朋友\",{\"1\":{\"741\":1}}],[\"而消费者伤心\",{\"1\":{\"671\":1}}],[\"而如果遍历方式改变的话\",{\"1\":{\"652\":1}}],[\"而如果创建复杂对象\",{\"1\":{\"558\":1}}],[\"而解释器模式是类行为型模式\",{\"1\":{\"642\":1}}],[\"而后这些词法单元再通过语法分析器构建语法分析树\",{\"1\":{\"641\":1}}],[\"而外部状态具有固化特性\",{\"1\":{\"638\":1}}],[\"而当每个连接要被回收利用时\",{\"1\":{\"631\":1}}],[\"而各个棋子之间的差别就是位置的不同\",{\"1\":{\"631\":1}}],[\"而使你的代码可读性变差\",{\"1\":{\"885\":1}}],[\"而使用策略模式可以避免使用多重条件语句\",{\"1\":{\"783\":1}}],[\"而使用简单工厂模式\",{\"1\":{\"614\":1}}],[\"而使调用者无感知\",{\"1\":{\"694\":1}}],[\"而使这些子系统更加容易被访问的模式\",{\"1\":{\"593\":1}}],[\"而创建的对象又频繁被销毁的时候\",{\"1\":{\"762\":1}}],[\"而创建\",{\"1\":{\"609\":1}}],[\"而抽象就是提高代码扩展性\",{\"1\":{\"808\":1}}],[\"而抽象工厂模式可生产多个等级的产品\",{\"1\":{\"616\":1}}],[\"而抽象工厂只提供创建产品的接口\",{\"1\":{\"614\":1}}],[\"而抽象工厂的原理稍微复杂点\",{\"1\":{\"606\":1}}],[\"而抽象类的成员可以有多种访问权限\",{\"1\":{\"133\":1}}],[\"而抽象类的字段没有这种限制\",{\"1\":{\"133\":1}}],[\"而采用装饰器模式却很好实现\",{\"1\":{\"586\":1}}],[\"而建造者模式则是要求按照指定的蓝图建造产品\",{\"1\":{\"557\":1}}],[\"而与其他的具体建造者无关\",{\"1\":{\"557\":1}}],[\"而通过字节码生存的则考虑了卸载功能\",{\"1\":{\"313\":1}}],[\"而通配符形式本来就需要自己强转\",{\"1\":{\"294\":1}}],[\"而反射生成的类\",{\"1\":{\"312\":1}}],[\"而getparametertypes\",{\"1\":{\"308\":1}}],[\"而getdeclaredmethod\",{\"1\":{\"308\":1}}],[\"而get\",{\"1\":{\"307\":1}}],[\"而getvalue却有普遍的意义\",{\"1\":{\"291\":1}}],[\"而静态变量和静态方法不需要使用对象来调用\",{\"1\":{\"296\":1}}],[\"而静态内部类不需要\",{\"1\":{\"144\":1}}],[\"而运行时能起作用的技术最好的就是反射了\",{\"1\":{\"295\":1}}],[\"而子类重写的方法是\",{\"1\":{\"291\":1}}],[\"而子类的类型是date\",{\"1\":{\"291\":1}}],[\"而桥方法的内部实现\",{\"1\":{\"291\":1}}],[\"而打在我们自己定义的setvalue和getvalue方法上面的\",{\"1\":{\"291\":1}}],[\"而无需指明具体的类\",{\"1\":{\"616\":1}}],[\"而无需关心这个子系统的内部细节\",{\"1\":{\"600\":1}}],[\"而无关它真正引用的对象\",{\"1\":{\"290\":1}}],[\"而无法获取\",{\"1\":{\"209\":1}}],[\"而引用list2没有使用泛型\",{\"1\":{\"290\":1}}],[\"而真正涉及类型检查的是它的引用\",{\"1\":{\"290\":1}}],[\"而参数\",{\"1\":{\"284\":1}}],[\"而泛型方法可以在调用的时候指明类型\",{\"1\":{\"283\":1}}],[\"而抛出\",{\"1\":{\"276\":1}}],[\"而此时由于异常被捕获\",{\"1\":{\"269\":1}}],[\"而指定的类对象无法被实例化时\",{\"1\":{\"261\":1}}],[\"而在显示端没有做降级预案\",{\"1\":{\"871\":1}}],[\"而在jdk7之前\",{\"1\":{\"851\":1}}],[\"而在eclipse中\",{\"1\":{\"847\":1}}],[\"而在软件层面\",{\"1\":{\"663\":1}}],[\"而在编译的时候\",{\"1\":{\"297\":1}}],[\"而在遍历classpah之后找不到对应名称的class文件时\",{\"1\":{\"261\":1}}],[\"而在之后再使用true进行定义boolean类型的变量过程中\",{\"1\":{\"91\":1}}],[\"而try语句块中\",{\"1\":{\"257\":1}}],[\"而true实际上是false\",{\"1\":{\"91\":1}}],[\"而且父类中的被\",{\"1\":{\"976\":1}}],[\"而且正在缓慢减速\",{\"1\":{\"873\":1}}],[\"而且不能工作\",{\"1\":{\"853\":1}}],[\"而且可读性更好\",{\"1\":{\"850\":1}}],[\"而且可以独立地改变它们之间的交互\",{\"1\":{\"655\":1}}],[\"而且要避免让这些操作的变化影响对象的结构\",{\"1\":{\"841\":1}}],[\"而且使用于从需求规格描述直至系统完成后的测试和维护等系统开发的各个阶段\",{\"1\":{\"823\":1}}],[\"而且融入了软件工程领域的新思想\",{\"1\":{\"823\":1}}],[\"而且在将来需求发生变化的时候\",{\"1\":{\"808\":1}}],[\"而且确定了这些步骤的执行顺序\",{\"1\":{\"800\":1}}],[\"而且增加\",{\"1\":{\"783\":1}}],[\"而且容易出错\",{\"1\":{\"780\":1}}],[\"而且修改某个状态类的行为也需要修改对应类的源码\",{\"1\":{\"775\":1}}],[\"而且当对象之间存在多重嵌套引用时\",{\"1\":{\"682\":1}}],[\"而且有可能出现循环引用\",{\"1\":{\"671\":1}}],[\"而且每一次保存都会消耗一定的内存\",{\"1\":{\"668\":1}}],[\"而且还能防止反序列化重新创建新的对象\",{\"1\":{\"759\":1}}],[\"而且还会暴露元素的内部结构\",{\"1\":{\"648\":1}}],[\"而且还易学易用\",{\"1\":{\"430\":1}}],[\"而且组合模式是对象结构型模式\",{\"1\":{\"642\":1}}],[\"而且都不是高访问量网站\",{\"1\":{\"635\":1}}],[\"而且很多参数都具有默认值\",{\"1\":{\"558\":1}}],[\"而且扩展困难\",{\"1\":{\"537\":1}}],[\"而且能快速构建\",{\"1\":{\"392\":1}}],[\"而且这个class对象保存在同名\",{\"1\":{\"302\":1}}],[\"而且大部分事情都是为了改善代码的可读性或者\",{\"1\":{\"262\":1}}],[\"而且一旦发生这种异常状况\",{\"1\":{\"249\":1}}],[\"而且\",{\"1\":{\"230\":1,\"264\":1,\"655\":1,\"770\":1,\"809\":1,\"816\":1}}],[\"而boolean和浮点型不可以\",{\"1\":{\"193\":1}}],[\"而不暴露聚合对象的内部表示\",{\"1\":{\"798\":1}}],[\"而不涉及任何具体的操作\",{\"1\":{\"725\":1}}],[\"而不需要实现接口\",{\"1\":{\"692\":1}}],[\"而不需要关心是男性还是女性\",{\"1\":{\"648\":1}}],[\"而不必担心破坏现有的代码\",{\"1\":{\"990\":1}}],[\"而不必专门引入多个新的类来进行管理\",{\"1\":{\"616\":1}}],[\"而不必知道具体的接收者对象是谁\",{\"1\":{\"564\":1}}],[\"而不知道具体的产品名\",{\"1\":{\"614\":1}}],[\"而不用调用多个接口才能达到目的\",{\"1\":{\"601\":1}}],[\"而不对其它模块产生任何影响\",{\"1\":{\"549\":1}}],[\"而不仅是在\",{\"1\":{\"449\":1}}],[\"而不会知道聚合的具体组成\",{\"1\":{\"652\":1}}],[\"而不会对其他调用者返回的数组产生任何影响\",{\"1\":{\"233\":2}}],[\"而不会生成新的对象\",{\"1\":{\"192\":1}}],[\"而不是将代码部署到设备之后\",{\"1\":{\"990\":1}}],[\"而不是一个完整的句子\",{\"1\":{\"958\":1}}],[\"而不是一下子全部按照这些建议来做\",{\"1\":{\"443\":1}}],[\"而不是该类的类型的引用或者表达式\",{\"1\":{\"951\":1}}],[\"而不是该对象本身\",{\"1\":{\"173\":1}}],[\"而不是对应的八进制\",{\"1\":{\"884\":1}}],[\"而不是全部\",{\"1\":{\"871\":1}}],[\"而不是0\",{\"1\":{\"869\":1}}],[\"而不是true\",{\"1\":{\"865\":2}}],[\"而不是false\",{\"1\":{\"865\":1}}],[\"而不是让错误码本身涵盖过多具体业务属性\",{\"1\":{\"857\":1}}],[\"而不是简单地注释掉\",{\"1\":{\"853\":1}}],[\"而不是keyset方式进行遍历\",{\"1\":{\"850\":1}}],[\"而不是size\",{\"1\":{\"850\":1}}],[\"而不是new\",{\"1\":{\"849\":1}}],[\"而不是equals\",{\"1\":{\"848\":1}}],[\"而不是抽象元素\",{\"1\":{\"840\":1}}],[\"而不是大而全\",{\"1\":{\"818\":1}}],[\"而不是怎么做\",{\"1\":{\"809\":1}}],[\"而不是具体的实现类来编程\",{\"1\":{\"809\":1}}],[\"而不是更复杂\",{\"1\":{\"797\":1}}],[\"而不是行为的继承\",{\"1\":{\"791\":1}}],[\"而不是使用静态导入\",{\"1\":{\"893\":1}}],[\"而不是使用\",{\"1\":{\"761\":1}}],[\"而不是使用继承\",{\"1\":{\"748\":1}}],[\"而不是使用原来的实例\",{\"1\":{\"313\":1}}],[\"而不是针对实现编程\",{\"1\":{\"746\":1}}],[\"而不是其具体实现\",{\"1\":{\"708\":1}}],[\"而不是动态地获得对象运行时的状态\",{\"1\":{\"686\":1}}],[\"而不是任由客人临时定制\",{\"1\":{\"560\":1}}],[\"而不是继承\",{\"1\":{\"545\":1}}],[\"而不是每次抛出异常的时候都强制它们去处理\",{\"1\":{\"448\":1}}],[\"而不是泛型类中的t\",{\"1\":{\"296\":1}}],[\"而不是重载了\",{\"1\":{\"291\":1}}],[\"而不是名字的基础上\",{\"1\":{\"265\":1}}],[\"而不是囫囵吞枣\",{\"1\":{\"252\":1}}],[\"而不是\",{\"1\":{\"211\":1,\"736\":1,\"935\":1,\"939\":1}}],[\"而不是都为\",{\"1\":{\"133\":1}}],[\"而不是引用传递\",{\"1\":{\"127\":1}}],[\"而不是贬低他人\",{\"1\":{\"36\":1}}],[\"而对于下面的代码来说是成立的\",{\"1\":{\"294\":1}}],[\"而对于hashmap\",{\"1\":{\"181\":1}}],[\"而对stringbuffer和stringbuilder的操作是对对象本身的操作\",{\"1\":{\"192\":1}}],[\"而stringbuffer和stringbuilder是可变字符序列\",{\"1\":{\"192\":1}}],[\"而接口隔离原则注重的是对接口依赖的隔离\",{\"1\":{\"721\":1}}],[\"而接口能更好的定义类型\",{\"1\":{\"189\":1}}],[\"而接口更像是一种\",{\"1\":{\"133\":1}}],[\"而嵌套静态类没有这个要求\",{\"1\":{\"184\":1}}],[\"而堆区\",{\"1\":{\"125\":1}}],[\"而字符串常量池是这个过程中常量字符串的存放位置\",{\"1\":{\"125\":1}}],[\"而\",{\"1\":{\"125\":1,\"138\":1,\"139\":1,\"151\":4,\"161\":1,\"178\":1,\"180\":1,\"312\":1,\"469\":1,\"549\":1,\"556\":1,\"621\":1,\"641\":1,\"769\":1,\"972\":1,\"981\":1,\"996\":2}}],[\"而实现高内聚的重要指导原则就是单一职责原则\",{\"1\":{\"818\":1}}],[\"而实际情况却不一定是\",{\"1\":{\"123\":1}}],[\"而实例化的新对象不满足后面的equals\",{\"1\":{\"92\":1}}],[\"而是提供一个带有\",{\"1\":{\"996\":1}}],[\"而是越有效越好\",{\"1\":{\"992\":1}}],[\"而是使用\",{\"1\":{\"877\":1}}],[\"而是取offset+n行\",{\"1\":{\"864\":1}}],[\"而是arraylist的一个视图\",{\"1\":{\"850\":1}}],[\"而是限制过度个性化\",{\"1\":{\"843\":1}}],[\"而是将图片存储到自建私有云上\",{\"1\":{\"809\":1}}],[\"而是将计算机的配置要求告诉计算机销售公司\",{\"1\":{\"549\":1}}],[\"而是如何组织这些算法\",{\"1\":{\"784\":1}}],[\"而是在需要实例化时\",{\"1\":{\"758\":1}}],[\"而是在子类中定义了一个新的方法\",{\"1\":{\"143\":1}}],[\"而是用过方法参数\",{\"1\":{\"748\":1}}],[\"而是通过threadpoolexecutor的方式\",{\"1\":{\"851\":1}}],[\"而是通过方法参数\",{\"1\":{\"745\":1}}],[\"而是通过接口来间接引用\",{\"1\":{\"725\":1}}],[\"而是一个陌生类\",{\"1\":{\"742\":1}}],[\"而是一个树形结构\",{\"1\":{\"573\":1}}],[\"而是动态地获得对象运行时的状态\",{\"1\":{\"690\":1}}],[\"而是放到配置文件中\",{\"1\":{\"627\":1}}],[\"而是继承抽象类或者是实现\",{\"1\":{\"619\":1}}],[\"而是继续进行匹配\",{\"1\":{\"311\":1}}],[\"而是继续执行finally块中的语句\",{\"1\":{\"273\":1,\"858\":1}}],[\"而是把这个\",{\"1\":{\"619\":1}}],[\"而是要组合其他类对象\",{\"1\":{\"614\":1}}],[\"而是已经预先配置好的\",{\"1\":{\"560\":1}}],[\"而是持有\",{\"1\":{\"527\":1}}],[\"而是交给了jvm去加载\",{\"1\":{\"310\":1}}],[\"而是重载\",{\"1\":{\"291\":1}}],[\"而是到了这里\",{\"1\":{\"275\":1}}],[\"而是先把要返回的值保存起来\",{\"1\":{\"197\":1}}],[\"而是\",{\"1\":{\"141\":1,\"795\":1}}],[\"而是等到使用迭代器去遍历的时候\",{\"1\":{\"114\":1}}],[\"而是直接使用如下代码\",{\"1\":{\"102\":1}}],[\"而加载的过程是由springfactoriesloader加载的\",{\"1\":{\"106\":1}}],[\"而jvm解决方法就是桥接方法\",{\"1\":{\"291\":1}}],[\"而junit3\",{\"1\":{\"241\":1}}],[\"而jdbc4\",{\"1\":{\"98\":1}}],[\"而java的spi机制可以为某个接口寻找服务实现\",{\"1\":{\"95\":1}}],[\"而java中的编译器\",{\"1\":{\"89\":1}}],[\"它\",{\"1\":{\"958\":1}}],[\"它违反了一些约定\",{\"1\":{\"947\":1}}],[\"它只针对于行内的空格\",{\"1\":{\"911\":1}}],[\"它只是提供一种方法实现契约\",{\"1\":{\"133\":1}}],[\"它由原子钟提供\",{\"1\":{\"873\":1}}],[\"它由一个模板方法和若干个基本方法构成\",{\"1\":{\"801\":1}}],[\"它指的是恶意攻击者往web页面里插入恶意html代码\",{\"1\":{\"861\":1}}],[\"它描述了类或组件对外可见的动作\",{\"1\":{\"825\":1}}],[\"它具有类的结构但不可被实例化\",{\"1\":{\"825\":1}}],[\"它用于帮助软件开发人员进行思考和记录思路的结果\",{\"1\":{\"822\":1}}],[\"它先于很多编程语言而诞生\",{\"1\":{\"808\":1}}],[\"它默认不做任何事\",{\"1\":{\"803\":1}}],[\"它提高了代码阅读的难度\",{\"1\":{\"800\":1}}],[\"它提供了一个用于保存观察者对象的聚集类和增加\",{\"1\":{\"672\":1}}],[\"它提供了一种抽象\",{\"1\":{\"188\":1}}],[\"它提供了\",{\"1\":{\"246\":1,\"484\":1}}],[\"它提供自动垃圾收集来进行内存管理\",{\"1\":{\"206\":1}}],[\"它在父类中提取了公共的部分代码\",{\"1\":{\"800\":1}}],[\"它把认为是不变部分的算法封装到父类中实现\",{\"1\":{\"800\":1}}],[\"它封装了不变部分\",{\"1\":{\"800\":1}}],[\"它可能是存款\",{\"1\":{\"800\":1}}],[\"它可以包含零条或多条语句\",{\"1\":{\"922\":1}}],[\"它可以在运行期扩展\",{\"1\":{\"702\":1}}],[\"它可以访问\",{\"1\":{\"694\":1}}],[\"它可以访问备忘录里的所有信息\",{\"1\":{\"664\":1}}],[\"它可以将复杂对象的建造过程抽象出来\",{\"1\":{\"549\":1}}],[\"它可以是抽象类或接口\",{\"1\":{\"519\":1}}],[\"它可以和想\",{\"1\":{\"484\":1}}],[\"它可以让你以注解的方式减少\",{\"1\":{\"471\":1}}],[\"它可以取的值如下所示\",{\"1\":{\"225\":1}}],[\"它可以看成是一个完全抽象的类\",{\"1\":{\"133\":1}}],[\"它通过对算法进行封装\",{\"1\":{\"783\":1}}],[\"它通常拥有很多的命令对象\",{\"1\":{\"561\":1}}],[\"它定义了客户端需要的接口\",{\"1\":{\"776\":1}}],[\"它定义了类必须得遵循的规则\",{\"1\":{\"188\":1}}],[\"它跟工厂模式的不同之处是\",{\"1\":{\"773\":1}}],[\"它就在自己的地址空间中创建一个\",{\"1\":{\"770\":1}}],[\"它就是javap\",{\"1\":{\"275\":1}}],[\"它无法支持延迟加载\",{\"1\":{\"769\":1}}],[\"它充当数据存储源的代理\",{\"1\":{\"750\":1}}],[\"它维持了类的封装性\",{\"1\":{\"747\":1}}],[\"它限制了复用的灵活性\",{\"1\":{\"747\":1}}],[\"它要求在软件复用时\",{\"1\":{\"745\":1}}],[\"它要求每个对象都必须知道它需要交互的对象\",{\"1\":{\"655\":1}}],[\"它克服了继承中重写父类造成的可复用性变差的缺点\",{\"1\":{\"733\":1}}],[\"它反映了基类与子类之间的关系\",{\"1\":{\"732\":1}}],[\"它反映此\",{\"1\":{\"308\":1}}],[\"它针对的是程序中的实现和细节\",{\"1\":{\"721\":1}}],[\"它广泛的被许多\",{\"1\":{\"702\":1}}],[\"它实现抽象目标中的通知方法\",{\"1\":{\"672\":1}}],[\"它实现了抽象享元接口\",{\"1\":{\"632\":1}}],[\"它以参数的形式注入具体享元的相关方法中\",{\"1\":{\"632\":1}}],[\"它负责根据从配置文件解析得到的\",{\"1\":{\"627\":1}}],[\"它负责加载具体的日志实现\",{\"1\":{\"104\":1}}],[\"它支持以不同方式遍历一个聚合\",{\"1\":{\"648\":1}}],[\"它支持的配置格式非常灵活和复杂\",{\"1\":{\"624\":1}}],[\"它支持web\",{\"1\":{\"387\":1}}],[\"它能在程序运行的过程中\",{\"1\":{\"622\":1}}],[\"它能够在更高层次上提高代码的可读性和可维护性\",{\"1\":{\"816\":1}}],[\"它能够获取到堆栈信息让你查阅\",{\"1\":{\"485\":1}}],[\"它能够修饰的程序元素包括类型\",{\"1\":{\"225\":1}}],[\"它还有点类似享元模式\",{\"1\":{\"773\":1}}],[\"它还有一些静态类如\",{\"1\":{\"466\":1}}],[\"它还包括配置的解析\",{\"1\":{\"621\":1}}],[\"它处理的是更大的对象创建工程\",{\"1\":{\"621\":1}}],[\"它包含抽象操作\",{\"1\":{\"825\":1}}],[\"它包含了一个更新自己的抽象方法\",{\"1\":{\"672\":1}}],[\"它包含了对各个子系统的引用\",{\"1\":{\"594\":1}}],[\"它包含多个创建产品的方法\",{\"1\":{\"616\":1}}],[\"它同具体工厂之间是多对一的关系\",{\"1\":{\"616\":1}}],[\"它同具体工厂之间一一对应\",{\"1\":{\"612\":1}}],[\"它同时支持\",{\"1\":{\"472\":1}}],[\"它属于对象结构型模式\",{\"1\":{\"579\":1}}],[\"它没有子节点\",{\"1\":{\"568\":1}}],[\"它没有使用许多我们尽力避免使用的样板\",{\"1\":{\"446\":1}}],[\"它创建了对象组的树形结构\",{\"1\":{\"567\":1}}],[\"它为我们省去了判空的操作\",{\"1\":{\"564\":1}}],[\"它拥有接收者对象\",{\"1\":{\"561\":1}}],[\"它拥有简洁的代码\",{\"1\":{\"424\":1,\"434\":1}}],[\"它调用建造者对象中的部件构造与装配方法完成复杂对象的创建\",{\"1\":{\"551\":1}}],[\"它允许用户只通过指定复杂对象的类型和内容就可以构建它们\",{\"1\":{\"549\":1}}],[\"它允许我们在运行时发现和使用类的信息\",{\"1\":{\"301\":1}}],[\"它空实现了\",{\"1\":{\"532\":1}}],[\"它让你在\",{\"1\":{\"474\":1}}],[\"它让你可以写更多的流畅的代码\",{\"1\":{\"455\":1}}],[\"它对\",{\"1\":{\"472\":1}}],[\"它被设计用来弥补本应该出现在\",{\"1\":{\"469\":1}}],[\"它有如下特征\",{\"1\":{\"868\":1}}],[\"它有以下优点\",{\"1\":{\"747\":1}}],[\"它有子节点\",{\"1\":{\"568\":1}}],[\"它有大量的牛逼的特性\",{\"1\":{\"480\":1}}],[\"它有一个路由文件\",{\"1\":{\"472\":1}}],[\"它有一些像\",{\"1\":{\"466\":1}}],[\"它有这样的一些特点\",{\"1\":{\"469\":1}}],[\"它有许多如\",{\"1\":{\"466\":1}}],[\"它仍然缺少一些关键的特性\",{\"1\":{\"464\":1}}],[\"它应该被每一个单独项目的\",{\"1\":{\"458\":1}}],[\"它应该仅仅被用来做依赖注入\",{\"1\":{\"449\":1}}],[\"它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性\",{\"1\":{\"737\":1}}],[\"它使用像\",{\"1\":{\"483\":1}}],[\"它使用用起来很简单\",{\"1\":{\"468\":1}}],[\"它使样板代码减少到最小化\",{\"1\":{\"447\":1}}],[\"它使得你的api更加易于学习和使用\",{\"1\":{\"265\":1}}],[\"它标识了此field\",{\"1\":{\"307\":1}}],[\"它假定我们在编译时已经知道了所有的类型\",{\"1\":{\"301\":1}}],[\"它将对数据的操作与数据结构进行分离\",{\"1\":{\"837\":1}}],[\"它将大大降低对象之间的耦合性\",{\"1\":{\"655\":1}}],[\"它将简单工厂模式看作是工厂方法模式的一种特例\",{\"1\":{\"606\":1}}],[\"它将会是这样子的\",{\"1\":{\"458\":1}}],[\"它将提供类型的约束\",{\"1\":{\"279\":1}}],[\"它将是为将使用的节点找到的最后一个文本\",{\"1\":{\"42\":1}}],[\"它接受一个\",{\"1\":{\"271\":1}}],[\"它主要用于描述软件系统的结构化设计\",{\"1\":{\"826\":1}}],[\"它主要用于回收在try块里打开的物力资源\",{\"1\":{\"251\":1}}],[\"它主要用来解决对象在多种状态转换时\",{\"1\":{\"775\":1}}],[\"它主要有两个作用\",{\"1\":{\"550\":1}}],[\"它主要是用于创建一个复杂的对象\",{\"1\":{\"550\":1}}],[\"它主要着力于保证你的代码符合代码标准\",{\"1\":{\"484\":1}}],[\"它主要的作用有以下四方面\",{\"1\":{\"221\":1}}],[\"它们之间没有其它代码\",{\"1\":{\"910\":1}}],[\"它们才会拥有相同级别的缩进\",{\"1\":{\"908\":1}}],[\"它们始终具有相同的名称\",{\"1\":{\"897\":1}}],[\"它们是最强的\",{\"1\":{\"827\":1}}],[\"它们是一个顶级逻辑的一个组成步骤\",{\"1\":{\"801\":1}}],[\"它们实际上是对一组类的关系及其互动方式的描述\",{\"1\":{\"819\":1}}],[\"它们能帮助你精简自己的设计\",{\"1\":{\"819\":1}}],[\"它们分别是\",{\"1\":{\"813\":1}}],[\"它们被设计为函数式风格并且遵循不可变性的设计风格\",{\"1\":{\"469\":1}}],[\"它们通过继承aqs实现其模版方法\",{\"1\":{\"873\":1}}],[\"它们通过以面向对象和被设计为可变的方式来保证和其他的类的兼容性\",{\"1\":{\"469\":1}}],[\"它们通常用于指示发生了异常情况\",{\"1\":{\"246\":1}}],[\"它们都是同一个版本\",{\"1\":{\"869\":1}}],[\"它们都是抽象装饰类\",{\"1\":{\"586\":1}}],[\"它们都用到了\",{\"1\":{\"814\":1}}],[\"它们都有大量的棋子对象\",{\"1\":{\"631\":1}}],[\"它们都可以用\",{\"1\":{\"461\":1}}],[\"它们都覆盖了父类的\",{\"1\":{\"211\":1}}],[\"它们对\",{\"1\":{\"457\":1}}],[\"它们不使用像\",{\"1\":{\"449\":1}}],[\"它们会报告无法访问的代码块\",{\"1\":{\"267\":1}}],[\"它们的可读性更好\",{\"1\":{\"265\":1}}],[\"它们永远不应该被用于正常的控制流\",{\"1\":{\"263\":1}}],[\"它发生在程序运行期间\",{\"1\":{\"245\":1}}],[\"它的所有方法都是虚拟的\",{\"1\":{\"996\":1}}],[\"它的add\",{\"1\":{\"850\":1}}],[\"它的方法也是isdeleted\",{\"1\":{\"845\":1}}],[\"它的特点是\",{\"1\":{\"822\":1}}],[\"它的特性支持集组聊天\",{\"1\":{\"414\":1}}],[\"它的子类可以按需要重写方法实现\",{\"1\":{\"800\":1}}],[\"它的成员变量是可以被修改的\",{\"1\":{\"767\":1}}],[\"它的主要特点是\",{\"1\":{\"798\":1}}],[\"它的主要特点是把抽象\",{\"1\":{\"537\":1}}],[\"它的主要作用是存储和管理子部件\",{\"1\":{\"568\":1}}],[\"它的主要作用是为树叶构件和树枝构件声明公共接口\",{\"1\":{\"568\":1}}],[\"它的主要目的是通过组装零配件而产生一个新产品\",{\"1\":{\"557\":1}}],[\"它的参数\",{\"1\":{\"265\":1}}],[\"它的取值范围定义在elementtype\",{\"1\":{\"227\":1}}],[\"它的作用是告诉编译器忽略指定的警告信息\",{\"1\":{\"225\":1}}],[\"它的引用可以理解为安全指针\",{\"1\":{\"151\":1}}],[\"它会在每个用例运行之前都运行一次\",{\"1\":{\"972\":1}}],[\"它会调用aqs的tryrelease方法\",{\"1\":{\"851\":2}}],[\"它会像这个样子\",{\"1\":{\"458\":1}}],[\"它会强制你去用\",{\"1\":{\"448\":1}}],[\"它会被文档化\",{\"1\":{\"224\":1}}],[\"它会抛出异常\",{\"1\":{\"141\":1}}],[\"它是展示函数或类如何使用的最佳文档\",{\"1\":{\"990\":1}}],[\"它是很多上层同步实现类的基础\",{\"1\":{\"873\":1}}],[\"它是对象之间耦合度最弱的一种关联方式\",{\"1\":{\"828\":1}}],[\"它是对象行为型模式\",{\"1\":{\"671\":1}}],[\"它是面向对象系统的建模中最常见的图\",{\"1\":{\"826\":1}}],[\"它是系统分析与设计阶段的重要产物\",{\"1\":{\"826\":1}}],[\"它是系统性能提高的一个瓶颈\",{\"1\":{\"629\":1}}],[\"它是用组合关系代替继承关系来实现的\",{\"1\":{\"798\":1}}],[\"它是动作正确性的保证\",{\"1\":{\"733\":1}}],[\"它是在某些情况下唯一可以出现的文本\",{\"1\":{\"958\":1}}],[\"它是在内存中构建一个子类对象从而实现对目标对象功能扩展\",{\"1\":{\"702\":1}}],[\"它是在本地运行的\",{\"1\":{\"484\":1}}],[\"它是中介者的接口\",{\"1\":{\"656\":1}}],[\"它是迪米特法则的典型应用\",{\"1\":{\"655\":1}}],[\"它是关键字\",{\"1\":{\"632\":1}}],[\"它是包含多个组成部件的复杂对象\",{\"1\":{\"551\":1}}],[\"它是一个抽象类或接口\",{\"1\":{\"672\":1}}],[\"它是一个包含创建产品各个子部件的抽象方法的接口\",{\"1\":{\"551\":1}}],[\"它是一个转换器\",{\"1\":{\"519\":1}}],[\"它是一个逻辑上的概念\",{\"1\":{\"125\":1}}],[\"它是被访问和适配的现存组件库中的组件接口\",{\"1\":{\"519\":1}}],[\"它是真正的能让\",{\"1\":{\"480\":1}}],[\"它是\",{\"1\":{\"476\":1}}],[\"它是框架学习和设计者必须掌握的基础\",{\"1\":{\"220\":1}}],[\"它与\",{\"1\":{\"181\":1}}],[\"它与该实例同生共死\",{\"1\":{\"144\":1}}],[\"它常用于基于\",{\"1\":{\"181\":1}}],[\"它涉及到多个指令\",{\"1\":{\"164\":1}}],[\"它不关心处理细节和请求的传递过程\",{\"1\":{\"708\":1}}],[\"它不直接访问接收者\",{\"1\":{\"561\":1}}],[\"它不能够区分正常的字符串和正则表达式字符串\",{\"1\":{\"483\":1}}],[\"它不仅会捕获所有异常\",{\"1\":{\"268\":1}}],[\"它不依赖于任何实例\",{\"1\":{\"144\":1}}],[\"它不是\",{\"1\":{\"141\":1}}],[\"它比单例更加不灵活\",{\"1\":{\"769\":1}}],[\"它比\",{\"1\":{\"129\":1}}],[\"它也被载入并实例化了\",{\"1\":{\"115\":1}}],[\"它所表示的是一个换行符\",{\"1\":{\"89\":1}}],[\"这份文档是可编译\",{\"1\":{\"990\":1}}],[\"这使得我们编写程序更灵活\",{\"1\":{\"990\":1}}],[\"这和junit\",{\"1\":{\"975\":1}}],[\"这包括了一个类的方法重写了父类的方法\",{\"1\":{\"949\":1}}],[\"这依然会混淆代码版本中的历史信息\",{\"1\":{\"912\":1}}],[\"这儿的\",{\"1\":{\"905\":1}}],[\"这实际上是一个javadoc的标签\",{\"1\":{\"853\":1}}],[\"这破坏了对象的封装性\",{\"1\":{\"837\":1}}],[\"这提高了程序的扩展性和灵活性\",{\"1\":{\"837\":1}}],[\"这几个类及其关系\",{\"1\":{\"819\":1}}],[\"这可能会导致大量毫无意义的工作\",{\"1\":{\"912\":1}}],[\"这可能也会让组件变得更加复杂\",{\"1\":{\"819\":1}}],[\"这可能是本文中最常被忽略的最佳实践\",{\"1\":{\"270\":1}}],[\"这才是我们所追求的境界\",{\"1\":{\"814\":1}}],[\"这显然不符合我们对现实世界中事物的认识\",{\"1\":{\"812\":1}}],[\"这句话在软件开发中特别适用\",{\"1\":{\"809\":1}}],[\"这句先加载数据库相关的驱动\",{\"1\":{\"98\":1}}],[\"这本书\",{\"1\":{\"808\":1}}],[\"这本质上是由于类型擦除决定的\",{\"1\":{\"293\":1}}],[\"这条规则不会被解释为要求或者禁止在行首或者行尾使用额外的空格\",{\"1\":{\"911\":1}}],[\"这条规则不是必须的\",{\"1\":{\"911\":1}}],[\"这条规则也适用于\",{\"1\":{\"907\":1}}],[\"这条规则也适用于以下\",{\"1\":{\"907\":1,\"911\":1}}],[\"这条原则的目的就是为了实现代码的松耦合\",{\"1\":{\"818\":1}}],[\"这条原则的设计初衷是\",{\"1\":{\"810\":1}}],[\"这条原则的另一个表述方式\",{\"1\":{\"808\":1}}],[\"这条原则的英文描述是\",{\"1\":{\"808\":1}}],[\"这条原则能非常有效地提高代码质量\",{\"1\":{\"808\":1}}],[\"这条原则中的\",{\"1\":{\"808\":1}}],[\"这条原则最早出现于\",{\"1\":{\"808\":1}}],[\"这条语句的时候\",{\"1\":{\"770\":1}}],[\"这导致一种反向的控制结构\",{\"1\":{\"800\":1}}],[\"这其实是继承带来的问题\",{\"1\":{\"788\":1}}],[\"这算法体现了几个设计原则\",{\"1\":{\"783\":1}}],[\"这算是我们扩展的一个相对比较极端的问题\",{\"1\":{\"275\":1}}],[\"这类代码难以应对变化\",{\"1\":{\"779\":1}}],[\"这类产品的创建无法用前面介绍的工厂模式描述\",{\"1\":{\"549\":1}}],[\"这借助\",{\"1\":{\"759\":1}}],[\"这不利于类的扩展与维护\",{\"1\":{\"747\":1}}],[\"这不利于软件功能的扩展与维护\",{\"1\":{\"560\":1}}],[\"这避免了使用众多的\",{\"1\":{\"707\":1}}],[\"这无疑增加了难度\",{\"1\":{\"707\":1}}],[\"这对全新的类来说不是很难\",{\"1\":{\"690\":1}}],[\"这对编译器没有影响\",{\"1\":{\"448\":1}}],[\"这违反了面向对象的设计原则\",{\"1\":{\"672\":1}}],[\"这违背了\",{\"1\":{\"593\":1,\"775\":1,\"837\":1}}],[\"这符合单一职责原则\",{\"1\":{\"663\":1}}],[\"这叫作\",{\"1\":{\"655\":1}}],[\"这在一定程度上增加了系统的复杂性\",{\"1\":{\"648\":1}}],[\"这简化了聚合类\",{\"1\":{\"648\":1}}],[\"这简化了客户端代码\",{\"1\":{\"567\":1}}],[\"这将增加程序的复杂性\",{\"1\":{\"629\":1}}],[\"这将会使分析导致异常的异常事件变得困难\",{\"1\":{\"271\":1}}],[\"这降低了系统中对象的数量\",{\"1\":{\"629\":1}}],[\"这给我们编码带来一定的麻烦\",{\"1\":{\"564\":1}}],[\"这点在实际使用时\",{\"1\":{\"660\":1}}],[\"这点在在使用的时候要注意\",{\"1\":{\"564\":1}}],[\"这点对于反射技术很重要\",{\"1\":{\"302\":1}}],[\"这会导致类的个数增加\",{\"1\":{\"800\":1}}],[\"这会增加代码的维护成本\",{\"1\":{\"622\":1}}],[\"这会增加系统的复杂性\",{\"1\":{\"560\":1}}],[\"这会鼓励产生无关代码\",{\"1\":{\"452\":1}}],[\"这一过程为打桩\",{\"1\":{\"552\":1,\"555\":1}}],[\"这限制了其使用范围\",{\"1\":{\"549\":1}}],[\"这说明\",{\"1\":{\"545\":1}}],[\"这说明了integer泛型实例在编译之后被擦除掉了\",{\"1\":{\"288\":1}}],[\"这增加了系统的理解与设计难度\",{\"1\":{\"537\":1}}],[\"这有助于系统进行分层设计\",{\"1\":{\"544\":1}}],[\"这有很多工具\",{\"1\":{\"484\":1}}],[\"这有关于构建器更好的例子\",{\"1\":{\"446\":1}}],[\"这还有很多例子\",{\"1\":{\"471\":1}}],[\"这用起来真的很简单\",{\"1\":{\"467\":1}}],[\"这部分主要参考自https\",{\"1\":{\"309\":1}}],[\"这篇文章将带你深入理解java\",{\"1\":{\"303\":1}}],[\"这如果实在普通的继承关系中\",{\"1\":{\"291\":1}}],[\"这恰恰说明了关于泛型变量的使用\",{\"1\":{\"290\":1}}],[\"这两页手册足够你可以开始入门使用\",{\"1\":{\"473\":1}}],[\"这两个注解是用来运行套件测试\",{\"1\":{\"982\":1}}],[\"这两个对象并不是同一个对象\",{\"1\":{\"770\":1}}],[\"这两个\",{\"1\":{\"461\":1}}],[\"这两个方案到底选哪一个要看你面对的是什么情况\",{\"1\":{\"459\":1}}],[\"这两个地方的catch变的一模一样\",{\"1\":{\"297\":1}}],[\"这两个参数一个是integer\",{\"1\":{\"289\":2}}],[\"这两个参数都是integer\",{\"1\":{\"289\":1}}],[\"这两步是spi的用法\",{\"1\":{\"103\":1}}],[\"这时候可以使用模板方法模式\",{\"1\":{\"805\":1}}],[\"这时候初始化\",{\"1\":{\"752\":1}}],[\"这时便会产生多个实例\",{\"1\":{\"754\":1}}],[\"这时可以先用小比例的虚拟代理替换真实的对象\",{\"1\":{\"705\":1}}],[\"这时需要找一个中介帮忙完成某项任务\",{\"1\":{\"692\":1}}],[\"这时需要第三者进行适配\",{\"1\":{\"518\":1}}],[\"这时只要找一个\",{\"1\":{\"655\":1}}],[\"这时只要一次类型转换就可以了\",{\"1\":{\"284\":1}}],[\"这时如果系统内部发生改变\",{\"1\":{\"593\":1}}],[\"这时要是有一个综合部门能解决一切手续问题就好了\",{\"1\":{\"593\":1}}],[\"这时就可以考虑使用\",{\"1\":{\"562\":1}}],[\"这时用适配器模式能很好地解决这些问题\",{\"1\":{\"518\":1}}],[\"这时的b为true\",{\"1\":{\"91\":1}}],[\"这次异常表中\",{\"1\":{\"275\":1}}],[\"这些假对象就被称为\",{\"1\":{\"996\":1}}],[\"这些断言方法是可以工作的\",{\"1\":{\"978\":1}}],[\"这些命名不是\",{\"1\":{\"937\":1}}],[\"这些注解所占用的行不构成换行\",{\"1\":{\"928\":1}}],[\"这些日志真的有人看吗\",{\"1\":{\"859\":1}}],[\"这些情况\",{\"1\":{\"858\":1}}],[\"这些操作彼此没有关联\",{\"1\":{\"837\":1}}],[\"这些被处理的数据元素相对稳定而访问方式多种多样的数据结构\",{\"1\":{\"837\":1}}],[\"这些虽简单却非常重要\",{\"1\":{\"823\":1}}],[\"这些符号用于描述软件模型中的各个元素和他\",{\"1\":{\"822\":1}}],[\"这些子类信奉\",{\"1\":{\"819\":1}}],[\"这些代码都需要做调整\",{\"1\":{\"809\":1}}],[\"这些方法应该按顺序放置在一起\",{\"1\":{\"848\":1}}],[\"这些方法\",{\"1\":{\"809\":1}}],[\"这些方法的定义如下\",{\"1\":{\"801\":1}}],[\"这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的\",{\"1\":{\"795\":1}}],[\"这些内容包括代码\",{\"1\":{\"770\":1}}],[\"这些\",{\"1\":{\"766\":1}}],[\"这些原则的目的只有一个\",{\"1\":{\"748\":1}}],[\"这些为外部状态\",{\"1\":{\"631\":1}}],[\"这些为内部状态\",{\"1\":{\"631\":1}}],[\"这些都是在代码中写死的\",{\"1\":{\"627\":1}}],[\"这些组件可能只是完成了一些核心功能\",{\"1\":{\"579\":1}}],[\"这些智能家电来自不同的厂家\",{\"1\":{\"562\":1}}],[\"这些就可以当做实现接口类\",{\"1\":{\"543\":1}}],[\"这些资源能够帮你成为\",{\"1\":{\"486\":1}}],[\"这些框架并没有你想象的那么灵活\",{\"1\":{\"457\":1}}],[\"这些框架都是尽力地降低你部署代码的壁垒\",{\"1\":{\"457\":1}}],[\"这些类都有构建器\",{\"1\":{\"451\":1}}],[\"这些会在不变性那一部分讨论\",{\"1\":{\"445\":1}}],[\"这些工具伴随着java一起出现\",{\"1\":{\"384\":1}}],[\"这些对象的类\",{\"1\":{\"837\":1}}],[\"这些对象耗费大量的内存资源\",{\"1\":{\"639\":1}}],[\"这些对象消耗大量内存\",{\"1\":{\"638\":1}}],[\"这些对象有很多相似的地方\",{\"1\":{\"629\":1}}],[\"这些对象描述了此\",{\"1\":{\"308\":2}}],[\"这些对象反映此\",{\"1\":{\"308\":2}}],[\"这些信息包含如下\",{\"1\":{\"275\":1}}],[\"这些异常一般是由程序逻辑错误引起的\",{\"1\":{\"248\":1}}],[\"这些异常是不检查异常\",{\"1\":{\"248\":1}}],[\"这些错误是不受检异常\",{\"1\":{\"247\":1}}],[\"这些错误无法恢复或者不可能捕捉\",{\"1\":{\"198\":1}}],[\"这么来说是比较抽象的\",{\"1\":{\"221\":1}}],[\"这么写的时候一定要找一个代码中隐蔽的角落\",{\"1\":{\"91\":1}}],[\"这么写的话是不是逼格一下子就支棱起来了\",{\"1\":{\"90\":1}}],[\"这种做法是允许的\",{\"1\":{\"912\":1}}],[\"这种行为称作\",{\"1\":{\"906\":1}}],[\"这种参数内有getname\",{\"1\":{\"859\":1}}],[\"这种参数类型可以用在类\",{\"1\":{\"279\":1}}],[\"这种命名的好处\",{\"1\":{\"859\":1}}],[\"这种描述模型所使用的语言被称为建模语言\",{\"1\":{\"824\":1}}],[\"这种关系更加灵活\",{\"1\":{\"818\":1}}],[\"这种判断还是有比较强的主观色彩\",{\"1\":{\"817\":1}}],[\"这种改动范围比较集中的小型重构的难度就容易多了\",{\"1\":{\"816\":1}}],[\"这种多例模式的理解方式有点类似工厂模式\",{\"1\":{\"773\":1}}],[\"这种设计思路虽然可以解决问题\",{\"1\":{\"812\":1}}],[\"这种设计模式就叫作单例设计模式\",{\"1\":{\"770\":1}}],[\"这种设计方案\",{\"1\":{\"554\":1}}],[\"这种调用关系就会非常隐蔽\",{\"1\":{\"765\":1}}],[\"这种使用方法有点类似硬编码\",{\"1\":{\"763\":1}}],[\"这种使用双引号的形式创建字符串实例\",{\"1\":{\"125\":1}}],[\"这种单例模式可用\",{\"1\":{\"753\":1}}],[\"这种单例模式\",{\"1\":{\"752\":1}}],[\"这种写法比较简单\",{\"1\":{\"752\":1}}],[\"这种复用可以在运行时动态进行\",{\"1\":{\"747\":1}}],[\"这种复用所需的依赖较少\",{\"1\":{\"747\":1}}],[\"这种类型的设计模式属于行为型模式\",{\"1\":{\"707\":1,\"800\":1}}],[\"这种模式对请求的发送者和接收者进行解耦\",{\"1\":{\"707\":1}}],[\"这种模式有时又称作发布\",{\"1\":{\"671\":1}}],[\"这种模式实现了文法表达式处理的接口\",{\"1\":{\"641\":1}}],[\"这种交互关系常常是\",{\"1\":{\"655\":1}}],[\"这种机制\",{\"1\":{\"622\":1}}],[\"这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制\",{\"1\":{\"300\":1}}],[\"这种方法可以解决开始遇到的问题\",{\"1\":{\"284\":1}}],[\"这种方式可以改写成\",{\"1\":{\"852\":1}}],[\"这种方式可分为创建型模式\",{\"1\":{\"798\":1}}],[\"这种方式是最值得推荐的\",{\"1\":{\"768\":1}}],[\"这种方式是\",{\"1\":{\"759\":1}}],[\"这种方式采用了类装载的机制来保证初始化实例时只有一个线程\",{\"1\":{\"758\":1}}],[\"这种方式\",{\"1\":{\"754\":1}}],[\"这种方式和上面的方式其实类似\",{\"1\":{\"753\":1}}],[\"这种方式基于\",{\"1\":{\"752\":1}}],[\"这种方式通常用于控制不同种类客户对真实对象的访问权限\",{\"1\":{\"705\":1}}],[\"这种方式通常用于要创建的目标对象开销很大时\",{\"1\":{\"705\":1}}],[\"这种方式通常是为了隐藏目标对象存在于不同地址空间的事实\",{\"1\":{\"705\":1}}],[\"这种方式既繁琐又浪费代码\",{\"1\":{\"445\":1}}],[\"这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量\",{\"1\":{\"183\":1}}],[\"这种方式来控制类的加载\",{\"1\":{\"145\":1}}],[\"这种重用必须建立在语义的基础上\",{\"1\":{\"265\":1}}],[\"这种异常的特点是java编译器会检查它\",{\"1\":{\"249\":1}}],[\"这种异常又分为两类\",{\"1\":{\"248\":1}}],[\"这种情况只在重载了类的构造器的时候才会出现\",{\"1\":{\"171\":1}}],[\"这种形式就是我们要讲的配置\",{\"1\":{\"622\":1}}],[\"这种形式\",{\"1\":{\"140\":1}}],[\"这意味着你要给出使用示例\",{\"1\":{\"454\":1}}],[\"这意味着代码可能不会执行到\",{\"1\":{\"264\":1}}],[\"这意味着它是由\",{\"1\":{\"163\":1}}],[\"这意味着\",{\"1\":{\"122\":1,\"883\":1,\"956\":1}}],[\"这就相当于将一种强依赖关系\",{\"1\":{\"818\":1}}],[\"这就会导致代码重复的问题\",{\"1\":{\"813\":1}}],[\"这就要求我们必须将\",{\"1\":{\"809\":1}}],[\"这就要求了散列函数要把所有域的值都考虑进来\",{\"1\":{\"139\":1}}],[\"这就类似\",{\"1\":{\"769\":1}}],[\"这就导致很多其他类都依赖这个类\",{\"1\":{\"741\":1}}],[\"这就造成了浪费\",{\"1\":{\"115\":1}}],[\"这就是开闭原则的经典定义\",{\"1\":{\"736\":1}}],[\"这就是享元模式的产生背景\",{\"1\":{\"629\":1}}],[\"这就是外观模式的目标\",{\"1\":{\"593\":1}}],[\"这就是装饰器模式的目标\",{\"1\":{\"580\":1}}],[\"这就是命令模式的体现\",{\"1\":{\"560\":1}}],[\"这就是\",{\"1\":{\"482\":1,\"702\":1}}],[\"这就是协变\",{\"1\":{\"291\":1}}],[\"这就是抛出异常\",{\"1\":{\"253\":1}}],[\"这就是为什么在\",{\"1\":{\"175\":1}}],[\"这就是spi的思想\",{\"1\":{\"96\":1}}],[\"这就是因为serviceloader\",{\"1\":{\"96\":1}}],[\"这也破坏了类的封装特性\",{\"1\":{\"812\":1}}],[\"这也就意味着\",{\"1\":{\"814\":1}}],[\"这也就说\",{\"1\":{\"770\":1}}],[\"这也就是所谓的\",{\"1\":{\"741\":1}}],[\"这也就是为什么需要在classpath下的meta\",{\"1\":{\"114\":1}}],[\"这也是导致许多开发团队转变最初想法的原因\",{\"1\":{\"820\":1}}],[\"这也是为什么我们不推荐使用继承\",{\"1\":{\"812\":1}}],[\"这也是考验代码设计好坏的一个标准\",{\"1\":{\"808\":1}}],[\"这也是\",{\"1\":{\"771\":1}}],[\"这也是项目开发中经常用到的一种实现思路\",{\"1\":{\"769\":1}}],[\"这也是我们这个\",{\"1\":{\"627\":1}}],[\"这也是我们发起这个开源项目的初衷\",{\"1\":{\"383\":1}}],[\"这也是泛型出现的原因\",{\"1\":{\"290\":1}}],[\"这也是绝大多数开发团队都会制定一些规则来规范进行异常处理的原因\",{\"1\":{\"262\":1}}],[\"这也意味着是eclipse制定了一系列的规则\",{\"1\":{\"105\":1}}],[\"这个\",{\"1\":{\"997\":1}}],[\"这个获取数据的接口被封装为\",{\"1\":{\"996\":1}}],[\"这个单测逻辑就比较复杂\",{\"1\":{\"991\":1}}],[\"这个注释改为用\",{\"1\":{\"962\":1}}],[\"这个注解我们也比较常用到\",{\"1\":{\"225\":1}}],[\"这个注解的作用是告诉编译器被修饰的程序元素已被\",{\"1\":{\"224\":1}}],[\"这个注解的作用我们大家都不陌生\",{\"1\":{\"223\":1}}],[\"这个注解的定义如下\",{\"1\":{\"224\":1}}],[\"这个注解可以被用来修饰方法\",{\"1\":{\"223\":1}}],[\"这个片段是用大写字母书写的并且会有标签符号\",{\"1\":{\"958\":1}}],[\"这个片段非常重要\",{\"1\":{\"958\":1}}],[\"这个特殊的注释不是必须的\",{\"1\":{\"924\":1}}],[\"这个改动可能会破坏原本令人愉悦的代码格式\",{\"1\":{\"912\":1}}],[\"这个index级别比较range还低\",{\"1\":{\"864\":1}}],[\"这个目录就是起到覆盖索引的作用\",{\"1\":{\"864\":1}}],[\"这个速度损耗可以忽略\",{\"1\":{\"864\":1}}],[\"这个try\",{\"1\":{\"852\":1}}],[\"这个变量是针对一个线程内所有操作共享的\",{\"1\":{\"851\":1}}],[\"这个区间内的integer值可以直接使用\",{\"1\":{\"848\":1}}],[\"这个想法表面看起来很棒\",{\"1\":{\"819\":1}}],[\"这个想法比本身这么做还要糟糕\",{\"1\":{\"452\":1}}],[\"这个手段也非常有用\",{\"1\":{\"818\":1}}],[\"这个口号喊得这么响\",{\"1\":{\"814\":1}}],[\"这个原则非常重要\",{\"1\":{\"807\":1}}],[\"这个术语是由埃里希\",{\"1\":{\"796\":1}}],[\"这个对象看起来像是改变了其类\",{\"1\":{\"775\":1}}],[\"这个对象已经成型\",{\"1\":{\"699\":1,\"702\":1}}],[\"这个词\",{\"1\":{\"764\":1}}],[\"这个例子来讲解\",{\"1\":{\"764\":1}}],[\"这个例子我把上述的知识点全部融入进来\",{\"1\":{\"234\":1}}],[\"这个中介就是代理对象\",{\"1\":{\"692\":1}}],[\"这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建\",{\"1\":{\"682\":1}}],[\"这个需要注意\",{\"1\":{\"668\":1}}],[\"这个需求很简单\",{\"1\":{\"591\":1}}],[\"这个时候为了让代码更清晰\",{\"1\":{\"972\":1}}],[\"这个时候请抽取\",{\"1\":{\"871\":1}}],[\"这个时候可使用目标对象子类来实现代理\",{\"1\":{\"702\":1}}],[\"这个时候\",{\"1\":{\"614\":1,\"814\":2}}],[\"这个时期方法区在hotspot中由本地内存的元空间\",{\"1\":{\"125\":1}}],[\"这个时期方法区在hotspot中由永久代\",{\"1\":{\"125\":1}}],[\"这个时期方法区在hotspot中是由永久代来实现的\",{\"1\":{\"125\":1}}],[\"这个解释器使用该标识来解释语言中的句子\",{\"1\":{\"591\":1}}],[\"这个组合很多\",{\"1\":{\"582\":1}}],[\"这个复杂对象通常由多个子部件按一定的步骤组合而成\",{\"1\":{\"549\":1}}],[\"这个根\",{\"1\":{\"458\":1}}],[\"这个教程\",{\"1\":{\"453\":1}}],[\"这个类\",{\"1\":{\"466\":1}}],[\"这个类里面保存的数据除了你去继承它\",{\"1\":{\"445\":1}}],[\"这个类型检查是针对谁的呢\",{\"1\":{\"290\":1}}],[\"这个方法需要传递几个参数\",{\"1\":{\"996\":1}}],[\"这个方法只会运行一次\",{\"1\":{\"972\":2}}],[\"这个方法返回是double类型\",{\"1\":{\"855\":1}}],[\"这个方法已经过时\",{\"1\":{\"848\":1}}],[\"这个方法我们一般不会派上用场\",{\"1\":{\"311\":1}}],[\"这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的\",{\"1\":{\"182\":1}}],[\"这个当然就是不行的\",{\"1\":{\"297\":1}}],[\"这个无论我们通过new\",{\"1\":{\"295\":1}}],[\"这个处理逻辑看着是合理的\",{\"1\":{\"270\":1}}],[\"这个参数或局部变量应该是final\",{\"1\":{\"204\":1}}],[\"这个过程可能会出现多个线程交差\",{\"1\":{\"164\":1}}],[\"这个编码可能跟原来的编码相同\",{\"1\":{\"159\":1}}],[\"这个概念被称为信息隐藏或封装\",{\"1\":{\"132\":1}}],[\"这个classloader用来定位\",{\"1\":{\"114\":1}}],[\"这个文件里的内容就是这个接口的具体的实现类\",{\"1\":{\"95\":1}}],[\"这个数转化为十进制后是2147483646\",{\"1\":{\"90\":1}}],[\"这段话听起来有点像绕口令\",{\"1\":{\"771\":1}}],[\"这段代码通过\",{\"1\":{\"477\":1}}],[\"这段代码会导致编译失败\",{\"1\":{\"275\":1}}],[\"这段代码才可以正常工作\",{\"1\":{\"264\":1}}],[\"这段代码最终打印结果为16843009\",{\"1\":{\"93\":1}}],[\"这段程序运行结果如何\",{\"1\":{\"89\":1}}],[\"这里节选自https\",{\"1\":{\"993\":1}}],[\"这里只是说明\",{\"1\":{\"789\":1}}],[\"这里请大家注意\",{\"1\":{\"778\":1}}],[\"这里有点不好理解\",{\"1\":{\"770\":1}}],[\"这里之所以会用\",{\"1\":{\"764\":1}}],[\"这里本意是求出\",{\"1\":{\"734\":3}}],[\"这里虽然没有在类这个级别上遵守单一职责原则\",{\"1\":{\"718\":1}}],[\"这里完成对基本数据类型\",{\"1\":{\"689\":1}}],[\"这里可以理解成一个新的公告板\",{\"1\":{\"678\":1}}],[\"这里处理\",{\"1\":{\"659\":1}}],[\"这里\",{\"1\":{\"644\":1,\"734\":2}}],[\"这里提到的文法和句子的概念同编译原理中的描述相同\",{\"1\":{\"641\":1}}],[\"这里每次都生成新的类加载器\",{\"1\":{\"312\":1}}],[\"这里是匹配最精确的子类进行返回\",{\"1\":{\"311\":1}}],[\"这里就不全部列出了\",{\"1\":{\"307\":1}}],[\"这里就涉及到使用java的spi扩展机制来查找相关驱动的东西了\",{\"1\":{\"103\":1}}],[\"这里例子源于https\",{\"1\":{\"305\":1}}],[\"这里我们使用到了双分派\",{\"1\":{\"839\":1}}],[\"这里我们增加了\",{\"1\":{\"742\":2,\"743\":2}}],[\"这里我们是对接口的依赖\",{\"1\":{\"727\":1}}],[\"这里我们拆分成\",{\"1\":{\"721\":1}}],[\"这里我们需要\",{\"1\":{\"650\":1}}],[\"这里我们需要回顾的是\",{\"1\":{\"303\":1}}],[\"这里我们首先需要理解\",{\"1\":{\"301\":1}}],[\"这里我们发现通过注解的方式\",{\"1\":{\"241\":1}}],[\"这里面的setvalue和getvalue这两个桥方法的意义又有不同\",{\"1\":{\"291\":1}}],[\"这里面的内容就是针对java中定义的接口的实现\",{\"1\":{\"100\":1}}],[\"这里仅以擦除方法定义中的有限制类型参数为例\",{\"1\":{\"287\":1}}],[\"这里给出几个被很多团队使用的异常处理最佳实践\",{\"1\":{\"262\":1}}],[\"这里展示部分代码\",{\"1\":{\"242\":1}}],[\"这里推荐你两篇文章\",{\"1\":{\"238\":1}}],[\"这里注意\",{\"1\":{\"233\":1}}],[\"这里的职责是指类变化的原因\",{\"1\":{\"716\":1}}],[\"这里的词法分析器和语法分析器都可以看做是解释器\",{\"1\":{\"641\":1}}],[\"这里的\",{\"1\":{\"183\":1,\"556\":1,\"742\":1,\"773\":1}}],[\"这里主要都是调用的lookupiterator的相应hasnext和next方法\",{\"1\":{\"114\":1}}],[\"这里主要都是实现了迭代器的hasnext和next方法\",{\"1\":{\"114\":1}}],[\"这里实际包含两个问题\",{\"1\":{\"113\":1}}],[\"这里具体说一下eclipse的插件思想\",{\"1\":{\"105\":1}}],[\"这里真正开始决定使用哪个factory\",{\"1\":{\"104\":1}}],[\"这里会搜索classpath下以及jar包中所有的meta\",{\"1\":{\"103\":1}}],[\"这里没有去meta\",{\"1\":{\"103\":1}}],[\"这里并没有涉及到spi的使用\",{\"1\":{\"102\":1}}],[\"这里在新窗口打开\",{\"1\":{\"96\":1}}],[\"这里简单举两个例子\",{\"1\":{\"93\":1}}],[\"这里用到的>>>是无符号右移操作\",{\"1\":{\"90\":1}}],[\"这玩意如果使用不当的话不是非常安全\",{\"1\":{\"93\":1}}],[\"这样造成了具体元素变更比较困难\",{\"1\":{\"840\":1}}],[\"这样即便在不了解全部细节的情况下\",{\"1\":{\"818\":1}}],[\"这样才会更有弹性\",{\"1\":{\"791\":1}}],[\"这样能把原来复杂的逻辑判断简单化\",{\"1\":{\"775\":1}}],[\"这样能方便我们控制对数据库连接资源的消耗\",{\"1\":{\"766\":1}}],[\"这样代码的改动就会比较大\",{\"1\":{\"764\":1}}],[\"这样类更加独立\",{\"1\":{\"741\":1}}],[\"这样写起来虽然简单\",{\"1\":{\"734\":1}}],[\"这样只需要传入继承接口的类\",{\"1\":{\"727\":1}}],[\"这样给接口传入不同的类\",{\"1\":{\"725\":1}}],[\"这样对一个采购请求进行处理和\",{\"1\":{\"709\":1}}],[\"这样当实现发生变化的时候\",{\"1\":{\"808\":1,\"810\":1}}],[\"这样当该对象没有被引用时\",{\"1\":{\"705\":1}}],[\"这样当我们游戏的对象很多时\",{\"1\":{\"666\":1}}],[\"这样以后就\",{\"1\":{\"663\":1}}],[\"这样我们就可以做到\",{\"1\":{\"771\":1}}],[\"这样我们就符合依赖倒转原则\",{\"1\":{\"727\":1}}],[\"这样我们的变量引用和实际对象间\",{\"1\":{\"729\":1}}],[\"这样我们不需要关心箱子里是什么\",{\"1\":{\"648\":1}}],[\"这样我们有新的图形种类时\",{\"1\":{\"739\":1}}],[\"这样我们有新的\",{\"1\":{\"609\":1}}],[\"这样每一个组只需保存一个内部状态\",{\"1\":{\"639\":1}}],[\"这样一来集合改变的话\",{\"1\":{\"652\":1}}],[\"这样一来就能解释上面的打印结果了\",{\"1\":{\"91\":1}}],[\"这样一个行为特性\",{\"1\":{\"813\":1}}],[\"这样一个行为\",{\"1\":{\"812\":1}}],[\"这样一个抽象的事物概念\",{\"1\":{\"812\":1}}],[\"这样一个\",{\"1\":{\"627\":2}}],[\"这样将单个的简单工厂类变成了\",{\"1\":{\"616\":1}}],[\"这样设计的依据\",{\"1\":{\"714\":1}}],[\"这样设计\",{\"1\":{\"582\":1}}],[\"这样实际上是站在组织大小来进行分层次的\",{\"1\":{\"573\":1}}],[\"这样是一种设计模式\",{\"1\":{\"562\":1}}],[\"这样是没有错误的\",{\"1\":{\"290\":1}}],[\"这样增加了代码维护成本\",{\"1\":{\"541\":1}}],[\"这样违背了\",{\"1\":{\"533\":1,\"742\":1}}],[\"这样你就可以很容易的根据接口类来开发客户端\",{\"1\":{\"472\":1}}],[\"这样你会清除地了解到你们公司选择的每一个外部依赖的版本\",{\"1\":{\"458\":1}}],[\"这样你在使用流或者资源的时候\",{\"1\":{\"186\":1}}],[\"这样会大大降低应用程序的复杂度\",{\"1\":{\"593\":1}}],[\"这样会带来一些安全性问题\",{\"1\":{\"569\":1}}],[\"这样会让读你代码的人误以为那就是文档\",{\"1\":{\"454\":1}}],[\"这样会污染代码\",{\"1\":{\"448\":1}}],[\"这样做是为了最小化局部变量的作用域\",{\"1\":{\"918\":1}}],[\"这样做逻辑清晰\",{\"1\":{\"852\":1}}],[\"这样做的好处是\",{\"1\":{\"692\":1,\"818\":1}}],[\"这样做的必然结果是不要对不需要写文档的地方填写文档\",{\"1\":{\"454\":1}}],[\"这样做有什么意义呢\",{\"1\":{\"290\":1}}],[\"这样这个类就不会被继承也不会被修改了\",{\"1\":{\"451\":1}}],[\"这样比写一连串的判断是否为空的检查代码更好\",{\"1\":{\"450\":1}}],[\"这样不仅减少了近一半的代码行数\",{\"1\":{\"445\":1}}],[\"这样就只允许在这些点进行扩展\",{\"1\":{\"805\":1}}],[\"这样就需要\",{\"1\":{\"788\":1}}],[\"这样就会误导用户\",{\"1\":{\"768\":1}}],[\"这样就会有classcastexception了\",{\"1\":{\"290\":1}}],[\"这样就能避免慢\",{\"1\":{\"766\":1}}],[\"这样就可以保证线程安全了\",{\"1\":{\"757\":1}}],[\"这样就可以使用了\",{\"1\":{\"521\":1}}],[\"这样就存在如下问题\",{\"1\":{\"709\":1}}],[\"这样就很好的解决了对象的开销问题\",{\"1\":{\"631\":1}}],[\"这样就不会造成类数量过多\",{\"1\":{\"583\":1}}],[\"这样就不会由于上游的\",{\"1\":{\"461\":1}}],[\"这样就避免了上一种方式的安全性问题\",{\"1\":{\"570\":1}}],[\"这样就完成了类方法的动态调用\",{\"1\":{\"308\":1}}],[\"这样就实现了表面上调用一次方法\",{\"1\":{\"92\":1}}],[\"这样调用\",{\"1\":{\"288\":1}}],[\"这样容器才够大\",{\"1\":{\"284\":1}}],[\"这样可以降低系统内存\",{\"1\":{\"629\":1}}],[\"这样可以添加更为具体的异常信息并能够做针对的异常处理\",{\"1\":{\"271\":1}}],[\"这样可以有多重实现\",{\"1\":{\"188\":1}}],[\"这样无论是打印到日志中还是在监控工具中\",{\"1\":{\"266\":1}}],[\"这样的情况下\",{\"1\":{\"997\":1}}],[\"这样的情况比第一种情况好的多\",{\"1\":{\"290\":1}}],[\"这样的祈使句\",{\"1\":{\"958\":1}}],[\"这样的注释使该行成为非空白的\",{\"1\":{\"932\":1}}],[\"这样的注解来检查类型\",{\"1\":{\"483\":1}}],[\"这样的代码块通常用于限制局部变量的作用域\",{\"1\":{\"901\":1}}],[\"这样的代码是无法通过编译器的检查的\",{\"1\":{\"291\":1}}],[\"这样的话\",{\"1\":{\"852\":1}}],[\"这样的话就可以控制对字段的修改行为\",{\"1\":{\"132\":1}}],[\"这样的处理方式让写的同学更加明确线程池的运行规则\",{\"1\":{\"851\":1}}],[\"这样的设计\",{\"1\":{\"812\":1}}],[\"这样的行为效率低下\",{\"1\":{\"990\":1}}],[\"这样的行为\",{\"1\":{\"812\":1}}],[\"这样的接口设计是否足够通用\",{\"1\":{\"809\":1}}],[\"这样的接口设计就没有意义了\",{\"1\":{\"809\":1}}],[\"这样的字眼\",{\"1\":{\"809\":1}}],[\"这样的修改听起来并不复杂\",{\"1\":{\"809\":1}}],[\"这样的例子在生活中还有很多\",{\"1\":{\"800\":1}}],[\"这样的例子还有很多\",{\"1\":{\"537\":1,\"655\":1,\"671\":1,\"837\":1}}],[\"这样的需求并不少见\",{\"1\":{\"766\":1}}],[\"这样的软件\",{\"1\":{\"537\":1}}],[\"这样的构建工具绑定到一起\",{\"1\":{\"484\":1}}],[\"这样的流畅接口让你的测试更具有可读性\",{\"1\":{\"478\":1}}],[\"这样的微框架\",{\"1\":{\"472\":1}}],[\"这样的框架\",{\"1\":{\"472\":1}}],[\"这样的很普通的类\",{\"1\":{\"452\":1}}],[\"这样的方法来调用就可以了\",{\"1\":{\"763\":1}}],[\"这样的方法\",{\"1\":{\"450\":1,\"466\":1}}],[\"这样的简单赋值时\",{\"1\":{\"93\":1}}],[\"这样\",{\"1\":{\"89\":1,\"291\":2,\"448\":1,\"450\":1,\"560\":1,\"639\":1,\"678\":1,\"727\":1,\"757\":1,\"818\":1}}],[\"这是测试驱动开发\",{\"1\":{\"991\":1}}],[\"这是基础\",{\"1\":{\"988\":1}}],[\"这是硬件实现的原子操作\",{\"1\":{\"873\":1}}],[\"这是不正确的\",{\"1\":{\"958\":1}}],[\"这是不对的\",{\"1\":{\"866\":1}}],[\"这是不合理的\",{\"1\":{\"848\":1,\"913\":1}}],[\"这是不可能的\",{\"1\":{\"176\":1}}],[\"这是示例注释\",{\"1\":{\"847\":1}}],[\"这是迪米特法则所不建议的\",{\"1\":{\"840\":1}}],[\"这是我觉得设计模式所处的位置\",{\"1\":{\"819\":1}}],[\"这是我们使用享元模式需要注意的地方\",{\"1\":{\"638\":1}}],[\"这是野鸭\",{\"1\":{\"787\":1,\"789\":1}}],[\"这是就会使用到单例模式\",{\"1\":{\"750\":1}}],[\"这是很恶心的样板代码\",{\"1\":{\"478\":1}}],[\"这是它的回报\",{\"1\":{\"477\":1}}],[\"这是正确的\",{\"1\":{\"296\":1}}],[\"这是非常不好的习惯\",{\"1\":{\"272\":1}}],[\"这是一种不负责任的表现\",{\"1\":{\"858\":1}}],[\"这是一种静态关系\",{\"1\":{\"217\":1}}],[\"这是一个片段\",{\"1\":{\"958\":1}}],[\"这是一个非核心功能点影响到核心应用的典型反例\",{\"1\":{\"858\":1}}],[\"这是一个大坑\",{\"1\":{\"848\":1}}],[\"这是一个用于绘图的类\",{\"1\":{\"738\":2,\"739\":1}}],[\"这是一个简单的泛型方法\",{\"1\":{\"289\":1}}],[\"这是一条通用规则\",{\"1\":{\"265\":1}}],[\"这是为了确保可以使用父类实例的地方都可以使用子类实例\",{\"1\":{\"132\":1}}],[\"这是postgresql对java的java\",{\"1\":{\"101\":1}}],[\"这是因为\",{\"1\":{\"141\":1}}],[\"这是因为不支持默认方法的接口的维护成本太高了\",{\"1\":{\"133\":1}}],[\"这是因为新的8字节内存空间addr2中存储的二进制数字是下面这样\",{\"1\":{\"93\":1}}],[\"这是因为在对int型的数字进行移位操作时\",{\"1\":{\"90\":1}}],[\"这是脚注内容\",{\"1\":{\"30\":1}}],[\"这是项目主页的案例\",{\"1\":{\"0\":1}}],[\"猜猜看\",{\"1\":{\"89\":1}}],[\"看不懂自己的代码\",{\"1\":{\"992\":1}}],[\"看修改代码会不会牵一发而动全身\",{\"1\":{\"817\":1}}],[\"看了刚刚的讲解\",{\"1\":{\"810\":1}}],[\"看代码示例\",{\"1\":{\"718\":1}}],[\"看看信息\",{\"1\":{\"678\":2}}],[\"看看下面的代码\",{\"1\":{\"89\":1}}],[\"看一个披萨的项目\",{\"1\":{\"609\":1}}],[\"看一下改造后的代码\",{\"1\":{\"92\":1}}],[\"看一下就穿帮了啊\",{\"1\":{\"89\":1}}],[\"看这\",{\"1\":{\"447\":1}}],[\"看这个名字也可以明白\",{\"1\":{\"93\":1}}],[\"看到这条日志你能做什么\",{\"1\":{\"859\":1}}],[\"看到这样的设计\",{\"1\":{\"764\":1}}],[\"看到这你是不是一脸懵逼\",{\"1\":{\"89\":1}}],[\"看到上面的代码\",{\"1\":{\"275\":1}}],[\"看下面代码\",{\"1\":{\"734\":1}}],[\"看下这个例子\",{\"1\":{\"279\":1}}],[\"看下底层实现\",{\"1\":{\"274\":1}}],[\"看下scanner\",{\"1\":{\"259\":1}}],[\"看懂\",{\"1\":{\"219\":1}}],[\"看完上面的几个例子解析\",{\"1\":{\"108\":1}}],[\"看问题的角度变广了\",{\"1\":{\"36\":1}}],[\"瞒天过海\",{\"0\":{\"89\":1}}],[\"壹\",{\"0\":{\"89\":1}}],[\"时需注意npe问题\",{\"1\":{\"865\":1}}],[\"时连同\",{\"1\":{\"832\":1}}],[\"时代变化\",{\"1\":{\"699\":1,\"702\":1}}],[\"时间测试\",{\"0\":{\"980\":1}}],[\"时间不在服务范围\",{\"1\":{\"874\":1}}],[\"时间单位为秒\",{\"1\":{\"854\":1}}],[\"时间处理库\",{\"1\":{\"470\":1}}],[\"时间日期工具库\",{\"0\":{\"396\":1}}],[\"时序图反映了一系列对象间的交互与协作关系\",{\"1\":{\"871\":1}}],[\"时序图与协作图\",{\"1\":{\"822\":1}}],[\"时序图\",{\"1\":{\"219\":1}}],[\"时\",{\"1\":{\"88\":1,\"287\":1,\"565\":1,\"618\":1,\"716\":1,\"732\":1,\"852\":1,\"865\":1,\"947\":1}}],[\"时常焦虑\",{\"1\":{\"36\":1}}],[\"塑造个人能力的不可替代性\",{\"1\":{\"88\":1}}],[\"熟练掌握这些小技巧后\",{\"1\":{\"88\":1}}],[\"4之后\",{\"1\":{\"998\":1}}],[\"498\",{\"1\":{\"979\":1,\"980\":1}}],[\"43\",{\"1\":{\"863\":1,\"979\":1,\"980\":1}}],[\"46094\",{\"1\":{\"314\":1}}],[\"46\",{\"1\":{\"310\":1}}],[\"47\",{\"1\":{\"979\":1,\"980\":1}}],[\"47394475\",{\"1\":{\"276\":1}}],[\"47449512\",{\"1\":{\"243\":1}}],[\"404\",{\"1\":{\"854\":1}}],[\"403\",{\"1\":{\"854\":1}}],[\"401\",{\"1\":{\"854\":1}}],[\"40896997\",{\"1\":{\"314\":1}}],[\"40\",{\"1\":{\"275\":3,\"676\":2,\"695\":1}}],[\"41\",{\"1\":{\"275\":6}}],[\"44425934\",{\"1\":{\"984\":1}}],[\"44\",{\"1\":{\"270\":1,\"524\":1,\"528\":1}}],[\"4554617c\",{\"1\":{\"127\":3,\"140\":2}}],[\"42\",{\"1\":{\"101\":1,\"103\":1}}],[\"4294967297\",{\"1\":{\"93\":1}}],[\"4\",{\"0\":{\"476\":1},\"1\":{\"85\":1,\"93\":6,\"123\":1,\"133\":1,\"141\":1,\"144\":1,\"173\":1,\"228\":1,\"241\":1,\"275\":1,\"285\":1,\"291\":3,\"478\":2,\"584\":2,\"601\":1,\"703\":1,\"723\":2,\"739\":1,\"779\":1,\"790\":1,\"794\":1,\"845\":2,\"846\":2,\"847\":8,\"848\":2,\"849\":1,\"850\":2,\"852\":1,\"854\":2,\"858\":1,\"861\":1,\"863\":1,\"865\":1,\"869\":1,\"870\":1,\"872\":8,\"974\":3,\"975\":1,\"978\":1,\"981\":2}}],[\"4px\",{\"1\":{\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"84\":1}}],[\"j2ee\",{\"1\":{\"750\":1}}],[\"jbpm\",{\"1\":{\"435\":1}}],[\"jboss\",{\"1\":{\"414\":1}}],[\"jgrapht\",{\"1\":{\"425\":1}}],[\"jgroups\",{\"1\":{\"399\":1}}],[\"jmap\",{\"1\":{\"485\":2}}],[\"jmock\",{\"0\":{\"477\":1},\"1\":{\"477\":2}}],[\"jmockit\",{\"1\":{\"431\":1}}],[\"jmonkeyengine\",{\"1\":{\"404\":1}}],[\"jmeter\",{\"1\":{\"431\":1}}],[\"jmh\",{\"1\":{\"422\":1}}],[\"jhiccup\",{\"1\":{\"422\":1}}],[\"jhipster\",{\"1\":{\"398\":1}}],[\"jfinal\",{\"1\":{\"420\":1}}],[\"jp\",{\"1\":{\"618\":4}}],[\"jprofiler\",{\"1\":{\"422\":1}}],[\"jpa\",{\"1\":{\"420\":2}}],[\"jpct\",{\"1\":{\"404\":1}}],[\"jna\",{\"1\":{\"417\":1}}],[\"jcp\",{\"1\":{\"440\":1}}],[\"jcommander\",{\"1\":{\"432\":1}}],[\"jca\",{\"1\":{\"427\":1}}],[\"jca和sdo\",{\"1\":{\"420\":1}}],[\"jctools\",{\"1\":{\"406\":1}}],[\"jcl\",{\"1\":{\"104\":1,\"473\":1,\"859\":2}}],[\"jep\",{\"1\":{\"646\":1}}],[\"jetty\",{\"1\":{\"429\":1}}],[\"jetbrain针对jvm\",{\"1\":{\"411\":1}}],[\"jetbrain的持续集成解决方案\",{\"1\":{\"392\":1}}],[\"jersey\",{\"1\":{\"424\":1,\"472\":2}}],[\"jersey和metrics\",{\"1\":{\"424\":1}}],[\"jeromq\",{\"1\":{\"414\":1}}],[\"jenkins\",{\"1\":{\"392\":1,\"460\":1}}],[\"jqassistant\",{\"1\":{\"388\":1}}],[\"john\",{\"1\":{\"795\":1}}],[\"johnson\",{\"1\":{\"795\":1}}],[\"josh\",{\"1\":{\"759\":1}}],[\"jock\",{\"1\":{\"440\":1}}],[\"jooλ\",{\"1\":{\"403\":1}}],[\"jooq\",{\"0\":{\"474\":1},\"1\":{\"394\":1,\"440\":1,\"442\":1,\"474\":3}}],[\"jopendocument\",{\"1\":{\"402\":1}}],[\"joda\",{\"0\":{\"470\":1},\"1\":{\"396\":2,\"470\":1}}],[\"job\",{\"1\":{\"387\":1}}],[\"join框架详解\",{\"0\":{\"495\":1}}],[\"joiner\",{\"1\":{\"466\":1,\"942\":4}}],[\"joinpoint\",{\"1\":{\"242\":16}}],[\"join\",{\"1\":{\"186\":1,\"474\":1}}],[\"jingjiren\",{\"1\":{\"984\":1}}],[\"jimfs\",{\"1\":{\"415\":1}}],[\"jitpack\",{\"1\":{\"401\":1}}],[\"jit\",{\"1\":{\"302\":1}}],[\"jianshu\",{\"1\":{\"116\":1,\"299\":1}}],[\"jreble\",{\"1\":{\"482\":1}}],[\"jrebel\",{\"0\":{\"482\":1},\"1\":{\"398\":1,\"482\":1}}],[\"jre精简\",{\"0\":{\"350\":1}}],[\"jre\",{\"0\":{\"152\":1},\"1\":{\"152\":4}}],[\"jvm的xms和xmx设置一样大小的内存容量\",{\"1\":{\"870\":1}}],[\"jvm探源与内存分析\",{\"1\":{\"843\":1}}],[\"jvm基准测试工具\",{\"1\":{\"422\":1}}],[\"jvm基础\",{\"1\":{\"303\":2}}],[\"jvm与jdk\",{\"0\":{\"410\":1}}],[\"jvm又会回调\",{\"1\":{\"310\":1}}],[\"jvm中class的表示\",{\"1\":{\"305\":1}}],[\"jvm会创建一个class对象\",{\"1\":{\"305\":1}}],[\"jvm会在当前出现异常的方法中\",{\"1\":{\"275\":1}}],[\"jvm知道你的本意吗\",{\"1\":{\"291\":1}}],[\"jvm处理异常的机制\",{\"0\":{\"275\":1}}],[\"jvm\",{\"0\":{\"364\":1,\"365\":1,\"366\":1,\"374\":1,\"378\":1,\"379\":2,\"381\":1,\"1008\":1},\"1\":{\"145\":1,\"146\":1,\"152\":1,\"185\":1,\"247\":2,\"268\":1,\"294\":1,\"310\":1,\"472\":1,\"485\":2,\"627\":2,\"758\":1,\"762\":1,\"769\":1}}],[\"jls7\",{\"1\":{\"120\":1}}],[\"j++\",{\"1\":{\"120\":1,\"306\":1}}],[\"j\",{\"1\":{\"120\":1,\"153\":1,\"306\":5,\"312\":2}}],[\"jakarta\",{\"1\":{\"859\":2}}],[\"january\",{\"1\":{\"849\":2}}],[\"ja\",{\"1\":{\"618\":2}}],[\"japaneseimperialcalendar\",{\"1\":{\"618\":3}}],[\"japanese\",{\"1\":{\"618\":1}}],[\"james\",{\"1\":{\"440\":1}}],[\"jade\",{\"1\":{\"432\":1}}],[\"jaxenter\",{\"1\":{\"442\":1}}],[\"jax\",{\"1\":{\"424\":1,\"472\":2}}],[\"jaxrs\",{\"1\":{\"424\":1}}],[\"jaxb\",{\"1\":{\"420\":1}}],[\"jasperreports\",{\"1\":{\"421\":1}}],[\"jasperreports的精简版\",{\"1\":{\"421\":1}}],[\"jabber\",{\"1\":{\"414\":1}}],[\"javin\",{\"1\":{\"440\":1}}],[\"javolution\",{\"1\":{\"406\":1}}],[\"javaup\",{\"0\":{\"1007\":1}}],[\"java里单元指一个类\",{\"1\":{\"989\":1}}],[\"java文件\",{\"1\":{\"972\":1,\"981\":1}}],[\"javaguide\",{\"1\":{\"875\":1}}],[\"java代码用正则来验证客户端的输入\",{\"1\":{\"861\":1}}],[\"java类库中定义的可以通过预检查方式规避的runtimeexception异常不应该通过catch的方式来处理\",{\"1\":{\"858\":1}}],[\"java服务端如果直接返回long整型数据给前端\",{\"1\":{\"854\":1}}],[\"java开发手册\",{\"1\":{\"843\":2}}],[\"java专业\",{\"1\":{\"650\":2}}],[\"java并发\",{\"0\":{\"512\":1}}],[\"java并发编程实战\",{\"1\":{\"438\":1}}],[\"javabean\",{\"1\":{\"444\":1,\"445\":1}}],[\"javabase\",{\"1\":{\"306\":7}}],[\"java包含最新的java技术资讯\",{\"1\":{\"442\":1}}],[\"javaworld\",{\"1\":{\"442\":1}}],[\"javalobby\",{\"1\":{\"442\":1}}],[\"java平台开发组\",{\"1\":{\"440\":1}}],[\"java杂志官方账号\",{\"1\":{\"440\":1}}],[\"javaone明星演讲者\",{\"1\":{\"440\":2}}],[\"javaoop基础知识总结\",{\"1\":{\"219\":1}}],[\"java解惑\",{\"1\":{\"438\":1}}],[\"java解释器调用main方法执行开始执行程序\",{\"1\":{\"252\":1}}],[\"java全栈web开发框架\",{\"1\":{\"434\":1}}],[\"javatuples\",{\"1\":{\"432\":1}}],[\"java版baidu\",{\"1\":{\"419\":1}}],[\"javamelody\",{\"1\":{\"416\":1}}],[\"java资源大全中文版\",{\"0\":{\"383\":1}}],[\"java动态调试技术原理\",{\"0\":{\"363\":1}}],[\"javafx\",{\"0\":{\"349\":1},\"1\":{\"405\":1,\"440\":1}}],[\"java反射机制在框架设计中极为广泛\",{\"1\":{\"300\":1}}],[\"java反射机制是在运行状态中\",{\"1\":{\"300\":1}}],[\"javaslang\",{\"0\":{\"469\":1},\"1\":{\"403\":1,\"469\":2}}],[\"javassist\",{\"1\":{\"386\":1}}],[\"javaserver\",{\"1\":{\"384\":2}}],[\"javase\",{\"1\":{\"294\":1,\"299\":1}}],[\"javascript会自动转换为number类型\",{\"1\":{\"854\":1}}],[\"javascript\",{\"1\":{\"77\":3,\"150\":1,\"907\":1}}],[\"java不允许进行这样的引用传递\",{\"1\":{\"290\":1}}],[\"java编程思想\",{\"1\":{\"438\":1}}],[\"java编程思想一书中\",{\"1\":{\"260\":1}}],[\"java编写原生ios应用\",{\"1\":{\"415\":1}}],[\"java编译器是通过先检查代码中泛型的类型\",{\"1\":{\"290\":1}}],[\"java实战经典\",{\"1\":{\"280\":1}}],[\"java实现oop\",{\"1\":{\"219\":1}}],[\"java泛型加入了类型参数的上下边界机制\",{\"1\":{\"284\":1}}],[\"java泛型的实现采取了\",{\"1\":{\"278\":1,\"287\":1}}],[\"java泛型这个特性是从jdk\",{\"1\":{\"278\":1,\"287\":1}}],[\"java标准异常中有几个是经常被使用的异常\",{\"1\":{\"265\":1}}],[\"java通\",{\"1\":{\"245\":1}}],[\"java异常类层次结构图\",{\"1\":{\"245\":1}}],[\"java异常都是对象\",{\"1\":{\"245\":1}}],[\"java异常机制可以使程序中异常处理代码和正常业务代码分离\",{\"1\":{\"244\":1}}],[\"java异常是java提供的一种识别及响应错误的一致性机制\",{\"1\":{\"244\":1}}],[\"javazejian\",{\"1\":{\"243\":1}}],[\"java8提供了哪些新的注解\",{\"0\":{\"236\":1}}],[\"java8\",{\"0\":{\"231\":1,\"232\":1},\"1\":{\"437\":1}}],[\"javadoc方式会提示相关注释\",{\"1\":{\"853\":1}}],[\"javadoc\",{\"0\":{\"454\":1,\"953\":1,\"959\":1,\"962\":1},\"1\":{\"229\":1,\"266\":1,\"877\":1,\"905\":1,\"911\":1,\"932\":2,\"955\":4,\"958\":2,\"959\":3,\"960\":1,\"961\":1,\"962\":3}}],[\"javap\",{\"1\":{\"228\":1,\"275\":1}}],[\"java内置注解\",{\"0\":{\"222\":1}}],[\"java自带的标准注解\",{\"1\":{\"221\":1}}],[\"java在编译时还可捕获类型声明中的许多常见错误\",{\"1\":{\"206\":1}}],[\"java在编译和运行程序时\",{\"1\":{\"206\":1}}],[\"java揭示出可能出现但未被处理的异常\",{\"1\":{\"206\":1}}],[\"java语言的鲁棒性\",{\"0\":{\"206\":1}}],[\"java中所有的锁\",{\"0\":{\"512\":1}}],[\"java中常见的异常类\",{\"1\":{\"261\":1}}],[\"java中有三种移位运算符\",{\"1\":{\"203\":1}}],[\"java中spi机制深入及源码解析\",{\"1\":{\"116\":1}}],[\"java中spi机制主要思想是将装配的控制权移到程序之外\",{\"1\":{\"95\":1}}],[\"java移位运算符\",{\"0\":{\"203\":1}}],[\"java虚拟机也要进行检查\",{\"1\":{\"198\":1}}],[\"java1\",{\"1\":{\"193\":1}}],[\"javacc是更加专门的轻量级工具\",{\"1\":{\"389\":1}}],[\"javacc\",{\"1\":{\"389\":1}}],[\"javac\",{\"1\":{\"152\":1}}],[\"java\",{\"0\":{\"150\":1,\"151\":1,\"158\":1,\"160\":1,\"164\":1,\"169\":1,\"171\":1,\"173\":1,\"178\":1,\"183\":1,\"185\":1,\"189\":1,\"324\":1,\"325\":1,\"326\":1,\"327\":1,\"328\":1,\"329\":1,\"330\":1,\"332\":1,\"333\":1,\"334\":1,\"335\":1,\"338\":1,\"339\":1,\"340\":1,\"341\":1,\"342\":1,\"343\":1,\"344\":1,\"345\":1,\"346\":1,\"347\":1,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":1,\"353\":1,\"354\":1,\"355\":1,\"356\":1,\"357\":1,\"358\":1,\"360\":1,\"361\":1,\"362\":1,\"366\":1,\"367\":1,\"368\":1,\"369\":1,\"370\":1,\"371\":1,\"372\":1,\"373\":1,\"374\":1,\"375\":1,\"376\":1,\"377\":1,\"380\":1,\"381\":1,\"443\":1,\"468\":1,\"514\":1,\"515\":1,\"516\":1,\"842\":1,\"875\":1,\"1004\":1},\"1\":{\"88\":1,\"95\":1,\"100\":1,\"103\":1,\"104\":2,\"114\":1,\"120\":2,\"122\":1,\"123\":1,\"127\":2,\"128\":1,\"129\":1,\"130\":2,\"132\":1,\"133\":4,\"141\":3,\"145\":4,\"146\":1,\"147\":1,\"148\":2,\"150\":6,\"151\":10,\"152\":2,\"153\":2,\"155\":9,\"161\":1,\"163\":1,\"169\":2,\"170\":1,\"181\":1,\"182\":1,\"185\":1,\"186\":2,\"187\":3,\"188\":1,\"189\":2,\"213\":1,\"214\":1,\"219\":2,\"222\":1,\"228\":1,\"229\":3,\"234\":22,\"243\":3,\"246\":1,\"259\":1,\"261\":8,\"262\":1,\"263\":1,\"264\":2,\"270\":10,\"275\":26,\"277\":2,\"284\":1,\"291\":6,\"293\":1,\"294\":2,\"295\":2,\"298\":3,\"299\":2,\"301\":1,\"302\":2,\"303\":1,\"305\":2,\"306\":8,\"307\":4,\"308\":18,\"310\":12,\"311\":1,\"312\":14,\"314\":3,\"403\":1,\"407\":1,\"419\":3,\"420\":1,\"422\":1,\"427\":1,\"430\":1,\"437\":1,\"438\":5,\"439\":2,\"440\":18,\"442\":7,\"443\":4,\"444\":1,\"447\":1,\"449\":4,\"450\":1,\"453\":1,\"455\":1,\"456\":1,\"457\":2,\"458\":1,\"459\":3,\"460\":1,\"463\":1,\"464\":1,\"466\":3,\"468\":3,\"469\":3,\"470\":2,\"471\":1,\"472\":4,\"473\":2,\"474\":1,\"476\":1,\"477\":1,\"480\":2,\"483\":1,\"485\":1,\"486\":1,\"487\":2,\"488\":4,\"489\":1,\"525\":1,\"556\":1,\"575\":1,\"585\":1,\"586\":1,\"609\":2,\"610\":1,\"618\":1,\"623\":1,\"627\":2,\"646\":1,\"648\":1,\"650\":1,\"682\":1,\"686\":3,\"699\":1,\"702\":2,\"703\":1,\"725\":1,\"759\":1,\"760\":1,\"762\":1,\"769\":1,\"771\":1,\"792\":2,\"795\":1,\"808\":2,\"813\":1,\"835\":1,\"848\":1,\"849\":4,\"850\":2,\"860\":1,\"872\":2,\"873\":2,\"876\":2,\"877\":1,\"880\":1,\"905\":2,\"913\":1,\"934\":1,\"952\":1,\"978\":7,\"979\":27,\"980\":23,\"981\":4,\"996\":2}}],[\"jacop\",{\"1\":{\"391\":1}}],[\"jackson\",{\"1\":{\"409\":1,\"424\":1}}],[\"jack\",{\"1\":{\"306\":2,\"636\":1,\"687\":1}}],[\"jar包\",{\"1\":{\"873\":3}}],[\"jar\",{\"1\":{\"103\":1,\"183\":1,\"457\":1,\"461\":1}}],[\"jar和postgresql\",{\"1\":{\"103\":1}}],[\"jar中的constant目录下\",{\"1\":{\"846\":1}}],[\"jar中\",{\"1\":{\"100\":1,\"101\":1}}],[\"jdbi\",{\"1\":{\"394\":1}}],[\"jdbctemplate\",{\"0\":{\"563\":1},\"1\":{\"563\":2}}],[\"jdbc接口定义\",{\"0\":{\"99\":1}}],[\"jdbc\",{\"0\":{\"98\":1,\"543\":1},\"1\":{\"98\":2,\"100\":1,\"102\":2,\"103\":4,\"145\":1,\"474\":1,\"543\":2,\"546\":1}}],[\"jdk8\",{\"1\":{\"850\":1}}],[\"jdk8中接口允许有默认实现\",{\"1\":{\"845\":1}}],[\"jdk9已修复\",{\"1\":{\"849\":1}}],[\"jdk7之后引入的概念\",{\"1\":{\"849\":1}}],[\"jdk开源实现\",{\"1\":{\"410\":1}}],[\"jdk中缺失的并发工具\",{\"1\":{\"406\":1}}],[\"jdk中查找服务的实现的工具类是\",{\"1\":{\"95\":1}}],[\"jdk\",{\"0\":{\"152\":1,\"186\":1,\"187\":1,\"556\":1,\"575\":1,\"585\":1,\"618\":1,\"637\":1,\"651\":1,\"679\":1,\"699\":1,\"790\":1},\"1\":{\"152\":1,\"186\":2,\"187\":1,\"227\":2,\"410\":2,\"585\":1,\"618\":1,\"637\":1,\"651\":1,\"679\":1,\"692\":1,\"698\":2,\"699\":1,\"700\":3,\"702\":2,\"760\":1,\"790\":1}}],[\"jdk版本\",{\"1\":{\"125\":1}}],[\"jdk1\",{\"1\":{\"104\":2,\"125\":3,\"172\":1,\"759\":1}}],[\"juint是java编程语言的单元测试框架\",{\"1\":{\"968\":1,\"969\":1}}],[\"juc锁\",{\"0\":{\"508\":1,\"509\":1,\"510\":1,\"511\":1}}],[\"juc工具类\",{\"0\":{\"500\":1,\"501\":1,\"502\":1,\"503\":1,\"504\":1}}],[\"juc\",{\"0\":{\"499\":1}}],[\"juc线程池\",{\"0\":{\"495\":1,\"496\":1,\"497\":1,\"498\":1}}],[\"juc集合\",{\"0\":{\"491\":1,\"492\":1,\"493\":1,\"494\":1}}],[\"juc原子类\",{\"0\":{\"490\":1}}],[\"jug协调\",{\"1\":{\"440\":1}}],[\"jug\",{\"1\":{\"440\":3}}],[\"juejin\",{\"1\":{\"314\":1}}],[\"junit5\",{\"0\":{\"985\":1}}],[\"junitsuitetest\",{\"1\":{\"982\":1}}],[\"junitstarter\",{\"1\":{\"979\":4}}],[\"junittest2\",{\"1\":{\"982\":3}}],[\"junittest1\",{\"1\":{\"982\":3}}],[\"junit提供了一个暂停的方便选项\",{\"1\":{\"980\":1}}],[\"junitcore\",{\"1\":{\"979\":2}}],[\"junit38classrunner\",{\"1\":{\"972\":1,\"981\":1}}],[\"junit3到junit4\",{\"0\":{\"241\":1}}],[\"junit会统计忽略的用例数\",{\"1\":{\"972\":1}}],[\"junit在一个条中显示进度\",{\"1\":{\"970\":1}}],[\"junit测试可以被组织为测试套件\",{\"1\":{\"970\":1}}],[\"junit测试可以自动运行并且检查自身结果并提供即时反馈\",{\"1\":{\"970\":1}}],[\"junit特点\",{\"0\":{\"970\":1}}],[\"junit4这\",{\"1\":{\"997\":1}}],[\"junit4ideatestrunner\",{\"1\":{\"979\":2}}],[\"junit4<\",{\"1\":{\"974\":1}}],[\"junit4的默认运行器\",{\"1\":{\"972\":1,\"981\":1}}],[\"junit4\",{\"0\":{\"968\":1},\"1\":{\"972\":1,\"975\":1,\"976\":1,\"977\":1,\"978\":3,\"979\":3,\"980\":3,\"981\":3,\"982\":3,\"983\":1,\"984\":1,\"997\":1}}],[\"junit4源码分析运行原理在新窗口打开\",{\"1\":{\"241\":1}}],[\"junit集成\",{\"1\":{\"434\":1}}],[\"junit\",{\"0\":{\"476\":1},\"1\":{\"241\":2,\"431\":2,\"476\":3,\"478\":1,\"819\":1,\"941\":1,\"970\":3,\"975\":3,\"976\":1,\"977\":2,\"978\":9,\"979\":21,\"980\":11,\"981\":9,\"982\":4,\"983\":3,\"984\":1,\"998\":2}}],[\"judge2\",{\"1\":{\"90\":1}}],[\"judge\",{\"1\":{\"90\":1,\"92\":3}}],[\"just\",{\"1\":{\"86\":1,\"104\":1,\"950\":1}}],[\"jsni\",{\"1\":{\"905\":1}}],[\"jstorm\",{\"1\":{\"869\":1}}],[\"jstorm或com\",{\"1\":{\"869\":1}}],[\"jstack\",{\"1\":{\"851\":1}}],[\"js渲染\",{\"1\":{\"868\":1}}],[\"jsp渲染\",{\"1\":{\"868\":1}}],[\"jsp\",{\"1\":{\"707\":1}}],[\"jsf框架\",{\"1\":{\"434\":1}}],[\"jsfiddle\",{\"1\":{\"77\":1}}],[\"jsoup\",{\"1\":{\"433\":1}}],[\"json是一种通用的mime类型\",{\"1\":{\"854\":1}}],[\"jsonobject\",{\"1\":{\"242\":2}}],[\"jsonresult\",{\"1\":{\"242\":5}}],[\"json\",{\"0\":{\"409\":1},\"1\":{\"87\":2,\"432\":1,\"467\":3,\"854\":2,\"874\":1}}],[\"jscience\",{\"1\":{\"425\":1}}],[\"jsr\",{\"1\":{\"396\":1}}],[\"52\",{\"1\":{\"854\":1}}],[\"523\",{\"1\":{\"446\":1}}],[\"52344729\",{\"1\":{\"305\":1,\"314\":1}}],[\"5d\",{\"1\":{\"846\":1}}],[\"57\",{\"1\":{\"742\":1,\"979\":1}}],[\"575817\",{\"1\":{\"276\":1}}],[\"5f\",{\"1\":{\"584\":1}}],[\"5v\",{\"1\":{\"524\":4,\"528\":3}}],[\"5c160420e51d452a60684431\",{\"1\":{\"314\":1}}],[\"53545041\",{\"1\":{\"299\":1}}],[\"53534949\",{\"1\":{\"116\":1}}],[\"53941091\",{\"1\":{\"299\":1}}],[\"51982979\",{\"1\":{\"299\":1}}],[\"5才开始加入的\",{\"1\":{\"278\":1,\"287\":1}}],[\"58\",{\"1\":{\"270\":1,\"979\":2}}],[\"589\",{\"1\":{\"270\":1}}],[\"5中提供了4个标准的元注解\",{\"1\":{\"226\":1}}],[\"5开始自带的标准注解\",{\"1\":{\"222\":1}}],[\"5版本开始引入的一个特性\",{\"1\":{\"220\":1,\"221\":1}}],[\"500\",{\"1\":{\"854\":1,\"863\":1}}],[\"5000\",{\"1\":{\"709\":3,\"710\":2,\"863\":1,\"980\":1}}],[\"50\",{\"1\":{\"209\":1,\"768\":4,\"777\":1,\"778\":1,\"863\":1,\"979\":1,\"980\":1}}],[\"5出现\",{\"1\":{\"172\":1}}],[\"5\",{\"0\":{\"187\":1},\"1\":{\"77\":1,\"81\":2,\"85\":1,\"120\":1,\"144\":1,\"173\":1,\"186\":1,\"187\":1,\"253\":1,\"275\":5,\"285\":1,\"291\":2,\"471\":1,\"524\":2,\"528\":2,\"555\":1,\"562\":3,\"584\":1,\"650\":1,\"659\":1,\"722\":1,\"723\":2,\"742\":2,\"743\":2,\"759\":1,\"779\":1,\"794\":1,\"798\":2,\"845\":1,\"846\":1,\"847\":3,\"848\":2,\"852\":1,\"854\":2,\"857\":1,\"858\":1,\"871\":2,\"872\":5,\"911\":2,\"942\":1,\"975\":1,\"981\":2,\"996\":1}}],[\"♥jvm相关知识体系详解♥\",{\"0\":{\"382\":1}}],[\"♥java并发知识体系详解♥\",{\"0\":{\"513\":1}}],[\"♥java8特性知识体系详解♥\",{\"0\":{\"359\":1}}],[\"♥java8+特性知识体系详解♥\",{\"0\":{\"337\":1}}],[\"♥java\",{\"0\":{\"336\":1}}],[\"♥\",{\"1\":{\"73\":1}}],[\"3中\",{\"1\":{\"998\":1}}],[\"3l\",{\"1\":{\"773\":2}}],[\"3=\",{\"1\":{\"734\":4}}],[\"3f\",{\"1\":{\"678\":2,\"846\":1,\"847\":1}}],[\"386\",{\"1\":{\"980\":1}}],[\"38259539\",{\"1\":{\"314\":1}}],[\"38173324\",{\"1\":{\"219\":1}}],[\"39\",{\"1\":{\"275\":3}}],[\"363\",{\"1\":{\"979\":1}}],[\"362909601374617660\",{\"1\":{\"854\":1}}],[\"362909601374617692\",{\"1\":{\"854\":1}}],[\"366\",{\"1\":{\"849\":1}}],[\"365\",{\"1\":{\"849\":4}}],[\"361\",{\"1\":{\"631\":1}}],[\"36\",{\"1\":{\"275\":3,\"843\":1}}],[\"34264849\",{\"1\":{\"984\":1}}],[\"340\",{\"1\":{\"980\":1}}],[\"345\",{\"1\":{\"857\":1}}],[\"34\",{\"1\":{\"275\":3,\"872\":1}}],[\"300\",{\"1\":{\"778\":1}}],[\"3000000000l\",{\"1\":{\"935\":2}}],[\"30000\",{\"1\":{\"709\":4,\"710\":2}}],[\"3011274\",{\"1\":{\"283\":1,\"299\":1}}],[\"30\",{\"1\":{\"275\":5,\"291\":1,\"667\":2,\"676\":1,\"678\":2,\"768\":2,\"778\":1,\"872\":1}}],[\"31执行结果为2018\",{\"1\":{\"849\":1}}],[\"31000\",{\"1\":{\"710\":1}}],[\"310实现\",{\"1\":{\"396\":1}}],[\"31\",{\"1\":{\"139\":6,\"275\":3,\"849\":1,\"872\":1}}],[\"325\",{\"1\":{\"979\":1}}],[\"323\",{\"1\":{\"120\":2}}],[\"32\",{\"1\":{\"119\":2,\"161\":1,\"942\":1}}],[\"33\",{\"1\":{\"727\":1,\"979\":1}}],[\"3391013\",{\"1\":{\"299\":1}}],[\"3325560\",{\"1\":{\"116\":1}}],[\"33350\",{\"1\":{\"277\":1}}],[\"333\",{\"1\":{\"81\":1,\"82\":1,\"84\":1}}],[\"3步\",{\"1\":{\"103\":1}}],[\"3为例\",{\"1\":{\"90\":1}}],[\"3544287\",{\"1\":{\"277\":1}}],[\"35\",{\"1\":{\"73\":1,\"942\":1}}],[\"3\",{\"0\":{\"167\":2,\"874\":1},\"1\":{\"71\":1,\"80\":1,\"104\":1,\"123\":1,\"133\":1,\"134\":1,\"138\":1,\"141\":1,\"143\":1,\"144\":1,\"173\":1,\"181\":1,\"228\":1,\"241\":1,\"275\":12,\"284\":1,\"285\":1,\"294\":2,\"420\":1,\"571\":2,\"584\":2,\"637\":1,\"643\":1,\"678\":1,\"700\":1,\"703\":1,\"718\":1,\"721\":1,\"723\":3,\"728\":1,\"734\":9,\"738\":1,\"739\":1,\"742\":1,\"752\":1,\"753\":1,\"773\":2,\"779\":1,\"790\":2,\"794\":1,\"798\":1,\"809\":1,\"826\":1,\"845\":3,\"846\":2,\"847\":4,\"848\":5,\"849\":3,\"850\":5,\"851\":2,\"852\":4,\"854\":2,\"857\":2,\"858\":1,\"863\":2,\"864\":2,\"865\":1,\"866\":1,\"868\":1,\"869\":2,\"870\":1,\"871\":2,\"872\":10,\"920\":4,\"924\":1,\"978\":3,\"981\":1,\"993\":1}}],[\"y的比较结果和y\",{\"1\":{\"850\":1}}],[\"yyyy\",{\"1\":{\"849\":1,\"851\":1,\"854\":1,\"859\":1}}],[\"yyyy表示当天所在的年\",{\"1\":{\"849\":1}}],[\"yangguanbao\",{\"1\":{\"850\":1,\"853\":1}}],[\"yang\",{\"1\":{\"847\":1,\"850\":1}}],[\"year\",{\"1\":{\"618\":1,\"849\":1}}],[\"years\",{\"1\":{\"489\":1}}],[\"yet\",{\"1\":{\"312\":1}}],[\"yes\",{\"1\":{\"71\":1,\"104\":1,\"846\":5,\"915\":2}}],[\"yesnostartis\",{\"1\":{\"71\":2}}],[\"y内容不变\",{\"1\":{\"181\":1}}],[\"y\",{\"1\":{\"119\":1,\"120\":2,\"133\":3,\"134\":6,\"138\":15,\"139\":1,\"143\":2,\"144\":7,\"181\":3,\"289\":2,\"637\":5,\"846\":1,\"848\":4,\"850\":3}}],[\"ys\",{\"1\":{\"96\":3}}],[\"youtubeimporteryoutubeimporter\",{\"1\":{\"947\":1}}],[\"youtube\",{\"1\":{\"947\":1}}],[\"youku\",{\"1\":{\"845\":1}}],[\"yougewe\",{\"1\":{\"309\":1}}],[\"yourself\",{\"1\":{\"871\":1}}],[\"yourkit\",{\"1\":{\"422\":1}}],[\"your\",{\"1\":{\"130\":1}}],[\"you\",{\"1\":{\"68\":2,\"71\":1,\"74\":1,\"76\":1,\"80\":1,\"85\":1,\"466\":1,\"847\":1,\"933\":1}}],[\"gps\",{\"1\":{\"874\":1}}],[\"gmt\",{\"1\":{\"873\":1}}],[\"gav\",{\"1\":{\"873\":1}}],[\"gavin\",{\"1\":{\"622\":2,\"624\":2}}],[\"gamma\",{\"1\":{\"795\":1,\"796\":1}}],[\"gamerole\",{\"1\":{\"667\":14}}],[\"gatling\",{\"1\":{\"431\":1}}],[\"gdb\",{\"1\":{\"481\":1}}],[\"greenwich\",{\"1\":{\"873\":1}}],[\"greek\",{\"1\":{\"610\":4,\"885\":1}}],[\"greekpizza\",{\"1\":{\"609\":5,\"610\":3}}],[\"greekpizz\",{\"1\":{\"609\":1}}],[\"gregoriancalendar\",{\"1\":{\"618\":3}}],[\"gregory\",{\"1\":{\"618\":1}}],[\"groups\",{\"1\":{\"922\":1}}],[\"groupings\",{\"1\":{\"910\":1}}],[\"groupid\",{\"1\":{\"873\":1}}],[\"groupid格式\",{\"1\":{\"869\":1}}],[\"groupid>\",{\"1\":{\"458\":1,\"974\":3}}],[\"groovy框架\",{\"1\":{\"434\":1}}],[\"groovy\",{\"1\":{\"411\":1,\"431\":1}}],[\"grizzly\",{\"1\":{\"419\":1}}],[\"grails\",{\"1\":{\"434\":1}}],[\"gradle项目\",{\"1\":{\"401\":1}}],[\"gradle\",{\"1\":{\"385\":1,\"458\":2,\"484\":1}}],[\"graphiceditor\",{\"1\":{\"738\":13,\"739\":8}}],[\"graphtype\",{\"1\":{\"75\":1,\"76\":1}}],[\"graph\",{\"0\":{\"86\":1},\"1\":{\"71\":1,\"74\":1,\"77\":1,\"80\":2,\"83\":1,\"86\":7}}],[\"gson\",{\"0\":{\"467\":1},\"1\":{\"409\":1,\"467\":7}}],[\"gs\",{\"1\":{\"406\":1}}],[\"guan\",{\"1\":{\"850\":2}}],[\"guaranteed\",{\"1\":{\"451\":1}}],[\"guava\",{\"0\":{\"466\":1},\"1\":{\"432\":1,\"451\":1,\"466\":4}}],[\"guava的函数式编程扩展\",{\"1\":{\"403\":1}}],[\"gupta\",{\"1\":{\"440\":1}}],[\"gui\",{\"0\":{\"405\":1},\"1\":{\"820\":1}}],[\"guice\",{\"1\":{\"397\":1,\"449\":1}}],[\"glassfish\",{\"1\":{\"384\":1,\"440\":1}}],[\"globaltimeout\",{\"1\":{\"980\":1}}],[\"global\",{\"1\":{\"104\":1}}],[\"gc问题分析与解决\",{\"0\":{\"367\":1}}],[\"gc\",{\"0\":{\"367\":1,\"371\":1,\"372\":1,\"373\":1},\"1\":{\"762\":1}}],[\"g\",{\"1\":{\"152\":1,\"848\":1,\"849\":1}}],[\"geeks\",{\"1\":{\"442\":1}}],[\"geekery\",{\"1\":{\"440\":1}}],[\"gee\",{\"1\":{\"440\":1}}],[\"gephi\",{\"1\":{\"432\":1}}],[\"genson\",{\"1\":{\"409\":1}}],[\"generation\",{\"0\":{\"447\":1}}],[\"generating\",{\"1\":{\"312\":1}}],[\"generateaccesstoken\",{\"1\":{\"809\":8}}],[\"generatestate\",{\"1\":{\"779\":1}}],[\"generatename\",{\"1\":{\"312\":1}}],[\"generate\",{\"1\":{\"312\":3,\"779\":3,\"848\":1}}],[\"generatemethod\",{\"1\":{\"312\":5}}],[\"generateconstructor\",{\"1\":{\"310\":1}}],[\"generatedname\",{\"1\":{\"312\":3}}],[\"generated\",{\"1\":{\"302\":1,\"310\":1,\"312\":4}}],[\"generalization\",{\"0\":{\"213\":1,\"833\":1},\"1\":{\"213\":1,\"833\":1}}],[\"genericdeclaration\",{\"1\":{\"302\":1}}],[\"generictype\",{\"1\":{\"298\":2}}],[\"generictype<string>\",{\"1\":{\"298\":2}}],[\"generictype<t>\",{\"1\":{\"298\":1}}],[\"genericarraytype\",{\"1\":{\"298\":1}}],[\"generics\",{\"1\":{\"287\":1,\"294\":1,\"299\":1,\"850\":3}}],[\"genericsdemo30\",{\"1\":{\"285\":1}}],[\"genericsdemo21\",{\"1\":{\"284\":1}}],[\"genericsdemo24\",{\"1\":{\"282\":1}}],[\"genericsdemo09\",{\"1\":{\"281\":1}}],[\"genericsdemo06\",{\"1\":{\"281\":1}}],[\"genericstest\",{\"1\":{\"234\":2}}],[\"generic\",{\"1\":{\"150\":1,\"299\":1}}],[\"gender\",{\"1\":{\"209\":6}}],[\"getyear\",{\"1\":{\"849\":1}}],[\"gethelper\",{\"1\":{\"851\":1}}],[\"gethours\",{\"1\":{\"849\":1}}],[\"gethttpmessage\",{\"1\":{\"845\":1}}],[\"gethumidity\",{\"1\":{\"676\":2,\"678\":1}}],[\"getnoraffllestate\",{\"1\":{\"778\":3}}],[\"getnext\",{\"1\":{\"708\":5}}],[\"getnameifpresent\",{\"1\":{\"928\":1,\"929\":1}}],[\"getname\",{\"1\":{\"106\":1,\"114\":4,\"127\":4,\"209\":1,\"242\":2,\"305\":12,\"306\":11,\"307\":1,\"308\":1,\"310\":2,\"311\":4,\"312\":3,\"574\":10,\"609\":2,\"610\":1,\"613\":4,\"636\":2,\"650\":6,\"685\":5,\"687\":1,\"826\":1,\"851\":1,\"859\":2,\"942\":1}}],[\"getxxx\",{\"1\":{\"675\":1}}],[\"getvit\",{\"1\":{\"667\":3}}],[\"getvariant\",{\"1\":{\"618\":1}}],[\"getvar\",{\"1\":{\"281\":2,\"282\":3,\"284\":2}}],[\"getvalue\",{\"1\":{\"114\":1,\"132\":1,\"281\":2,\"289\":2,\"291\":18,\"644\":2,\"779\":7,\"850\":2}}],[\"getexpstr\",{\"1\":{\"644\":2}}],[\"getexceptiontypes\",{\"1\":{\"310\":1,\"312\":3}}],[\"getlanguage\",{\"1\":{\"618\":2}}],[\"getlock\",{\"1\":{\"852\":1}}],[\"getloginname\",{\"1\":{\"242\":1}}],[\"getlogger\",{\"1\":{\"242\":1,\"859\":1,\"942\":1}}],[\"getlog\",{\"1\":{\"104\":1,\"859\":1}}],[\"getlong\",{\"1\":{\"93\":1}}],[\"getgreekpizza\",{\"1\":{\"610\":1}}],[\"getgenericreturntype方法都是获取method对象表示的方法的返回类型\",{\"1\":{\"308\":1}}],[\"getgenericreturntype\",{\"1\":{\"308\":1}}],[\"getgenericparametertypes也是同样的道理\",{\"1\":{\"308\":1}}],[\"getgenericparametertypes\",{\"1\":{\"306\":4,\"308\":1}}],[\"getgenericsuperclass\",{\"1\":{\"298\":1}}],[\"getgender\",{\"1\":{\"209\":1}}],[\"getwomanresult\",{\"1\":{\"839\":6}}],[\"getwebsitecount\",{\"1\":{\"636\":2}}],[\"getwebsitecategory\",{\"1\":{\"636\":5}}],[\"getwall\",{\"1\":{\"555\":1}}],[\"getwidget\",{\"1\":{\"451\":1}}],[\"getunicodelocaletype\",{\"1\":{\"618\":1}}],[\"getunsafe\",{\"1\":{\"310\":1}}],[\"getuser\",{\"1\":{\"469\":1}}],[\"getbytes\",{\"1\":{\"978\":2}}],[\"getb\",{\"1\":{\"858\":1}}],[\"getbean从singletonobjects\",{\"1\":{\"627\":1}}],[\"getbean\",{\"1\":{\"622\":1,\"624\":1,\"625\":3,\"627\":1}}],[\"getbaise\",{\"1\":{\"555\":1}}],[\"getbaz\",{\"1\":{\"450\":1}}],[\"getbar\",{\"1\":{\"450\":2}}],[\"getboolean\",{\"1\":{\"307\":1}}],[\"getfoo\",{\"1\":{\"960\":1}}],[\"getflyweight\",{\"1\":{\"632\":6}}],[\"getfindclasses\",{\"1\":{\"310\":1}}],[\"getfindclasstime\",{\"1\":{\"310\":1}}],[\"getfield\",{\"1\":{\"307\":4}}],[\"getfields\",{\"1\":{\"305\":2,\"307\":3,\"310\":1}}],[\"getfactory\",{\"1\":{\"104\":3}}],[\"getobject\",{\"1\":{\"848\":1}}],[\"getobjectaddress\",{\"1\":{\"127\":5}}],[\"getogenericstring\",{\"1\":{\"306\":4}}],[\"getownertype\",{\"1\":{\"298\":1}}],[\"getrandominstance\",{\"1\":{\"773\":1}}],[\"getrawtype\",{\"1\":{\"298\":1}}],[\"getruntime\",{\"1\":{\"760\":1}}],[\"getroofed\",{\"1\":{\"555\":1}}],[\"getresult\",{\"1\":{\"551\":1}}],[\"getresources\",{\"1\":{\"106\":1,\"114\":1}}],[\"getresourceasstream\",{\"1\":{\"104\":1,\"625\":1}}],[\"getreflectionfactory\",{\"1\":{\"310\":1,\"311\":1}}],[\"getreturntype方法\",{\"1\":{\"308\":1}}],[\"getreturntype\",{\"1\":{\"308\":1,\"311\":2,\"312\":3}}],[\"getrequesturi\",{\"1\":{\"242\":1}}],[\"getrequest\",{\"1\":{\"242\":3}}],[\"geta\",{\"1\":{\"858\":1}}],[\"getandincrement\",{\"1\":{\"851\":1}}],[\"getannotationlog\",{\"1\":{\"242\":2}}],[\"getannotation的区别在于\",{\"1\":{\"233\":1}}],[\"getannotation\",{\"1\":{\"233\":1,\"234\":1,\"242\":1}}],[\"getannotationsbytype会检测注解对应的重复注解容器\",{\"1\":{\"233\":1}}],[\"getannotationsbytype方法与\",{\"1\":{\"233\":1}}],[\"getannotationsbytype\",{\"1\":{\"233\":1}}],[\"getannotations\",{\"1\":{\"230\":1,\"233\":1}}],[\"getallemployee\",{\"1\":{\"742\":4,\"743\":4}}],[\"getallcount\",{\"1\":{\"308\":4}}],[\"getarg\",{\"1\":{\"627\":3}}],[\"getadapter\",{\"1\":{\"618\":1}}],[\"getage\",{\"1\":{\"305\":1,\"306\":1,\"685\":5,\"687\":1}}],[\"getactualtypearguments\",{\"1\":{\"298\":3}}],[\"getdispensoutstate\",{\"1\":{\"778\":1}}],[\"getdispensestate\",{\"1\":{\"778\":1}}],[\"getdata\",{\"1\":{\"298\":1,\"312\":1,\"445\":1,\"848\":1}}],[\"getdef\",{\"1\":{\"667\":3}}],[\"getdefault\",{\"1\":{\"618\":2}}],[\"getdesc\",{\"1\":{\"650\":1}}],[\"getdes\",{\"1\":{\"574\":7,\"584\":10}}],[\"getdeclaringclass\",{\"1\":{\"306\":4,\"307\":3,\"310\":2,\"312\":6}}],[\"getdeclaredmethods0\",{\"1\":{\"311\":1}}],[\"getdeclaredmethods方法都只能获取当前类的方法\",{\"1\":{\"308\":1}}],[\"getdeclaredmethods\",{\"1\":{\"308\":2}}],[\"getdeclaredmethod\",{\"1\":{\"308\":4,\"309\":1,\"311\":1}}],[\"getdeclaredconstructors0\",{\"1\":{\"310\":1}}],[\"getdeclaredconstructors\",{\"1\":{\"306\":2}}],[\"getdeclaredconstructor\",{\"1\":{\"306\":3}}],[\"getdeclaredannotations\",{\"1\":{\"233\":1,\"234\":1}}],[\"getdeclaredannotationsbytype\",{\"1\":{\"233\":1}}],[\"getdeclaredannotation\",{\"1\":{\"233\":1}}],[\"getdeclaredfields方法来获取字段即可\",{\"1\":{\"307\":1}}],[\"getdeclaredfields\",{\"1\":{\"305\":2,\"307\":2}}],[\"getdeclaredfield\",{\"1\":{\"91\":2,\"93\":1,\"307\":4}}],[\"getdeptid\",{\"1\":{\"242\":1}}],[\"getdeptname\",{\"1\":{\"242\":5}}],[\"getdept\",{\"1\":{\"242\":3}}],[\"getkey\",{\"1\":{\"281\":2,\"779\":1,\"850\":2}}],[\"gettime\",{\"1\":{\"849\":1}}],[\"gettemperature\",{\"1\":{\"676\":2,\"678\":1}}],[\"getter的参数名称\",{\"1\":{\"845\":1}}],[\"getter的参数名称也要避免与成员变量名称相同\",{\"1\":{\"845\":1}}],[\"getter\",{\"1\":{\"132\":1,\"471\":2,\"609\":1,\"613\":1,\"626\":2,\"778\":1,\"848\":1,\"873\":1}}],[\"gettypename\",{\"1\":{\"308\":1}}],[\"gettype\",{\"1\":{\"307\":1,\"627\":1,\"710\":1}}],[\"gettargetexception\",{\"1\":{\"310\":1}}],[\"gettarget\",{\"1\":{\"242\":1}}],[\"getiterator\",{\"1\":{\"649\":3}}],[\"getisref\",{\"1\":{\"627\":1}}],[\"getip\",{\"1\":{\"242\":1}}],[\"getidcard\",{\"1\":{\"828\":1}}],[\"getid\",{\"1\":{\"132\":1,\"627\":5,\"710\":5,\"742\":4,\"743\":4,\"763\":1,\"764\":6,\"769\":4,\"771\":2,\"772\":2,\"850\":2}}],[\"getinsance\",{\"1\":{\"769\":1}}],[\"getinstanc\",{\"1\":{\"601\":2}}],[\"getinstance\",{\"1\":{\"104\":1,\"601\":10,\"618\":4,\"752\":5,\"753\":3,\"754\":3,\"755\":4,\"756\":3,\"757\":3,\"758\":4,\"763\":1,\"764\":4,\"768\":9,\"769\":1,\"771\":1,\"772\":2,\"773\":5,\"849\":1}}],[\"getinfo\",{\"1\":{\"632\":2,\"727\":6}}],[\"getintance\",{\"1\":{\"764\":2,\"768\":1}}],[\"getinterfaces\",{\"1\":{\"305\":2,\"700\":1}}],[\"getint\",{\"1\":{\"93\":3,\"307\":1}}],[\"getpersonbyname\",{\"1\":{\"927\":1}}],[\"getpingfenbyname\",{\"1\":{\"845\":1}}],[\"getproxyinstance\",{\"1\":{\"700\":2,\"703\":2}}],[\"getproperty\",{\"1\":{\"103\":1,\"104\":3,\"106\":1}}],[\"getpressure\",{\"1\":{\"676\":2,\"678\":1}}],[\"getprice\",{\"1\":{\"584\":5,\"710\":7,\"996\":2}}],[\"getparametertypes\",{\"1\":{\"306\":5,\"308\":1,\"310\":2,\"311\":1,\"312\":3}}],[\"getparametermap\",{\"1\":{\"242\":1}}],[\"getparentdelegationtime\",{\"1\":{\"310\":1}}],[\"getparentid\",{\"1\":{\"242\":1}}],[\"getparent\",{\"1\":{\"114\":1}}],[\"getseq\",{\"1\":{\"846\":1}}],[\"getsecuritymanager\",{\"1\":{\"114\":1,\"310\":2}}],[\"getstrategy\",{\"1\":{\"784\":1}}],[\"getstate\",{\"1\":{\"664\":6,\"776\":1,\"779\":1}}],[\"getstatic\",{\"1\":{\"275\":9}}],[\"getsuperclass\",{\"1\":{\"305\":1}}],[\"getsupercalss\",{\"1\":{\"305\":1}}],[\"getsuppressed\",{\"1\":{\"259\":1}}],[\"getsimplename\",{\"1\":{\"305\":7}}],[\"getsignature\",{\"1\":{\"242\":2}}],[\"getsalary\",{\"1\":{\"284\":1}}],[\"getsavedproperty\",{\"1\":{\"120\":1}}],[\"getsysuser\",{\"1\":{\"242\":1}}],[\"getsystemresources\",{\"1\":{\"106\":1,\"114\":1}}],[\"getsystemproperty\",{\"1\":{\"104\":1}}],[\"getsystemclassloader\",{\"1\":{\"103\":1,\"114\":2}}],[\"getmanresult\",{\"1\":{\"839\":5}}],[\"getmapping\",{\"1\":{\"242\":1}}],[\"getmemento\",{\"1\":{\"664\":2,\"667\":2}}],[\"getmediator\",{\"1\":{\"659\":5}}],[\"getmethodaccessor\",{\"1\":{\"312\":1}}],[\"getmethod\",{\"1\":{\"242\":2,\"288\":1,\"308\":3}}],[\"getmethods\",{\"1\":{\"234\":1,\"308\":2,\"310\":1}}],[\"getmessage\",{\"1\":{\"104\":3,\"242\":2,\"659\":7,\"687\":1,\"689\":1,\"779\":1,\"859\":1}}],[\"getmodifiers\",{\"1\":{\"91\":1,\"310\":3,\"312\":3}}],[\"getc\",{\"1\":{\"858\":1}}],[\"getcurrentstate\",{\"1\":{\"779\":19}}],[\"getcount\",{\"1\":{\"778\":2}}],[\"getcountry\",{\"1\":{\"618\":2}}],[\"getcolor\",{\"1\":{\"685\":5,\"687\":1}}],[\"getconstructorargs\",{\"1\":{\"627\":1}}],[\"getconstructor0\",{\"1\":{\"310\":3}}],[\"getconstructors\",{\"1\":{\"306\":1}}],[\"getconstructor\",{\"1\":{\"306\":2,\"627\":1}}],[\"getcontrollermethoddescription\",{\"1\":{\"242\":2}}],[\"getcontextclassloader\",{\"1\":{\"114\":1}}],[\"getcontextclassloaderinternal\",{\"1\":{\"104\":1}}],[\"getcontext\",{\"1\":{\"114\":1}}],[\"getconfigurationfile\",{\"1\":{\"104\":1}}],[\"getconnection\",{\"1\":{\"102\":1}}],[\"getcheesepizza\",{\"1\":{\"610\":1}}],[\"getchild\",{\"1\":{\"568\":1,\"569\":1,\"571\":5}}],[\"getchar\",{\"1\":{\"307\":1}}],[\"getcanrafflestate\",{\"1\":{\"778\":1}}],[\"getcanonicalname与getsimplename的区别\",{\"1\":{\"305\":1}}],[\"getcanonicalname\",{\"1\":{\"305\":7,\"960\":1}}],[\"getcalendarprovider\",{\"1\":{\"618\":1}}],[\"getcallerclass\",{\"1\":{\"310\":4,\"311\":1,\"312\":1}}],[\"getcachedfactory\",{\"1\":{\"104\":1}}],[\"getclassname\",{\"1\":{\"312\":3,\"627\":2}}],[\"getclassloadinglock\",{\"1\":{\"310\":2}}],[\"getclassloader\",{\"1\":{\"234\":1,\"310\":1,\"312\":2,\"700\":1}}],[\"getclass\",{\"1\":{\"137\":1,\"138\":2,\"190\":1,\"242\":1,\"288\":3,\"298\":1,\"302\":1,\"305\":6,\"308\":1,\"309\":1,\"311\":1,\"625\":1,\"700\":3,\"703\":1}}],[\"get\",{\"1\":{\"93\":1,\"141\":6,\"145\":1,\"147\":1,\"209\":1,\"288\":1,\"290\":3,\"294\":2,\"295\":1,\"307\":2,\"310\":3,\"311\":1,\"312\":1,\"419\":1,\"451\":2,\"571\":2,\"618\":6,\"627\":5,\"632\":1,\"636\":1,\"644\":1,\"649\":2,\"650\":1,\"659\":12,\"678\":1,\"741\":1,\"771\":1,\"773\":3,\"846\":1,\"850\":1,\"854\":1}}],[\"git\",{\"1\":{\"460\":1}}],[\"gitbook\",{\"1\":{\"155\":1}}],[\"gitbook2\",{\"1\":{\"155\":1}}],[\"gitbook中文文档\",{\"1\":{\"155\":1}}],[\"github\",{\"1\":{\"77\":8,\"155\":2,\"413\":1,\"420\":2,\"437\":1,\"447\":1,\"875\":1,\"978\":1,\"984\":1}}],[\"give\",{\"1\":{\"104\":1}}],[\"given\",{\"1\":{\"73\":1}}],[\"goncalves\",{\"1\":{\"440\":1}}],[\"google的断言和命题\",{\"1\":{\"431\":1}}],[\"google数据交换格式\",{\"1\":{\"395\":1}}],[\"google\",{\"0\":{\"875\":1},\"1\":{\"395\":1,\"434\":1,\"442\":1,\"449\":2,\"453\":1,\"875\":1,\"876\":2,\"878\":1,\"905\":1,\"907\":1,\"912\":1,\"937\":2,\"947\":1}}],[\"goodflybehavior\",{\"1\":{\"789\":2}}],[\"good\",{\"1\":{\"104\":1,\"460\":1,\"951\":1,\"978\":7}}],[\"gof\",{\"1\":{\"187\":1,\"606\":1,\"795\":1,\"808\":1}}],[\"goto\",{\"1\":{\"151\":2,\"275\":5}}],[\"going\",{\"1\":{\"80\":1}}],[\"goes\",{\"1\":{\"68\":1}}],[\"go\",{\"1\":{\"57\":2,\"68\":1,\"392\":1}}],[\"ufeff\",{\"1\":{\"885\":1}}],[\"u221e\",{\"1\":{\"885\":1}}],[\"udp连接采用与文件一样的方式去管理\",{\"1\":{\"870\":1}}],[\"uk\",{\"1\":{\"863\":1}}],[\"uuid之类的唯一编号进行查询\",{\"1\":{\"859\":1}}],[\"uid等\",{\"1\":{\"845\":1}}],[\"ui\",{\"1\":{\"840\":1}}],[\"ui函数库\",{\"1\":{\"415\":1}}],[\"umbrella\",{\"1\":{\"427\":1}}],[\"uml类图\",{\"0\":{\"821\":1}}],[\"uml\",{\"0\":{\"822\":1,\"825\":1,\"826\":1},\"1\":{\"219\":2,\"822\":7,\"823\":11,\"824\":3,\"825\":2,\"827\":2,\"830\":1,\"831\":1,\"832\":1,\"833\":1,\"834\":1,\"835\":1}}],[\"uc\",{\"1\":{\"860\":1}}],[\"ucp\",{\"1\":{\"310\":1}}],[\"uclazz=cs3\",{\"1\":{\"306\":1}}],[\"u03bcs\",{\"1\":{\"885\":3}}],[\"u011240877\",{\"1\":{\"299\":1}}],[\"u000a\",{\"1\":{\"884\":1}}],[\"u0000\",{\"1\":{\"120\":1}}],[\"u000d就是一个unicode转义字符\",{\"1\":{\"89\":1}}],[\"u000d\",{\"1\":{\"89\":3}}],[\"u0030\",{\"1\":{\"89\":3}}],[\"u0032\",{\"1\":{\"89\":1}}],[\"u003b\",{\"1\":{\"89\":2}}],[\"u007f\",{\"1\":{\"120\":1}}],[\"u0070\",{\"1\":{\"89\":1}}],[\"u0073\",{\"1\":{\"89\":1}}],[\"u0072\",{\"1\":{\"89\":1}}],[\"u0029\",{\"1\":{\"89\":1}}],[\"u0028\",{\"1\":{\"89\":1}}],[\"u002e\",{\"1\":{\"89\":1}}],[\"u002b\",{\"1\":{\"89\":2}}],[\"u006c\",{\"1\":{\"89\":1}}],[\"u0064\",{\"1\":{\"89\":1}}],[\"u0065\",{\"1\":{\"89\":3}}],[\"u0068\",{\"1\":{\"89\":1}}],[\"u0061\",{\"1\":{\"89\":2}}],[\"u0054\",{\"1\":{\"89\":1}}],[\"u\",{\"1\":{\"114\":9}}],[\"unaligned\",{\"1\":{\"912\":1}}],[\"unauthorized\",{\"1\":{\"854\":1}}],[\"unorder\",{\"1\":{\"850\":1}}],[\"unoptimized\",{\"1\":{\"225\":1}}],[\"unknown\",{\"1\":{\"845\":1}}],[\"unknownhostexception\",{\"1\":{\"256\":2}}],[\"undobuttonwaspushed\",{\"1\":{\"562\":3}}],[\"undocommand\",{\"1\":{\"562\":4}}],[\"undo\",{\"1\":{\"560\":1,\"562\":7,\"565\":1}}],[\"undertow\",{\"1\":{\"419\":1}}],[\"underlying\",{\"1\":{\"310\":1}}],[\"underscore\",{\"1\":{\"150\":1}}],[\"under\",{\"1\":{\"145\":1,\"310\":1,\"860\":1,\"994\":1}}],[\"unicode\",{\"1\":{\"884\":1,\"885\":5,\"905\":2}}],[\"unitabbrev\",{\"1\":{\"885\":4}}],[\"unit\",{\"1\":{\"860\":1,\"988\":1,\"989\":1}}],[\"unitils\",{\"1\":{\"431\":1}}],[\"unified\",{\"1\":{\"822\":1}}],[\"university\",{\"1\":{\"574\":10,\"831\":1}}],[\"univocity\",{\"1\":{\"393\":1}}],[\"unirest\",{\"1\":{\"419\":2}}],[\"unix\",{\"0\":{\"331\":1}}],[\"unique\",{\"1\":{\"242\":2}}],[\"unbounded\",{\"1\":{\"294\":1}}],[\"unboxing\",{\"1\":{\"225\":1}}],[\"unresolved\",{\"1\":{\"284\":1}}],[\"unlock对未加锁的对象解锁\",{\"1\":{\"851\":1}}],[\"unlock\",{\"1\":{\"258\":1,\"772\":1,\"851\":3}}],[\"unlike\",{\"1\":{\"104\":1}}],[\"unused\",{\"1\":{\"225\":2}}],[\"unqualified\",{\"1\":{\"225\":2}}],[\"unchecked\",{\"0\":{\"249\":1},\"1\":{\"225\":2,\"234\":1,\"252\":1,\"310\":2}}],[\"un\",{\"1\":{\"225\":1}}],[\"unexpected\",{\"1\":{\"145\":1,\"978\":1,\"979\":1}}],[\"unsort\",{\"1\":{\"850\":3}}],[\"unsound\",{\"1\":{\"294\":1}}],[\"unsigned\",{\"1\":{\"848\":1,\"863\":5}}],[\"unsharedconcreteflyweight\",{\"1\":{\"632\":11}}],[\"unsharable\",{\"1\":{\"632\":1}}],[\"unsupportedmethodexception\",{\"1\":{\"812\":2}}],[\"unsupportedoperationexception\",{\"1\":{\"114\":2,\"265\":1,\"574\":2}}],[\"unsupportedencodingexception\",{\"1\":{\"104\":1}}],[\"unsafe和原子类详解\",{\"0\":{\"490\":1}}],[\"unsafe除了能直接操作内存空间外\",{\"1\":{\"93\":1}}],[\"unsafe\",{\"1\":{\"93\":19,\"310\":1}}],[\"unsafefield\",{\"1\":{\"93\":3}}],[\"utc\",{\"1\":{\"873\":1}}],[\"utf\",{\"0\":{\"881\":1},\"1\":{\"104\":1,\"114\":1,\"259\":1,\"312\":56,\"881\":1,\"974\":1}}],[\"utils类\",{\"1\":{\"869\":1}}],[\"util\",{\"0\":{\"452\":1},\"1\":{\"95\":1,\"114\":1,\"234\":2,\"291\":7,\"473\":1,\"845\":1,\"848\":1,\"849\":1,\"850\":5,\"851\":1,\"978\":1,\"980\":5,\"981\":4}}],[\"url外部重定向传入的目标地址必须执行白名单过滤\",{\"1\":{\"861\":1}}],[\"url参数超长\",{\"1\":{\"854\":1}}],[\"url带的参数必须无敏感信息或符合安全要求\",{\"1\":{\"854\":1}}],[\"url路径不能使用大写\",{\"1\":{\"854\":1}}],[\"urldecoder中的方法decode\",{\"1\":{\"848\":1}}],[\"urlresource\",{\"1\":{\"106\":1}}],[\"url\",{\"1\":{\"102\":2,\"106\":3,\"114\":3,\"631\":1,\"809\":6,\"814\":14,\"905\":1}}],[\"urls\",{\"1\":{\"77\":1,\"106\":3}}],[\"upper\",{\"1\":{\"942\":1}}],[\"upload\",{\"1\":{\"809\":5}}],[\"uploadtoaliyun\",{\"1\":{\"809\":5}}],[\"upcurtains\",{\"1\":{\"659\":2}}],[\"uprightphone\",{\"1\":{\"542\":6}}],[\"updatedept\",{\"1\":{\"242\":1}}],[\"update\",{\"1\":{\"242\":1,\"676\":3,\"678\":5,\"679\":1,\"863\":2,\"866\":1}}],[\"upgrades\",{\"1\":{\"145\":1}}],[\"up\",{\"1\":{\"71\":1,\"104\":2,\"312\":1,\"601\":5,\"659\":1}}],[\"ultimately\",{\"1\":{\"71\":1}}],[\"usage\",{\"1\":{\"77\":1,\"225\":1}}],[\"usesprimitivetypes\",{\"1\":{\"312\":1}}],[\"usesprimitives\",{\"1\":{\"312\":3}}],[\"usecaches\",{\"1\":{\"310\":2}}],[\"use类型\",{\"1\":{\"236\":1}}],[\"use注解\",{\"1\":{\"236\":1}}],[\"userdao\",{\"1\":{\"995\":2}}],[\"userdo\",{\"1\":{\"845\":2}}],[\"userinfo\",{\"1\":{\"851\":1}}],[\"useridgenerator\",{\"1\":{\"764\":1}}],[\"userid\",{\"1\":{\"469\":2}}],[\"userthreadfactory\",{\"1\":{\"851\":2}}],[\"users\",{\"1\":{\"850\":1}}],[\"userservice\",{\"1\":{\"622\":1,\"995\":2}}],[\"userrequested\",{\"1\":{\"790\":1}}],[\"user2\",{\"1\":{\"306\":2}}],[\"user2=\",{\"1\":{\"306\":1}}],[\"user1\",{\"1\":{\"306\":3}}],[\"user1=\",{\"1\":{\"306\":1}}],[\"user必须无参构造函数\",{\"1\":{\"306\":1}}],[\"usercache\",{\"1\":{\"850\":1}}],[\"userclass\",{\"1\":{\"305\":3}}],[\"userconstants\",{\"1\":{\"242\":2}}],[\"user\",{\"1\":{\"145\":1,\"242\":1,\"305\":13,\"306\":25,\"636\":12,\"764\":2,\"770\":7,\"773\":2,\"853\":2,\"857\":1}}],[\"username\",{\"1\":{\"102\":1}}],[\"usetcclstr\",{\"1\":{\"104\":4}}],[\"used\",{\"1\":{\"80\":1,\"104\":4,\"122\":1,\"145\":1,\"302\":1}}],[\"usemaxwidth\",{\"1\":{\"77\":1}}],[\"use\",{\"1\":{\"70\":1,\"73\":1,\"76\":1,\"80\":1,\"87\":2,\"104\":6,\"133\":1,\"145\":4,\"227\":1,\"234\":1,\"236\":3,\"264\":3,\"466\":1,\"636\":6,\"822\":1,\"927\":1}}],[\"using\",{\"1\":{\"68\":1,\"73\":1,\"77\":3,\"82\":1,\"85\":1,\"104\":4,\"134\":1,\"145\":4,\"225\":1,\"864\":1}}],[\"<version>4\",{\"1\":{\"974\":1}}],[\"<version>1\",{\"1\":{\"974\":1}}],[\"<groupid>junit<\",{\"1\":{\"974\":1}}],[\"<groupid>org\",{\"1\":{\"458\":1,\"974\":2}}],[\"<configuration>\",{\"1\":{\"974\":1}}],[\"<constructor\",{\"1\":{\"622\":3,\"624\":3}}],[\"<artifactid>junit<\",{\"1\":{\"974\":1}}],[\"<artifactid>java\",{\"1\":{\"974\":1}}],[\"<artifactid>maven\",{\"1\":{\"974\":1}}],[\"<artifactid>some\",{\"1\":{\"458\":1}}],[\"<modelversion>4\",{\"1\":{\"974\":1}}],[\"<plugin>\",{\"1\":{\"974\":1}}],[\"<plugins>\",{\"1\":{\"974\":1}}],[\"<project\",{\"1\":{\"974\":1}}],[\"<p>\",{\"1\":{\"956\":2}}],[\"<ul>\",{\"1\":{\"956\":1}}],[\"<isnotnull>表示不为null值时执行\",{\"1\":{\"866\":1}}],[\"<isnotempty>表示不为空且不为null时执行\",{\"1\":{\"866\":1}}],[\"<isequal>中的comparevalue是与属性值对比的常量\",{\"1\":{\"866\":1}}],[\"<integer>either\",{\"1\":{\"978\":1}}],[\"<integer>add\",{\"1\":{\"289\":2}}],[\"<init>\",{\"1\":{\"228\":1,\"291\":1,\"310\":1,\"312\":3}}],[\"<logger\",{\"1\":{\"859\":1}}],[\"<build>\",{\"1\":{\"974\":1}}],[\"<bean\",{\"1\":{\"622\":2,\"624\":2}}],[\"<beans>\",{\"1\":{\"622\":1,\"624\":1}}],[\"<body>\",{\"1\":{\"77\":1}}],[\"<dependencymanagement>里只是声明版本\",{\"1\":{\"869\":1}}],[\"<dependencymanagement>部分来管理\",{\"1\":{\"458\":1}}],[\"<dependency>\",{\"1\":{\"458\":1,\"974\":1}}],[\"<dependencies>\",{\"1\":{\"458\":1,\"974\":1}}],[\"<div\",{\"1\":{\"77\":1}}],[\"<number>add\",{\"1\":{\"289\":1}}],[\"<2500\",{\"1\":{\"284\":1}}],[\"<extends\",{\"1\":{\"907\":1}}],[\"<e\",{\"1\":{\"284\":1}}],[\"<target>8<\",{\"1\":{\"974\":1}}],[\"<table>\",{\"1\":{\"956\":1}}],[\"<t>\",{\"1\":{\"285\":2,\"289\":1,\"293\":1,\"310\":1,\"790\":1}}],[\"<t\",{\"1\":{\"233\":4,\"279\":1,\"284\":1,\"296\":1,\"297\":2,\"911\":1}}],[\"<|\",{\"1\":{\"213\":2,\"214\":2}}],[\"<<interface>>\",{\"1\":{\"826\":1}}],[\"<<\",{\"1\":{\"203\":2}}],[\"<>\",{\"1\":{\"186\":1}}],[\"<=\",{\"1\":{\"120\":1,\"209\":2,\"709\":4,\"710\":3}}],[\"<scope>test<\",{\"1\":{\"974\":1}}],[\"<script>\",{\"1\":{\"77\":2}}],[\"<source>8<\",{\"1\":{\"974\":1}}],[\"<s>\",{\"1\":{\"114\":3}}],[\"<style>\",{\"1\":{\"83\":1}}],[\"<\",{\"1\":{\"70\":1,\"77\":4,\"83\":1,\"93\":1,\"114\":1,\"120\":1,\"141\":5,\"276\":3,\"284\":6,\"287\":1,\"288\":1,\"293\":1,\"306\":2,\"310\":1,\"311\":1,\"312\":1,\"458\":2,\"562\":1,\"622\":3,\"624\":3,\"627\":1,\"644\":1,\"649\":1,\"678\":1,\"709\":3,\"710\":2,\"742\":2,\"743\":2,\"778\":1,\"845\":1,\"848\":2,\"852\":1,\"855\":1,\"974\":8,\"978\":1,\"981\":1}}],[\"xsd\",{\"1\":{\"974\":2}}],[\"xsi\",{\"1\":{\"974\":1}}],[\"xsi=\",{\"1\":{\"974\":1}}],[\"xss跨站脚本攻击\",{\"1\":{\"861\":1}}],[\"x等于\",{\"1\":{\"858\":1}}],[\"x等于1\",{\"1\":{\"273\":1}}],[\"x的比较结果相反\",{\"1\":{\"850\":1}}],[\"x为基本数据类型\",{\"1\":{\"848\":1}}],[\"xueli\",{\"1\":{\"728\":5}}],[\"x2\",{\"1\":{\"637\":2}}],[\"x1==x2\",{\"1\":{\"637\":1}}],[\"x1\",{\"1\":{\"637\":2}}],[\"xiaomifactory\",{\"1\":{\"617\":6}}],[\"xiaomirouter\",{\"1\":{\"617\":2}}],[\"xiaomiphone\",{\"1\":{\"617\":2}}],[\"xiaomi\",{\"1\":{\"542\":3}}],[\"xhtml和css\",{\"1\":{\"421\":1}}],[\"xmpp\",{\"1\":{\"414\":1}}],[\"xmlschema\",{\"1\":{\"974\":1}}],[\"xmlservice\",{\"1\":{\"845\":2}}],[\"xmlns\",{\"1\":{\"974\":1}}],[\"xmlns=\",{\"1\":{\"974\":1}}],[\"xmlhttprequest\",{\"1\":{\"947\":2}}],[\"xml配置参数使用\",{\"1\":{\"866\":1}}],[\"xml增加映射\",{\"1\":{\"866\":1}}],[\"xmlbeanconfigparser\",{\"1\":{\"625\":1,\"626\":2}}],[\"xml解析器\",{\"1\":{\"434\":1}}],[\"xml\",{\"1\":{\"105\":1,\"421\":1,\"449\":5,\"484\":2,\"622\":1,\"624\":2,\"625\":1,\"646\":1,\"854\":2,\"947\":1,\"974\":1}}],[\"xtend\",{\"1\":{\"411\":1}}],[\"xls\",{\"1\":{\"402\":1}}],[\"xlsx\",{\"1\":{\"402\":1}}],[\"x本地发布文件\",{\"1\":{\"401\":1}}],[\"xx\",{\"1\":{\"312\":1,\"870\":1}}],[\"xxstring\",{\"1\":{\"279\":1}}],[\"xxx的方式命名\",{\"1\":{\"863\":1}}],[\"xxx的命名方式是为了明确其取值含义与取值范围\",{\"1\":{\"863\":1}}],[\"xxx的命名方式\",{\"1\":{\"845\":1}}],[\"xxx方式\",{\"1\":{\"853\":1}}],[\"xxxlock\",{\"1\":{\"851\":3}}],[\"xxx一般为网页名称\",{\"1\":{\"845\":1}}],[\"xxxvo\",{\"1\":{\"845\":1}}],[\"xxxdto\",{\"1\":{\"845\":1}}],[\"xxxdo\",{\"1\":{\"845\":1}}],[\"xxx即为数据表名\",{\"1\":{\"845\":1}}],[\"xxx到xxx的映射关系\",{\"1\":{\"845\":1,\"863\":1}}],[\"xxx为业务领域相关的名称\",{\"1\":{\"845\":1}}],[\"xxx为方法名\",{\"1\":{\"199\":1}}],[\"xxx为变量名或对象名\",{\"1\":{\"199\":1}}],[\"xxx\",{\"1\":{\"144\":1,\"199\":2,\"242\":1}}],[\"xxxxxxx\",{\"1\":{\"230\":1}}],[\"xxxx\",{\"1\":{\"102\":4,\"532\":2}}],[\"xyz\",{\"1\":{\"270\":3}}],[\"x<<5\",{\"1\":{\"139\":1}}],[\"x<0\",{\"1\":{\"90\":1}}],[\"xerces\",{\"1\":{\"104\":1}}],[\"x>>>31==1\",{\"1\":{\"90\":1}}],[\"x>>>31==0\",{\"1\":{\"90\":1}}],[\"x>0\",{\"1\":{\"90\":1}}],[\"x\",{\"1\":{\"69\":1,\"70\":2,\"90\":2,\"119\":2,\"120\":2,\"130\":2,\"132\":2,\"133\":3,\"134\":6,\"138\":20,\"139\":3,\"143\":3,\"144\":8,\"181\":5,\"203\":2,\"243\":1,\"273\":1,\"277\":1,\"289\":1,\"299\":1,\"314\":1,\"398\":1,\"469\":2,\"637\":8,\"709\":4,\"848\":4,\"850\":3,\"852\":2,\"855\":1,\"858\":1,\"901\":2,\"911\":1,\"912\":2,\"946\":1}}],[\">返回list\",{\"1\":{\"298\":1}}],[\">t\",{\"1\":{\"296\":1}}],[\">的类型参数都被替换为object\",{\"1\":{\"287\":1}}],[\">>>\",{\"1\":{\"203\":1}}],[\">>\",{\"1\":{\"203\":2}}],[\">=\",{\"1\":{\"114\":4,\"120\":2,\"650\":2,\"852\":1}}],[\">id2\",{\"1\":{\"81\":1}}],[\">e\",{\"1\":{\"77\":1,\"85\":1}}],[\">d\",{\"1\":{\"77\":3,\"83\":1,\"85\":1}}],[\">c\",{\"1\":{\"77\":3,\"85\":1}}],[\">c2\",{\"1\":{\"74\":1,\"75\":1}}],[\">f2\",{\"1\":{\"76\":1}}],[\">f1\",{\"1\":{\"76\":1}}],[\">a2\",{\"1\":{\"74\":4,\"75\":2}}],[\">|two|\",{\"1\":{\"86\":1}}],[\">|text|b\",{\"1\":{\"63\":1}}],[\">|one|\",{\"1\":{\"86\":1}}],[\">|link\",{\"1\":{\"86\":1}}],[\">|no|\",{\"1\":{\"71\":1}}],[\">|yes|\",{\"1\":{\"71\":1}}],[\">\",{\"1\":{\"65\":1,\"68\":9,\"70\":1,\"71\":14,\"75\":3,\"76\":3,\"77\":1,\"78\":3,\"82\":1,\"83\":1,\"86\":1,\"106\":1,\"114\":6,\"137\":1,\"218\":1,\"242\":2,\"284\":3,\"285\":5,\"293\":1,\"294\":7,\"306\":10,\"307\":4,\"308\":4,\"310\":15,\"311\":3,\"312\":13,\"455\":2,\"469\":4,\"524\":1,\"528\":1,\"622\":5,\"624\":5,\"657\":4,\"700\":2,\"710\":1,\"778\":1,\"790\":3,\"838\":4,\"848\":3,\"850\":7,\"859\":1,\"864\":2,\"901\":1,\"907\":2,\"911\":1,\"974\":2,\"978\":1}}],[\">b2\",{\"1\":{\"74\":1,\"75\":1}}],[\">b\",{\"1\":{\"60\":1,\"63\":1,\"64\":1,\"73\":1,\"77\":3,\"83\":1}}],[\"w3\",{\"1\":{\"974\":1}}],[\"w3cnote\",{\"1\":{\"243\":1}}],[\"w+\",{\"1\":{\"937\":1}}],[\"wtf\",{\"1\":{\"845\":1}}],[\"w\",{\"1\":{\"637\":3,\"852\":1}}],[\"wrapped\",{\"1\":{\"955\":1}}],[\"wrapper\",{\"1\":{\"518\":1}}],[\"wrapping\",{\"1\":{\"906\":1}}],[\"wrapexception\",{\"1\":{\"270\":1,\"271\":1}}],[\"wrong\",{\"1\":{\"310\":1}}],[\"writeobject\",{\"1\":{\"689\":1}}],[\"writer\",{\"1\":{\"586\":1}}],[\"writestringtofile\",{\"1\":{\"465\":1}}],[\"writing\",{\"1\":{\"145\":1}}],[\"written\",{\"1\":{\"71\":1,\"955\":1}}],[\"wujing\",{\"1\":{\"219\":1}}],[\"woman\",{\"1\":{\"209\":1,\"839\":15}}],[\"would\",{\"1\":{\"145\":1}}],[\"world\",{\"0\":{\"975\":1},\"1\":{\"96\":2,\"241\":4,\"310\":1,\"311\":1,\"622\":1,\"727\":2,\"819\":1,\"847\":1,\"975\":1}}],[\"worker\",{\"1\":{\"851\":1}}],[\"workqueue\",{\"1\":{\"845\":1}}],[\"work\",{\"1\":{\"86\":1,\"209\":3,\"310\":1}}],[\"working\",{\"1\":{\"77\":1,\"209\":1}}],[\"words\",{\"1\":{\"947\":1}}],[\"word这样的格式\",{\"1\":{\"402\":1}}],[\"word\",{\"1\":{\"68\":2,\"309\":2,\"663\":1,\"669\":1,\"800\":1}}],[\"weight\",{\"1\":{\"846\":1}}],[\"weixin\",{\"1\":{\"219\":1,\"727\":3,\"984\":1}}],[\"weatherdata中\",{\"1\":{\"676\":1}}],[\"weatherdata\",{\"1\":{\"675\":1,\"676\":9,\"677\":1,\"678\":16}}],[\"weaver\",{\"1\":{\"440\":1}}],[\"weakhashmap源码解析\",{\"0\":{\"323\":1}}],[\"web层绝不应该继续往上抛异常\",{\"1\":{\"868\":1}}],[\"web层\",{\"1\":{\"868\":1}}],[\"websocket\",{\"1\":{\"874\":2}}],[\"website4\",{\"1\":{\"636\":2}}],[\"website3\",{\"1\":{\"636\":2}}],[\"website2\",{\"1\":{\"636\":2}}],[\"website1\",{\"1\":{\"636\":2}}],[\"websitefactory\",{\"1\":{\"636\":3}}],[\"website\",{\"1\":{\"636\":8}}],[\"websphere\",{\"1\":{\"429\":1}}],[\"weblogic传道者\",{\"1\":{\"440\":1}}],[\"web框架\",{\"0\":{\"434\":1}}],[\"webmagic\",{\"1\":{\"433\":1}}],[\"web接口和无schema的json文档\",{\"1\":{\"426\":1}}],[\"web\",{\"1\":{\"420\":1,\"424\":1,\"427\":1,\"431\":1,\"434\":1,\"472\":3,\"484\":1,\"750\":1,\"762\":1}}],[\"webapps\",{\"1\":{\"104\":1}}],[\"weka\",{\"1\":{\"413\":1}}],[\"wesley\",{\"1\":{\"153\":1}}],[\"we\",{\"1\":{\"104\":6,\"310\":3,\"312\":2,\"997\":1}}],[\"well\",{\"1\":{\"68\":1,\"104\":1,\"310\":1}}],[\"www\",{\"1\":{\"77\":8,\"116\":2,\"155\":1,\"219\":2,\"238\":1,\"243\":3,\"276\":1,\"277\":2,\"283\":1,\"299\":3,\"309\":1,\"314\":2,\"974\":1,\"984\":1}}],[\"why\",{\"1\":{\"123\":1,\"129\":1,\"130\":1}}],[\"where条件limit\",{\"1\":{\"864\":1}}],[\"where后边的信息被注释掉\",{\"1\":{\"861\":1}}],[\"where\",{\"1\":{\"104\":1,\"474\":1,\"864\":4,\"865\":3}}],[\"whether\",{\"1\":{\"104\":3}}],[\"whentype\",{\"1\":{\"469\":2}}],[\"when\",{\"1\":{\"71\":1,\"77\":2,\"80\":1,\"104\":4,\"133\":1,\"145\":2,\"225\":1,\"310\":2}}],[\"whitelist\",{\"1\":{\"845\":1}}],[\"while\",{\"1\":{\"96\":1,\"103\":2,\"104\":4,\"106\":1,\"111\":1,\"114\":3,\"252\":1,\"257\":1,\"284\":1,\"310\":1,\"649\":1,\"650\":2,\"838\":1,\"847\":1,\"850\":1,\"852\":1,\"900\":1,\"901\":1}}],[\"which\",{\"1\":{\"71\":1,\"76\":1,\"77\":1,\"78\":1,\"86\":1,\"104\":5,\"145\":4,\"310\":4,\"312\":1,\"849\":1}}],[\"whatfeatureofgroup\",{\"1\":{\"851\":1}}],[\"what\",{\"1\":{\"80\":1,\"151\":1}}],[\"wiki\",{\"1\":{\"978\":1,\"984\":1}}],[\"winter\",{\"1\":{\"846\":1}}],[\"wind\",{\"1\":{\"211\":5}}],[\"windows\",{\"1\":{\"750\":1,\"770\":1,\"820\":1}}],[\"window\",{\"1\":{\"77\":1}}],[\"widget>\",{\"1\":{\"466\":2}}],[\"widget\",{\"1\":{\"459\":2}}],[\"width\",{\"1\":{\"80\":1,\"81\":2,\"82\":1,\"83\":1,\"84\":1,\"87\":1}}],[\"wicket\",{\"1\":{\"434\":1}}],[\"wiremock\",{\"1\":{\"431\":1}}],[\"wire\",{\"1\":{\"395\":1}}],[\"wildduck\",{\"1\":{\"787\":1,\"789\":6}}],[\"wildfly\",{\"1\":{\"429\":1}}],[\"wildcardtype\",{\"1\":{\"298\":1}}],[\"wildcard\",{\"1\":{\"294\":1}}],[\"will\",{\"1\":{\"68\":1,\"76\":1,\"77\":2,\"78\":2,\"80\":1,\"84\":1,\"86\":1,\"104\":6,\"269\":1,\"980\":1}}],[\"wizardforcel\",{\"1\":{\"155\":1}}],[\"without\",{\"0\":{\"86\":1},\"1\":{\"84\":1,\"86\":1,\"145\":1}}],[\"within\",{\"1\":{\"72\":1,\"78\":1}}],[\"with\",{\"0\":{\"46\":1,\"60\":1,\"63\":1,\"65\":1,\"67\":1,\"86\":1,\"259\":1,\"264\":1},\"1\":{\"51\":1,\"59\":1,\"68\":1,\"71\":3,\"75\":1,\"76\":1,\"77\":2,\"78\":1,\"85\":1,\"86\":3,\"87\":2,\"104\":5,\"145\":1,\"150\":1,\"186\":1,\"255\":1,\"259\":1,\"264\":2,\"275\":1,\"468\":1,\"474\":1,\"477\":1,\"858\":1,\"859\":1,\"978\":1}}],[\"watervehicle\",{\"1\":{\"718\":1}}],[\"wall\",{\"1\":{\"555\":5}}],[\"war\",{\"1\":{\"457\":1,\"461\":1}}],[\"warn\",{\"1\":{\"242\":2}}],[\"warnings\",{\"1\":{\"225\":19}}],[\"warning\",{\"1\":{\"14\":1,\"68\":1,\"234\":2}}],[\"wait的连接数太多\",{\"1\":{\"870\":1}}],[\"wait状态的连接\",{\"1\":{\"870\":1}}],[\"wait超时时间\",{\"1\":{\"870\":1}}],[\"wait被重载了两次\",{\"1\":{\"190\":1}}],[\"wait\",{\"1\":{\"137\":3,\"190\":1,\"308\":3,\"485\":1,\"839\":6}}],[\"want\",{\"1\":{\"80\":1}}],[\"was<java\",{\"1\":{\"979\":1}}],[\"wasn\",{\"1\":{\"104\":2}}],[\"was\",{\"1\":{\"77\":2,\"80\":1,\"104\":1}}],[\"way\",{\"1\":{\"68\":1,\"80\":2,\"104\":1,\"618\":1}}],[\"npe\",{\"1\":{\"872\":1,\"873\":1}}],[\"nginx默认限制是1mb\",{\"1\":{\"854\":1}}],[\"nfirst\",{\"1\":{\"649\":1}}],[\"nfe\",{\"1\":{\"120\":1}}],[\"ninja\",{\"1\":{\"434\":1}}],[\"nio框架\",{\"1\":{\"419\":1}}],[\"nio\",{\"0\":{\"333\":1,\"334\":1,\"335\":1},\"1\":{\"150\":1}}],[\"nls\",{\"1\":{\"225\":2}}],[\"nanotime的方式\",{\"1\":{\"849\":1}}],[\"nanotime\",{\"1\":{\"276\":6,\"310\":2}}],[\"nanos\",{\"1\":{\"137\":1}}],[\"nashhorn\",{\"1\":{\"150\":1}}],[\"nativemethodaccessorimpl\",{\"1\":{\"312\":6,\"979\":3,\"980\":3}}],[\"nativeconstructoraccessorimpl\",{\"1\":{\"310\":1}}],[\"native\",{\"0\":{\"232\":1},\"1\":{\"137\":6,\"226\":1,\"232\":2,\"302\":1,\"308\":5,\"310\":1,\"312\":2,\"934\":1,\"979\":1,\"980\":2}}],[\"name反例\",{\"1\":{\"863\":1}}],[\"nameprefix\",{\"1\":{\"851\":3}}],[\"namelist\",{\"1\":{\"845\":1}}],[\"nameandtype\",{\"1\":{\"312\":21}}],[\"namefield\",{\"1\":{\"307\":2}}],[\"name=name\",{\"1\":{\"826\":1}}],[\"name=init\",{\"1\":{\"305\":1}}],[\"name=\",{\"1\":{\"305\":1,\"306\":4,\"307\":1,\"685\":1,\"687\":1,\"689\":4,\"859\":1}}],[\"named\",{\"1\":{\"84\":1}}],[\"name\",{\"1\":{\"77\":1,\"85\":1,\"104\":6,\"114\":2,\"127\":8,\"155\":1,\"209\":6,\"242\":2,\"305\":9,\"306\":13,\"307\":5,\"308\":4,\"310\":12,\"311\":5,\"312\":10,\"474\":2,\"571\":10,\"574\":14,\"609\":1,\"613\":1,\"636\":8,\"650\":13,\"659\":20,\"685\":9,\"687\":9,\"689\":6,\"700\":3,\"710\":16,\"773\":3,\"809\":5,\"826\":3,\"830\":2,\"831\":1,\"845\":2,\"851\":2,\"859\":1,\"863\":1,\"865\":3,\"927\":2,\"937\":2,\"960\":2,\"983\":1}}],[\"namespace\",{\"1\":{\"312\":1}}],[\"names\",{\"1\":{\"73\":1,\"104\":3,\"114\":6,\"145\":1,\"942\":1}}],[\"n\",{\"0\":{\"332\":1},\"1\":{\"114\":3,\"120\":4,\"217\":1,\"218\":2,\"312\":2,\"537\":1,\"830\":2,\"884\":1,\"978\":1}}],[\"nutch\",{\"1\":{\"433\":1}}],[\"nutz\",{\"1\":{\"420\":1}}],[\"numeric\",{\"1\":{\"950\":1}}],[\"num2\",{\"1\":{\"734\":4}}],[\"num1\",{\"1\":{\"734\":4}}],[\"numofdepartment\",{\"1\":{\"650\":3}}],[\"numnonprimitiveparametertypes\",{\"1\":{\"312\":1}}],[\"numnewmembers\",{\"1\":{\"311\":2}}],[\"num\",{\"1\":{\"312\":5,\"446\":8,\"778\":2,\"846\":1}}],[\"numcpentries\",{\"1\":{\"312\":8}}],[\"numinvocations\",{\"1\":{\"312\":1}}],[\"number>被替换为object\",{\"1\":{\"287\":1}}],[\"number>的类型参数被替换为number\",{\"1\":{\"287\":1}}],[\"number>和<\",{\"1\":{\"287\":1}}],[\"number>\",{\"1\":{\"279\":1,\"284\":1}}],[\"number=10\",{\"1\":{\"230\":1}}],[\"numberformatexception\",{\"1\":{\"120\":1,\"241\":1,\"261\":1,\"267\":4,\"269\":2,\"270\":6,\"271\":2,\"950\":1}}],[\"numbers\",{\"1\":{\"73\":1}}],[\"number\",{\"1\":{\"71\":2,\"80\":1,\"103\":1,\"140\":4,\"230\":2,\"289\":2,\"312\":1,\"942\":1,\"981\":1}}],[\"nuisance\",{\"1\":{\"104\":1}}],[\"null<>1的返回结果是null\",{\"1\":{\"865\":1}}],[\"null<>null的返回结果是null\",{\"1\":{\"865\":1}}],[\"null=null的返回结果是null\",{\"1\":{\"865\":1}}],[\"null与任何值的直接比较都为null\",{\"1\":{\"865\":1}}],[\"nullable\",{\"1\":{\"450\":2,\"483\":1,\"927\":2}}],[\"nulls\",{\"0\":{\"450\":1}}],[\"nullpointerexception>\",{\"1\":{\"979\":1}}],[\"nullpointerexception\",{\"1\":{\"198\":1,\"261\":1,\"263\":2,\"265\":1,\"312\":2,\"850\":1,\"858\":2,\"873\":1,\"979\":1}}],[\"null\",{\"1\":{\"91\":1,\"92\":1,\"93\":1,\"96\":2,\"103\":3,\"104\":18,\"106\":1,\"114\":20,\"120\":1,\"138\":5,\"141\":2,\"181\":1,\"225\":2,\"241\":3,\"242\":7,\"257\":2,\"263\":1,\"264\":3,\"281\":1,\"282\":1,\"284\":2,\"296\":2,\"302\":2,\"306\":1,\"310\":30,\"311\":9,\"312\":5,\"450\":6,\"469\":1,\"528\":1,\"555\":1,\"571\":2,\"610\":2,\"613\":3,\"618\":4,\"625\":3,\"626\":1,\"627\":4,\"632\":1,\"644\":2,\"649\":2,\"650\":1,\"687\":1,\"689\":6,\"708\":2,\"754\":2,\"755\":1,\"756\":1,\"757\":4,\"768\":7,\"772\":2,\"778\":1,\"789\":1,\"790\":2,\"828\":1,\"850\":4,\"851\":5,\"852\":5,\"858\":1,\"865\":2,\"942\":1,\"978\":7}}],[\"nested\",{\"1\":{\"877\":1}}],[\"nexus\",{\"1\":{\"401\":1,\"461\":2}}],[\"nextid\",{\"1\":{\"851\":2}}],[\"nextint\",{\"1\":{\"773\":1,\"778\":1}}],[\"nextservice\",{\"1\":{\"114\":3}}],[\"nextname\",{\"1\":{\"114\":5}}],[\"nextelement\",{\"1\":{\"104\":1,\"106\":1,\"114\":1}}],[\"next\",{\"1\":{\"0\":1,\"78\":1,\"96\":1,\"103\":3,\"111\":1,\"114\":5,\"284\":5,\"649\":4,\"650\":4,\"708\":5,\"838\":1,\"850\":1}}],[\"necessary\",{\"1\":{\"310\":1}}],[\"necessarily\",{\"1\":{\"104\":1}}],[\"never\",{\"1\":{\"269\":2,\"716\":1}}],[\"negativearraysizeexception\",{\"1\":{\"261\":1}}],[\"net周边信息为主\",{\"1\":{\"442\":1}}],[\"net官方账号\",{\"1\":{\"440\":1}}],[\"netbeans大牛\",{\"1\":{\"440\":1}}],[\"netbeans\",{\"1\":{\"407\":1,\"480\":1}}],[\"netty\",{\"0\":{\"332\":1},\"1\":{\"419\":1}}],[\"net\",{\"1\":{\"116\":2,\"219\":1,\"238\":1,\"243\":2,\"277\":3,\"299\":4,\"305\":1,\"314\":3,\"419\":1,\"440\":1,\"442\":1,\"591\":1,\"848\":1,\"870\":1,\"978\":1,\"984\":2,\"1000\":1}}],[\"needs\",{\"1\":{\"145\":1}}],[\"needed\",{\"1\":{\"104\":1}}],[\"need\",{\"1\":{\"78\":1,\"104\":1,\"145\":1,\"152\":1,\"997\":1}}],[\"newcustomerid\",{\"1\":{\"947\":2}}],[\"newthread\",{\"1\":{\"851\":1}}],[\"newtclass\",{\"1\":{\"293\":1}}],[\"newproxyinstance\",{\"1\":{\"699\":2,\"700\":2}}],[\"newproduct\",{\"1\":{\"612\":1,\"616\":1}}],[\"newscast\",{\"1\":{\"488\":1}}],[\"newsletter\",{\"1\":{\"442\":1}}],[\"newfoowidget\",{\"1\":{\"467\":1}}],[\"newfactory\",{\"1\":{\"104\":6}}],[\"newhashmap\",{\"1\":{\"466\":1}}],[\"newmethodaccessor\",{\"1\":{\"312\":2}}],[\"newmembers\",{\"1\":{\"311\":3}}],[\"newreflectiondata\",{\"1\":{\"310\":2}}],[\"newlock\",{\"1\":{\"310\":3}}],[\"newline\",{\"1\":{\"78\":1}}],[\"newexception\",{\"1\":{\"276\":2}}],[\"newer\",{\"1\":{\"104\":1}}],[\"newobject\",{\"1\":{\"276\":2}}],[\"newinstance0\",{\"1\":{\"310\":1}}],[\"newinstancecallercache\",{\"1\":{\"310\":2}}],[\"newinstance\",{\"1\":{\"114\":1,\"285\":1,\"293\":1,\"295\":2,\"305\":3,\"306\":5,\"307\":1,\"308\":1,\"309\":1,\"310\":15,\"311\":1,\"312\":5,\"627\":2}}],[\"new\",{\"0\":{\"69\":1},\"1\":{\"69\":1,\"77\":3,\"86\":2,\"91\":1,\"92\":1,\"103\":2,\"104\":4,\"106\":2,\"114\":14,\"120\":7,\"125\":3,\"127\":3,\"132\":1,\"133\":4,\"134\":1,\"138\":2,\"139\":3,\"140\":1,\"141\":11,\"143\":1,\"144\":7,\"150\":2,\"201\":3,\"210\":1,\"211\":3,\"222\":1,\"234\":1,\"236\":2,\"241\":4,\"242\":1,\"252\":3,\"253\":2,\"257\":4,\"258\":1,\"259\":2,\"264\":6,\"270\":2,\"271\":1,\"276\":4,\"279\":3,\"281\":2,\"282\":1,\"284\":5,\"285\":6,\"288\":3,\"289\":2,\"290\":19,\"291\":3,\"293\":3,\"294\":12,\"295\":1,\"298\":1,\"305\":1,\"309\":1,\"310\":15,\"311\":1,\"312\":9,\"416\":1,\"446\":2,\"455\":1,\"466\":1,\"467\":1,\"471\":1,\"477\":3,\"524\":2,\"528\":3,\"532\":4,\"538\":2,\"542\":8,\"553\":1,\"555\":4,\"561\":3,\"562\":13,\"571\":12,\"574\":12,\"580\":2,\"584\":6,\"596\":4,\"601\":7,\"606\":1,\"609\":4,\"610\":7,\"613\":6,\"614\":1,\"617\":6,\"618\":6,\"619\":2,\"624\":1,\"625\":3,\"626\":2,\"627\":7,\"632\":8,\"636\":7,\"637\":5,\"644\":12,\"649\":3,\"650\":10,\"656\":4,\"659\":7,\"664\":3,\"666\":1,\"667\":3,\"672\":4,\"676\":2,\"678\":4,\"682\":1,\"685\":5,\"687\":2,\"689\":6,\"695\":2,\"700\":3,\"703\":4,\"708\":2,\"710\":5,\"718\":4,\"723\":8,\"727\":5,\"728\":6,\"734\":5,\"738\":7,\"739\":5,\"741\":2,\"742\":6,\"743\":6,\"744\":1,\"745\":1,\"748\":1,\"752\":3,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"757\":1,\"758\":1,\"760\":1,\"761\":1,\"768\":5,\"769\":1,\"770\":1,\"771\":3,\"772\":2,\"773\":7,\"776\":4,\"778\":6,\"779\":11,\"784\":3,\"789\":10,\"790\":3,\"801\":1,\"803\":3,\"809\":2,\"812\":1,\"813\":2,\"814\":3,\"828\":1,\"832\":4,\"838\":6,\"839\":7,\"847\":3,\"848\":5,\"849\":2,\"850\":20,\"851\":9,\"852\":2,\"855\":1,\"866\":1,\"868\":1,\"901\":1,\"911\":2,\"920\":4,\"942\":1,\"947\":1,\"978\":6,\"980\":1,\"981\":2}}],[\"noflybehavior\",{\"1\":{\"789\":3}}],[\"norafflestate\",{\"1\":{\"778\":3}}],[\"noraffllestate\",{\"1\":{\"778\":2}}],[\"normally\",{\"1\":{\"955\":1}}],[\"normal\",{\"1\":{\"71\":2,\"864\":1}}],[\"nocommand\",{\"1\":{\"562\":3}}],[\"noclassdeffounderror\",{\"1\":{\"247\":1}}],[\"noinflation\",{\"1\":{\"312\":1}}],[\"nonstatic\",{\"1\":{\"942\":1}}],[\"nonfinal\",{\"1\":{\"942\":1}}],[\"nonfairsync\",{\"1\":{\"852\":1}}],[\"nonterminalexpression\",{\"1\":{\"642\":1}}],[\"nonterminal\",{\"1\":{\"642\":1}}],[\"nonempty\",{\"1\":{\"947\":1}}],[\"nonemptyarray\",{\"1\":{\"942\":1}}],[\"none\",{\"1\":{\"312\":1}}],[\"nonprimitiveparametersbaseidx\",{\"1\":{\"312\":1}}],[\"non\",{\"1\":{\"144\":2,\"145\":2,\"225\":1,\"302\":1,\"310\":2,\"312\":6,\"907\":1,\"942\":2,\"947\":1}}],[\"nosuchmethoderror\",{\"1\":{\"872\":1}}],[\"nosuchmethodexception\",{\"1\":{\"261\":1,\"308\":1,\"309\":1,\"310\":4,\"311\":2,\"627\":1}}],[\"nosuchbeandefinitionexception\",{\"1\":{\"627\":2}}],[\"nosuchelementexception\",{\"1\":{\"114\":1,\"198\":1,\"950\":1}}],[\"nosuchfieldexception\",{\"1\":{\"91\":1,\"261\":1,\"307\":1}}],[\"now\",{\"1\":{\"85\":1,\"86\":1,\"849\":1}}],[\"no\",{\"1\":{\"71\":1,\"80\":1,\"104\":5,\"310\":2,\"311\":1,\"562\":13,\"618\":1,\"773\":2,\"850\":1,\"902\":1,\"915\":1}}],[\"notfound\",{\"1\":{\"854\":1}}],[\"notgenerics\",{\"1\":{\"850\":4}}],[\"notpaystate\",{\"1\":{\"779\":3}}],[\"notpeopleacceptevent\",{\"1\":{\"779\":5}}],[\"notifyobservers\",{\"1\":{\"678\":3}}],[\"notifyobserver\",{\"1\":{\"672\":3}}],[\"notifyall\",{\"1\":{\"137\":1,\"190\":1,\"308\":1}}],[\"notify\",{\"1\":{\"137\":1,\"190\":1,\"308\":1,\"679\":1}}],[\"nothing\",{\"1\":{\"103\":1}}],[\"notepad<string\",{\"1\":{\"281\":2}}],[\"notepad<k\",{\"1\":{\"281\":1}}],[\"note\",{\"1\":{\"71\":1,\"77\":1,\"104\":2,\"218\":1,\"310\":1,\"312\":1,\"618\":1}}],[\"not\",{\"1\":{\"51\":1,\"68\":2,\"86\":1,\"104\":4,\"114\":1,\"133\":4,\"145\":3,\"242\":2,\"264\":1,\"284\":1,\"294\":1,\"302\":1,\"310\":7,\"311\":1,\"312\":2,\"625\":1,\"627\":2,\"779\":3,\"808\":1,\"865\":1,\"902\":1,\"942\":1,\"950\":1,\"978\":7}}],[\"nodeid2\",{\"1\":{\"82\":1}}],[\"nodeid1\",{\"1\":{\"82\":2}}],[\"nodeid\",{\"1\":{\"77\":4}}],[\"nodes\",{\"0\":{\"59\":1},\"1\":{\"59\":1,\"68\":1,\"71\":1,\"80\":1,\"82\":2}}],[\"node\",{\"0\":{\"45\":1,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":1,\"52\":1,\"53\":1,\"81\":1},\"1\":{\"71\":3,\"77\":2,\"78\":1,\"81\":1,\"82\":2,\"419\":1,\"852\":1}}],[\"rt\",{\"1\":{\"979\":3}}],[\"rtti\",{\"1\":{\"301\":2}}],[\"rpc执行超时\",{\"1\":{\"874\":1}}],[\"rpc\",{\"1\":{\"874\":3}}],[\"rpc方法的返回值和参数必须使用包装数据类型\",{\"1\":{\"848\":1}}],[\"rpc框架\",{\"1\":{\"419\":1}}],[\"ritchie\",{\"1\":{\"901\":1}}],[\"richard\",{\"1\":{\"795\":1}}],[\"right\",{\"1\":{\"43\":1,\"44\":2,\"71\":1,\"644\":17}}],[\"rcp\",{\"1\":{\"434\":1}}],[\"rsa\",{\"1\":{\"874\":1}}],[\"rss甚至html\",{\"1\":{\"854\":1}}],[\"rs\",{\"1\":{\"472\":2}}],[\"rs规范完全认证的可移植实现\",{\"1\":{\"424\":1}}],[\"rs参考实现\",{\"1\":{\"424\":1}}],[\"rxjava\",{\"1\":{\"423\":1}}],[\"roadvehicle\",{\"1\":{\"718\":6}}],[\"robert\",{\"1\":{\"716\":1}}],[\"robovm\",{\"1\":{\"415\":1}}],[\"roofed\",{\"1\":{\"553\":3,\"555\":9}}],[\"root\",{\"1\":{\"310\":5,\"311\":1,\"312\":3}}],[\"rocketmq是一个开源的分布式消息传递和流数据平台\",{\"1\":{\"414\":1}}],[\"rocketmq\",{\"1\":{\"414\":1}}],[\"routerproduct\",{\"1\":{\"617\":5}}],[\"routine\",{\"1\":{\"310\":1,\"312\":2}}],[\"round\",{\"0\":{\"46\":1},\"1\":{\"86\":1}}],[\"rules\",{\"1\":{\"980\":1}}],[\"rule\",{\"1\":{\"980\":3}}],[\"ruby\",{\"1\":{\"419\":1}}],[\"rudy\",{\"1\":{\"299\":1}}],[\"runreflectivecall\",{\"1\":{\"979\":1,\"980\":1}}],[\"runchildren\",{\"1\":{\"979\":1}}],[\"runchild\",{\"1\":{\"979\":2}}],[\"runleaf\",{\"1\":{\"979\":1}}],[\"runwith就是放在测试类名之前\",{\"1\":{\"972\":1,\"981\":1}}],[\"runwith\",{\"1\":{\"972\":6,\"981\":8,\"982\":3,\"999\":2}}],[\"runwater\",{\"1\":{\"718\":2}}],[\"runner\",{\"1\":{\"979\":1,\"981\":1,\"982\":1}}],[\"runners\",{\"1\":{\"979\":15,\"980\":7,\"981\":4,\"982\":1,\"983\":1}}],[\"runnable\",{\"1\":{\"851\":1}}],[\"running\",{\"1\":{\"145\":1}}],[\"runair\",{\"1\":{\"718\":2}}],[\"runoob\",{\"1\":{\"243\":1}}],[\"runtimevisibleannotations\",{\"1\":{\"228\":2}}],[\"runtimeinvisibleannotations\",{\"1\":{\"228\":2}}],[\"runtimepolicy\",{\"1\":{\"228\":5}}],[\"runtime\",{\"1\":{\"125\":1,\"145\":1,\"198\":1,\"224\":1,\"228\":2,\"230\":1,\"234\":1,\"236\":2,\"242\":1,\"760\":6}}],[\"runtimeexceptions\",{\"1\":{\"448\":1}}],[\"runtimeexception或它们的子类\",{\"1\":{\"252\":1}}],[\"runtimeexception与其子类\",{\"1\":{\"249\":1}}],[\"runtimeexception\",{\"1\":{\"104\":1,\"261\":1,\"625\":1,\"768\":2,\"779\":2,\"858\":1}}],[\"run\",{\"1\":{\"103\":2,\"114\":2,\"145\":1,\"152\":1,\"214\":2,\"294\":2,\"301\":1,\"310\":2,\"312\":1,\"644\":2,\"718\":13,\"768\":1,\"979\":4,\"980\":3}}],[\"ralph\",{\"1\":{\"795\":1}}],[\"raffle\",{\"1\":{\"778\":8}}],[\"raffleactivity\",{\"1\":{\"778\":12}}],[\"ratelimiter\",{\"1\":{\"622\":6,\"624\":7}}],[\"ratpack\",{\"1\":{\"434\":1}}],[\"rahman\",{\"1\":{\"440\":1}}],[\"race604\",{\"1\":{\"238\":1,\"243\":1}}],[\"rawtype\",{\"1\":{\"225\":1}}],[\"rawtypes\",{\"1\":{\"222\":1}}],[\"ran2\",{\"1\":{\"980\":1}}],[\"ran1\",{\"1\":{\"980\":1}}],[\"random的实例或者math\",{\"1\":{\"851\":1}}],[\"random实例包括java\",{\"1\":{\"851\":1}}],[\"randomaccesssublist\",{\"1\":{\"850\":1}}],[\"random\",{\"1\":{\"773\":2,\"778\":2,\"851\":1,\"855\":1}}],[\"range对索引进行范围检索\",{\"1\":{\"864\":1}}],[\"range\",{\"1\":{\"120\":2,\"863\":1}}],[\"ranks\",{\"1\":{\"71\":3}}],[\"rank\",{\"1\":{\"71\":1}}],[\"r\",{\"0\":{\"901\":1},\"1\":{\"114\":5,\"139\":3,\"437\":1,\"738\":5,\"773\":2,\"778\":2,\"860\":1,\"884\":1,\"902\":1,\"903\":1}}],[\"rdcconfig\",{\"1\":{\"863\":1}}],[\"rdc\",{\"1\":{\"850\":2,\"863\":1}}],[\"rd\",{\"1\":{\"104\":5,\"310\":17,\"311\":7}}],[\"remappingfunction\",{\"1\":{\"850\":1}}],[\"remotecontroller\",{\"1\":{\"562\":13}}],[\"remoteexception\",{\"1\":{\"469\":1}}],[\"remove元素请使用iterator方式\",{\"1\":{\"850\":1}}],[\"removeobserver\",{\"1\":{\"678\":3}}],[\"removed\",{\"1\":{\"150\":1}}],[\"remove\",{\"1\":{\"114\":2,\"242\":3,\"568\":1,\"569\":1,\"571\":7,\"574\":7,\"649\":3,\"650\":3,\"672\":2,\"678\":1,\"838\":2,\"839\":1,\"850\":3,\"851\":1}}],[\"reuse\",{\"1\":{\"745\":2}}],[\"reusable\",{\"1\":{\"469\":1}}],[\"reentrantreadwritelock详解\",{\"0\":{\"511\":1}}],[\"reentrantlock详解\",{\"0\":{\"510\":1}}],[\"reentrantlock\",{\"1\":{\"258\":2,\"873\":1}}],[\"reilly\",{\"1\":{\"442\":1}}],[\"reinhold\",{\"1\":{\"440\":1}}],[\"rebellabs\",{\"1\":{\"442\":1}}],[\"rebellabs作者\",{\"1\":{\"440\":1}}],[\"reza\",{\"1\":{\"440\":1}}],[\"receive\",{\"1\":{\"656\":4,\"727\":6}}],[\"receiver\",{\"1\":{\"560\":1,\"561\":7,\"727\":2}}],[\"recommend2\",{\"1\":{\"848\":1}}],[\"recommend1\",{\"1\":{\"848\":1}}],[\"recovergamerolefrommemento\",{\"1\":{\"667\":2}}],[\"recover\",{\"1\":{\"469\":1,\"901\":1}}],[\"record\",{\"1\":{\"310\":1,\"958\":1}}],[\"recordoper\",{\"1\":{\"242\":1}}],[\"rectangle\",{\"1\":{\"738\":6,\"739\":3}}],[\"rect\",{\"1\":{\"83\":1}}],[\"repeat\",{\"1\":{\"871\":1}}],[\"repeatable请参考java\",{\"1\":{\"231\":1}}],[\"repeatable\",{\"0\":{\"231\":1},\"1\":{\"236\":1,\"860\":1}}],[\"repeatable和\",{\"1\":{\"226\":1}}],[\"repository\",{\"0\":{\"461\":1},\"1\":{\"401\":1}}],[\"reported\",{\"1\":{\"104\":1}}],[\"report\",{\"1\":{\"104\":1}}],[\"replace\",{\"1\":{\"310\":1}}],[\"ref指的是使用普通的索引\",{\"1\":{\"864\":1}}],[\"refbeandefinition\",{\"1\":{\"627\":4}}],[\"ref=\",{\"1\":{\"622\":1,\"624\":1}}],[\"refinedabstraction\",{\"1\":{\"538\":3}}],[\"refined\",{\"1\":{\"538\":2}}],[\"referred\",{\"1\":{\"310\":1,\"312\":2}}],[\"refer\",{\"1\":{\"310\":1}}],[\"referenced\",{\"1\":{\"144\":4}}],[\"reference\",{\"1\":{\"127\":1,\"275\":1}}],[\"reflectutil\",{\"1\":{\"310\":1,\"312\":3}}],[\"reflectmethod\",{\"1\":{\"308\":1}}],[\"reflectfield\",{\"1\":{\"307\":1}}],[\"reflect类库一起对反射技术进行了全力的支持\",{\"1\":{\"304\":1}}],[\"reflect下的annotatedelement接口提供这些方法\",{\"1\":{\"233\":1}}],[\"reflectivecallable\",{\"1\":{\"979\":2,\"980\":2}}],[\"reflectively\",{\"1\":{\"310\":1}}],[\"reflective\",{\"1\":{\"145\":4,\"310\":1}}],[\"reflectiondata<>\",{\"1\":{\"310\":1}}],[\"reflectiondata<t>\",{\"1\":{\"310\":6,\"311\":1}}],[\"reflectiondata\",{\"1\":{\"310\":14,\"311\":1}}],[\"reflectionfactory\",{\"1\":{\"310\":4,\"311\":2,\"312\":5}}],[\"reflection\",{\"1\":{\"145\":11,\"310\":8,\"311\":4,\"312\":2,\"314\":1}}],[\"reflect\",{\"1\":{\"145\":2,\"234\":1,\"295\":1,\"298\":2,\"305\":1,\"306\":1,\"307\":9,\"308\":10,\"310\":7,\"312\":5,\"699\":1,\"979\":4,\"980\":4}}],[\"relic\",{\"1\":{\"416\":1}}],[\"relation\",{\"1\":{\"873\":1}}],[\"relative\",{\"1\":{\"225\":18}}],[\"relay\",{\"1\":{\"656\":4}}],[\"relactiondata\",{\"1\":{\"310\":1}}],[\"reload\",{\"1\":{\"114\":2}}],[\"release\",{\"1\":{\"86\":1}}],[\"releases\",{\"1\":{\"51\":1}}],[\"registerobserver\",{\"1\":{\"678\":4}}],[\"register\",{\"1\":{\"656\":4,\"659\":6,\"869\":1}}],[\"registermethodstofilter\",{\"1\":{\"311\":1}}],[\"registernatives\",{\"1\":{\"302\":2}}],[\"registered\",{\"1\":{\"104\":1}}],[\"regular\",{\"1\":{\"71\":1}}],[\"resize\",{\"1\":{\"850\":1}}],[\"res=\",{\"1\":{\"703\":1}}],[\"response\",{\"1\":{\"672\":4,\"854\":1,\"950\":2}}],[\"responsebody\",{\"1\":{\"242\":3}}],[\"responsibility\",{\"1\":{\"591\":1,\"707\":1,\"716\":1,\"798\":1}}],[\"restorememento\",{\"1\":{\"664\":2}}],[\"restful\",{\"1\":{\"472\":1}}],[\"rest\",{\"1\":{\"431\":1,\"472\":1,\"477\":1}}],[\"restx\",{\"1\":{\"424\":1}}],[\"restexpress\",{\"1\":{\"424\":1}}],[\"resteasy\",{\"1\":{\"424\":1}}],[\"rest框架\",{\"0\":{\"424\":1},\"1\":{\"424\":1}}],[\"restriction\",{\"1\":{\"225\":1}}],[\"restrictions\",{\"1\":{\"145\":1}}],[\"restricted\",{\"1\":{\"145\":1}}],[\"res\",{\"1\":{\"310\":13,\"311\":15,\"312\":3,\"703\":2}}],[\"resolve前后信息比对\",{\"1\":{\"869\":1}}],[\"resolve\",{\"1\":{\"310\":2}}],[\"resolveclass\",{\"1\":{\"310\":2}}],[\"resolved\",{\"1\":{\"145\":1}}],[\"resourceobserver\",{\"1\":{\"845\":1}}],[\"resource是java\",{\"1\":{\"259\":1}}],[\"resource\",{\"0\":{\"259\":1,\"264\":1},\"1\":{\"104\":2,\"106\":3,\"186\":1,\"255\":1,\"264\":2}}],[\"resources方式\",{\"1\":{\"858\":1}}],[\"resources\",{\"0\":{\"486\":1},\"1\":{\"96\":1,\"150\":1}}],[\"resultarray\",{\"1\":{\"978\":1}}],[\"result<record3<string\",{\"1\":{\"474\":1}}],[\"results\",{\"1\":{\"310\":1}}],[\"result\",{\"1\":{\"86\":2,\"106\":3,\"139\":8,\"141\":4,\"145\":1,\"252\":3,\"257\":3,\"284\":4,\"469\":1,\"474\":1,\"478\":9,\"852\":1}}],[\"reactor\",{\"1\":{\"423\":1}}],[\"reactive\",{\"1\":{\"423\":1}}],[\"reached\",{\"1\":{\"310\":1}}],[\"reason\",{\"1\":{\"104\":1,\"716\":1,\"845\":1}}],[\"real\",{\"1\":{\"694\":1}}],[\"realcause\",{\"1\":{\"297\":2}}],[\"really\",{\"1\":{\"294\":1,\"312\":1}}],[\"reallocatememory\",{\"1\":{\"93\":1}}],[\"realization\",{\"0\":{\"214\":1},\"1\":{\"214\":1,\"834\":1}}],[\"reality\",{\"1\":{\"91\":2}}],[\"readable\",{\"1\":{\"940\":1}}],[\"readability\",{\"1\":{\"86\":1}}],[\"readobject\",{\"1\":{\"689\":1}}],[\"ready\",{\"1\":{\"600\":1,\"601\":2}}],[\"reader\",{\"1\":{\"252\":3,\"257\":5,\"586\":1}}],[\"readfile\",{\"1\":{\"252\":1,\"253\":1,\"256\":2,\"257\":3}}],[\"readlines\",{\"1\":{\"465\":1}}],[\"readline\",{\"1\":{\"104\":1,\"114\":1,\"252\":1,\"257\":1,\"644\":2}}],[\"read\",{\"1\":{\"68\":1,\"104\":1,\"253\":1,\"257\":1,\"264\":3,\"310\":1,\"312\":1}}],[\"reviewed\",{\"1\":{\"779\":3}}],[\"reviewstate\",{\"1\":{\"779\":2}}],[\"review\",{\"1\":{\"88\":1}}],[\"reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后\",{\"1\":{\"228\":1}}],[\"reteniton注解的作用是\",{\"1\":{\"228\":1}}],[\"retentiontest命令获取到的retentiontest\",{\"1\":{\"228\":1}}],[\"retentiontest\",{\"1\":{\"228\":3}}],[\"retentiontarget\",{\"0\":{\"228\":1}}],[\"retentionpolicy\",{\"1\":{\"223\":1,\"224\":1,\"225\":1,\"228\":4,\"230\":1,\"234\":2,\"236\":2,\"242\":1}}],[\"retention用于标明注解被保留的阶段\",{\"1\":{\"221\":1}}],[\"retention\",{\"0\":{\"228\":1},\"1\":{\"221\":1,\"223\":1,\"224\":1,\"225\":1,\"226\":1,\"228\":4,\"230\":1,\"234\":2,\"236\":2,\"242\":1}}],[\"return包装数据类型的对象时\",{\"1\":{\"858\":1}}],[\"return等来终止\",{\"1\":{\"852\":1}}],[\"returnval\",{\"1\":{\"700\":2,\"703\":4}}],[\"returntype\",{\"1\":{\"312\":5}}],[\"returned\",{\"1\":{\"310\":1}}],[\"returns\",{\"1\":{\"310\":1,\"311\":1,\"958\":2,\"960\":2}}],[\"returning\",{\"1\":{\"242\":1}}],[\"return\",{\"1\":{\"91\":1,\"96\":2,\"103\":3,\"104\":4,\"106\":1,\"114\":22,\"120\":2,\"127\":2,\"132\":2,\"138\":5,\"139\":1,\"141\":7,\"147\":1,\"209\":2,\"222\":2,\"225\":1,\"228\":4,\"234\":1,\"236\":2,\"241\":1,\"242\":11,\"253\":1,\"273\":2,\"275\":6,\"279\":4,\"281\":3,\"282\":1,\"284\":6,\"285\":1,\"289\":3,\"291\":11,\"293\":1,\"295\":2,\"296\":2,\"298\":1,\"305\":3,\"306\":3,\"308\":2,\"310\":30,\"311\":8,\"312\":10,\"445\":1,\"446\":3,\"450\":1,\"468\":1,\"469\":2,\"524\":2,\"528\":2,\"555\":5,\"571\":4,\"574\":8,\"584\":5,\"601\":6,\"610\":4,\"613\":2,\"617\":4,\"618\":3,\"625\":1,\"626\":3,\"627\":4,\"632\":2,\"636\":3,\"644\":7,\"649\":5,\"650\":12,\"659\":1,\"664\":4,\"667\":6,\"676\":3,\"678\":3,\"685\":4,\"687\":5,\"689\":4,\"700\":2,\"703\":4,\"708\":1,\"710\":3,\"727\":3,\"734\":7,\"741\":1,\"742\":4,\"743\":4,\"752\":1,\"753\":1,\"754\":1,\"755\":2,\"756\":1,\"757\":2,\"758\":1,\"760\":1,\"768\":4,\"769\":1,\"771\":2,\"772\":2,\"773\":3,\"776\":1,\"778\":6,\"779\":10,\"784\":1,\"790\":4,\"803\":2,\"826\":1,\"828\":1,\"838\":2,\"846\":1,\"848\":2,\"850\":1,\"851\":3,\"852\":6,\"858\":3,\"872\":1,\"885\":1,\"901\":2,\"915\":1,\"924\":1,\"950\":2,\"955\":1,\"957\":1,\"958\":1,\"981\":3}}],[\"retrofit\",{\"1\":{\"424\":1}}],[\"retro\",{\"1\":{\"85\":1}}],[\"rethink\",{\"1\":{\"71\":2}}],[\"redis\",{\"1\":{\"818\":1}}],[\"rediscounter\",{\"1\":{\"622\":13,\"624\":3}}],[\"redbeansoyamilk\",{\"1\":{\"803\":4}}],[\"redo\",{\"1\":{\"560\":1,\"565\":1}}],[\"redhatter\",{\"1\":{\"440\":1}}],[\"redhat开发的面向对象静态类型编程语言\",{\"1\":{\"411\":1}}],[\"reddit的java子社区\",{\"1\":{\"437\":1}}],[\"redefineclasses\",{\"1\":{\"310\":1}}],[\"redefinedcount\",{\"1\":{\"310\":6}}],[\"reduce\",{\"1\":{\"186\":1}}],[\"redundant\",{\"1\":{\"133\":1}}],[\"red\",{\"1\":{\"80\":1,\"440\":1}}],[\"requirespermissions\",{\"1\":{\"242\":4}}],[\"requires\",{\"1\":{\"145\":1,\"310\":1}}],[\"require\",{\"1\":{\"129\":1}}],[\"requirenonnull\",{\"1\":{\"114\":1}}],[\"required\",{\"1\":{\"80\":1,\"104\":1,\"130\":1}}],[\"requestt\",{\"1\":{\"946\":1}}],[\"requestmapping\",{\"1\":{\"242\":1}}],[\"request\",{\"1\":{\"242\":1,\"310\":1,\"311\":1,\"708\":7,\"861\":1,\"947\":1}}],[\"requests\",{\"1\":{\"71\":1}}],[\"requested\",{\"1\":{\"71\":1,\"104\":1}}],[\"render\",{\"1\":{\"72\":1,\"76\":1,\"145\":1}}],[\"rendering\",{\"1\":{\"71\":1}}],[\"rendered\",{\"1\":{\"71\":1,\"87\":1}}],[\"rhombus\",{\"0\":{\"52\":1}}],[\"rl\",{\"1\":{\"44\":1,\"76\":1}}],[\"snapshot<\",{\"1\":{\"974\":1}}],[\"snake\",{\"1\":{\"942\":1}}],[\"snip\",{\"1\":{\"485\":1}}],[\"ssrf\",{\"1\":{\"861\":1}}],[\"ss\",{\"1\":{\"849\":1,\"854\":1}}],[\"sb\",{\"1\":{\"845\":1}}],[\"sbe\",{\"1\":{\"395\":1}}],[\"srp\",{\"0\":{\"715\":1},\"1\":{\"716\":1}}],[\"srcv\",{\"1\":{\"524\":2}}],[\"src\",{\"1\":{\"524\":4,\"525\":4,\"527\":4,\"528\":6,\"529\":1,\"532\":1,\"534\":4,\"860\":1}}],[\"squadron\",{\"1\":{\"462\":1}}],[\"square\",{\"1\":{\"449\":1}}],[\"sql语句中表的别名前加as\",{\"1\":{\"865\":1}}],[\"sql语句\",{\"0\":{\"865\":1}}],[\"sql性能优化的目标\",{\"1\":{\"864\":1}}],[\"sql性能\",{\"1\":{\"864\":1}}],[\"sql注入\",{\"1\":{\"861\":1}}],[\"sqlprovider\",{\"1\":{\"563\":1}}],[\"sqlexception\",{\"1\":{\"261\":1,\"469\":1}}],[\"sqlexception等以及用户自定义的exception异常\",{\"1\":{\"248\":1}}],[\"sql\",{\"1\":{\"95\":1,\"99\":1,\"100\":1,\"101\":1,\"103\":1,\"109\":1,\"110\":3,\"442\":1,\"474\":3,\"766\":9,\"849\":4,\"866\":1,\"872\":1}}],[\"smallint\",{\"1\":{\"863\":1}}],[\"smack\",{\"1\":{\"414\":1}}],[\"smith\",{\"1\":{\"636\":1}}],[\"smime操作\",{\"1\":{\"427\":1}}],[\"sleep\",{\"1\":{\"980\":6}}],[\"slave\",{\"1\":{\"845\":1}}],[\"slf4j的常见实现log4j和logback\",{\"1\":{\"859\":1}}],[\"slf4j\",{\"0\":{\"473\":1},\"1\":{\"412\":1,\"473\":3,\"859\":4}}],[\"slot\",{\"1\":{\"310\":1}}],[\"slower\",{\"1\":{\"145\":1}}],[\"svg\",{\"1\":{\"408\":1}}],[\"svg生成器\",{\"1\":{\"408\":1}}],[\"svc\",{\"1\":{\"114\":2}}],[\"s0\",{\"1\":{\"312\":3,\"664\":1}}],[\"sd\",{\"1\":{\"518\":1}}],[\"sdk\",{\"1\":{\"459\":1}}],[\"sdogpublic\",{\"1\":{\"305\":3}}],[\"sdogprotected\",{\"1\":{\"305\":2}}],[\"sdogprivate\",{\"1\":{\"305\":2}}],[\"sdogdefault\",{\"1\":{\"305\":2}}],[\"sdut\",{\"1\":{\"287\":1}}],[\"skywang12345\",{\"1\":{\"277\":1}}],[\"scm1\",{\"1\":{\"869\":1}}],[\"scott\",{\"1\":{\"797\":1}}],[\"scope>\",{\"1\":{\"974\":1}}],[\"scope=\",{\"1\":{\"624\":1}}],[\"scope=singleton\",{\"1\":{\"622\":1}}],[\"scope=prototype\",{\"1\":{\"622\":1}}],[\"scope\",{\"1\":{\"622\":1,\"626\":6,\"627\":3}}],[\"score=88\",{\"1\":{\"307\":1}}],[\"score是private的\",{\"1\":{\"307\":1}}],[\"scorefield\",{\"1\":{\"307\":4}}],[\"score\",{\"1\":{\"307\":3}}],[\"scene\",{\"1\":{\"405\":1}}],[\"schedule\",{\"1\":{\"979\":1}}],[\"scheduledthreadpool\",{\"1\":{\"851\":1,\"872\":1}}],[\"scheduledthreadpoolexecutor详解\",{\"0\":{\"497\":1}}],[\"schemalocation=\",{\"1\":{\"974\":1}}],[\"schema生成typesafe代码\",{\"1\":{\"394\":1}}],[\"schoolmanager\",{\"1\":{\"742\":10,\"743\":9}}],[\"schoolmasterapprover\",{\"1\":{\"710\":7}}],[\"school\",{\"1\":{\"217\":2}}],[\"scala\",{\"1\":{\"407\":1,\"411\":1,\"469\":1,\"472\":2}}],[\"scalable\",{\"1\":{\"312\":1}}],[\"scale\",{\"1\":{\"406\":1}}],[\"scanner\",{\"1\":{\"259\":7}}],[\"screen\",{\"1\":{\"215\":2,\"601\":14}}],[\"script>\",{\"1\":{\"77\":2}}],[\"swap\",{\"1\":{\"873\":1}}],[\"swagger是一个规范且完整的框架\",{\"1\":{\"424\":1}}],[\"swagger\",{\"1\":{\"424\":1}}],[\"swim\",{\"1\":{\"787\":1,\"788\":1,\"789\":2}}],[\"swing的后继者\",{\"1\":{\"405\":1}}],[\"switchstring\",{\"1\":{\"852\":1}}],[\"switch能否用string做参数\",{\"0\":{\"193\":1}}],[\"switch\",{\"0\":{\"130\":1,\"170\":1,\"922\":1},\"1\":{\"130\":6,\"150\":1,\"170\":2,\"186\":1,\"225\":3,\"618\":1,\"644\":1,\"709\":1,\"775\":2,\"783\":1,\"847\":1,\"852\":1,\"872\":1,\"901\":1,\"922\":3,\"923\":3,\"924\":2,\"925\":2}}],[\"swedish\",{\"1\":{\"68\":1}}],[\"s5\",{\"1\":{\"125\":2}}],[\"s4\",{\"1\":{\"125\":2}}],[\"s3\",{\"1\":{\"125\":4}}],[\"s2\",{\"1\":{\"125\":3,\"312\":1}}],[\"s10461\",{\"1\":{\"299\":1}}],[\"s1\",{\"1\":{\"125\":8,\"129\":7,\"312\":2,\"664\":1}}],[\"save\",{\"1\":{\"772\":1,\"828\":1,\"833\":1,\"958\":1}}],[\"sa\",{\"1\":{\"427\":2}}],[\"sat4j\",{\"1\":{\"391\":1}}],[\"safe\",{\"1\":{\"312\":2,\"469\":1,\"851\":1}}],[\"sanimalpublic\",{\"1\":{\"305\":2}}],[\"sanimalprotected\",{\"1\":{\"305\":1}}],[\"sanimalprivate\",{\"1\":{\"305\":1}}],[\"sanimaldefault\",{\"1\":{\"305\":1}}],[\"sayok\",{\"1\":{\"759\":2}}],[\"saybyebye\",{\"1\":{\"469\":1}}],[\"say\",{\"1\":{\"241\":3,\"847\":2}}],[\"sayworld\",{\"1\":{\"241\":3}}],[\"sayhello\",{\"1\":{\"241\":3,\"309\":3,\"700\":3}}],[\"sakurainluojia\",{\"1\":{\"116\":1}}],[\"sameinstance\",{\"1\":{\"978\":1}}],[\"same\",{\"1\":{\"44\":1,\"68\":3,\"77\":1,\"80\":1,\"104\":1,\"310\":2,\"312\":1,\"978\":3}}],[\"s>类型\",{\"1\":{\"114\":1}}],[\"s>>\",{\"1\":{\"114\":1}}],[\"s>\",{\"1\":{\"114\":1}}],[\"s\",{\"1\":{\"96\":2,\"104\":1,\"114\":5,\"129\":1,\"130\":2,\"294\":1,\"310\":1,\"312\":11,\"453\":1,\"455\":6,\"659\":2,\"738\":10,\"739\":2,\"759\":1,\"784\":4,\"851\":1,\"852\":2,\"854\":2,\"855\":1,\"885\":1,\"937\":1,\"947\":1,\"950\":2}}],[\"sysctl\",{\"1\":{\"870\":1}}],[\"systematically\",{\"1\":{\"145\":1}}],[\"systems\",{\"1\":{\"104\":1}}],[\"system\",{\"1\":{\"89\":3,\"91\":2,\"92\":4,\"93\":4,\"96\":2,\"103\":1,\"104\":6,\"114\":1,\"120\":4,\"125\":3,\"127\":7,\"130\":4,\"133\":5,\"134\":2,\"138\":2,\"139\":2,\"140\":1,\"141\":3,\"144\":4,\"209\":2,\"211\":3,\"230\":1,\"234\":3,\"241\":3,\"242\":5,\"252\":1,\"257\":3,\"275\":11,\"276\":9,\"279\":4,\"281\":3,\"282\":1,\"284\":2,\"285\":2,\"288\":2,\"298\":1,\"305\":18,\"306\":21,\"307\":7,\"308\":9,\"309\":1,\"310\":4,\"524\":4,\"528\":6,\"532\":1,\"538\":2,\"542\":15,\"553\":3,\"555\":8,\"561\":3,\"562\":11,\"571\":2,\"574\":3,\"580\":4,\"584\":13,\"595\":1,\"596\":3,\"601\":19,\"609\":4,\"610\":3,\"613\":8,\"617\":18,\"618\":6,\"622\":1,\"632\":4,\"636\":2,\"637\":6,\"644\":5,\"649\":3,\"650\":2,\"656\":5,\"659\":6,\"664\":3,\"667\":5,\"672\":4,\"676\":4,\"678\":10,\"685\":5,\"687\":6,\"689\":5,\"695\":3,\"700\":5,\"703\":6,\"708\":4,\"710\":4,\"718\":7,\"723\":16,\"727\":2,\"728\":3,\"734\":13,\"738\":5,\"739\":4,\"742\":4,\"743\":5,\"752\":3,\"753\":3,\"754\":4,\"755\":4,\"756\":4,\"757\":4,\"758\":4,\"759\":4,\"776\":2,\"778\":15,\"779\":4,\"784\":3,\"787\":6,\"788\":4,\"789\":11,\"790\":2,\"801\":3,\"803\":8,\"838\":5,\"839\":8,\"847\":3,\"848\":3,\"849\":1,\"850\":1,\"851\":1,\"852\":7,\"855\":1,\"860\":1,\"976\":6,\"977\":1,\"979\":2,\"980\":1,\"981\":1,\"982\":2,\"983\":3,\"994\":1}}],[\"symbol\",{\"1\":{\"859\":2}}],[\"symbolexpression\",{\"1\":{\"644\":5}}],[\"sync\",{\"1\":{\"852\":1}}],[\"synchroinzed\",{\"1\":{\"772\":1}}],[\"synchronized详解\",{\"0\":{\"506\":1}}],[\"synchronized\",{\"1\":{\"124\":1,\"310\":1,\"755\":1,\"756\":1,\"757\":2,\"758\":1,\"768\":3,\"772\":1,\"851\":1,\"934\":1}}],[\"synthetic\",{\"1\":{\"225\":1,\"302\":1}}],[\"syntaxes\",{\"1\":{\"68\":1}}],[\"syntax\",{\"0\":{\"72\":1},\"1\":{\"68\":1,\"73\":1,\"78\":1,\"85\":1,\"86\":1,\"114\":1,\"150\":1}}],[\"segmentfault\",{\"1\":{\"993\":1,\"1000\":1}}],[\"segregation1\",{\"1\":{\"723\":2}}],[\"segregation\",{\"1\":{\"721\":1}}],[\"seq\",{\"1\":{\"846\":5}}],[\"sequence\",{\"1\":{\"219\":1,\"423\":1}}],[\"seasonenum\",{\"1\":{\"846\":2}}],[\"searchmethods\",{\"1\":{\"311\":2}}],[\"search文件里写上两个实现类\",{\"1\":{\"96\":1}}],[\"searchdoc\",{\"1\":{\"96\":4}}],[\"search\",{\"1\":{\"96\":9}}],[\"session\",{\"1\":{\"750\":1,\"761\":1}}],[\"sessionfactory\",{\"1\":{\"750\":3}}],[\"session会话\",{\"1\":{\"427\":1}}],[\"sendalarm\",{\"1\":{\"659\":3}}],[\"send\",{\"1\":{\"656\":5}}],[\"sendmessage\",{\"1\":{\"659\":9,\"941\":1}}],[\"sendmes\",{\"1\":{\"617\":5}}],[\"sensitive\",{\"1\":{\"145\":1}}],[\"semaphore等\",{\"1\":{\"873\":1}}],[\"semaphore详解\",{\"0\":{\"504\":1}}],[\"semantic\",{\"1\":{\"430\":1}}],[\"semicolon\",{\"0\":{\"86\":1},\"1\":{\"86\":2}}],[\"select\",{\"1\":{\"474\":1,\"803\":2,\"864\":2,\"865\":6}}],[\"selectdeptcount\",{\"1\":{\"242\":1}}],[\"selenium\",{\"1\":{\"431\":1}}],[\"selenide\",{\"1\":{\"431\":1}}],[\"selfinterrupt\",{\"1\":{\"852\":1}}],[\"self\",{\"1\":{\"77\":1}}],[\"se\",{\"1\":{\"150\":2,\"407\":1,\"792\":2}}],[\"serverinstances\",{\"1\":{\"773\":6}}],[\"serveraddress\",{\"1\":{\"773\":4}}],[\"serverno\",{\"1\":{\"773\":6}}],[\"server\",{\"1\":{\"485\":1,\"773\":2}}],[\"servletcontextconfig\",{\"1\":{\"750\":1}}],[\"servlet\",{\"1\":{\"432\":1,\"707\":1,\"750\":1}}],[\"servletutils\",{\"1\":{\"242\":3}}],[\"service或manager向外传输的对象\",{\"1\":{\"868\":1,\"873\":1}}],[\"service层\",{\"1\":{\"868\":1}}],[\"serviceexception等\",{\"1\":{\"858\":1}}],[\"service测试桩\",{\"1\":{\"431\":1}}],[\"service集成sso和idm\",{\"1\":{\"427\":1}}],[\"service进行扩展并将其关联到数据库\",{\"1\":{\"415\":1}}],[\"serviceconfigurationerror\",{\"1\":{\"114\":7}}],[\"serviceloader实现了iterable接口\",{\"1\":{\"114\":2}}],[\"serviceloader具体的源码实现在下面\",{\"1\":{\"103\":1}}],[\"serviceloader<>\",{\"1\":{\"114\":1}}],[\"serviceloader<s>\",{\"1\":{\"114\":4}}],[\"serviceloader<search>\",{\"1\":{\"96\":1}}],[\"serviceloader<driver>\",{\"1\":{\"103\":2,\"111\":1}}],[\"serviceloader\",{\"1\":{\"95\":1,\"96\":1,\"103\":2,\"111\":1,\"114\":4,\"115\":1}}],[\"services目录下定义一个名字为接口全限定名的文件\",{\"1\":{\"110\":1}}],[\"services目录下的java\",{\"1\":{\"103\":1}}],[\"services目录下查找配置文件\",{\"1\":{\"103\":1}}],[\"services目录\",{\"1\":{\"100\":1}}],[\"services下寻找org\",{\"1\":{\"104\":1}}],[\"services下根据平台定义的接口新建文件\",{\"1\":{\"96\":1}}],[\"services下找接口的全限定名文件\",{\"1\":{\"96\":1}}],[\"services\",{\"1\":{\"95\":2,\"96\":1,\"104\":3,\"114\":3,\"472\":3}}],[\"service\",{\"1\":{\"95\":2,\"104\":6,\"114\":32,\"387\":1,\"424\":1,\"845\":1}}],[\"serialization\",{\"1\":{\"312\":2}}],[\"serializationconstructoraccessorimpl\",{\"1\":{\"312\":2}}],[\"serializationconstructoraccessor\",{\"1\":{\"312\":1}}],[\"serializationtargetclassidx\",{\"1\":{\"312\":3}}],[\"serializationtargetclass\",{\"1\":{\"312\":2}}],[\"serializable\",{\"0\":{\"185\":1},\"1\":{\"122\":1,\"185\":1,\"225\":1,\"302\":1,\"306\":1,\"689\":2,\"741\":1}}],[\"serialversionuid\",{\"1\":{\"225\":1,\"689\":1}}],[\"serial\",{\"1\":{\"225\":1}}],[\"see\",{\"1\":{\"104\":1,\"269\":1,\"310\":1,\"312\":1,\"489\":1}}],[\"secrectkey\",{\"1\":{\"809\":2}}],[\"sections\",{\"1\":{\"145\":1}}],[\"seconds\",{\"1\":{\"980\":5}}],[\"secondary反例\",{\"1\":{\"845\":1}}],[\"second\",{\"1\":{\"104\":1,\"618\":1,\"847\":1,\"865\":2,\"983\":1}}],[\"securitymanager\",{\"1\":{\"310\":1}}],[\"security\",{\"1\":{\"104\":2,\"145\":3,\"310\":5}}],[\"securityexception\",{\"1\":{\"104\":1,\"234\":1,\"261\":1,\"311\":1}}],[\"securitylevel\",{\"1\":{\"77\":1}}],[\"securitylevel=\",{\"1\":{\"77\":2}}],[\"set<string>\",{\"1\":{\"942\":1}}],[\"setheader\",{\"1\":{\"854\":1}}],[\"sethousebuilder\",{\"1\":{\"555\":2}}],[\"setmoniter\",{\"1\":{\"832\":1}}],[\"setmouse\",{\"1\":{\"832\":1}}],[\"setmemento\",{\"1\":{\"664\":2,\"667\":2}}],[\"setmemory\",{\"1\":{\"93\":1}}],[\"setmedium\",{\"1\":{\"656\":2}}],[\"setmethodaccessor\",{\"1\":{\"312\":1}}],[\"setmethod\",{\"1\":{\"242\":1}}],[\"setquackbehavior\",{\"1\":{\"789\":1}}],[\"setflybehavior\",{\"1\":{\"789\":2}}],[\"setnext\",{\"1\":{\"708\":2,\"711\":1}}],[\"setname\",{\"1\":{\"127\":2,\"305\":1,\"306\":2,\"574\":1,\"610\":6,\"613\":4,\"636\":1,\"650\":1,\"685\":1,\"687\":1,\"826\":1}}],[\"setstrategy\",{\"1\":{\"784\":3}}],[\"setstate\",{\"1\":{\"664\":5,\"776\":3,\"778\":5,\"779\":10}}],[\"setstatus\",{\"1\":{\"242\":2}}],[\"setsuperclass\",{\"1\":{\"703\":1}}],[\"setvit\",{\"1\":{\"667\":4}}],[\"setvalue方法是为了解决类型擦除与多态之间的冲突\",{\"1\":{\"291\":1}}],[\"setvalue\",{\"1\":{\"281\":2,\"289\":2,\"291\":14}}],[\"setvar\",{\"1\":{\"281\":2,\"282\":2,\"284\":4,\"471\":1}}],[\"setprice\",{\"1\":{\"584\":8}}],[\"setparent\",{\"1\":{\"312\":2}}],[\"setcallback\",{\"1\":{\"703\":2}}],[\"setcolor\",{\"1\":{\"685\":1,\"687\":1}}],[\"setcommand\",{\"1\":{\"561\":1,\"562\":3}}],[\"setchar\",{\"1\":{\"307\":1}}],[\"setroofed\",{\"1\":{\"555\":1}}],[\"setrequestvalue\",{\"1\":{\"242\":2}}],[\"setrequestmethod\",{\"1\":{\"242\":1}}],[\"setwall\",{\"1\":{\"555\":1}}],[\"set和hash\",{\"1\":{\"406\":1}}],[\"setbaise\",{\"1\":{\"555\":1}}],[\"setboolean\",{\"1\":{\"307\":1}}],[\"setbusinesstype\",{\"1\":{\"242\":1}}],[\"setdef\",{\"1\":{\"667\":4}}],[\"setdesc\",{\"1\":{\"650\":1}}],[\"setdes\",{\"1\":{\"574\":1,\"584\":8}}],[\"setdelegate\",{\"1\":{\"310\":1,\"312\":4}}],[\"setdeptname\",{\"1\":{\"242\":1}}],[\"setdata\",{\"1\":{\"298\":1,\"445\":1,\"676\":4,\"678\":4}}],[\"setkey\",{\"1\":{\"281\":2}}],[\"setteacher\",{\"1\":{\"831\":1}}],[\"setter方法中\",{\"1\":{\"848\":2}}],[\"setter方法放在类体最后\",{\"1\":{\"848\":1}}],[\"setter方法\",{\"1\":{\"848\":1}}],[\"setter\",{\"1\":{\"132\":1,\"471\":2,\"555\":1,\"609\":1,\"613\":1,\"626\":2,\"728\":3,\"745\":1,\"748\":1,\"778\":1,\"832\":1}}],[\"settv\",{\"1\":{\"728\":3}}],[\"setting\",{\"1\":{\"617\":5}}],[\"settitle\",{\"1\":{\"242\":1}}],[\"seterrormsg\",{\"1\":{\"242\":1}}],[\"setoperparam\",{\"1\":{\"242\":1}}],[\"setoperatortype\",{\"1\":{\"242\":1}}],[\"setopername\",{\"1\":{\"242\":1}}],[\"setoperurl\",{\"1\":{\"242\":1}}],[\"setoperip\",{\"1\":{\"242\":1}}],[\"setjsonresult\",{\"1\":{\"242\":1}}],[\"setup\",{\"1\":{\"241\":3,\"997\":2}}],[\"setinfo\",{\"1\":{\"632\":1}}],[\"setint\",{\"1\":{\"91\":1}}],[\"setid\",{\"1\":{\"132\":1,\"742\":4,\"743\":4}}],[\"setapprover\",{\"1\":{\"710\":5}}],[\"setage\",{\"1\":{\"305\":1,\"306\":3,\"685\":1,\"687\":1}}],[\"setattribute\",{\"1\":{\"104\":1}}],[\"setaccessible\",{\"1\":{\"91\":2,\"93\":1,\"306\":1,\"307\":2,\"308\":1,\"310\":1}}],[\"set\",{\"1\":{\"74\":1,\"75\":1,\"76\":1,\"77\":1,\"87\":1,\"91\":1,\"139\":4,\"141\":6,\"145\":2,\"147\":1,\"307\":5,\"446\":1,\"451\":1,\"741\":1,\"838\":1,\"849\":1,\"851\":1,\"866\":1}}],[\"spy\",{\"1\":{\"996\":4}}],[\"spock\",{\"1\":{\"431\":1}}],[\"spm\",{\"1\":{\"416\":1}}],[\"springboot2+h2+mockito实战\",{\"0\":{\"987\":1}}],[\"springjunit4classrunner\",{\"1\":{\"972\":1,\"981\":1}}],[\"springmvc\",{\"0\":{\"533\":1},\"1\":{\"533\":2,\"710\":1}}],[\"spring安全课程作者\",{\"1\":{\"440\":1}}],[\"springsource\",{\"1\":{\"407\":1}}],[\"spring\",{\"0\":{\"688\":1,\"1010\":1},\"1\":{\"106\":5,\"240\":1,\"398\":1,\"434\":2,\"449\":4,\"457\":1,\"480\":1,\"563\":1,\"622\":3,\"624\":2,\"688\":1,\"702\":1,\"750\":1,\"769\":1,\"846\":1,\"869\":1}}],[\"spring中spi机制\",{\"0\":{\"106\":1}}],[\"split\",{\"1\":{\"103\":1,\"848\":1}}],[\"spi和api的区别是什么\",{\"0\":{\"113\":1}}],[\"spi需要遵循的规范\",{\"1\":{\"112\":1}}],[\"spi服务发现机制\",{\"1\":{\"104\":1}}],[\"spi机制实现原理\",{\"0\":{\"114\":1}}],[\"spi机制通常怎么使用\",{\"0\":{\"108\":1}}],[\"spi机制深入理解\",{\"0\":{\"107\":1}}],[\"spi机制\",{\"0\":{\"98\":1,\"104\":1,\"105\":1,\"106\":1}}],[\"spi机制的缺陷\",{\"0\":{\"115\":1}}],[\"spi机制的广泛应用\",{\"0\":{\"97\":1}}],[\"spi机制的简单示例\",{\"0\":{\"96\":1}}],[\"spi机制详解\",{\"0\":{\"95\":1}}],[\"spi整体机制图如下\",{\"1\":{\"95\":1}}],[\"spi\",{\"1\":{\"95\":2,\"96\":3,\"113\":3,\"116\":1}}],[\"spinner\",{\"1\":{\"85\":1}}],[\"spades\",{\"1\":{\"915\":1}}],[\"sparrow\",{\"1\":{\"813\":1}}],[\"spark\",{\"1\":{\"413\":1,\"414\":1,\"424\":1,\"472\":2}}],[\"space\",{\"1\":{\"86\":2,\"939\":1}}],[\"spaces\",{\"0\":{\"86\":1},\"1\":{\"847\":1}}],[\"span>\",{\"1\":{\"83\":1}}],[\"spans\",{\"1\":{\"71\":1}}],[\"span\",{\"1\":{\"71\":1}}],[\"specifying\",{\"1\":{\"104\":2}}],[\"specifies\",{\"1\":{\"104\":1}}],[\"specified\",{\"1\":{\"104\":6,\"618\":1}}],[\"specificmethod\",{\"1\":{\"801\":2}}],[\"specification\",{\"1\":{\"431\":1}}],[\"specific\",{\"1\":{\"81\":1,\"84\":1,\"104\":1,\"225\":1}}],[\"specialist\",{\"1\":{\"442\":1}}],[\"special\",{\"0\":{\"72\":1}}],[\"site\",{\"1\":{\"861\":1}}],[\"situation\",{\"1\":{\"104\":1}}],[\"simpledateformat是线程不安全的类\",{\"1\":{\"851\":1}}],[\"simpledateformat\",{\"1\":{\"849\":1,\"851\":1}}],[\"simplefactory\",{\"1\":{\"608\":1,\"610\":6}}],[\"simple\",{\"0\":{\"607\":1},\"1\":{\"608\":1,\"851\":1}}],[\"simpletrycatchfinally\",{\"1\":{\"275\":3}}],[\"simpletrycatch\",{\"1\":{\"275\":2}}],[\"simon\",{\"1\":{\"440\":1}}],[\"signleton2\",{\"1\":{\"768\":1}}],[\"signature\",{\"1\":{\"242\":3,\"310\":1,\"312\":1}}],[\"signs\",{\"1\":{\"71\":1,\"78\":1}}],[\"singularity是一个mesos框架\",{\"1\":{\"387\":1}}],[\"singularity\",{\"1\":{\"387\":1}}],[\"singleresponsibility3\",{\"1\":{\"718\":1}}],[\"singleresponsibility2\",{\"1\":{\"718\":1}}],[\"singleresponsibility1\",{\"1\":{\"718\":1}}],[\"singletonlist\",{\"1\":{\"850\":1}}],[\"singleton2\",{\"1\":{\"768\":1}}],[\"singleton1\",{\"1\":{\"768\":2}}],[\"singletoninstance\",{\"1\":{\"758\":4}}],[\"singletontest08\",{\"1\":{\"759\":1}}],[\"singletontest07\",{\"1\":{\"758\":1}}],[\"singletontest06\",{\"1\":{\"757\":1}}],[\"singletontest04\",{\"1\":{\"755\":1,\"756\":1}}],[\"singletontest03\",{\"1\":{\"754\":1}}],[\"singletontest02\",{\"1\":{\"753\":1}}],[\"singletontest01\",{\"1\":{\"752\":1}}],[\"singletonobjects\",{\"1\":{\"627\":7}}],[\"singleton\",{\"1\":{\"589\":1,\"624\":1,\"626\":3,\"627\":2,\"752\":9,\"753\":9,\"754\":10,\"755\":9,\"756\":10,\"757\":12,\"758\":13,\"759\":6,\"768\":28,\"798\":1}}],[\"single\",{\"1\":{\"86\":1,\"104\":1,\"716\":1}}],[\"sinat\",{\"1\":{\"314\":1}}],[\"since\",{\"1\":{\"145\":1,\"310\":1,\"312\":1}}],[\"size过大导致内存溢出\",{\"1\":{\"861\":1}}],[\"size正在变大的情况下\",{\"1\":{\"850\":1}}],[\"size=1\",{\"1\":{\"228\":4}}],[\"size\",{\"1\":{\"120\":1,\"139\":1,\"285\":2,\"288\":1,\"295\":2,\"478\":1,\"627\":3,\"636\":1,\"649\":1,\"650\":1,\"678\":1,\"866\":4}}],[\"side\",{\"1\":{\"71\":1,\"145\":1}}],[\"sonarlint插件详解\",{\"0\":{\"966\":1}}],[\"sonarqube\",{\"1\":{\"388\":1,\"484\":2}}],[\"son\",{\"1\":{\"845\":1}}],[\"soak\",{\"1\":{\"803\":2}}],[\"sort会抛illegalargumentexception异常\",{\"1\":{\"850\":1}}],[\"sort\",{\"1\":{\"790\":6,\"850\":3}}],[\"soyamilk\",{\"1\":{\"803\":7}}],[\"soy\",{\"1\":{\"581\":1,\"583\":1,\"584\":2,\"585\":1}}],[\"solr\",{\"1\":{\"426\":1}}],[\"solid\",{\"1\":{\"187\":1,\"219\":1}}],[\"software\",{\"1\":{\"736\":2}}],[\"softreference<>\",{\"1\":{\"310\":1}}],[\"softreference<reflectiondata<t>>\",{\"1\":{\"310\":2}}],[\"softreference\",{\"1\":{\"310\":2}}],[\"softlab\",{\"1\":{\"287\":1}}],[\"source>\",{\"1\":{\"974\":1}}],[\"sourcepolicy\",{\"1\":{\"228\":5}}],[\"source\",{\"1\":{\"223\":1,\"225\":1,\"228\":2,\"848\":1}}],[\"somemutabletype>\",{\"1\":{\"942\":1}}],[\"somemutabletype\",{\"1\":{\"942\":1}}],[\"someannotation\",{\"1\":{\"911\":1}}],[\"somethingthatyieldsafoo\",{\"1\":{\"951\":1}}],[\"somethingelse\",{\"1\":{\"901\":1}}],[\"something\",{\"1\":{\"252\":1,\"268\":1,\"269\":2,\"270\":1,\"271\":1,\"468\":1,\"901\":1}}],[\"someclass\",{\"1\":{\"82\":2}}],[\"some\",{\"1\":{\"80\":1,\"104\":1,\"478\":6}}],[\"so\",{\"1\":{\"71\":1,\"73\":1,\"86\":1,\"312\":1,\"933\":1}}],[\"suteclass\",{\"1\":{\"999\":1}}],[\"sut\",{\"1\":{\"994\":3,\"996\":2,\"997\":1}}],[\"suit\",{\"1\":{\"915\":1}}],[\"suiteclasses\",{\"1\":{\"972\":1,\"981\":1,\"982\":1,\"999\":1}}],[\"suite\",{\"1\":{\"145\":1,\"407\":1,\"972\":1,\"981\":1,\"982\":5,\"999\":1}}],[\"sum\",{\"1\":{\"865\":1}}],[\"summer\",{\"1\":{\"846\":1}}],[\"summed\",{\"1\":{\"71\":1}}],[\"suppress\",{\"1\":{\"225\":19,\"234\":1}}],[\"suppresswarnings\",{\"0\":{\"225\":1},\"1\":{\"221\":1,\"222\":3,\"225\":1,\"234\":1,\"310\":2}}],[\"supportsipv6onios\",{\"1\":{\"947\":2}}],[\"supports\",{\"1\":{\"947\":1}}],[\"support\",{\"0\":{\"85\":1},\"1\":{\"150\":1}}],[\"supported\",{\"1\":{\"69\":1,\"73\":1,\"77\":1}}],[\"supertype\",{\"1\":{\"732\":1}}],[\"superclass\",{\"1\":{\"298\":2,\"312\":3}}],[\"super是一个关键字\",{\"1\":{\"200\":1}}],[\"super从子类调用父类构造\",{\"1\":{\"200\":1}}],[\"super只能指代其直接父类\",{\"1\":{\"199\":1}}],[\"super出现在父类的子类中\",{\"0\":{\"199\":1}}],[\"superset\",{\"1\":{\"152\":1}}],[\"super在新窗口打开\",{\"1\":{\"134\":1}}],[\"superextendexample\",{\"1\":{\"134\":5}}],[\"superexample\",{\"1\":{\"134\":6}}],[\"super\",{\"0\":{\"134\":1,\"200\":1},\"1\":{\"127\":1,\"134\":4,\"141\":4,\"144\":1,\"199\":3,\"200\":1,\"241\":2,\"254\":1,\"284\":8,\"287\":1,\"291\":6,\"305\":1,\"306\":3,\"310\":1,\"312\":1,\"538\":1,\"542\":9,\"574\":10,\"580\":2,\"584\":5,\"601\":1,\"636\":1,\"644\":6,\"650\":1,\"659\":4,\"667\":1,\"685\":1,\"687\":2,\"689\":4,\"710\":4,\"738\":5,\"739\":4,\"790\":1,\"850\":4}}],[\"sunxianghuang\",{\"1\":{\"299\":1}}],[\"sun\",{\"1\":{\"120\":1,\"310\":7,\"311\":1,\"312\":5,\"700\":1,\"979\":3,\"980\":3}}],[\"such\",{\"1\":{\"81\":1,\"145\":2}}],[\"successfully\",{\"1\":{\"485\":1}}],[\"success\",{\"1\":{\"77\":1,\"242\":1,\"469\":1,\"839\":5,\"845\":1,\"979\":2}}],[\"surrounded\",{\"1\":{\"77\":1}}],[\"sublist\",{\"1\":{\"850\":1}}],[\"subtract\",{\"1\":{\"848\":2}}],[\"subtype\",{\"1\":{\"114\":1,\"732\":1}}],[\"subject\",{\"1\":{\"672\":9,\"678\":2,\"679\":1,\"694\":2}}],[\"subexpression\",{\"1\":{\"644\":3}}],[\"substitution\",{\"1\":{\"732\":1}}],[\"substring\",{\"1\":{\"114\":1,\"242\":2,\"310\":1}}],[\"subsystem03\",{\"1\":{\"596\":3}}],[\"subsystem02\",{\"1\":{\"596\":3}}],[\"subsystem01\",{\"1\":{\"596\":3}}],[\"sub\",{\"1\":{\"312\":1,\"595\":1,\"742\":2,\"743\":2}}],[\"subaochen\",{\"1\":{\"287\":1}}],[\"subclass\",{\"1\":{\"104\":8}}],[\"subgraph\",{\"1\":{\"74\":6,\"75\":3,\"76\":4}}],[\"subgraphs\",{\"0\":{\"74\":1,\"76\":1},\"1\":{\"75\":1}}],[\"subroutine\",{\"0\":{\"48\":1}}],[\"sth\",{\"1\":{\"852\":2}}],[\"stereo\",{\"1\":{\"601\":11}}],[\"stephen\",{\"1\":{\"440\":1}}],[\"step\",{\"1\":{\"92\":6}}],[\"study\",{\"1\":{\"830\":1}}],[\"student\",{\"1\":{\"217\":2,\"230\":2,\"307\":12,\"830\":1,\"850\":2}}],[\"stus\",{\"1\":{\"830\":1}}],[\"stub\",{\"1\":{\"431\":1,\"996\":7}}],[\"sts\",{\"1\":{\"407\":1}}],[\"st\",{\"1\":{\"307\":6}}],[\"st=\",{\"1\":{\"307\":1}}],[\"stock\",{\"1\":{\"845\":3}}],[\"storm\",{\"1\":{\"399\":1}}],[\"store\",{\"1\":{\"294\":1}}],[\"storage\",{\"1\":{\"122\":1,\"772\":3}}],[\"stopwatch\",{\"1\":{\"947\":1}}],[\"stoptv\",{\"1\":{\"659\":3}}],[\"stop\",{\"1\":{\"81\":1,\"941\":1}}],[\"strong\",{\"1\":{\"851\":1}}],[\"stroke\",{\"1\":{\"80\":2,\"81\":5,\"82\":2,\"83\":2,\"84\":2}}],[\"structures\",{\"0\":{\"1012\":1}}],[\"structure\",{\"1\":{\"838\":1}}],[\"structs\",{\"0\":{\"445\":1}}],[\"struts2\",{\"1\":{\"707\":1}}],[\"strategypattern\",{\"1\":{\"784\":1}}],[\"strategymethod\",{\"1\":{\"784\":7}}],[\"strategy\",{\"1\":{\"591\":1,\"783\":1,\"784\":15,\"788\":1,\"790\":1,\"791\":1,\"798\":1,\"814\":1}}],[\"strange\",{\"1\":{\"104\":1}}],[\"str\",{\"1\":{\"455\":3,\"848\":5,\"850\":5,\"907\":2,\"911\":2}}],[\"str2\",{\"1\":{\"290\":1}}],[\"str1\",{\"1\":{\"290\":1}}],[\"stream\",{\"1\":{\"187\":1,\"455\":2,\"466\":1,\"850\":5}}],[\"streams\",{\"0\":{\"455\":1},\"1\":{\"150\":1,\"423\":1}}],[\"strictfp\",{\"1\":{\"934\":1}}],[\"strictly\",{\"1\":{\"310\":1}}],[\"strict\",{\"1\":{\"77\":1}}],[\"string因为覆写了hashcode和equals方法\",{\"1\":{\"850\":1}}],[\"string类\",{\"1\":{\"848\":1}}],[\"string类的父类只有object类\",{\"1\":{\"284\":1}}],[\"stringresult\",{\"1\":{\"468\":1}}],[\"stringindexoutofboundsexception\",{\"1\":{\"261\":1}}],[\"string>>\",{\"1\":{\"474\":1}}],[\"string>\",{\"1\":{\"236\":2,\"284\":1,\"659\":2,\"850\":2}}],[\"string由于有final修饰\",{\"1\":{\"192\":1}}],[\"string对象是不可变的\",{\"1\":{\"192\":1}}],[\"string接收bytes的构造器转成string\",{\"1\":{\"160\":1}}],[\"strings\",{\"1\":{\"150\":1,\"618\":1,\"978\":1}}],[\"stringbuilder和stringbuffer的区别在于stringbuilder不保证同步\",{\"1\":{\"192\":1}}],[\"stringbuilder在新窗口打开\",{\"1\":{\"124\":1}}],[\"stringbuilder\",{\"0\":{\"124\":1},\"1\":{\"124\":2,\"556\":3,\"847\":4}}],[\"stringbuffer与stringbuilder的区别\",{\"0\":{\"192\":1}}],[\"stringbuffer\",{\"0\":{\"124\":1},\"1\":{\"124\":3}}],[\"stringutils\",{\"1\":{\"106\":1,\"242\":4}}],[\"string\",{\"0\":{\"121\":1,\"124\":1,\"125\":1,\"159\":1,\"169\":1,\"170\":1,\"192\":1},\"1\":{\"59\":1,\"87\":1,\"89\":3,\"91\":1,\"92\":3,\"96\":4,\"102\":1,\"103\":4,\"104\":8,\"106\":3,\"114\":9,\"120\":1,\"122\":4,\"123\":14,\"124\":3,\"125\":11,\"127\":7,\"130\":3,\"132\":3,\"137\":1,\"144\":5,\"151\":1,\"159\":1,\"169\":1,\"173\":1,\"180\":1,\"186\":1,\"201\":1,\"209\":3,\"211\":1,\"225\":2,\"229\":1,\"230\":1,\"234\":5,\"241\":3,\"242\":7,\"252\":2,\"253\":1,\"254\":1,\"256\":2,\"257\":2,\"266\":1,\"270\":3,\"271\":1,\"275\":22,\"276\":1,\"281\":2,\"282\":1,\"284\":5,\"285\":1,\"288\":2,\"289\":2,\"290\":6,\"291\":1,\"294\":1,\"298\":4,\"305\":10,\"306\":20,\"307\":11,\"308\":13,\"309\":3,\"310\":6,\"311\":6,\"312\":8,\"445\":5,\"446\":3,\"450\":3,\"452\":3,\"455\":1,\"467\":1,\"468\":1,\"469\":1,\"474\":1,\"477\":1,\"524\":1,\"528\":1,\"532\":1,\"538\":1,\"542\":1,\"553\":1,\"555\":10,\"561\":1,\"562\":1,\"571\":6,\"574\":21,\"580\":1,\"584\":5,\"596\":1,\"601\":1,\"609\":2,\"610\":3,\"613\":6,\"617\":1,\"618\":2,\"622\":3,\"624\":2,\"625\":4,\"626\":5,\"627\":1,\"629\":1,\"632\":8,\"636\":8,\"637\":1,\"638\":1,\"642\":4,\"644\":14,\"649\":1,\"650\":18,\"656\":1,\"659\":11,\"664\":8,\"667\":1,\"672\":1,\"676\":1,\"678\":1,\"685\":10,\"687\":11,\"689\":9,\"695\":1,\"700\":3,\"703\":3,\"708\":4,\"710\":7,\"718\":10,\"723\":2,\"727\":6,\"728\":1,\"734\":2,\"738\":2,\"739\":1,\"742\":7,\"743\":7,\"752\":1,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"757\":1,\"758\":1,\"759\":1,\"773\":3,\"776\":1,\"778\":1,\"779\":12,\"784\":1,\"789\":1,\"790\":1,\"801\":1,\"803\":1,\"809\":24,\"814\":2,\"826\":3,\"830\":2,\"831\":1,\"838\":3,\"839\":1,\"845\":3,\"846\":4,\"847\":4,\"848\":7,\"850\":11,\"851\":3,\"852\":2,\"866\":1,\"872\":1,\"885\":4,\"907\":1,\"911\":2,\"915\":1,\"921\":2,\"927\":2,\"928\":1,\"929\":1,\"942\":3,\"955\":1,\"978\":14,\"980\":1}}],[\"styleguide\",{\"1\":{\"875\":1}}],[\"style>\",{\"1\":{\"83\":1}}],[\"style\",{\"0\":{\"444\":1},\"1\":{\"80\":4,\"81\":2,\"82\":1,\"83\":1,\"442\":1,\"453\":1}}],[\"styles\",{\"1\":{\"77\":1,\"81\":1,\"82\":1,\"83\":1}}],[\"styling\",{\"0\":{\"79\":1,\"80\":1,\"81\":1}}],[\"still\",{\"1\":{\"71\":1,\"310\":1,\"489\":1}}],[\"standardtest\",{\"1\":{\"976\":1}}],[\"standard\",{\"1\":{\"976\":1}}],[\"stands\",{\"1\":{\"147\":1}}],[\"stampedlock\",{\"0\":{\"355\":1}}],[\"stale\",{\"1\":{\"310\":1}}],[\"staff\",{\"1\":{\"284\":1}}],[\"stack<>\",{\"1\":{\"644\":1}}],[\"stack<expression>\",{\"1\":{\"644\":1}}],[\"stack\",{\"0\":{\"318\":1},\"1\":{\"310\":1,\"644\":11,\"857\":1}}],[\"stackify\",{\"1\":{\"270\":2}}],[\"stack=0\",{\"1\":{\"228\":3}}],[\"stack=1\",{\"1\":{\"228\":1}}],[\"stackoverflowerror\",{\"1\":{\"247\":1,\"268\":1}}],[\"stackoverflow\",{\"1\":{\"116\":1,\"124\":1,\"127\":1,\"129\":1,\"130\":1,\"437\":1}}],[\"stateenum\",{\"1\":{\"779\":8}}],[\"statepatternclient\",{\"1\":{\"776\":1}}],[\"statechange\",{\"1\":{\"659\":15}}],[\"state\",{\"1\":{\"591\":1,\"632\":2,\"664\":14,\"775\":1,\"776\":15,\"778\":16,\"779\":22,\"798\":1}}],[\"statementname\",{\"1\":{\"866\":1}}],[\"statementcallback\",{\"1\":{\"563\":5}}],[\"statements\",{\"1\":{\"86\":1,\"225\":1,\"252\":1,\"852\":1,\"979\":3,\"980\":3}}],[\"statement\",{\"1\":{\"43\":1,\"76\":1,\"80\":1,\"82\":1,\"86\":1,\"130\":1,\"150\":1,\"225\":1,\"474\":1,\"902\":2,\"922\":1}}],[\"stats\",{\"1\":{\"310\":1}}],[\"static的\",{\"1\":{\"981\":1}}],[\"static<t\",{\"1\":{\"297\":1}}],[\"staticfield\",{\"1\":{\"144\":1}}],[\"staticinnerclass\",{\"1\":{\"144\":4}}],[\"static\",{\"0\":{\"144\":1},\"1\":{\"89\":3,\"91\":4,\"92\":3,\"96\":1,\"103\":2,\"104\":2,\"106\":2,\"114\":7,\"120\":5,\"127\":4,\"133\":2,\"144\":20,\"194\":1,\"201\":2,\"211\":1,\"225\":2,\"234\":13,\"242\":1,\"252\":2,\"253\":2,\"256\":2,\"257\":1,\"259\":1,\"275\":8,\"276\":1,\"279\":4,\"281\":2,\"282\":1,\"284\":11,\"285\":3,\"288\":2,\"289\":3,\"290\":2,\"291\":1,\"293\":1,\"296\":3,\"297\":2,\"298\":1,\"302\":5,\"305\":10,\"306\":2,\"307\":1,\"308\":1,\"309\":1,\"310\":3,\"311\":3,\"312\":1,\"446\":1,\"452\":2,\"469\":2,\"524\":1,\"528\":1,\"532\":2,\"538\":1,\"542\":1,\"553\":1,\"555\":1,\"561\":1,\"562\":1,\"571\":2,\"574\":1,\"580\":1,\"584\":1,\"596\":1,\"601\":13,\"608\":3,\"609\":1,\"610\":3,\"613\":1,\"617\":1,\"618\":3,\"624\":1,\"626\":2,\"632\":1,\"636\":1,\"637\":1,\"644\":3,\"649\":1,\"650\":1,\"656\":1,\"659\":1,\"664\":1,\"667\":1,\"672\":1,\"676\":1,\"678\":1,\"685\":1,\"687\":1,\"689\":2,\"695\":1,\"699\":1,\"700\":2,\"703\":2,\"708\":1,\"710\":1,\"718\":3,\"723\":2,\"727\":2,\"728\":1,\"734\":2,\"738\":2,\"739\":1,\"742\":1,\"743\":1,\"752\":3,\"753\":4,\"754\":3,\"755\":3,\"756\":3,\"757\":3,\"758\":5,\"759\":1,\"760\":3,\"768\":9,\"769\":2,\"771\":2,\"772\":4,\"773\":5,\"776\":1,\"778\":1,\"779\":2,\"784\":1,\"789\":1,\"790\":2,\"801\":1,\"803\":1,\"809\":2,\"838\":1,\"839\":1,\"846\":6,\"847\":1,\"851\":1,\"852\":2,\"855\":1,\"859\":2,\"897\":1,\"934\":1,\"942\":13,\"972\":2,\"975\":1,\"976\":2,\"978\":2,\"980\":1,\"981\":1}}],[\"startrunnerwithargs\",{\"1\":{\"979\":2}}],[\"startedat\",{\"1\":{\"845\":1}}],[\"starttime\",{\"1\":{\"845\":1}}],[\"starttv\",{\"1\":{\"659\":3}}],[\"startcoffee\",{\"1\":{\"659\":3}}],[\"startswith\",{\"1\":{\"455\":2,\"978\":1}}],[\"startstop\",{\"1\":{\"81\":1}}],[\"startuml\",{\"1\":{\"213\":1,\"214\":1,\"215\":1,\"216\":1,\"217\":1,\"218\":1}}],[\"startonload\",{\"1\":{\"77\":1}}],[\"start\",{\"1\":{\"71\":2,\"78\":1,\"81\":1,\"532\":2,\"617\":10,\"848\":1,\"866\":3}}],[\"stadium\",{\"0\":{\"47\":1}}],[\"shell\",{\"1\":{\"905\":1}}],[\"shell注入\",{\"1\":{\"861\":1}}],[\"sheep5\",{\"1\":{\"685\":2,\"687\":5}}],[\"sheep4\",{\"1\":{\"685\":2,\"687\":5}}],[\"sheep3\",{\"1\":{\"685\":2,\"687\":5}}],[\"sheep2\",{\"1\":{\"685\":2,\"687\":5}}],[\"sheep\",{\"1\":{\"685\":28,\"687\":27,\"689\":2}}],[\"shutdown\",{\"1\":{\"617\":10}}],[\"shiro\",{\"1\":{\"427\":1}}],[\"shiroutils\",{\"1\":{\"242\":2}}],[\"ship\",{\"1\":{\"104\":1}}],[\"sharing\",{\"1\":{\"310\":1}}],[\"sharedobjectstorage\",{\"1\":{\"772\":1}}],[\"shared\",{\"1\":{\"104\":1,\"312\":1}}],[\"shallowcloneexample\",{\"1\":{\"141\":7}}],[\"shape\",{\"0\":{\"48\":1,\"49\":1,\"51\":1},\"1\":{\"51\":1,\"308\":5,\"738\":18,\"739\":10}}],[\"shaped\",{\"0\":{\"47\":1}}],[\"shapes\",{\"0\":{\"45\":1}}],[\"show\",{\"1\":{\"296\":2}}],[\"shortblack\",{\"1\":{\"581\":1,\"584\":3}}],[\"shortvalue\",{\"1\":{\"312\":1}}],[\"short\",{\"1\":{\"119\":1,\"120\":1,\"129\":4,\"130\":2,\"165\":1,\"193\":1,\"302\":1,\"312\":5,\"955\":1,\"978\":2}}],[\"shorter\",{\"1\":{\"82\":1}}],[\"shouldn\",{\"1\":{\"478\":2}}],[\"shouldskip\",{\"1\":{\"311\":6}}],[\"should\",{\"1\":{\"80\":1,\"82\":1,\"86\":1,\"104\":1,\"145\":3,\"269\":1,\"716\":1,\"732\":1,\"736\":1,\"978\":6}}],[\"shopping\",{\"1\":{\"57\":2}}],[\"l3\",{\"1\":{\"773\":1}}],[\"l2\",{\"1\":{\"773\":1}}],[\"l1\",{\"1\":{\"773\":2}}],[\"l1==l2\",{\"1\":{\"773\":1}}],[\"lsp\",{\"0\":{\"730\":1}}],[\"lsa\",{\"1\":{\"294\":6}}],[\"ldorderpizzafactory\",{\"1\":{\"613\":6}}],[\"ldpepperpizza\",{\"1\":{\"613\":2}}],[\"ldpizzasimplefactory\",{\"1\":{\"613\":1}}],[\"ldcheesepizza\",{\"1\":{\"613\":2}}],[\"ldc\",{\"1\":{\"275\":11}}],[\"ljc\",{\"1\":{\"440\":1}}],[\"ljava\",{\"1\":{\"275\":18,\"291\":4,\"305\":1,\"312\":11}}],[\"lucky\",{\"1\":{\"847\":1}}],[\"lucene\",{\"1\":{\"426\":1}}],[\"lukas\",{\"1\":{\"440\":1}}],[\"lwjgl\",{\"1\":{\"404\":1}}],[\"l\",{\"1\":{\"133\":1,\"234\":2,\"276\":6,\"809\":1,\"846\":1,\"935\":1}}],[\"ln\",{\"1\":{\"114\":17}}],[\"lc\",{\"1\":{\"114\":8}}],[\"lots\",{\"0\":{\"452\":1},\"1\":{\"446\":1}}],[\"lombok\",{\"0\":{\"471\":1},\"1\":{\"398\":1,\"471\":2}}],[\"london\",{\"1\":{\"440\":1}}],[\"lonelyroamer\",{\"1\":{\"299\":1}}],[\"longexpressioninvolving\",{\"1\":{\"907\":1}}],[\"longer\",{\"1\":{\"71\":2}}],[\"long类型能表示的最大值是\",{\"1\":{\"854\":1}}],[\"long或long赋值时\",{\"1\":{\"846\":1}}],[\"longblack\",{\"1\":{\"581\":1,\"584\":6,\"585\":1}}],[\"longvalue\",{\"1\":{\"312\":1}}],[\"long\",{\"0\":{\"160\":1,\"166\":1},\"1\":{\"93\":4,\"119\":1,\"130\":4,\"137\":2,\"166\":2,\"242\":1,\"270\":5,\"276\":3,\"302\":1,\"308\":2,\"310\":2,\"312\":1,\"689\":1,\"764\":6,\"769\":4,\"771\":2,\"772\":2,\"773\":3,\"846\":1,\"847\":1,\"848\":1,\"852\":1,\"907\":2,\"935\":1,\"978\":2}}],[\"locking\",{\"1\":{\"851\":1}}],[\"lock对象的unlock方法在执行时\",{\"1\":{\"851\":1}}],[\"locksupport详解\",{\"0\":{\"509\":1}}],[\"lock\",{\"1\":{\"258\":2,\"310\":5,\"772\":4,\"851\":14,\"852\":1}}],[\"localvalue\",{\"1\":{\"845\":1}}],[\"locales\",{\"1\":{\"618\":1}}],[\"localeprovideradapter\",{\"1\":{\"618\":1}}],[\"locale\",{\"1\":{\"618\":6}}],[\"localdatetime代替calendar\",{\"1\":{\"851\":1}}],[\"localdatetime\",{\"0\":{\"351\":1}}],[\"localdate\",{\"0\":{\"351\":1},\"1\":{\"849\":2}}],[\"locals=1\",{\"1\":{\"228\":4}}],[\"locals\",{\"1\":{\"225\":1}}],[\"local\",{\"1\":{\"224\":1,\"225\":1,\"227\":1}}],[\"location\",{\"1\":{\"106\":3}}],[\"locating\",{\"1\":{\"104\":1}}],[\"low\",{\"1\":{\"120\":6}}],[\"logical\",{\"1\":{\"910\":1}}],[\"loginproxy\",{\"1\":{\"845\":1}}],[\"logtype\",{\"1\":{\"859\":2}}],[\"logname\",{\"1\":{\"859\":3}}],[\"logs\",{\"1\":{\"859\":2}}],[\"logstash\",{\"1\":{\"412\":1}}],[\"logback\",{\"1\":{\"412\":1,\"859\":1}}],[\"log4j\",{\"1\":{\"412\":1,\"473\":1,\"859\":1}}],[\"logansquare\",{\"1\":{\"409\":1}}],[\"logandthrowexception\",{\"1\":{\"270\":1}}],[\"loganexception\",{\"1\":{\"269\":1}}],[\"logaspect\",{\"1\":{\"242\":2}}],[\"log注解\",{\"1\":{\"242\":1}}],[\"logpointcut\",{\"1\":{\"242\":3}}],[\"loggername\",{\"1\":{\"773\":3}}],[\"logger>\",{\"1\":{\"773\":1}}],[\"loggerfactory\",{\"1\":{\"242\":1,\"859\":2}}],[\"logger\",{\"1\":{\"242\":1,\"305\":6,\"773\":13,\"859\":7,\"942\":3}}],[\"logging\",{\"0\":{\"104\":1},\"1\":{\"104\":21,\"473\":1,\"859\":4}}],[\"log的方法进行切点拦截\",{\"1\":{\"242\":1}}],[\"log接口\",{\"1\":{\"104\":1}}],[\"log\",{\"1\":{\"104\":1,\"242\":18,\"264\":6,\"267\":2,\"269\":1,\"270\":1,\"451\":1,\"625\":1,\"773\":1,\"859\":9,\"980\":3}}],[\"loghierarchy\",{\"1\":{\"104\":1}}],[\"logdiagnostic\",{\"1\":{\"104\":16}}],[\"logfactory的子类创建log\",{\"1\":{\"104\":1}}],[\"logfactory的getlog\",{\"1\":{\"104\":1}}],[\"logfactory的实现\",{\"1\":{\"104\":1}}],[\"logfactory属性是否指定factory实现\",{\"1\":{\"104\":1}}],[\"logfactory属性指定的factory\",{\"1\":{\"104\":1}}],[\"logfactoryimpl\",{\"1\":{\"104\":3}}],[\"logfactory实现\",{\"1\":{\"104\":1}}],[\"logfactory\",{\"1\":{\"104\":27,\"859\":2}}],[\"logfatory是一个抽象类\",{\"1\":{\"104\":1}}],[\"logconfigurationexception\",{\"1\":{\"104\":2}}],[\"loadbeandefinitions\",{\"1\":{\"625\":2}}],[\"loadclass\",{\"1\":{\"234\":1,\"310\":6}}],[\"loadproperties\",{\"1\":{\"106\":1}}],[\"loadfactorynames\",{\"1\":{\"106\":1}}],[\"loaded\",{\"1\":{\"104\":3,\"310\":1,\"398\":1}}],[\"loadeddrivers\",{\"1\":{\"103\":4,\"111\":2}}],[\"loader\",{\"1\":{\"104\":4,\"114\":12,\"302\":2,\"310\":2,\"312\":1,\"699\":1,\"700\":2,\"930\":1}}],[\"loadinstalled\",{\"1\":{\"114\":1}}],[\"loading\",{\"1\":{\"103\":1,\"104\":1,\"752\":2,\"754\":1}}],[\"loadinitialdrivers\",{\"1\":{\"103\":2}}],[\"load\",{\"1\":{\"96\":2,\"103\":3,\"104\":5,\"111\":1,\"114\":4,\"312\":1,\"772\":1}}],[\"looking\",{\"1\":{\"104\":5}}],[\"lookupiterator是懒加载迭代器\",{\"1\":{\"114\":1}}],[\"lookupiterator\",{\"1\":{\"114\":4}}],[\"lookup\",{\"1\":{\"104\":16,\"310\":1}}],[\"looks\",{\"1\":{\"82\":1}}],[\"look\",{\"1\":{\"82\":1,\"104\":1}}],[\"loose\",{\"1\":{\"77\":2}}],[\"latch\",{\"1\":{\"980\":2}}],[\"latencyutils\",{\"1\":{\"422\":1}}],[\"layegg\",{\"1\":{\"813\":7}}],[\"lastthing\",{\"1\":{\"901\":1}}],[\"last\",{\"1\":{\"474\":1}}],[\"lastindexof\",{\"1\":{\"310\":1}}],[\"lanterna\",{\"1\":{\"415\":1}}],[\"language\",{\"1\":{\"431\":1,\"618\":1,\"822\":1}}],[\"languages\",{\"1\":{\"150\":1}}],[\"langreflectaccess\",{\"1\":{\"310\":1}}],[\"lang包中\",{\"1\":{\"302\":1}}],[\"lang\",{\"1\":{\"120\":1,\"141\":2,\"145\":2,\"151\":1,\"163\":1,\"228\":1,\"229\":3,\"233\":1,\"234\":8,\"237\":1,\"242\":1,\"261\":8,\"270\":5,\"275\":25,\"279\":1,\"291\":4,\"295\":1,\"298\":3,\"304\":1,\"305\":3,\"306\":8,\"307\":4,\"308\":18,\"310\":8,\"311\":1,\"312\":25,\"465\":1,\"556\":1,\"699\":1,\"703\":1,\"760\":1,\"873\":2,\"978\":6,\"979\":5,\"980\":4}}],[\"lazyinitdemo\",{\"1\":{\"851\":1}}],[\"lazyinit\",{\"1\":{\"626\":1}}],[\"lazyiterator中的hasnext方法\",{\"1\":{\"114\":1}}],[\"lazyiterator\",{\"1\":{\"114\":4}}],[\"lazy\",{\"1\":{\"622\":2,\"624\":1,\"752\":2,\"754\":1}}],[\"lazily\",{\"1\":{\"310\":1}}],[\"launch4j\",{\"1\":{\"401\":1}}],[\"launcher\",{\"1\":{\"310\":1}}],[\"laura\",{\"1\":{\"299\":1}}],[\"lambda差距的扩展\",{\"1\":{\"403\":1}}],[\"lambda表达式\",{\"0\":{\"356\":1}}],[\"lambda\",{\"1\":{\"150\":1,\"187\":1,\"455\":1,\"790\":1,\"900\":1,\"907\":4,\"911\":1}}],[\"label\",{\"1\":{\"71\":1,\"907\":1}}],[\"lagom\",{\"1\":{\"68\":1}}],[\"letter\",{\"1\":{\"885\":1}}],[\"legacymergesort\",{\"1\":{\"790\":2}}],[\"les\",{\"1\":{\"488\":1}}],[\"leave\",{\"1\":{\"912\":1}}],[\"least\",{\"1\":{\"812\":1}}],[\"leaf3\",{\"1\":{\"571\":5}}],[\"leaf2\",{\"1\":{\"571\":5}}],[\"leaf1\",{\"1\":{\"571\":5}}],[\"leaf\",{\"1\":{\"568\":1,\"571\":10}}],[\"leak\",{\"1\":{\"173\":1}}],[\"learn\",{\"1\":{\"96\":3}}],[\"leader\",{\"1\":{\"440\":4}}],[\"lead\",{\"1\":{\"77\":1}}],[\"level3\",{\"1\":{\"863\":1}}],[\"level\",{\"1\":{\"71\":1,\"145\":1,\"859\":1,\"863\":1}}],[\"lengthofyear\",{\"1\":{\"849\":2}}],[\"length\",{\"0\":{\"71\":1},\"1\":{\"71\":1,\"103\":1,\"114\":1,\"120\":1,\"141\":7,\"281\":1,\"295\":1,\"306\":3,\"310\":5,\"311\":2,\"312\":3,\"644\":1,\"650\":1,\"790\":1,\"848\":1,\"865\":2,\"911\":1}}],[\"left\",{\"1\":{\"43\":1,\"44\":2,\"644\":17,\"864\":1}}],[\"license\",{\"0\":{\"887\":1},\"1\":{\"886\":1}}],[\"liskov\",{\"1\":{\"732\":2,\"734\":2}}],[\"listusers\",{\"1\":{\"848\":1}}],[\"listobjects\",{\"1\":{\"845\":1}}],[\"listname\",{\"1\":{\"845\":1}}],[\"listener\",{\"1\":{\"532\":2}}],[\"lists\",{\"1\":{\"466\":1}}],[\"list语法\",{\"1\":{\"403\":1}}],[\"list2\",{\"1\":{\"288\":3,\"290\":8,\"742\":2,\"743\":2}}],[\"list6\",{\"1\":{\"285\":1,\"294\":1}}],[\"list1\",{\"1\":{\"288\":3,\"290\":14,\"742\":2,\"743\":2}}],[\"list15\",{\"1\":{\"285\":1,\"294\":1}}],[\"list14\",{\"1\":{\"285\":1,\"294\":1}}],[\"list13\",{\"1\":{\"285\":1,\"294\":1}}],[\"list12\",{\"1\":{\"285\":1,\"294\":1}}],[\"list11\",{\"1\":{\"285\":1,\"294\":1}}],[\"listb\",{\"1\":{\"284\":4}}],[\"lista\",{\"1\":{\"284\":2}}],[\"list中的元素也会随之修改\",{\"1\":{\"850\":1}}],[\"list中的元素都是object类型\",{\"1\":{\"279\":1}}],[\"list中只能放string\",{\"1\":{\"279\":1}}],[\"list<pair<string\",{\"1\":{\"850\":2}}],[\"list<person>\",{\"1\":{\"839\":1}}],[\"list<user>\",{\"1\":{\"848\":1}}],[\"list<element>\",{\"1\":{\"838\":1}}],[\"list<employee>\",{\"1\":{\"742\":3,\"743\":3}}],[\"list<tercher>\",{\"1\":{\"830\":1}}],[\"list<student>\",{\"1\":{\"830\":1}}],[\"list<string>\",{\"1\":{\"96\":3,\"106\":2,\"114\":1,\"279\":1,\"285\":5,\"294\":7,\"455\":2,\"469\":1,\"478\":1,\"850\":3,\"911\":1}}],[\"list<collegeemployee>\",{\"1\":{\"742\":3,\"743\":3}}],[\"list<college>\",{\"1\":{\"650\":3}}],[\"list<colleague>\",{\"1\":{\"656\":1}}],[\"list<constructorarg>\",{\"1\":{\"626\":1}}],[\"list<department>\",{\"1\":{\"650\":3}}],[\"list<observer>\",{\"1\":{\"672\":1}}],[\"list<object>\",{\"1\":{\"649\":3}}],[\"list<organizationcomponent>\",{\"1\":{\"574\":2}}],[\"list<beandefinition\",{\"1\":{\"627\":1}}],[\"list<beandefinition>\",{\"1\":{\"625\":1,\"626\":5,\"627\":1}}],[\"list<b>\",{\"1\":{\"284\":3}}],[\"list<integer>\",{\"1\":{\"294\":2}}],[\"list<instrument>\",{\"1\":{\"211\":1}}],[\"list<\",{\"1\":{\"284\":3,\"285\":2,\"294\":4}}],[\"list<a>\",{\"1\":{\"284\":2}}],[\"list集合就是一个累赘\",{\"1\":{\"181\":1}}],[\"list和set\",{\"1\":{\"181\":1}}],[\"list\",{\"1\":{\"82\":1,\"188\":1,\"222\":4,\"234\":2,\"279\":6,\"288\":6,\"289\":4,\"290\":5,\"445\":1,\"455\":2,\"469\":1,\"574\":1,\"649\":11,\"650\":3,\"651\":2,\"656\":1,\"742\":8,\"743\":8,\"838\":5,\"839\":1,\"850\":15,\"865\":1,\"911\":1,\"940\":1}}],[\"lightoffcommand\",{\"1\":{\"562\":6}}],[\"lightoncommand\",{\"1\":{\"562\":6}}],[\"lightreceiver\",{\"1\":{\"562\":13}}],[\"lightadmin\",{\"1\":{\"415\":1}}],[\"live\",{\"1\":{\"485\":1}}],[\"libraries\",{\"0\":{\"463\":1}}],[\"library\",{\"1\":{\"104\":1,\"459\":4}}],[\"liberty\",{\"1\":{\"429\":1}}],[\"lib\",{\"1\":{\"406\":1,\"818\":1}}],[\"libgdx\",{\"1\":{\"404\":1}}],[\"liquibase\",{\"1\":{\"384\":1}}],[\"lily\",{\"1\":{\"307\":2}}],[\"li\",{\"1\":{\"294\":6}}],[\"literals\",{\"1\":{\"150\":2,\"225\":1}}],[\"little\",{\"1\":{\"68\":1}}],[\"limitations\",{\"1\":{\"77\":1}}],[\"like\",{\"1\":{\"68\":1,\"76\":1,\"82\":1,\"133\":1,\"898\":1}}],[\"lingpipe\",{\"1\":{\"418\":1}}],[\"linux和mac\",{\"1\":{\"401\":1}}],[\"linenumbertable\",{\"1\":{\"228\":4}}],[\"lines\",{\"1\":{\"68\":1,\"955\":1}}],[\"liner\",{\"1\":{\"68\":1}}],[\"line\",{\"1\":{\"68\":2,\"78\":1,\"104\":1,\"114\":2,\"228\":4,\"269\":1,\"906\":1}}],[\"linkedhashset\",{\"0\":{\"321\":1}}],[\"linkedhashmap等等\",{\"1\":{\"181\":1}}],[\"linkedhashmap<>\",{\"1\":{\"114\":1}}],[\"linkedhashmap<string\",{\"1\":{\"114\":2}}],[\"linkedlist<>\",{\"1\":{\"839\":1}}],[\"linkedlist源码解析\",{\"0\":{\"316\":1}}],[\"linkedlist\",{\"1\":{\"188\":1,\"651\":1}}],[\"linked\",{\"1\":{\"71\":1}}],[\"link\",{\"0\":{\"60\":1,\"61\":1,\"63\":1,\"64\":1,\"65\":1,\"66\":1,\"67\":1,\"71\":1,\"86\":1},\"1\":{\"59\":1,\"71\":6,\"77\":7,\"80\":3,\"86\":3,\"617\":5}}],[\"linkstyle\",{\"1\":{\"80\":2}}],[\"links\",{\"0\":{\"59\":1,\"62\":1,\"68\":1,\"80\":1},\"1\":{\"59\":2,\"68\":2,\"71\":4,\"77\":2,\"80\":4}}],[\"lr\",{\"1\":{\"43\":1,\"44\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":1,\"52\":1,\"53\":1,\"60\":1,\"61\":1,\"62\":2,\"63\":2,\"64\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":2,\"69\":1,\"70\":1,\"72\":1,\"73\":1,\"76\":1,\"77\":3,\"78\":1,\"81\":1,\"82\":1,\"83\":1,\"86\":1}}],[\"b无法排序\",{\"1\":{\"864\":1}}],[\"b0321\",{\"1\":{\"874\":1}}],[\"b0320\",{\"1\":{\"874\":1}}],[\"b0315\",{\"1\":{\"874\":1}}],[\"b0314\",{\"1\":{\"874\":1}}],[\"b0313\",{\"1\":{\"874\":1}}],[\"b0312\",{\"1\":{\"874\":1}}],[\"b0311\",{\"1\":{\"874\":1}}],[\"b0310\",{\"1\":{\"874\":1}}],[\"b0300\",{\"1\":{\"874\":1}}],[\"b0220\",{\"1\":{\"874\":1}}],[\"b0210\",{\"1\":{\"874\":1}}],[\"b0200\",{\"1\":{\"874\":1}}],[\"b0001\",{\"1\":{\"857\":1,\"874\":1}}],[\"b0101\",{\"1\":{\"874\":1}}],[\"b0100\",{\"1\":{\"874\":1}}],[\"b01\",{\"1\":{\"485\":1}}],[\"b表示错误来源于当前系统\",{\"1\":{\"857\":1}}],[\"b的结果是int类型\",{\"1\":{\"852\":1}}],[\"b的结果为false\",{\"1\":{\"848\":1}}],[\"b空格\",{\"1\":{\"847\":1}}],[\"b类\",{\"1\":{\"723\":1}}],[\"b=20\",{\"1\":{\"644\":5}}],[\"bjorderpizzafactory\",{\"1\":{\"613\":6}}],[\"bjpepperpizza\",{\"1\":{\"613\":2}}],[\"bjpizzasimplefactory\",{\"1\":{\"613\":1}}],[\"bjcheesepizza\",{\"1\":{\"613\":2}}],[\"bdd测试框架\",{\"1\":{\"431\":1}}],[\"bigint\",{\"1\":{\"863\":1}}],[\"bigdecimal的等值比较应使用compareto\",{\"1\":{\"848\":1}}],[\"bigdecimal\",{\"1\":{\"848\":15,\"872\":1}}],[\"bis\",{\"1\":{\"689\":4}}],[\"biancheng\",{\"1\":{\"591\":1}}],[\"bien\",{\"1\":{\"440\":1}}],[\"bio\",{\"0\":{\"330\":1}}],[\"bit\",{\"1\":{\"310\":1,\"955\":1}}],[\"bingtang\",{\"1\":{\"728\":5}}],[\"bintray\",{\"1\":{\"401\":1}}],[\"binary\",{\"1\":{\"150\":1}}],[\"binder\",{\"1\":{\"424\":1}}],[\"bind\",{\"1\":{\"77\":1}}],[\"bbb\",{\"1\":{\"125\":3,\"130\":1}}],[\"bbf\",{\"1\":{\"81\":1}}],[\"blacklist\",{\"1\":{\"845\":1}}],[\"blade\",{\"1\":{\"424\":1,\"434\":1}}],[\"blank\",{\"1\":{\"77\":5}}],[\"blockjunit4classrunner\",{\"1\":{\"979\":4}}],[\"blocks\",{\"1\":{\"902\":1}}],[\"blocklist\",{\"1\":{\"845\":1}}],[\"blockingqueue详解\",{\"0\":{\"491\":1}}],[\"block\",{\"1\":{\"225\":1,\"257\":2,\"898\":1,\"902\":2,\"980\":1}}],[\"bloch\",{\"1\":{\"153\":1,\"759\":1}}],[\"blog\",{\"1\":{\"116\":2,\"219\":1,\"238\":1,\"243\":2,\"276\":1,\"277\":3,\"287\":1,\"299\":4,\"305\":1,\"314\":3,\"442\":1,\"984\":2,\"1000\":1}}],[\"bu\",{\"1\":{\"869\":2}}],[\"buddhistcalendar\",{\"1\":{\"618\":3}}],[\"buddhist\",{\"1\":{\"618\":1}}],[\"buddy\",{\"1\":{\"386\":1}}],[\"bufferedwriter\",{\"1\":{\"586\":1}}],[\"bufferedreader\",{\"1\":{\"104\":3,\"114\":3,\"252\":2,\"257\":2,\"586\":1,\"644\":2}}],[\"burns\",{\"1\":{\"440\":1}}],[\"bucket\",{\"1\":{\"809\":10}}],[\"bucketname\",{\"1\":{\"809\":9}}],[\"buck\",{\"1\":{\"385\":1}}],[\"businuess\",{\"1\":{\"266\":1}}],[\"business\",{\"1\":{\"855\":4,\"868\":1,\"873\":1}}],[\"businessstatus\",{\"1\":{\"242\":2}}],[\"businesstype\",{\"1\":{\"242\":10}}],[\"build>\",{\"1\":{\"974\":1}}],[\"buildhouse\",{\"1\":{\"555\":2}}],[\"buildwalls\",{\"1\":{\"553\":3,\"555\":4}}],[\"buildbasic\",{\"1\":{\"553\":3,\"555\":4}}],[\"builder\",{\"0\":{\"446\":1},\"1\":{\"405\":1,\"446\":4,\"549\":2,\"550\":2,\"551\":4,\"555\":1,\"589\":1,\"798\":1,\"847\":4}}],[\"buildkite\",{\"1\":{\"392\":1}}],[\"buildinternalsignature\",{\"1\":{\"312\":1}}],[\"build\",{\"1\":{\"105\":1,\"446\":3,\"451\":1,\"553\":2}}],[\"bugs\",{\"1\":{\"104\":1}}],[\"bug\",{\"1\":{\"88\":1,\"447\":1,\"481\":2,\"484\":2,\"779\":1,\"816\":1,\"849\":1}}],[\"but\",{\"1\":{\"71\":1,\"104\":2,\"145\":1,\"294\":1,\"310\":1,\"311\":1,\"736\":1,\"912\":1,\"979\":1}}],[\"bao\",{\"1\":{\"850\":2}}],[\"baidusite\",{\"1\":{\"678\":5}}],[\"baise\",{\"1\":{\"555\":5}}],[\"bake\",{\"1\":{\"609\":1}}],[\"baz\",{\"1\":{\"450\":2}}],[\"bazel\",{\"1\":{\"385\":1}}],[\"barexception\",{\"1\":{\"907\":1,\"911\":1}}],[\"bar>\",{\"1\":{\"907\":1,\"911\":1}}],[\"barwidget\",{\"1\":{\"450\":1}}],[\"bar\",{\"1\":{\"450\":6,\"459\":4}}],[\"batik\",{\"1\":{\"408\":1}}],[\"bamboo\",{\"1\":{\"392\":1}}],[\"badflybehavior\",{\"1\":{\"789\":2}}],[\"bad\",{\"1\":{\"104\":1,\"951\":2,\"978\":2}}],[\"ban\",{\"1\":{\"85\":1,\"978\":1}}],[\"backed\",{\"1\":{\"779\":3}}],[\"backendserver>\",{\"1\":{\"773\":1}}],[\"backendserver\",{\"1\":{\"773\":7}}],[\"back\",{\"1\":{\"618\":1}}],[\"backpressure\",{\"1\":{\"423\":1}}],[\"background\",{\"1\":{\"81\":1}}],[\"backwards\",{\"1\":{\"80\":1}}],[\"base64\",{\"0\":{\"353\":1},\"1\":{\"465\":1}}],[\"basecontroller\",{\"1\":{\"242\":1}}],[\"baseclassloader\",{\"1\":{\"104\":5}}],[\"base\",{\"1\":{\"73\":1,\"312\":1,\"452\":1,\"734\":4}}],[\"based\",{\"1\":{\"71\":1,\"849\":1}}],[\"basictest\",{\"1\":{\"477\":1}}],[\"basic\",{\"0\":{\"85\":1,\"1003\":1},\"1\":{\"68\":1,\"243\":2,\"277\":2,\"299\":2,\"314\":2}}],[\"brackets\",{\"1\":{\"901\":1}}],[\"brand\",{\"1\":{\"542\":18}}],[\"bright\",{\"1\":{\"601\":3}}],[\"bridgetest\",{\"1\":{\"538\":1}}],[\"bridge\",{\"1\":{\"537\":1,\"538\":1,\"547\":2,\"590\":1,\"798\":1}}],[\"bruno\",{\"1\":{\"440\":1}}],[\"brpc\",{\"1\":{\"419\":1}}],[\"broker生成\",{\"1\":{\"870\":1}}],[\"broker\",{\"1\":{\"414\":2}}],[\"browsers\",{\"1\":{\"145\":1}}],[\"browser\",{\"1\":{\"77\":2,\"145\":1}}],[\"breaks\",{\"1\":{\"145\":1,\"225\":1}}],[\"break\",{\"0\":{\"72\":1},\"1\":{\"130\":4,\"311\":2,\"618\":3,\"644\":3,\"852\":3,\"924\":2}}],[\"b2\",{\"1\":{\"76\":2}}],[\"b1\",{\"1\":{\"74\":1,\"75\":1,\"76\":2}}],[\"by最后的字段是组合索引的一部分\",{\"1\":{\"864\":1}}],[\"by的场景\",{\"1\":{\"864\":1}}],[\"by导致数据库慢查询\",{\"1\":{\"861\":1}}],[\"bye\",{\"1\":{\"469\":2}}],[\"bytearrayinputstream\",{\"1\":{\"689\":2}}],[\"bytearrayoutputstream\",{\"1\":{\"689\":2}}],[\"byteman\",{\"1\":{\"386\":1}}],[\"bytevalue\",{\"1\":{\"312\":1}}],[\"bytevectorfactory\",{\"1\":{\"312\":1}}],[\"bytevector\",{\"1\":{\"312\":1}}],[\"bytecode\",{\"1\":{\"310\":1,\"312\":2}}],[\"bytes\",{\"0\":{\"160\":1},\"1\":{\"312\":3}}],[\"byte\",{\"0\":{\"159\":1,\"161\":2},\"1\":{\"93\":1,\"119\":1,\"120\":1,\"130\":2,\"159\":1,\"161\":2,\"165\":5,\"193\":1,\"302\":1,\"312\":2,\"386\":1,\"885\":1,\"978\":5}}],[\"by\",{\"0\":{\"451\":1},\"1\":{\"71\":3,\"77\":3,\"78\":1,\"87\":2,\"104\":7,\"120\":1,\"127\":2,\"145\":1,\"310\":1,\"312\":3,\"864\":2,\"979\":2}}],[\"beautiful\",{\"1\":{\"851\":1}}],[\"beat\",{\"1\":{\"803\":2}}],[\"beancreationfailureexception\",{\"1\":{\"627\":1}}],[\"beanclass\",{\"1\":{\"627\":3}}],[\"beanconfigparser\",{\"1\":{\"625\":6,\"626\":3}}],[\"bean\",{\"1\":{\"627\":8,\"688\":1}}],[\"beandefinitionlist\",{\"1\":{\"627\":3}}],[\"beandefinition>\",{\"1\":{\"627\":1}}],[\"beandefinition\",{\"1\":{\"625\":2,\"626\":2,\"627\":26}}],[\"beandefinitions\",{\"1\":{\"625\":2,\"626\":2,\"627\":4}}],[\"beanid\",{\"1\":{\"625\":3,\"627\":3}}],[\"bean>\",{\"1\":{\"622\":2,\"624\":2}}],[\"beansfactory\",{\"1\":{\"622\":4,\"625\":8,\"626\":1,\"627\":5}}],[\"beans>\",{\"1\":{\"622\":1,\"624\":1}}],[\"beans\",{\"1\":{\"622\":1,\"624\":2,\"869\":1}}],[\"bertrand\",{\"1\":{\"736\":1}}],[\"beetl\",{\"1\":{\"430\":1}}],[\"been\",{\"1\":{\"133\":1,\"310\":1,\"312\":1,\"768\":1}}],[\"being\",{\"1\":{\"302\":1}}],[\"benn\",{\"1\":{\"275\":1}}],[\"benefit\",{\"1\":{\"145\":1}}],[\"before修饰的方法执行前\",{\"1\":{\"976\":1}}],[\"before修饰的方法会在子类\",{\"1\":{\"976\":1}}],[\"before注解修饰的方法会在每个测试方法执行前执行一次\",{\"1\":{\"976\":1}}],[\"before对应\",{\"1\":{\"972\":1}}],[\"before来插入一条用户a信息\",{\"1\":{\"972\":1}}],[\"before不止运行一次\",{\"1\":{\"972\":1}}],[\"beforeclass注解方法执行前执行\",{\"1\":{\"976\":1}}],[\"beforeclass注解方法会在子类的\",{\"1\":{\"976\":1}}],[\"beforeclass注解修饰的方法\",{\"1\":{\"976\":1}}],[\"beforeclass创建数据库连接\",{\"1\":{\"972\":1}}],[\"beforeclass的区别在于\",{\"1\":{\"972\":1}}],[\"beforeclass对应\",{\"1\":{\"972\":1}}],[\"beforeclass\",{\"1\":{\"972\":2,\"976\":2,\"997\":1}}],[\"before\",{\"1\":{\"241\":2,\"972\":1,\"976\":4,\"981\":2,\"997\":3}}],[\"behavior\",{\"1\":{\"145\":1}}],[\"behaviour\",{\"1\":{\"104\":1}}],[\"because\",{\"1\":{\"104\":1,\"145\":1,\"310\":2,\"312\":2,\"942\":1}}],[\"belonging\",{\"1\":{\"310\":1,\"312\":2}}],[\"belong\",{\"1\":{\"80\":1}}],[\"below\",{\"1\":{\"68\":3,\"69\":1,\"72\":1,\"74\":1,\"75\":1,\"77\":1,\"80\":1,\"82\":3,\"83\":1,\"86\":2}}],[\"beginners\",{\"1\":{\"77\":1}}],[\"be\",{\"1\":{\"59\":1,\"71\":3,\"73\":1,\"77\":3,\"78\":5,\"80\":1,\"83\":1,\"84\":1,\"86\":1,\"87\":1,\"104\":6,\"114\":1,\"120\":3,\"130\":1,\"133\":2,\"144\":4,\"145\":8,\"310\":6,\"311\":2,\"312\":5,\"451\":1,\"478\":2,\"716\":1,\"736\":1,\"850\":1,\"978\":6}}],[\"better\",{\"0\":{\"443\":1}}],[\"between\",{\"0\":{\"59\":1,\"86\":1},\"1\":{\"86\":2,\"113\":1,\"116\":1,\"120\":2,\"150\":1,\"151\":1}}],[\"beta\",{\"1\":{\"0\":1}}],[\"b\",{\"0\":{\"162\":4,\"165\":2,\"180\":1,\"181\":1},\"1\":{\"57\":1,\"61\":1,\"62\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":5,\"69\":2,\"70\":2,\"71\":9,\"76\":1,\"77\":7,\"78\":2,\"82\":1,\"83\":1,\"85\":4,\"86\":2,\"91\":2,\"127\":4,\"130\":1,\"141\":3,\"144\":2,\"153\":1,\"165\":5,\"180\":3,\"218\":5,\"222\":1,\"279\":16,\"284\":4,\"289\":1,\"312\":2,\"632\":5,\"643\":2,\"644\":5,\"721\":2,\"723\":18,\"732\":3,\"734\":30,\"741\":10,\"745\":3,\"768\":2,\"771\":2,\"776\":2,\"784\":1,\"814\":1,\"818\":1,\"834\":1,\"838\":2,\"845\":1,\"846\":1,\"848\":10,\"851\":2,\"852\":2,\"854\":2,\"857\":1,\"860\":1,\"864\":4,\"884\":1,\"911\":1,\"917\":1,\"978\":1,\"979\":2}}],[\"both\",{\"1\":{\"978\":1}}],[\"bottom\",{\"1\":{\"43\":1,\"44\":3}}],[\"body里带参数时必须设置content\",{\"1\":{\"854\":1}}],[\"body>\",{\"1\":{\"77\":1}}],[\"bo\",{\"1\":{\"845\":2,\"868\":1,\"873\":2}}],[\"bos\",{\"1\":{\"689\":5}}],[\"boss\",{\"1\":{\"665\":2}}],[\"boudreau\",{\"1\":{\"440\":1}}],[\"bouncy\",{\"1\":{\"427\":1}}],[\"borges\",{\"1\":{\"440\":1}}],[\"border\",{\"1\":{\"81\":1,\"860\":1}}],[\"boot\",{\"1\":{\"434\":1,\"457\":1}}],[\"boot与angularjs应用程序的yeoman源代码生成器\",{\"1\":{\"398\":1}}],[\"bootstrapping\",{\"1\":{\"311\":1}}],[\"books\",{\"0\":{\"487\":1}}],[\"book\",{\"1\":{\"155\":1,\"474\":4}}],[\"boolean命名不需要加is前缀\",{\"1\":{\"855\":1}}],[\"booleanvalue\",{\"1\":{\"104\":2,\"312\":1}}],[\"boolean\",{\"1\":{\"91\":6,\"104\":2,\"114\":4,\"119\":1,\"120\":1,\"137\":1,\"138\":1,\"233\":1,\"242\":1,\"307\":2,\"308\":2,\"310\":4,\"311\":3,\"312\":4,\"452\":1,\"583\":1,\"626\":3,\"649\":2,\"650\":2,\"778\":5,\"803\":2,\"851\":1,\"852\":3,\"871\":1,\"978\":2,\"981\":3}}],[\"boxing\",{\"1\":{\"225\":2,\"312\":3}}],[\"box<t>\",{\"1\":{\"147\":1}}],[\"box\",{\"1\":{\"47\":2,\"48\":2,\"51\":2,\"52\":2,\"53\":2,\"54\":2,\"55\":2,\"72\":2,\"609\":1}}],[\"btest\",{\"1\":{\"972\":1,\"981\":1}}],[\"bt\",{\"1\":{\"44\":1,\"76\":1}}],[\"omg\",{\"1\":{\"822\":1}}],[\"o2\",{\"1\":{\"732\":2,\"790\":3,\"850\":2}}],[\"o1\",{\"1\":{\"732\":2,\"790\":3,\"850\":2}}],[\"ois\",{\"1\":{\"689\":4}}],[\"oom\",{\"1\":{\"873\":1}}],[\"oom的发生是有概率的\",{\"1\":{\"870\":1}}],[\"ooa\",{\"1\":{\"797\":1}}],[\"oos\",{\"1\":{\"689\":4}}],[\"oo\",{\"0\":{\"731\":1},\"1\":{\"581\":1,\"796\":1}}],[\"oop规约\",{\"0\":{\"848\":1}}],[\"oopsla\",{\"1\":{\"732\":1}}],[\"oop\",{\"0\":{\"764\":1},\"1\":{\"187\":1,\"207\":1,\"764\":2,\"769\":1,\"873\":1}}],[\"oceanbase等进行数据交互\",{\"1\":{\"868\":1}}],[\"ocp\",{\"0\":{\"735\":1},\"1\":{\"533\":1,\"579\":1,\"610\":4,\"613\":1,\"677\":1,\"678\":1,\"690\":1,\"736\":1,\"738\":3,\"739\":1}}],[\"occurs\",{\"1\":{\"275\":1}}],[\"occur\",{\"1\":{\"104\":1}}],[\"occurred\",{\"1\":{\"104\":3}}],[\"o等\",{\"1\":{\"432\":1}}],[\"obs2\",{\"1\":{\"672\":2}}],[\"obs1\",{\"1\":{\"672\":2}}],[\"obs\",{\"1\":{\"672\":2}}],[\"observerpattern\",{\"1\":{\"672\":1}}],[\"observers\",{\"1\":{\"672\":4,\"678\":7}}],[\"observer\",{\"1\":{\"591\":1,\"671\":1,\"672\":14,\"678\":8,\"679\":4,\"798\":1}}],[\"observable\",{\"1\":{\"423\":1,\"679\":5}}],[\"ob\",{\"1\":{\"649\":4,\"656\":3}}],[\"obj5\",{\"1\":{\"978\":2}}],[\"obj4\",{\"1\":{\"978\":3}}],[\"obj3\",{\"1\":{\"596\":2,\"978\":2}}],[\"obj2\",{\"1\":{\"201\":1,\"596\":2,\"978\":3}}],[\"obj1\",{\"1\":{\"201\":1,\"596\":2,\"978\":3}}],[\"obj\",{\"1\":{\"137\":1,\"263\":2,\"293\":2,\"307\":4,\"308\":3,\"312\":11,\"571\":4,\"584\":13,\"649\":11,\"852\":1,\"858\":2,\"907\":1}}],[\"objectthreadlocal\",{\"1\":{\"851\":2}}],[\"object的equals方法容易抛空指针异常\",{\"1\":{\"848\":1}}],[\"object$\",{\"1\":{\"845\":1}}],[\"objectoutputstream\",{\"1\":{\"689\":2}}],[\"object>\",{\"1\":{\"627\":1,\"850\":1,\"866\":1,\"907\":1}}],[\"objectinputstream\",{\"1\":{\"689\":2}}],[\"objective\",{\"1\":{\"419\":1}}],[\"objectid\",{\"1\":{\"104\":1}}],[\"object泛型\",{\"1\":{\"289\":1}}],[\"object有哪些公用方法\",{\"0\":{\"190\":1}}],[\"objectstructure\",{\"1\":{\"838\":3,\"839\":10}}],[\"objects\",{\"1\":{\"114\":1,\"145\":1,\"302\":1,\"310\":6,\"311\":1,\"703\":1,\"732\":2,\"848\":1}}],[\"object\",{\"0\":{\"136\":1,\"163\":1,\"173\":1,\"447\":1},\"1\":{\"87\":1,\"137\":2,\"138\":2,\"141\":4,\"151\":1,\"163\":1,\"228\":1,\"242\":2,\"276\":1,\"284\":1,\"288\":1,\"289\":4,\"290\":4,\"291\":9,\"293\":2,\"294\":6,\"305\":1,\"306\":1,\"307\":7,\"308\":17,\"309\":1,\"310\":13,\"312\":22,\"420\":1,\"458\":1,\"571\":2,\"625\":2,\"626\":1,\"627\":5,\"649\":12,\"650\":2,\"672\":1,\"686\":2,\"687\":1,\"689\":4,\"699\":1,\"700\":9,\"703\":11,\"736\":1,\"833\":2,\"838\":1,\"848\":2,\"850\":1,\"868\":4,\"873\":8,\"907\":1,\"911\":2,\"952\":1,\"978\":16,\"981\":1,\"996\":17}}],[\"oss\",{\"1\":{\"874\":1}}],[\"ostrich\",{\"1\":{\"812\":1,\"813\":2}}],[\"os\",{\"1\":{\"401\":1,\"820\":1,\"838\":5}}],[\"oauth2\",{\"1\":{\"427\":1}}],[\"oa\",{\"0\":{\"709\":1},\"1\":{\"294\":5}}],[\"oveerride只不过是假象\",{\"1\":{\"291\":1}}],[\"overops\",{\"1\":{\"416\":1}}],[\"overhead\",{\"1\":{\"145\":1}}],[\"overload\",{\"1\":{\"135\":1}}],[\"override可以准确判断是否覆盖成功\",{\"1\":{\"848\":1}}],[\"override注解\",{\"1\":{\"848\":1}}],[\"override标签中也可以看到\",{\"1\":{\"291\":1}}],[\"override\",{\"0\":{\"223\":1,\"949\":1},\"1\":{\"96\":2,\"133\":2,\"134\":1,\"135\":2,\"138\":1,\"139\":1,\"141\":4,\"221\":1,\"222\":3,\"223\":1,\"234\":3,\"241\":2,\"291\":4,\"305\":1,\"306\":1,\"310\":1,\"312\":1,\"524\":1,\"528\":1,\"532\":13,\"542\":6,\"553\":3,\"555\":6,\"562\":10,\"574\":13,\"584\":3,\"609\":2,\"613\":6,\"617\":20,\"625\":1,\"626\":2,\"636\":1,\"644\":2,\"650\":10,\"659\":7,\"678\":3,\"685\":1,\"687\":2,\"689\":2,\"695\":2,\"700\":3,\"703\":2,\"710\":4,\"728\":3,\"739\":4,\"778\":12,\"779\":31,\"787\":3,\"788\":1,\"789\":6,\"803\":4,\"812\":1,\"813\":8,\"814\":1,\"839\":8,\"850\":1,\"851\":2,\"901\":1,\"915\":1,\"928\":1,\"929\":2,\"949\":2}}],[\"overboard\",{\"1\":{\"68\":1}}],[\"odd\",{\"1\":{\"104\":1}}],[\"out来进行人肉验证\",{\"1\":{\"860\":1}}],[\"out或system\",{\"1\":{\"859\":1}}],[\"outstate\",{\"1\":{\"632\":2}}],[\"outside\",{\"1\":{\"310\":1,\"311\":1}}],[\"outofmemoryerror\",{\"1\":{\"247\":1,\"268\":1,\"873\":1}}],[\"outerclass\",{\"1\":{\"144\":6}}],[\"outputimpl\",{\"1\":{\"650\":6}}],[\"output220v\",{\"1\":{\"524\":2,\"528\":2}}],[\"output5v\",{\"1\":{\"524\":4,\"528\":4}}],[\"outputstream\",{\"0\":{\"327\":1},\"1\":{\"586\":1}}],[\"output\",{\"1\":{\"104\":1,\"306\":1,\"312\":1}}],[\"out\",{\"1\":{\"89\":3,\"91\":2,\"92\":4,\"93\":4,\"96\":2,\"120\":4,\"125\":3,\"127\":7,\"130\":4,\"133\":5,\"134\":2,\"138\":2,\"139\":2,\"140\":1,\"141\":3,\"144\":4,\"209\":2,\"211\":3,\"230\":1,\"234\":3,\"241\":3,\"252\":1,\"257\":3,\"275\":11,\"276\":3,\"279\":4,\"281\":3,\"282\":1,\"284\":2,\"285\":2,\"288\":2,\"298\":1,\"305\":18,\"306\":21,\"307\":7,\"308\":9,\"309\":1,\"524\":4,\"528\":6,\"532\":1,\"538\":2,\"542\":15,\"553\":3,\"555\":8,\"561\":3,\"562\":11,\"571\":2,\"574\":3,\"580\":4,\"584\":13,\"596\":3,\"601\":19,\"609\":4,\"610\":3,\"613\":8,\"617\":18,\"618\":6,\"622\":1,\"632\":4,\"636\":2,\"637\":6,\"644\":3,\"649\":3,\"650\":2,\"656\":5,\"659\":6,\"664\":3,\"667\":5,\"672\":4,\"676\":4,\"678\":10,\"685\":5,\"687\":6,\"689\":5,\"695\":3,\"700\":5,\"703\":6,\"708\":4,\"710\":4,\"718\":7,\"723\":16,\"727\":2,\"728\":3,\"734\":13,\"738\":5,\"739\":4,\"742\":4,\"743\":5,\"752\":3,\"753\":3,\"754\":4,\"755\":4,\"756\":4,\"757\":4,\"758\":4,\"759\":4,\"776\":2,\"778\":15,\"779\":4,\"784\":3,\"787\":6,\"788\":4,\"789\":11,\"790\":2,\"801\":3,\"803\":8,\"838\":5,\"839\":8,\"847\":3,\"848\":3,\"850\":1,\"851\":1,\"852\":7,\"855\":1,\"873\":1,\"976\":6,\"977\":1,\"979\":2,\"980\":2,\"981\":1,\"982\":2,\"983\":3}}],[\"oldreflectiondata\",{\"1\":{\"310\":5}}],[\"oldmethod\",{\"1\":{\"222\":1,\"234\":4}}],[\"old\",{\"1\":{\"86\":3,\"104\":1,\"234\":5}}],[\"optaplanner\",{\"1\":{\"391\":1}}],[\"option\",{\"1\":{\"469\":1}}],[\"options\",{\"1\":{\"419\":1}}],[\"optionalcall\",{\"1\":{\"477\":1}}],[\"optional<foowidget>\",{\"1\":{\"450\":1}}],[\"optional<bar>\",{\"1\":{\"450\":3}}],[\"optionally\",{\"1\":{\"411\":1}}],[\"optional类深度解析\",{\"0\":{\"352\":1}}],[\"optional\",{\"1\":{\"86\":2,\"312\":1,\"450\":6}}],[\"optimizations\",{\"1\":{\"145\":1,\"302\":1}}],[\"operlog\",{\"1\":{\"242\":26}}],[\"operationb\",{\"1\":{\"838\":3}}],[\"operationa\",{\"1\":{\"838\":3}}],[\"operation5\",{\"1\":{\"723\":10}}],[\"operation4\",{\"1\":{\"723\":10}}],[\"operation3\",{\"1\":{\"723\":10}}],[\"operation2\",{\"1\":{\"723\":10}}],[\"operation1\",{\"1\":{\"723\":14}}],[\"operationimpl\",{\"1\":{\"538\":3}}],[\"operations\",{\"1\":{\"145\":2,\"150\":1,\"225\":3}}],[\"operation\",{\"1\":{\"145\":1,\"538\":3,\"571\":10,\"580\":9,\"632\":8,\"642\":1}}],[\"operatortype\",{\"1\":{\"242\":4}}],[\"operators\",{\"1\":{\"129\":1}}],[\"operator\",{\"1\":{\"82\":1}}],[\"openandclose\",{\"1\":{\"728\":3}}],[\"openandclose3\",{\"1\":{\"728\":3}}],[\"openandclose2\",{\"1\":{\"728\":6}}],[\"openandclose1\",{\"1\":{\"728\":5}}],[\"openjpa\",{\"1\":{\"420\":1}}],[\"openjdk官方账号\",{\"1\":{\"440\":1}}],[\"openjdk\",{\"1\":{\"410\":1,\"440\":1}}],[\"opennlp\",{\"1\":{\"418\":1}}],[\"openrefine\",{\"1\":{\"415\":1}}],[\"openfire安装和使用都非常简单\",{\"1\":{\"414\":1}}],[\"openfire\",{\"1\":{\"414\":1}}],[\"openstream\",{\"1\":{\"114\":1}}],[\"opened\",{\"1\":{\"77\":2}}],[\"open\",{\"0\":{\"61\":1},\"1\":{\"77\":2,\"542\":13,\"728\":9,\"736\":3,\"852\":1,\"870\":1}}],[\"owner\",{\"1\":{\"390\":1}}],[\"own\",{\"1\":{\"78\":1,\"104\":1}}],[\"othercondition\",{\"1\":{\"901\":1}}],[\"othergraphic\",{\"1\":{\"739\":3}}],[\"otherwise\",{\"1\":{\"312\":1}}],[\"other\",{\"1\":{\"71\":1,\"80\":1,\"104\":2,\"242\":1,\"478\":2,\"618\":1,\"851\":1}}],[\"others\",{\"0\":{\"1009\":1},\"1\":{\"71\":1}}],[\"okay\",{\"1\":{\"933\":1}}],[\"ok~\",{\"1\":{\"759\":1}}],[\"okhttp\",{\"1\":{\"419\":1}}],[\"okrethinkend\",{\"1\":{\"71\":2}}],[\"ok\",{\"1\":{\"71\":2,\"165\":1,\"275\":2,\"284\":1,\"285\":3,\"294\":5,\"659\":1,\"704\":1,\"727\":1,\"847\":1,\"854\":1,\"874\":1,\"950\":1}}],[\"o\",{\"1\":{\"69\":1,\"70\":2,\"138\":5,\"215\":3,\"289\":1,\"294\":4,\"442\":1,\"586\":1,\"678\":7,\"703\":1}}],[\"onbuttonwaspushed\",{\"1\":{\"562\":3}}],[\"oncommand\",{\"1\":{\"562\":2}}],[\"oncommands\",{\"1\":{\"562\":6}}],[\"onanimationresume\",{\"1\":{\"532\":1}}],[\"onanimationrepeat\",{\"1\":{\"532\":3}}],[\"onanimationpause\",{\"1\":{\"532\":1}}],[\"onanimationcancel\",{\"1\":{\"532\":3}}],[\"onanimationend\",{\"1\":{\"532\":3}}],[\"onanimationstart\",{\"1\":{\"532\":6}}],[\"onjava\",{\"1\":{\"442\":1}}],[\"ontology\",{\"1\":{\"432\":1}}],[\"oneof\",{\"1\":{\"477\":1}}],[\"oneresult\",{\"1\":{\"86\":1}}],[\"onea2a1c1\",{\"1\":{\"74\":1}}],[\"one\",{\"1\":{\"68\":2,\"71\":1,\"74\":2,\"75\":2,\"82\":1,\"86\":1,\"92\":3,\"104\":4,\"296\":3,\"310\":1,\"312\":2,\"708\":1,\"716\":1,\"847\":1,\"978\":2}}],[\"on\",{\"0\":{\"62\":1},\"1\":{\"71\":3,\"77\":1,\"78\":1,\"104\":2,\"145\":2,\"152\":1,\"310\":3,\"442\":2,\"459\":2,\"474\":1,\"562\":6,\"601\":14,\"942\":1,\"947\":1}}],[\"only\",{\"1\":{\"51\":1,\"85\":1,\"104\":1,\"302\":1,\"310\":1,\"312\":2}}],[\"orelse\",{\"1\":{\"450\":1}}],[\"orm映射\",{\"0\":{\"866\":1}}],[\"orm框架\",{\"1\":{\"420\":1}}],[\"ormlite\",{\"1\":{\"420\":1}}],[\"orm\",{\"0\":{\"420\":1},\"1\":{\"474\":1,\"873\":1}}],[\"orbit\",{\"1\":{\"399\":1}}],[\"oracle首席架构师\",{\"1\":{\"440\":1}}],[\"oracle技术团队顾问\",{\"1\":{\"440\":1}}],[\"oracle产品经理\",{\"1\":{\"440\":1}}],[\"oracle\",{\"1\":{\"294\":2,\"299\":1,\"543\":1,\"868\":1}}],[\"ordinary\",{\"1\":{\"873\":1,\"877\":1}}],[\"ordinal\",{\"1\":{\"242\":4}}],[\"orderid\",{\"1\":{\"854\":1}}],[\"orderidgenerator\",{\"1\":{\"764\":1}}],[\"orderlist\",{\"1\":{\"854\":1}}],[\"orderfactory\",{\"1\":{\"845\":1}}],[\"orderfailureevent\",{\"1\":{\"779\":4}}],[\"ordertype\",{\"1\":{\"610\":6,\"613\":9}}],[\"orderpizzafactory\",{\"1\":{\"613\":4}}],[\"orderpizza\",{\"1\":{\"609\":2,\"610\":2,\"613\":1}}],[\"order2\",{\"1\":{\"584\":11}}],[\"order\",{\"1\":{\"72\":1,\"80\":1,\"310\":1,\"584\":24,\"764\":2,\"773\":1,\"850\":1,\"864\":3,\"885\":1,\"983\":1}}],[\"originator\",{\"1\":{\"664\":4}}],[\"original\",{\"1\":{\"141\":4}}],[\"orientations\",{\"1\":{\"44\":1}}],[\"orientation\",{\"0\":{\"44\":1},\"1\":{\"71\":1}}],[\"oriented\",{\"1\":{\"43\":2,\"403\":1,\"736\":1,\"873\":1}}],[\"organizationcomponents\",{\"1\":{\"574\":10}}],[\"organizationcomponent\",{\"1\":{\"574\":30}}],[\"org\",{\"1\":{\"104\":5,\"859\":4,\"974\":4,\"975\":2,\"976\":1,\"977\":2,\"978\":6,\"979\":17,\"980\":11,\"981\":8,\"982\":4,\"983\":3}}],[\"or\",{\"0\":{\"152\":1},\"1\":{\"43\":1,\"59\":1,\"62\":1,\"63\":1,\"71\":3,\"77\":1,\"80\":1,\"81\":1,\"87\":2,\"104\":4,\"127\":1,\"130\":1,\"225\":1,\"256\":1,\"310\":2,\"312\":5,\"618\":1,\"664\":8,\"933\":1,\"978\":1}}],[\"oflnt\",{\"1\":{\"532\":2}}],[\"offbuttonwaspushed\",{\"1\":{\"562\":3}}],[\"offcommand\",{\"1\":{\"562\":2}}],[\"offcommands\",{\"1\":{\"562\":6}}],[\"off\",{\"1\":{\"488\":1,\"562\":6,\"601\":12}}],[\"of\",{\"0\":{\"50\":1,\"68\":1,\"71\":1,\"452\":1},\"1\":{\"43\":1,\"59\":1,\"68\":1,\"69\":1,\"71\":4,\"77\":4,\"78\":1,\"80\":3,\"82\":4,\"85\":1,\"86\":4,\"87\":1,\"103\":1,\"104\":12,\"144\":1,\"145\":12,\"152\":1,\"225\":1,\"294\":1,\"302\":1,\"310\":8,\"311\":1,\"312\":7,\"439\":1,\"466\":1,\"469\":3,\"477\":1,\"591\":1,\"618\":2,\"707\":1,\"798\":1,\"849\":1,\"873\":1,\"942\":4,\"955\":2}}],[\"fw\",{\"1\":{\"845\":1}}],[\"f12\",{\"1\":{\"632\":2}}],[\"f11\",{\"1\":{\"632\":2}}],[\"f03\",{\"1\":{\"632\":2}}],[\"f02\",{\"1\":{\"632\":2}}],[\"f01\",{\"1\":{\"632\":2}}],[\"fst\",{\"1\":{\"428\":1}}],[\"february\",{\"1\":{\"849\":1}}],[\"feed\",{\"1\":{\"779\":3}}],[\"feedbackstate\",{\"1\":{\"779\":5}}],[\"feedbackevent\",{\"1\":{\"779\":6}}],[\"fetch\",{\"1\":{\"474\":1}}],[\"featuring\",{\"1\":{\"431\":1}}],[\"features\",{\"0\":{\"464\":1},\"1\":{\"145\":1}}],[\"feature\",{\"1\":{\"86\":1}}],[\"feignclient\",{\"1\":{\"814\":7}}],[\"feign\",{\"1\":{\"424\":1,\"814\":1}}],[\"f2\",{\"1\":{\"307\":3}}],[\"flash\",{\"1\":{\"820\":2}}],[\"flask\",{\"1\":{\"472\":1}}],[\"flatmap\",{\"1\":{\"450\":2}}],[\"flatbuffers\",{\"1\":{\"428\":1}}],[\"flag\",{\"1\":{\"307\":1,\"847\":3,\"852\":2}}],[\"flags\",{\"1\":{\"228\":4,\"312\":1}}],[\"flink\",{\"1\":{\"413\":1}}],[\"flysqrlboy\",{\"1\":{\"1000\":1}}],[\"flyability\",{\"1\":{\"813\":2}}],[\"flyable\",{\"1\":{\"813\":5}}],[\"flybehavor\",{\"1\":{\"789\":1}}],[\"flybehavior\",{\"1\":{\"789\":15}}],[\"flyweightpattern\",{\"1\":{\"632\":1}}],[\"flyweights\",{\"1\":{\"632\":3}}],[\"flyweight>\",{\"1\":{\"632\":2}}],[\"flyweightfactory\",{\"1\":{\"632\":4}}],[\"flyweight\",{\"1\":{\"590\":1,\"629\":1,\"632\":20,\"637\":1,\"798\":1}}],[\"flyway\",{\"1\":{\"394\":1}}],[\"flyingsaucer\",{\"1\":{\"421\":1}}],[\"fly\",{\"1\":{\"214\":2,\"787\":3,\"788\":3,\"789\":10,\"812\":7,\"813\":5}}],[\"float和double都存在精度损失的问题\",{\"1\":{\"863\":1}}],[\"floatvalue\",{\"1\":{\"312\":1}}],[\"float\",{\"0\":{\"128\":1},\"1\":{\"119\":1,\"128\":4,\"279\":3,\"302\":1,\"312\":1,\"584\":6,\"676\":15,\"678\":24,\"710\":3,\"846\":1,\"847\":1,\"848\":9}}],[\"flow\",{\"1\":{\"78\":2,\"80\":1}}],[\"flowchartconfig\",{\"1\":{\"87\":2}}],[\"flowcharts\",{\"0\":{\"75\":1},\"1\":{\"76\":1}}],[\"flowchart\",{\"0\":{\"44\":1},\"1\":{\"43\":3,\"44\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":1,\"52\":1,\"53\":1,\"54\":1,\"55\":1,\"56\":1,\"57\":1,\"58\":1,\"60\":1,\"61\":1,\"62\":2,\"63\":2,\"64\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":5,\"69\":1,\"70\":1,\"71\":4,\"72\":1,\"73\":1,\"74\":2,\"75\":3,\"76\":1,\"77\":4,\"78\":1,\"81\":1,\"82\":1,\"83\":1,\"85\":1,\"86\":1,\"87\":1}}],[\"f\",{\"1\":{\"128\":2,\"289\":1,\"305\":4,\"307\":6,\"312\":2,\"485\":1,\"596\":2,\"884\":1}}],[\"fridge\",{\"1\":{\"853\":2}}],[\"friend=\",{\"1\":{\"687\":4}}],[\"friend\",{\"1\":{\"687\":6}}],[\"france\",{\"1\":{\"440\":1}}],[\"frameworkmethod\",{\"1\":{\"979\":3,\"980\":3}}],[\"frameworkmethod$1\",{\"1\":{\"979\":1,\"980\":1}}],[\"frameworks\",{\"0\":{\"457\":1}}],[\"framework\",{\"0\":{\"472\":1,\"483\":1},\"1\":{\"431\":1,\"483\":1}}],[\"freeinstance\",{\"1\":{\"772\":2}}],[\"freemarker\",{\"1\":{\"430\":1}}],[\"freememory\",{\"1\":{\"93\":4}}],[\"french\",{\"1\":{\"488\":1}}],[\"frequently\",{\"1\":{\"145\":1}}],[\"frob\",{\"1\":{\"901\":1}}],[\"frobnicatestring\",{\"1\":{\"452\":1}}],[\"from表\",{\"1\":{\"864\":2}}],[\"fromuserthreadfactory\",{\"1\":{\"851\":1}}],[\"fromjson\",{\"1\":{\"467\":1}}],[\"from\",{\"1\":{\"43\":2,\"71\":1,\"75\":1,\"77\":1,\"83\":1,\"85\":1,\"104\":3,\"144\":4,\"145\":1,\"165\":1,\"225\":1,\"275\":4,\"302\":1,\"310\":3,\"311\":1,\"312\":2,\"474\":1,\"865\":4,\"978\":1}}],[\"frontmatter\",{\"1\":{\"6\":1,\"10\":3,\"32\":1,\"34\":1}}],[\"front\",{\"1\":{\"0\":1}}],[\"fixmethodorder\",{\"1\":{\"983\":2}}],[\"fixme\",{\"1\":{\"853\":1}}],[\"fixedthreadpool和singlethreadpool\",{\"1\":{\"851\":1}}],[\"fixture\",{\"0\":{\"997\":1},\"1\":{\"477\":2,\"997\":2}}],[\"fix\",{\"1\":{\"104\":1}}],[\"fine\",{\"1\":{\"912\":1,\"950\":1}}],[\"fineprint\",{\"1\":{\"294\":1}}],[\"fin\",{\"1\":{\"870\":1}}],[\"finished\",{\"1\":{\"855\":1}}],[\"finishcoffee\",{\"1\":{\"659\":2}}],[\"finduser\",{\"1\":{\"469\":1}}],[\"findboyfriend\",{\"1\":{\"852\":1}}],[\"findbootstrapclassornull\",{\"1\":{\"310\":1}}],[\"findbugs\",{\"1\":{\"388\":1,\"484\":2}}],[\"findclass\",{\"1\":{\"310\":2}}],[\"findloadedclass0\",{\"1\":{\"310\":1}}],[\"findloadedclass\",{\"1\":{\"310\":3}}],[\"find\",{\"1\":{\"104\":2,\"310\":1,\"625\":1}}],[\"final可以声明类\",{\"1\":{\"848\":1}}],[\"final定义\",{\"1\":{\"846\":1}}],[\"final详解\",{\"0\":{\"505\":1}}],[\"final类和方法\",{\"1\":{\"431\":1}}],[\"final方法等\",{\"1\":{\"431\":1}}],[\"finally块必须对资源对象\",{\"1\":{\"858\":1}}],[\"finally块进行回收\",{\"1\":{\"851\":1}}],[\"finally代码块都会执行\",{\"1\":{\"851\":1}}],[\"finally部分的代码如果被调用\",{\"1\":{\"275\":1}}],[\"finally里面的部分已经被提取到了try部分和catch部分\",{\"1\":{\"275\":1}}],[\"finally或者try\",{\"1\":{\"260\":1}}],[\"finally遇见如下情况不会执行\",{\"1\":{\"258\":1}}],[\"finally可用在不需要捕获异常的代码\",{\"1\":{\"258\":1}}],[\"finally吗\",{\"1\":{\"258\":1}}],[\"finally语句块中的代码一定会被执行\",{\"1\":{\"260\":1}}],[\"finally语句块中发生了异常\",{\"1\":{\"258\":1}}],[\"finally语句块里的语句还是会被执行\",{\"1\":{\"257\":1}}],[\"finally语句块总是会被执行\",{\"1\":{\"251\":1}}],[\"finally不执行的几种情况\",{\"1\":{\"197\":1}}],[\"finally不管有没有异常都要处理\",{\"1\":{\"197\":1}}],[\"finally中最好不要包含return\",{\"1\":{\"197\":1}}],[\"finally是在return后面的表达式运算后执行的\",{\"1\":{\"197\":1}}],[\"finally在return返回前执行\",{\"1\":{\"197\":1}}],[\"finally比return先执行\",{\"1\":{\"197\":1}}],[\"finally仍然会执行\",{\"1\":{\"197\":1}}],[\"finally\",{\"0\":{\"182\":1,\"257\":1,\"258\":1,\"264\":1},\"1\":{\"182\":2,\"196\":1,\"225\":2,\"251\":1,\"255\":2,\"257\":3,\"258\":2,\"259\":2,\"260\":1,\"264\":4,\"273\":1,\"275\":10,\"625\":1,\"689\":1,\"851\":4,\"858\":1,\"872\":1,\"902\":1}}],[\"finalizer\",{\"1\":{\"952\":1}}],[\"finalizers\",{\"0\":{\"952\":1}}],[\"finalize\",{\"0\":{\"182\":1},\"1\":{\"137\":1,\"182\":2,\"190\":1,\"952\":1}}],[\"final\",{\"0\":{\"143\":1,\"182\":1},\"1\":{\"91\":2,\"104\":1,\"106\":1,\"114\":5,\"120\":3,\"122\":4,\"133\":2,\"137\":6,\"143\":6,\"182\":2,\"194\":1,\"242\":3,\"259\":1,\"302\":6,\"308\":6,\"310\":3,\"312\":4,\"445\":1,\"446\":3,\"450\":4,\"451\":5,\"455\":2,\"466\":2,\"467\":3,\"471\":1,\"477\":2,\"478\":1,\"689\":1,\"703\":2,\"752\":1,\"758\":1,\"760\":1,\"768\":8,\"771\":1,\"773\":3,\"779\":1,\"803\":1,\"804\":1,\"809\":2,\"845\":2,\"846\":5,\"851\":3,\"852\":2,\"859\":2,\"872\":2,\"927\":1,\"934\":1,\"942\":13,\"945\":1,\"980\":1,\"981\":1}}],[\"firsttest\",{\"1\":{\"975\":1}}],[\"first\",{\"1\":{\"104\":3,\"310\":1,\"312\":1,\"474\":1,\"649\":4,\"768\":1,\"847\":2,\"865\":2,\"983\":1}}],[\"fieldaccessor\",{\"1\":{\"312\":1}}],[\"field类还提供了专门针对基本数据类型的方法\",{\"1\":{\"307\":1}}],[\"field类及其用法\",{\"0\":{\"307\":1}}],[\"field2\",{\"1\":{\"307\":3}}],[\"field表示class对象所表示的类的成员变量\",{\"1\":{\"304\":1}}],[\"fields2\",{\"1\":{\"307\":2}}],[\"fields\",{\"1\":{\"133\":1,\"145\":1,\"307\":2,\"312\":2,\"446\":1,\"851\":1}}],[\"field\",{\"1\":{\"91\":3,\"93\":1,\"144\":3,\"145\":2,\"224\":1,\"225\":4,\"227\":1,\"275\":9,\"302\":2,\"305\":3,\"307\":23,\"310\":3,\"877\":1}}],[\"filterwriter\",{\"1\":{\"586\":1}}],[\"filterreader\",{\"1\":{\"586\":1}}],[\"filteroutputstream\",{\"1\":{\"586\":1}}],[\"filterinputstream\",{\"1\":{\"585\":4,\"586\":1}}],[\"filtered\",{\"1\":{\"455\":3}}],[\"filteredname\",{\"1\":{\"311\":4}}],[\"filterednames\",{\"1\":{\"311\":4}}],[\"filter\",{\"1\":{\"311\":2,\"455\":1,\"466\":1,\"707\":1}}],[\"filtermethods\",{\"1\":{\"311\":3}}],[\"filename\",{\"1\":{\"852\":1}}],[\"filenotfoundexception\",{\"1\":{\"198\":1,\"234\":3,\"252\":1,\"256\":4,\"261\":1,\"264\":3}}],[\"file=heapdump\",{\"1\":{\"485\":1}}],[\"fileutils\",{\"1\":{\"465\":1}}],[\"fileinputstream\",{\"1\":{\"259\":1,\"264\":6,\"585\":1}}],[\"filereader\",{\"1\":{\"252\":1,\"257\":1}}],[\"filepath\",{\"1\":{\"252\":2,\"253\":1,\"256\":2,\"257\":2}}],[\"filesharedobjectstorage\",{\"1\":{\"772\":1}}],[\"files\",{\"1\":{\"104\":1,\"870\":1}}],[\"filesearch\",{\"1\":{\"96\":2}}],[\"file\",{\"1\":{\"87\":1,\"104\":15,\"114\":1,\"252\":4,\"253\":1,\"257\":5,\"264\":15,\"485\":1,\"625\":1,\"847\":1,\"852\":1,\"870\":1}}],[\"fill\",{\"1\":{\"81\":2,\"82\":2,\"83\":1,\"84\":1}}],[\"fake\",{\"1\":{\"996\":7}}],[\"fairsync\",{\"1\":{\"852\":1}}],[\"fair\",{\"1\":{\"852\":3}}],[\"failontimeout\",{\"1\":{\"980\":2}}],[\"failontimeout$callablestatement\",{\"1\":{\"980\":2}}],[\"failure\",{\"1\":{\"469\":1,\"978\":4}}],[\"fail\",{\"1\":{\"104\":1,\"114\":8,\"242\":1,\"839\":5,\"950\":1,\"979\":2}}],[\"failed\",{\"1\":{\"103\":1,\"253\":1,\"257\":1}}],[\"fast\",{\"1\":{\"423\":1}}],[\"fastjson给scm定制的版本号\",{\"1\":{\"869\":1}}],[\"fastjson\",{\"1\":{\"409\":1,\"869\":1}}],[\"fastutil\",{\"1\":{\"406\":1}}],[\"facadepattern\",{\"1\":{\"596\":1}}],[\"facade\",{\"1\":{\"590\":1,\"593\":2,\"594\":1,\"595\":2,\"596\":3,\"603\":3,\"798\":1}}],[\"facebook构建工具\",{\"1\":{\"385\":1}}],[\"faces\",{\"1\":{\"384\":1}}],[\"factories\",{\"1\":{\"106\":4}}],[\"factories配置文件\",{\"1\":{\"106\":1}}],[\"factories文件的格式为\",{\"1\":{\"106\":1}}],[\"factories文件\",{\"1\":{\"106\":2}}],[\"factorymethod\",{\"1\":{\"798\":1}}],[\"factoryclassnames\",{\"1\":{\"106\":2}}],[\"factoryclassname\",{\"1\":{\"104\":5,\"106\":2}}],[\"factoryclass\",{\"1\":{\"104\":8,\"106\":2}}],[\"factory\",{\"0\":{\"607\":1,\"611\":1,\"615\":1},\"1\":{\"104\":27,\"589\":1,\"608\":2,\"612\":1,\"616\":2,\"618\":1,\"632\":7,\"636\":6}}],[\"fall\",{\"0\":{\"924\":1},\"1\":{\"618\":1,\"924\":3}}],[\"fallthrough\",{\"1\":{\"225\":1}}],[\"fallback\",{\"1\":{\"104\":1}}],[\"false\",{\"0\":{\"167\":1},\"1\":{\"91\":3,\"104\":1,\"114\":2,\"120\":3,\"125\":1,\"138\":7,\"167\":1,\"305\":1,\"307\":1,\"308\":1,\"310\":5,\"311\":3,\"312\":5,\"626\":1,\"627\":1,\"637\":4,\"649\":1,\"650\":2,\"778\":4,\"803\":1,\"848\":1,\"851\":1,\"852\":1,\"859\":1,\"978\":2,\"981\":3}}],[\"fabric8\",{\"1\":{\"392\":1}}],[\"fabricate\",{\"1\":{\"312\":1}}],[\"fabricated\",{\"1\":{\"310\":1}}],[\"fab\",{\"1\":{\"85\":1}}],[\"fa\",{\"1\":{\"85\":8}}],[\"f96\",{\"1\":{\"82\":1}}],[\"f9f\",{\"1\":{\"81\":1,\"82\":1,\"84\":1}}],[\"ff\",{\"1\":{\"601\":2}}],[\"ff0000\",{\"1\":{\"83\":1}}],[\"ffff00\",{\"1\":{\"83\":1}}],[\"fff\",{\"1\":{\"81\":1}}],[\"ff3\",{\"1\":{\"80\":1}}],[\"f66\",{\"1\":{\"81\":1}}],[\"fusco\",{\"1\":{\"440\":1}}],[\"fugue\",{\"1\":{\"403\":1}}],[\"fun2\",{\"1\":{\"285\":2}}],[\"fun1\",{\"1\":{\"285\":2}}],[\"fun\",{\"1\":{\"284\":3,\"978\":1}}],[\"fund\",{\"1\":{\"284\":2}}],[\"funb\",{\"1\":{\"284\":1}}],[\"funa\",{\"1\":{\"284\":2}}],[\"fun3\",{\"1\":{\"133\":1}}],[\"func3\",{\"1\":{\"734\":2}}],[\"func2\",{\"1\":{\"133\":4,\"144\":1,\"734\":4}}],[\"func1\",{\"1\":{\"133\":8,\"144\":2,\"734\":16}}],[\"func\",{\"1\":{\"127\":4,\"134\":8,\"284\":4,\"468\":1}}],[\"functional\",{\"1\":{\"403\":1}}],[\"functionality\",{\"1\":{\"77\":2}}],[\"functions\",{\"1\":{\"77\":1}}],[\"function\",{\"1\":{\"77\":4,\"845\":1}}],[\"fully\",{\"1\":{\"145\":1}}],[\"fullname\",{\"1\":{\"114\":3}}],[\"full\",{\"1\":{\"77\":1}}],[\"futuretask\",{\"1\":{\"980\":2}}],[\"futuretask详解\",{\"0\":{\"496\":1}}],[\"future\",{\"1\":{\"51\":1,\"302\":1,\"912\":1}}],[\"focus\",{\"1\":{\"601\":1}}],[\"foldedphone\",{\"1\":{\"542\":4}}],[\"following\",{\"1\":{\"71\":3,\"145\":1,\"310\":1}}],[\"foobart\",{\"1\":{\"946\":1}}],[\"fooexception\",{\"1\":{\"907\":1,\"911\":1}}],[\"foo\",{\"1\":{\"459\":2,\"471\":5,\"477\":2,\"901\":1,\"907\":2,\"911\":2,\"922\":1,\"951\":2,\"958\":1,\"960\":1}}],[\"foowidgetdependency\",{\"1\":{\"477\":3}}],[\"foowidgettest\",{\"1\":{\"477\":1}}],[\"foowidget\",{\"1\":{\"450\":6,\"451\":7,\"467\":3,\"477\":2}}],[\"fo创建pdf\",{\"1\":{\"421\":1}}],[\"fop\",{\"1\":{\"421\":1}}],[\"found\",{\"1\":{\"104\":2,\"130\":1,\"310\":3,\"312\":2}}],[\"fourth\",{\"1\":{\"80\":1,\"104\":1}}],[\"four\",{\"1\":{\"68\":1}}],[\"font\",{\"1\":{\"85\":2}}],[\"fontawesome\",{\"0\":{\"85\":1},\"1\":{\"85\":1}}],[\"foreach\",{\"1\":{\"907\":1,\"911\":1}}],[\"foreach方法\",{\"1\":{\"850\":1}}],[\"force\",{\"1\":{\"863\":1}}],[\"forcecode\",{\"1\":{\"845\":2}}],[\"forgery\",{\"1\":{\"861\":1}}],[\"forserialization\",{\"1\":{\"312\":8}}],[\"forinputstring\",{\"1\":{\"270\":1}}],[\"fork\",{\"0\":{\"495\":1},\"1\":{\"186\":1,\"770\":1}}],[\"forname0\",{\"1\":{\"310\":1}}],[\"forname\",{\"1\":{\"98\":2,\"102\":1,\"103\":2,\"114\":2,\"145\":1,\"283\":4,\"302\":1,\"305\":7,\"306\":2,\"307\":2,\"308\":2,\"309\":1,\"310\":2,\"627\":2}}],[\"forbiddena\",{\"1\":{\"85\":1}}],[\"forbidden\",{\"1\":{\"85\":1,\"854\":1}}],[\"for\",{\"0\":{\"85\":1},\"1\":{\"68\":1,\"71\":2,\"74\":1,\"77\":5,\"80\":1,\"85\":2,\"93\":1,\"103\":1,\"104\":11,\"114\":1,\"120\":1,\"122\":1,\"133\":1,\"141\":5,\"145\":1,\"147\":1,\"150\":2,\"152\":1,\"211\":1,\"225\":1,\"230\":1,\"234\":2,\"270\":2,\"276\":3,\"284\":1,\"285\":1,\"288\":1,\"302\":1,\"305\":3,\"306\":4,\"307\":2,\"308\":2,\"310\":7,\"311\":5,\"312\":68,\"455\":1,\"562\":1,\"571\":2,\"574\":2,\"618\":3,\"627\":3,\"644\":2,\"656\":1,\"672\":1,\"678\":1,\"716\":1,\"732\":1,\"736\":2,\"742\":4,\"743\":4,\"778\":1,\"839\":1,\"845\":1,\"847\":2,\"848\":1,\"849\":1,\"850\":1,\"852\":1,\"900\":1,\"911\":1,\"917\":1,\"980\":1,\"981\":1}}],[\"format\",{\"1\":{\"618\":1,\"905\":1}}],[\"format=b\",{\"1\":{\"485\":1}}],[\"formatting\",{\"0\":{\"453\":1}}],[\"formulation\",{\"1\":{\"104\":1}}],[\"form\",{\"0\":{\"50\":1},\"1\":{\"68\":1,\"82\":1,\"947\":1}}],[\"渲染框时将使用先前定义的那个\",{\"1\":{\"42\":1}}],[\"再明确触发状态转换的条件是什么\",{\"1\":{\"871\":1}}],[\"再通过sublist取start\",{\"1\":{\"866\":1}}],[\"再通过类加载子系统进行加载到jvm中运行\",{\"1\":{\"303\":1}}],[\"再做对应的异常处理\",{\"1\":{\"858\":1}}],[\"再根据内容特征\",{\"1\":{\"843\":1}}],[\"再根据里面的内容加载相应的实现类\",{\"1\":{\"96\":1}}],[\"再或者说\",{\"1\":{\"817\":1}}],[\"再听我下面的讲解\",{\"1\":{\"812\":1}}],[\"再进行浮点数的运算操作\",{\"1\":{\"848\":1}}],[\"再进行不同情况的处理\",{\"1\":{\"775\":1}}],[\"再进行编译\",{\"1\":{\"290\":1}}],[\"再使用\",{\"1\":{\"768\":1}}],[\"再让\",{\"1\":{\"732\":1}}],[\"再到公网或者数据库取\",{\"1\":{\"704\":1}}],[\"再把需要备份的数据放到这个新对象\",{\"1\":{\"666\":1}}],[\"再调用\",{\"1\":{\"627\":1,\"768\":1}}],[\"再比如\",{\"1\":{\"560\":1,\"648\":1}}],[\"再自己加载\",{\"1\":{\"310\":1}}],[\"再来看看\",{\"1\":{\"305\":1}}],[\"再说\",{\"1\":{\"290\":1}}],[\"再看子类的两个重写的方法的类型\",{\"1\":{\"291\":1}}],[\"再看第二种情况\",{\"1\":{\"290\":1}}],[\"再看一个实际例子\",{\"1\":{\"284\":1}}],[\"再次分析上面的java代码\",{\"1\":{\"275\":1}}],[\"再次执行judge\",{\"1\":{\"92\":1}}],[\"再long\",{\"1\":{\"160\":1}}],[\"再从这个地址读取一个int类型长度的变量\",{\"1\":{\"93\":1}}],[\"再一个个拔除治疗\",{\"1\":{\"36\":1}}],[\"再难的事\",{\"1\":{\"36\":1}}],[\"也确实真的没什么值得好说了\",{\"1\":{\"960\":1}}],[\"也都是正确的\",{\"1\":{\"947\":1}}],[\"也都会犯错误\",{\"1\":{\"484\":1}}],[\"也许是你自己\",{\"1\":{\"912\":1}}],[\"也许还有一些类的\",{\"1\":{\"819\":1}}],[\"也适用这个规则\",{\"1\":{\"897\":1}}],[\"也避免提供那些无法明确执行的建议\",{\"1\":{\"876\":1}}],[\"也避免的反复进行方法同步\",{\"1\":{\"757\":1}}],[\"也指数据库表一\",{\"1\":{\"873\":1}}],[\"也返回为\",{\"1\":{\"865\":1}}],[\"也必须把d放在索引的最前列\",{\"1\":{\"864\":1}}],[\"也必须建成唯一索引\",{\"1\":{\"864\":1}}],[\"也便于通过日志对系统进行及时监控\",{\"1\":{\"859\":1}}],[\"也有利于归类查找\",{\"1\":{\"859\":1}}],[\"也有可能是catch部分发生异常\",{\"1\":{\"275\":1}}],[\"也并非高枕无忧\",{\"1\":{\"858\":1}}],[\"也能清晰理解当时的思路\",{\"1\":{\"853\":1}}],[\"也存在多个游客\",{\"1\":{\"837\":1}}],[\"也表示类之间的整体与部分的关系\",{\"1\":{\"832\":1}}],[\"也提供了很大的灵活性\",{\"1\":{\"804\":1}}],[\"也称为上下文\",{\"1\":{\"776\":1}}],[\"也称jakarta\",{\"1\":{\"104\":1}}],[\"也会影响到代码的可维护性\",{\"1\":{\"812\":1}}],[\"也会导致不必要的开发负担\",{\"1\":{\"810\":1}}],[\"也会导致\",{\"1\":{\"741\":1}}],[\"也会编译通过\",{\"1\":{\"248\":1}}],[\"也带来了弊端\",{\"1\":{\"731\":1}}],[\"也希望做这样的产品展示网站\",{\"1\":{\"633\":1}}],[\"也需要在评审通过后上线\",{\"1\":{\"871\":1}}],[\"也需要定义<resultmap>\",{\"1\":{\"866\":1}}],[\"也需要修改\",{\"1\":{\"609\":1}}],[\"也需要进行文档说明\",{\"1\":{\"266\":1}}],[\"也叫最少知识原则或者迪米特法则\",{\"1\":{\"812\":1}}],[\"也叫具体目标类\",{\"1\":{\"672\":1}}],[\"也叫抽象目标类\",{\"1\":{\"672\":1}}],[\"也叫\",{\"1\":{\"593\":1,\"610\":1,\"629\":1}}],[\"也违背了我们之后要讲的最小知识原则\",{\"1\":{\"812\":1}}],[\"也违背了\",{\"1\":{\"593\":1}}],[\"也体现了开闭原则\",{\"1\":{\"579\":1}}],[\"也更方便使用程序来控制创建过程\",{\"1\":{\"557\":1}}],[\"也要采用大括号的编码方式\",{\"1\":{\"852\":1}}],[\"也要增加相应的接收方法\",{\"1\":{\"727\":1}}],[\"也要在各个手机样式类下增加\",{\"1\":{\"541\":1}}],[\"也要警醒自己身上是否有和他相似的缺点\",{\"1\":{\"36\":1}}],[\"也增加了使用的成本\",{\"1\":{\"525\":1}}],[\"也是如此\",{\"1\":{\"897\":1}}],[\"也是系统编码与测试的重要模型依据\",{\"1\":{\"826\":1}}],[\"也是框架的\",{\"1\":{\"819\":1}}],[\"也是我在阅读源码的时候经常会用到的\",{\"1\":{\"817\":1}}],[\"也是在类装载的时候\",{\"1\":{\"753\":1}}],[\"也是各种设计模式的基础\",{\"1\":{\"714\":1}}],[\"也是抽象表达式的子类\",{\"1\":{\"642\":1}}],[\"也是可以的\",{\"1\":{\"613\":1}}],[\"也是一种解耦的有效手段\",{\"1\":{\"818\":1}}],[\"也是一种设计模式\",{\"1\":{\"564\":1}}],[\"也是一个通信媒介\",{\"1\":{\"262\":1}}],[\"也是浪费\",{\"1\":{\"445\":1}}],[\"也是返回方法的参数类型\",{\"1\":{\"308\":1}}],[\"也是方法的返回类型\",{\"1\":{\"308\":1}}],[\"也差不多\",{\"1\":{\"289\":1}}],[\"也不利于快速定位错误点\",{\"1\":{\"859\":1}}],[\"也不利于定位问题\",{\"1\":{\"858\":1}}],[\"也不利于维护\",{\"1\":{\"846\":1}}],[\"也不是进入这里\",{\"1\":{\"852\":2}}],[\"也不是兄弟关系\",{\"1\":{\"814\":1}}],[\"也不是动态加入\",{\"1\":{\"677\":1}}],[\"也不能依赖执行的先后次序\",{\"1\":{\"860\":1}}],[\"也不能以下划线或美元符号结束\",{\"1\":{\"845\":1}}],[\"也不能模拟生成一个新的对象\",{\"1\":{\"750\":1}}],[\"也不能声明异常\",{\"1\":{\"252\":1}}],[\"也不会形成例如\",{\"1\":{\"958\":1}}],[\"也不会影响外观对象\",{\"1\":{\"593\":1}}],[\"也不会出现异常\",{\"1\":{\"294\":1}}],[\"也不知道被请求的操作是哪个\",{\"1\":{\"560\":1}}],[\"也不知道构造方法如何\",{\"1\":{\"283\":1}}],[\"也不再要求\",{\"1\":{\"529\":1}}],[\"也将捕获所有的错误\",{\"1\":{\"268\":1}}],[\"也没有必要基于接口编程\",{\"1\":{\"810\":1}}],[\"也没有用throws子句声明抛出它\",{\"1\":{\"248\":1}}],[\"也没有加载具体实现类\",{\"1\":{\"103\":1}}],[\"也包含了\",{\"1\":{\"187\":1}}],[\"也就意味着\",{\"1\":{\"816\":1}}],[\"也就意味着放弃了继承和多态这两个强有力的面向对象特性\",{\"1\":{\"764\":1}}],[\"也就相当于损失了可以应对未来需求变化的扩展性\",{\"1\":{\"764\":1}}],[\"也就违背了广义上理解的\",{\"1\":{\"764\":1}}],[\"也就找不到对应的类字节码文件\",{\"1\":{\"293\":1}}],[\"也就不能引用其它对象\",{\"1\":{\"143\":1}}],[\"也就是在父类中\",{\"1\":{\"804\":1}}],[\"也就是我们平时所说的\",{\"1\":{\"770\":1}}],[\"也就是我们要研究的异常表\",{\"1\":{\"275\":1}}],[\"也就是采用接口隔离原则\",{\"1\":{\"721\":1,\"723\":1}}],[\"也就是只是将该成员变量的引用值\",{\"1\":{\"689\":1}}],[\"也就是将该属性值复制一份给新的对象\",{\"1\":{\"689\":1}}],[\"也就是所谓的单例对象\",{\"1\":{\"622\":1}}],[\"也就是利用反射创建对象\",{\"1\":{\"283\":1}}],[\"也就是说在\",{\"1\":{\"851\":1}}],[\"也就是说在泛型使用过程中\",{\"1\":{\"279\":1}}],[\"也就是说访问者关注了其他类的内部细节\",{\"1\":{\"840\":1}}],[\"也就是说员工必须记住每个领导的姓名\",{\"1\":{\"707\":1}}],[\"也就是说就是通过定义一个一致的接口\",{\"1\":{\"600\":1}}],[\"也就是说上面的t会变为原始类型throwable\",{\"1\":{\"297\":1}}],[\"也就是说仅仅语法合格\",{\"1\":{\"295\":1}}],[\"也就是说虚拟机根本不能分别这两个方法\",{\"1\":{\"291\":1}}],[\"也就是说\",{\"1\":{\"248\":1,\"249\":1,\"291\":1,\"554\":1,\"558\":1,\"564\":1,\"689\":1,\"741\":2,\"766\":1,\"767\":1,\"768\":1,\"770\":1,\"772\":1,\"813\":1,\"878\":1}}],[\"也就是说可以使用\",{\"1\":{\"210\":1}}],[\"也就是说真正被传递的是实参\",{\"1\":{\"204\":1}}],[\"也就是说如果需要线程安全需要使用stringbuffer\",{\"1\":{\"192\":1}}],[\"也就是说它不能是抽象方法\",{\"1\":{\"144\":1}}],[\"也就是说它不能有任何的方法实现\",{\"1\":{\"133\":1}}],[\"也就是说这个变量属于类的\",{\"1\":{\"144\":1}}],[\"也就是确保满足里氏替换原则\",{\"1\":{\"132\":1}}],[\"也可动态地新增或者删除责任\",{\"1\":{\"707\":1}}],[\"也可能是\",{\"1\":{\"848\":1}}],[\"也可能是基于数据库的搜索\",{\"1\":{\"96\":1}}],[\"也可能不同\",{\"1\":{\"159\":1}}],[\"也可以依据作者的决定而换行\",{\"1\":{\"906\":1}}],[\"也可以加快编译时的打包构建\",{\"1\":{\"869\":1}}],[\"也可以加香肠\",{\"1\":{\"579\":1}}],[\"也可以直接依赖于service层\",{\"1\":{\"868\":1}}],[\"也可以是单向的\",{\"1\":{\"830\":1}}],[\"也可以是在运行时被初始化后不能被改变的常量\",{\"1\":{\"143\":1}}],[\"也可以通过工厂模式\",{\"1\":{\"769\":1}}],[\"也可以通过构造函数传递给类的成员变量\",{\"1\":{\"769\":1}}],[\"也可以从配置文件中加载得到\",{\"1\":{\"768\":1}}],[\"也可以实现多态\",{\"1\":{\"764\":1}}],[\"也可以引入配置文件\",{\"1\":{\"608\":1}}],[\"也可以再动态地撤销时\",{\"1\":{\"586\":1}}],[\"也可以单品咖啡\",{\"1\":{\"581\":1}}],[\"也可以和持续集成工具绑定使用\",{\"1\":{\"484\":1}}],[\"也可以做一些很简单的事情\",{\"1\":{\"466\":1}}],[\"也可以被看作为一种部署框架\",{\"1\":{\"457\":1}}],[\"也可以被解释为illegalstateexception\",{\"1\":{\"265\":1}}],[\"也可以在关联线的两端标注角色名\",{\"1\":{\"830\":1}}],[\"也可以在所有其他构建工具中使用\",{\"1\":{\"401\":1}}],[\"也可以在不影响客户端代码的情况下进行\",{\"1\":{\"209\":1}}],[\"也可以在不同于\",{\"1\":{\"42\":1}}],[\"也可以购买商业版\",{\"1\":{\"392\":1}}],[\"也可以不标注\",{\"1\":{\"972\":1,\"981\":1}}],[\"也可以不指定泛型\",{\"1\":{\"289\":1}}],[\"也可以不处理\",{\"1\":{\"248\":1}}],[\"也可以捕获多种类型异常\",{\"1\":{\"256\":1}}],[\"也可以使用方便插入和删除的\",{\"1\":{\"188\":1}}],[\"也可以找到同样的配置文件\",{\"1\":{\"101\":1}}],[\"也总有解决办法\",{\"1\":{\"36\":1}}],[\"因访问对象隐私设\",{\"1\":{\"874\":1}}],[\"因国际化需要\",{\"1\":{\"865\":1}}],[\"因某种计算比较复杂而短时间无法完成\",{\"1\":{\"705\":1}}],[\"因而使用\",{\"1\":{\"996\":1}}],[\"因而\",{\"1\":{\"245\":1}}],[\"因为所有的测试都是通过了的\",{\"1\":{\"990\":1}}],[\"因为你了解单元测试会在你的预期之中\",{\"1\":{\"990\":1}}],[\"因为你需要的是精确的参数类型\",{\"1\":{\"284\":1}}],[\"因为本初子午线被定义在通过那里的经线\",{\"1\":{\"873\":1}}],[\"因为已经处于顶层\",{\"1\":{\"868\":1}}],[\"因为日志在manager或service层一定需要捕获并打印到日志文件中去\",{\"1\":{\"868\":1}}],[\"因为无法进行预发布\",{\"1\":{\"863\":1}}],[\"因为string字符串的拼接会使用stringbuilder的append\",{\"1\":{\"859\":1}}],[\"因为set存储的是不重复的对象\",{\"1\":{\"850\":1}}],[\"因为承载的信息价值较低\",{\"1\":{\"848\":1}}],[\"因为自动拆箱\",{\"1\":{\"848\":1}}],[\"因为不仅是编程知识点\",{\"1\":{\"843\":1}}],[\"因为不断地有浏览器停止对\",{\"1\":{\"820\":1}}],[\"因为现在你已经能在很多方面更好的理解问题了\",{\"1\":{\"820\":1}}],[\"因为依赖关系简单\",{\"1\":{\"816\":1}}],[\"因为除了鸵鸟之外\",{\"1\":{\"812\":1}}],[\"因为北京鸭不能飞翔\",{\"1\":{\"787\":1}}],[\"因为线程内唯一\",{\"1\":{\"771\":1}}],[\"因为成分对象的内部细节是新对象看不见的\",{\"1\":{\"747\":1}}],[\"因为继承会将父类的实现细节暴露给子类\",{\"1\":{\"747\":1}}],[\"因为继承实际上让两个类耦合性增强了\",{\"1\":{\"732\":1}}],[\"因为职责单一\",{\"1\":{\"741\":1}}],[\"因为原有的测试代码仍然能够正常运行\",{\"1\":{\"737\":1}}],[\"因为可以通过接口的继承\",{\"1\":{\"722\":1}}],[\"因为代理对象需要与目标对象实现一样的接口\",{\"1\":{\"696\":1}}],[\"因为该类的属性\",{\"1\":{\"689\":1}}],[\"因为实际上两个对象的该成员变量都指向同一个实例\",{\"1\":{\"689\":1}}],[\"因为超出f\",{\"1\":{\"637\":1}}],[\"因为内存空间有限\",{\"1\":{\"631\":1}}],[\"因为要求细粒度\",{\"1\":{\"631\":1}}],[\"因为编译一个子系统不会影响其他的子系统\",{\"1\":{\"593\":1}}],[\"因为编译器知道这些变量的值\",{\"1\":{\"183\":1}}],[\"因为咖啡单品\",{\"1\":{\"583\":1}}],[\"因为他是叶子节点\",{\"1\":{\"574\":1}}],[\"因为每一个具体操作都需要设计一个具体命令类\",{\"1\":{\"560\":1}}],[\"因为每一步不好走的路\",{\"1\":{\"36\":1}}],[\"因为软件最终还是提供给现实生活中的人使用的\",{\"1\":{\"545\":1}}],[\"因为父类拥有的方法\",{\"1\":{\"545\":1}}],[\"因为我们要搞清楚某个类具有哪些方法\",{\"1\":{\"812\":1}}],[\"因为我们主要是讲解设计模式\",{\"1\":{\"624\":1}}],[\"因为我们是使用它引用list1来调用它的方法\",{\"1\":{\"290\":1}}],[\"因为我喜欢\",{\"1\":{\"474\":1}}],[\"因为将来很长一段时间\",{\"1\":{\"462\":1}}],[\"因为里面的那些方法放在别处确实都不太合适\",{\"1\":{\"452\":1}}],[\"因为类的卸载是只有在类加载器可以被回收的情况下才会被回收的\",{\"1\":{\"312\":1}}],[\"因为类型检查就是编译时完成的\",{\"1\":{\"290\":1}}],[\"因为泛型信息在编译的时候已经变为原始类型\",{\"1\":{\"297\":1}}],[\"因为泛型类中的泛型参数的实例化是在定义对象的时候指定的\",{\"1\":{\"296\":1}}],[\"因为泛型类型\",{\"1\":{\"295\":1}}],[\"因为泛型类型的实例为\",{\"1\":{\"288\":1}}],[\"因为泛型类要在实例化的时候就指明类型\",{\"1\":{\"283\":1}}],[\"因为异常都是在运行时捕获和抛出的\",{\"1\":{\"297\":1}}],[\"因为具体类型会导致可存入任意类型对象\",{\"1\":{\"294\":1}}],[\"因为对于通配符的方式最后取出数据是要做显式类型转换的\",{\"1\":{\"294\":1}}],[\"因为对象的\",{\"1\":{\"177\":1}}],[\"因为当类型擦除后\",{\"1\":{\"292\":1}}],[\"因为虚拟机通过参数类型和返回类型来确定一个方法\",{\"1\":{\"291\":1}}],[\"因为是从string转换为object\",{\"1\":{\"290\":1}}],[\"因为如果是在编译之后检查\",{\"1\":{\"290\":1}}],[\"因为在写单元测试的时候\",{\"1\":{\"990\":1}}],[\"因为在\",{\"1\":{\"293\":1,\"294\":1}}],[\"因为在pair<t>中\",{\"1\":{\"289\":1}}],[\"因为在将一个数字无符号右移32位后\",{\"1\":{\"90\":1}}],[\"因为循环也占用了时间\",{\"1\":{\"276\":1}}],[\"因为先捕获throwable后捕获exception\",{\"1\":{\"275\":1}}],[\"因为终于看到了exception\",{\"1\":{\"275\":1}}],[\"因为它要测的东西很多\",{\"1\":{\"991\":1}}],[\"因为它会引起效率\",{\"1\":{\"646\":1}}],[\"因为它拥有非常棒的可插拔性\",{\"1\":{\"473\":1}}],[\"因为它使用起来比其他的更为简单方便\",{\"1\":{\"462\":1}}],[\"因为它是一个javadoc标签\",{\"1\":{\"853\":1}}],[\"因为它是一个奇素数\",{\"1\":{\"139\":1}}],[\"因为它是\",{\"1\":{\"267\":1}}],[\"因为它们不会充斥着程序员不熟悉的异常\",{\"1\":{\"265\":1}}],[\"因为它与程序员原来已经熟悉的习惯用法是一致的\",{\"1\":{\"265\":1}}],[\"因为java的大部分方法要么已经处理异常\",{\"1\":{\"253\":1}}],[\"因为公司没了员工还在\",{\"1\":{\"216\":1}}],[\"因为频繁的生成对象将会对系统性能产生影响\",{\"1\":{\"192\":1}}],[\"因为客户端只使用接口\",{\"1\":{\"188\":1}}],[\"因为有些异常具备以\",{\"1\":{\"859\":1}}],[\"因为有些浮点数不能完全精确的表示出来\",{\"1\":{\"167\":1}}],[\"因为有强制的规范指定需要同时重写\",{\"1\":{\"179\":1}}],[\"因为与\",{\"1\":{\"139\":1}}],[\"因为接口没有抽象类严格的类层次结构要求\",{\"1\":{\"133\":1}}],[\"因为字面量\",{\"1\":{\"129\":1}}],[\"因为这样的坏处时\",{\"1\":{\"972\":1}}],[\"因为这些都很简单\",{\"1\":{\"606\":1}}],[\"因为这要求\",{\"1\":{\"525\":1}}],[\"因为这是一个泛型方法\",{\"1\":{\"296\":1}}],[\"因为这是向下转型\",{\"1\":{\"128\":1}}],[\"因为这么做的话就失去了对这个字段修改行为的控制\",{\"1\":{\"132\":1}}],[\"因为这会使得精度降低\",{\"1\":{\"128\":1}}],[\"因为这违背了java中判断逻辑的基本常识\",{\"1\":{\"92\":1}}],[\"因为改变的是同一个地址指向的内容\",{\"1\":{\"127\":1}}],[\"因为\",{\"1\":{\"123\":1,\"165\":1,\"166\":1,\"470\":1,\"644\":1,\"727\":1,\"734\":1,\"892\":1,\"896\":1,\"997\":1}}],[\"因为直接操作内存啥的看上去就很高大上不是么\",{\"1\":{\"93\":1}}],[\"因为后面的unicode编码的转义后表示的是a++\",{\"1\":{\"89\":1}}],[\"因此缩进级别不会增加\",{\"1\":{\"928\":1}}],[\"因此所有对于类的格式化规则也适用于枚举类\",{\"1\":{\"915\":1}}],[\"因此子项目需要显式的声明依赖\",{\"1\":{\"869\":1}}],[\"因此子类可以通过扩展方式增加相应的功能\",{\"1\":{\"800\":1}}],[\"因此使用sum\",{\"1\":{\"865\":1}}],[\"因此代码会变得越来越臃肿\",{\"1\":{\"779\":1}}],[\"因此迪米特法则只是要求降低类间\",{\"1\":{\"744\":1}}],[\"因此调用者\",{\"1\":{\"734\":1}}],[\"因此调用泛型方法时\",{\"1\":{\"283\":1}}],[\"因此需控制链中最大节点数量\",{\"1\":{\"711\":1}}],[\"因此需要重写\",{\"1\":{\"787\":1}}],[\"因此需要\",{\"1\":{\"284\":1}}],[\"因此该方法做成抽象\",{\"1\":{\"710\":1}}],[\"因此我们这里使用默认的\",{\"1\":{\"689\":1}}],[\"因此它依赖于同事角色\",{\"1\":{\"656\":1}}],[\"因此它不可被继承\",{\"1\":{\"122\":1}}],[\"因此大数情况下使用语言中已有的聚合类的迭代器就已经够了\",{\"1\":{\"653\":1}}],[\"因此外观模式降低了客户端对子系统使用的复杂性\",{\"1\":{\"603\":1}}],[\"因此在设计程序架构时\",{\"1\":{\"820\":1}}],[\"因此在这种情况下\",{\"1\":{\"557\":1}}],[\"因此在方法中改变指针引用的对象\",{\"1\":{\"127\":1}}],[\"因此其使用范围受到一定的限制\",{\"1\":{\"557\":1}}],[\"因此其使用范围有一定的局限性\",{\"1\":{\"544\":1}}],[\"因此对应class对象只能有jvm创建和加载\",{\"1\":{\"302\":1}}],[\"因此那些方式初始化泛型数组都不是最优雅的方式\",{\"1\":{\"295\":1}}],[\"因此变量obj的类型为user\",{\"1\":{\"283\":1}}],[\"因此泛型方法中的泛型t就被指明为user\",{\"1\":{\"283\":1}}],[\"因此返回的是class<user>类型的对象\",{\"1\":{\"283\":1}}],[\"因此没有办法去new一个对象\",{\"1\":{\"283\":1}}],[\"因此为了兼容之前的版本\",{\"1\":{\"278\":1,\"287\":1}}],[\"因此写了一个catch块\",{\"1\":{\"269\":1}}],[\"因此student类自动有了该注解\",{\"1\":{\"230\":1}}],[\"因此这条规则并不适用\",{\"1\":{\"947\":1}}],[\"因此这种方案\",{\"1\":{\"573\":1}}],[\"因此这是一种多对一的关系\",{\"1\":{\"217\":1}}],[\"因此这两个对象的散列值是不同的\",{\"1\":{\"139\":1}}],[\"因此也可以用\",{\"1\":{\"217\":1}}],[\"因此访问权限应当尽可能地使每个类或者成员不被外界访问\",{\"1\":{\"132\":1}}],[\"因此不能确定有其他的方式\",{\"1\":{\"752\":1}}],[\"因此不能隐式地将\",{\"1\":{\"129\":1}}],[\"因此不满足第一个表达式\",{\"1\":{\"91\":1}}],[\"因此是线程安全的\",{\"1\":{\"124\":1}}],[\"因此只需要进行一次计算\",{\"1\":{\"123\":1}}],[\"因此多个\",{\"1\":{\"120\":1}}],[\"因此会执行else中的语句\",{\"1\":{\"92\":1}}],[\"因此执行第一句打印语句\",{\"1\":{\"92\":1}}],[\"因此执行第二个条件\",{\"1\":{\"92\":1}}],[\"因此如果直接写32的话\",{\"1\":{\"90\":1}}],[\"因此可以通过继承等机制来改变或扩展文法\",{\"1\":{\"641\":1}}],[\"因此可以做改进\",{\"1\":{\"583\":1}}],[\"因此可以很方便地替换具体建造者或增加新的具体建造者\",{\"1\":{\"557\":1}}],[\"因此可以用class\",{\"1\":{\"283\":1}}],[\"因此可以用来判断数字的正负\",{\"1\":{\"90\":1}}],[\"因此可以写出可读写更强\",{\"1\":{\"186\":1}}],[\"因此可以保证\",{\"1\":{\"122\":1}}],[\"因此可以借助于\",{\"1\":{\"11\":1}}],[\"因此\",{\"1\":{\"8\":1,\"125\":1,\"210\":1,\"247\":1,\"262\":1,\"264\":1,\"267\":1,\"270\":1,\"445\":1,\"452\":1,\"461\":1,\"545\":1,\"560\":1,\"608\":1,\"609\":1,\"613\":1,\"644\":1,\"682\":1,\"840\":1,\"863\":1,\"869\":1,\"937\":1,\"995\":1}}],[\"想删除就删除\",{\"1\":{\"848\":1}}],[\"想重来时就重来\",{\"1\":{\"591\":1}}],[\"想选哪配就哪配\",{\"1\":{\"589\":1}}],[\"想对方法进行\",{\"1\":{\"560\":1}}],[\"想象一下如果你不用等待代码构建完成而能实时看到代码的变化会是怎样\",{\"1\":{\"482\":1}}],[\"想象一下我们有一个更复杂的\",{\"1\":{\"446\":1}}],[\"想为你的类的变量添加\",{\"1\":{\"471\":1}}],[\"想办法解决而不是抱怨\",{\"1\":{\"36\":1}}],[\"想要再绝一点\",{\"1\":{\"89\":1}}],[\"想要成功\",{\"1\":{\"36\":1}}],[\"想要使用此布局\",{\"1\":{\"0\":1}}],[\"会依赖\",{\"1\":{\"995\":1}}],[\"会在每个测试方法前后都会被调用\",{\"1\":{\"997\":1}}],[\"会在所有方法执行结束后执行一次\",{\"1\":{\"976\":1}}],[\"会在所有方法运行前被执行\",{\"1\":{\"976\":1}}],[\"会在用户的文件系统中建立一个虚拟的硬盘\",{\"1\":{\"705\":1}}],[\"会出现在段落之间\",{\"1\":{\"956\":1}}],[\"会统计值为null的行\",{\"1\":{\"865\":1}}],[\"会翻开第\",{\"1\":{\"864\":1}}],[\"会抛出nosuchmethoderror\",{\"1\":{\"858\":1}}],[\"会抛出异常\",{\"1\":{\"779\":1}}],[\"会直接显示在页面上\",{\"1\":{\"855\":1}}],[\"会强制拆箱升级成表示范围更大的那个类型\",{\"1\":{\"852\":1}}],[\"会是同样的结果吗\",{\"1\":{\"850\":1}}],[\"会触发jdk\",{\"1\":{\"849\":1}}],[\"会触发事情处理器方法\",{\"1\":{\"700\":1}}],[\"会复用已有对象\",{\"1\":{\"848\":1}}],[\"会觉得这个代码写得莫名其妙\",{\"1\":{\"814\":1}}],[\"会觉得莫名其妙\",{\"1\":{\"764\":1}}],[\"会下蛋这些行为特性\",{\"1\":{\"813\":1}}],[\"会飞\",{\"1\":{\"813\":1}}],[\"会飞不会叫\",{\"1\":{\"812\":1}}],[\"会飞会叫\",{\"1\":{\"812\":1}}],[\"会飞的鸟类\",{\"1\":{\"812\":1}}],[\"会影响到代码的可读性\",{\"1\":{\"814\":1}}],[\"会影响其他部分\",{\"1\":{\"788\":1}}],[\"会影响依赖它的多个类\",{\"1\":{\"741\":1}}],[\"会产生很多类\",{\"1\":{\"780\":1}}],[\"会产生一个同名的\",{\"1\":{\"145\":1}}],[\"会改变订单的状态\",{\"1\":{\"779\":1}}],[\"会有\",{\"1\":{\"788\":1}}],[\"会有这样的需求吗\",{\"1\":{\"766\":1}}],[\"会有很多类\",{\"1\":{\"582\":1}}],[\"会带来诸多问题\",{\"1\":{\"763\":1}}],[\"会调用目标对象的方法\",{\"1\":{\"703\":1}}],[\"会把当前执行的目标对象方法作为参数传入\",{\"1\":{\"700\":1}}],[\"会把父类的方法也获取到\",{\"1\":{\"308\":1}}],[\"会造成内存的浪费\",{\"1\":{\"752\":1}}],[\"会造成请求处理速度变慢\",{\"1\":{\"692\":1}}],[\"会造成调用过程混乱\",{\"1\":{\"600\":1}}],[\"会比较复杂且耗时耗资源\",{\"1\":{\"682\":1}}],[\"会以集合的方式来管理用户\",{\"1\":{\"678\":1}}],[\"会形成网状结构\",{\"1\":{\"660\":1}}],[\"会生成多个迭代器不好管理类\",{\"1\":{\"652\":1}}],[\"会引起类膨胀\",{\"1\":{\"641\":1}}],[\"会引发\",{\"1\":{\"146\":1}}],[\"会主动调用\",{\"1\":{\"622\":1}}],[\"会导致迁移复杂度升高\",{\"1\":{\"854\":1}}],[\"会导致代码的可读性变差\",{\"1\":{\"764\":1,\"812\":1}}],[\"会导致这个工厂类变得很复杂\",{\"1\":{\"614\":1}}],[\"会导致后面的catch永远无法被执行\",{\"1\":{\"275\":1}}],[\"会花费大量的代价\",{\"1\":{\"610\":1}}],[\"会将一个请求封装为一个对象\",{\"1\":{\"560\":1}}],[\"会与泛型的设计思想冲突\",{\"1\":{\"294\":1}}],[\"会严重影响应用的性能\",{\"1\":{\"272\":1}}],[\"会编译不通过\",{\"1\":{\"236\":1}}],[\"会执行实际引用对象所在类的\",{\"1\":{\"211\":1}}],[\"会执行匿名内部类内的实例化初始块代码\",{\"1\":{\"92\":1}}],[\"会自动调isxxx\",{\"1\":{\"855\":1}}],[\"会自动调用\",{\"1\":{\"259\":1}}],[\"会自动关闭\",{\"1\":{\"186\":1}}],[\"会自动地将新建的对象放入\",{\"1\":{\"125\":1}}],[\"会扫描所有路径下的jar包\",{\"1\":{\"106\":1}}],[\"会遍历plugins文件夹中的目录\",{\"1\":{\"105\":1}}],[\"会去meta\",{\"1\":{\"96\":1}}],[\"会进行自动装箱\",{\"1\":{\"91\":1}}],[\"会对操作符右边的参数进行模32的取余运算\",{\"1\":{\"90\":1}}],[\"会让你做事更有效率\",{\"1\":{\"36\":1}}],[\"会使用默认运行器\",{\"1\":{\"972\":1,\"981\":1}}],[\"会使用特殊的前缀或后缀\",{\"1\":{\"937\":1}}],[\"会使用缓存池中的对象\",{\"1\":{\"120\":1}}],[\"会使用\",{\"1\":{\"11\":1}}],[\"练习在一段时间内专注于一件事\",{\"1\":{\"36\":1}}],[\"练习专注力\",{\"1\":{\"36\":1}}],[\"穿合适的衣服\",{\"1\":{\"36\":1}}],[\"每当使用实现注释来定义一个类或者成员的总体目的或者行为的时候\",{\"1\":{\"962\":1}}],[\"每当新写一个语句块或者块状结构时\",{\"1\":{\"903\":1}}],[\"每条语句的最后都有换行符\",{\"1\":{\"904\":1}}],[\"每组中的\",{\"1\":{\"892\":1}}],[\"每位数字的地位和含义是相同的\",{\"1\":{\"857\":1}}],[\"每位在网络应用中使用\",{\"1\":{\"820\":1}}],[\"每增加一个新的元素类\",{\"1\":{\"837\":1}}],[\"每添加一个策略就要增加一个类\",{\"1\":{\"791\":1}}],[\"每添加一个外部依赖都打上一个标签很麻烦\",{\"1\":{\"458\":1}}],[\"每领取一次奖品\",{\"1\":{\"778\":1}}],[\"每台计算机根据目标地址是否同自己的地址相同来决定是否接收\",{\"1\":{\"707\":1}}],[\"每盘棋都有可能有两三百个棋子对象产生\",{\"1\":{\"631\":1}}],[\"每一个表也必然有一个<resultmap>与之对应\",{\"1\":{\"866\":1}}],[\"每一个api需对应一个路径\",{\"1\":{\"854\":1}}],[\"每一个不同的实现都需要一个子类实现\",{\"1\":{\"804\":1}}],[\"每一个具体建造者都相对独立\",{\"1\":{\"557\":1}}],[\"每一层对象对应的类都必须支持深克隆\",{\"1\":{\"682\":1}}],[\"每一步的过程类\",{\"1\":{\"601\":1}}],[\"每天早上上班时间都很紧张\",{\"1\":{\"579\":1}}],[\"每天都要认真清洁自己\",{\"1\":{\"36\":1}}],[\"每封电子邮件的发件人\",{\"1\":{\"549\":1}}],[\"每被调用一次都会生成一个delegatingclassloader类加载器对象\",{\"1\":{\"312\":1}}],[\"每种类型都需要重载一个add方法\",{\"1\":{\"279\":1}}],[\"每对\",{\"1\":{\"242\":1}}],[\"每次变量声明\",{\"1\":{\"917\":1}}],[\"每次声明一个变量\",{\"0\":{\"917\":1}}],[\"每次有代码push时单元测试都会被执行\",{\"1\":{\"860\":1}}],[\"每次调用方法时都要判断当前是什么状态\",{\"1\":{\"780\":1}}],[\"每次都要返回不同的对象\",{\"1\":{\"614\":1}}],[\"每次都会新建一个对象\",{\"1\":{\"120\":1}}],[\"每次对string的操作相当于生成一个新的string对象\",{\"1\":{\"192\":1}}],[\"每个单测比较简单易懂\",{\"1\":{\"991\":1}}],[\"每个单词\",{\"1\":{\"947\":1}}],[\"每个组件都以\",{\"1\":{\"941\":1}}],[\"每个有效的标识符都可以由正则表达式\",{\"1\":{\"937\":1}}],[\"每个语句组要么会突然终止\",{\"1\":{\"924\":1}}],[\"每个语句组都包含了一个或多个\",{\"1\":{\"922\":1}}],[\"每个枚举常量的逗号之后可以选择性地换行\",{\"1\":{\"915\":1}}],[\"每个枚举值都需要调用一次构造函数\",{\"1\":{\"172\":1}}],[\"每个\",{\"1\":{\"905\":1,\"925\":1,\"958\":1}}],[\"每个顶级类都定义在它们的源文件中\",{\"1\":{\"895\":1}}],[\"每个版本的变化应该被记录\",{\"1\":{\"869\":1}}],[\"每个case要么通过continue\",{\"1\":{\"852\":1}}],[\"每个线程退出前必须调用countdown方法\",{\"1\":{\"851\":1}}],[\"每个线程在想获得类的实例时候\",{\"1\":{\"755\":1}}],[\"每个软件开发者都经历过许多相似的故事\",{\"1\":{\"820\":1}}],[\"每个阶段的开发工作量都不会很大\",{\"1\":{\"818\":1}}],[\"每个会下蛋的鸟都要实现一遍\",{\"1\":{\"813\":1}}],[\"每个状态都要一个对应的类\",{\"1\":{\"780\":1}}],[\"每个状态都实现它\",{\"1\":{\"778\":1}}],[\"每个对象都会与其他对象有耦合关系\",{\"1\":{\"741\":1}}],[\"每个对象只需保持一个指向其后继者的引用\",{\"1\":{\"707\":1}}],[\"每个人的身份证号等\",{\"1\":{\"762\":1}}],[\"每个人必须记住所有朋友电话\",{\"1\":{\"655\":1}}],[\"每个人必须记住他\",{\"1\":{\"655\":1}}],[\"每个人都是先从外表认识他人的\",{\"1\":{\"36\":1}}],[\"每个运算符号\",{\"1\":{\"644\":1}}],[\"每个类的职责都比较单一\",{\"1\":{\"741\":1}}],[\"每个类只需要处理自己该处理的工作\",{\"1\":{\"707\":1}}],[\"每个类对象的创建需要依赖哪些其他类对象\",{\"1\":{\"621\":1}}],[\"每个类都应该使用该类的维护者可以解释清楚的\",{\"1\":{\"896\":1}}],[\"每个类都会有一个与之对应的class实例\",{\"1\":{\"313\":1}}],[\"每个类都有一个\",{\"1\":{\"145\":1}}],[\"每个包裹扫一遍\",{\"1\":{\"591\":1}}],[\"每个接收者都包含对下一个接收者的引用\",{\"1\":{\"591\":1}}],[\"每个通过关键字class标识的类\",{\"1\":{\"302\":1}}],[\"每个java类运行时都在jvm里表现为一个class对象\",{\"1\":{\"302\":1}}],[\"每创建一个实例就会产生一个实例变量\",{\"1\":{\"144\":1}}],[\"每晚复盘\",{\"1\":{\"36\":1}}],[\"但第一个用例会删除这个用户a\",{\"1\":{\"972\":1}}],[\"但必须是public\",{\"1\":{\"972\":1}}],[\"但必须考虑数据一致\",{\"1\":{\"863\":1}}],[\"但常量究竟意味着什么\",{\"1\":{\"942\":1}}],[\"但有时候也可能是形容词或形容词短语\",{\"1\":{\"940\":1}}],[\"但却难以日后维护\",{\"1\":{\"912\":1}}],[\"但除了以下提及的几个例外\",{\"1\":{\"959\":1}}],[\"但除了\",{\"1\":{\"911\":1}}],[\"但比较笨拙和易出错\",{\"1\":{\"885\":1}}],[\"但没理由这么做\",{\"1\":{\"885\":1}}],[\"但并不意味着这是编写优雅代码的唯一方式\",{\"1\":{\"878\":1}}],[\"但并不具有继承关系\",{\"1\":{\"814\":1}}],[\"但核心关键点上的必要设计和文档沉淀是需要的\",{\"1\":{\"871\":1}}],[\"但truncate无事务且不触发trigger\",{\"1\":{\"865\":1}}],[\"但sum\",{\"1\":{\"865\":1}}],[\"但提高查找速度是明显的\",{\"1\":{\"864\":1}}],[\"但很不幸\",{\"1\":{\"854\":1}}],[\"但已经被广泛使用\",{\"1\":{\"853\":1}}],[\"但已经逐步\",{\"1\":{\"125\":1}}],[\"但目前还未实现的功能\",{\"1\":{\"853\":1}}],[\"但接口实现上没做任何保护\",{\"1\":{\"852\":1}}],[\"但因为并发处理错误导致奖品数量瞬间变成了负数\",{\"1\":{\"852\":1}}],[\"但会因竞争同一seed导致的性能下降\",{\"1\":{\"851\":1}}],[\"但小于size\",{\"1\":{\"850\":1}}],[\"但事实上equals的结果为false\",{\"1\":{\"848\":1}}],[\"但事实上a\",{\"1\":{\"848\":1}}],[\"但父类并不知道子类的定义只有知道对方信息时才能指向对方箭头的方向是从子类指向父类\",{\"1\":{\"835\":1}}],[\"但如果建造蚂蚁z空间大楼\",{\"1\":{\"871\":1}}],[\"但如果因为参数错误导致中间执行回退\",{\"1\":{\"852\":1}}],[\"但如果学校停办了\",{\"1\":{\"831\":1}}],[\"但如果我们还关注\",{\"1\":{\"812\":1}}],[\"但仅仅几个月后\",{\"1\":{\"820\":1}}],[\"但几个月后开始流行原型按钮\",{\"1\":{\"820\":1}}],[\"但实际返回为false\",{\"1\":{\"846\":1}}],[\"但实际上要让已有的代码在全新的代码中工作\",{\"1\":{\"819\":1}}],[\"但实际这是一颗java语法糖\",{\"1\":{\"193\":1}}],[\"但组合也并不是完美的\",{\"1\":{\"814\":1}}],[\"但组件接口定义和自己要求的接口定义不同\",{\"1\":{\"535\":1}}],[\"但也有特例\",{\"1\":{\"812\":1}}],[\"但继承层次过深\",{\"1\":{\"812\":1}}],[\"但继承具有静态特征\",{\"1\":{\"580\":1}}],[\"但调用将以抽象类中定义的方式进行\",{\"1\":{\"800\":1}}],[\"但某些步骤的具体实现还未知\",{\"1\":{\"800\":1}}],[\"但对大项目的开发或者框架设计\",{\"1\":{\"797\":1}}],[\"但对已有的类进行改造时\",{\"1\":{\"690\":1}}],[\"但同时也要避免设计过度\",{\"1\":{\"797\":1}}],[\"但线程唯一单例的代码实现很简单\",{\"1\":{\"771\":1}}],[\"但我不用不行啊\",{\"1\":{\"769\":1}}],[\"但之后我们发现\",{\"1\":{\"766\":1}}],[\"但又经常用到的对象\",{\"1\":{\"761\":1}}],[\"但它是一种更强烈的聚合关系\",{\"1\":{\"832\":1}}],[\"但它同样可以用于描述非软件领域的系统\",{\"1\":{\"823\":1}}],[\"但它也存在以下缺点\",{\"1\":{\"747\":1}}],[\"但它们与当前系统的接口规范不兼容\",{\"1\":{\"518\":1}}],[\"但整个继承体系的复用性会比较差\",{\"1\":{\"734\":1}}],[\"但两者是不同的\",{\"1\":{\"721\":1}}],[\"但两者可以结合使用\",{\"1\":{\"549\":1}}],[\"但具体由哪个对象处理该请求在运行时自动确定\",{\"1\":{\"712\":1}}],[\"但每个领导能批准的天数不同\",{\"1\":{\"707\":1}}],[\"但左右两个数字有可能也是一个解析的结果\",{\"1\":{\"644\":1}}],[\"但位置是变化的\",{\"1\":{\"631\":1}}],[\"但由于叶子和分支有不同的接口\",{\"1\":{\"570\":1}}],[\"但其操作算法经常变化的程序\",{\"1\":{\"841\":1}}],[\"但其中个别部分易变时\",{\"1\":{\"805\":1}}],[\"但其不能对备忘录的内容进行访问与修改\",{\"1\":{\"664\":1}}],[\"但其缺点是\",{\"1\":{\"569\":1}}],[\"但其创建步骤都大同小异\",{\"1\":{\"549\":1}}],[\"但其接口同新系统的接口不一致\",{\"1\":{\"535\":1}}],[\"但基本只对收录的资源做了极为简要的介绍\",{\"1\":{\"383\":1}}],[\"但不推荐的\",{\"1\":{\"947\":1}}],[\"但不得不填充错误码时返回五个零\",{\"1\":{\"857\":1}}],[\"但不包含属性\",{\"1\":{\"825\":1}}],[\"但不包括继承的方法\",{\"1\":{\"308\":1}}],[\"但不够优美\",{\"1\":{\"812\":1}}],[\"但不是继承\",{\"1\":{\"745\":1}}],[\"但不能不干净\",{\"1\":{\"36\":1}}],[\"但最终其实际值是不会发生改变的\",{\"1\":{\"307\":1}}],[\"但引用的类还没有加载\",{\"1\":{\"305\":1}}],[\"但这种情况下\",{\"1\":{\"930\":1}}],[\"但这可能会触发一系列的代码格式化\",{\"1\":{\"912\":1}}],[\"但这不是本文档所要求的\",{\"1\":{\"910\":1}}],[\"但这就暴露了对象内部的细节\",{\"1\":{\"666\":1}}],[\"但这也是继承的一大缺点\",{\"1\":{\"545\":1}}],[\"但这经常会给同一个异常输出多条日志\",{\"1\":{\"270\":1}}],[\"但这仅仅是一个语法糖\",{\"1\":{\"170\":1}}],[\"但现实是经常会出现无法预料的异常\",{\"1\":{\"269\":1}}],[\"但问题在于\",{\"1\":{\"267\":1}}],[\"但finally语句块后的语句不会被执行\",{\"1\":{\"257\":1}}],[\"但在\",{\"1\":{\"912\":1}}],[\"但在之前换行也可以接受\",{\"1\":{\"907\":1}}],[\"但在运行时产生异常\",{\"1\":{\"869\":1}}],[\"但在运行时会被系统抛出\",{\"1\":{\"252\":1}}],[\"但在linux下默认是区分大小写\",{\"1\":{\"863\":1}}],[\"但在测试质量的保障上\",{\"1\":{\"860\":1}}],[\"但在代码运行期时\",{\"1\":{\"858\":1}}],[\"但在方法说明里必须注明外部参数检查\",{\"1\":{\"852\":1}}],[\"但在不改变其结构的情况下\",{\"1\":{\"579\":1}}],[\"但在一定程度上它的发生是可以预计的\",{\"1\":{\"249\":1}}],[\"但定义注解时依然无法使用extends关键字继承\",{\"1\":{\"237\":1}}],[\"但注解在编译后\",{\"1\":{\"237\":1}}],[\"但可以让耦合关系没那么紧密\",{\"1\":{\"818\":1}}],[\"但可以利用变量c的newinstance方法去创建对象\",{\"1\":{\"283\":1}}],[\"但可以通过对象对外提供的接口来访问该对象\",{\"1\":{\"209\":1}}],[\"但可读性大大降低\",{\"1\":{\"144\":1}}],[\"但要求编写者一定要在使用前给变量赋值\",{\"1\":{\"205\":1}}],[\"但变量不初始化为默认值就使用是不安全的\",{\"1\":{\"205\":1}}],[\"但非静态内部类需要持有对外部类的引用\",{\"1\":{\"201\":1}}],[\"但能实现多个接口\",{\"1\":{\"194\":1}}],[\"但字符串常量池\",{\"1\":{\"125\":1}}],[\"但是其中某个参数无论是什么值都不会影响测试的结果\",{\"1\":{\"996\":1}}],[\"但是大家在设计评审中经常出现语焉不详\",{\"1\":{\"871\":1}}],[\"但是合并成一个war\",{\"1\":{\"869\":1}}],[\"但是接口返回值不允许使用枚举类型或者包含枚举类型的pojo对象\",{\"1\":{\"869\":1}}],[\"但是参数可能会进行字符串拼接运算\",{\"1\":{\"859\":1}}],[\"但是参数类型\",{\"1\":{\"135\":1}}],[\"但是请勿互相越俎代庖\",{\"1\":{\"857\":1}}],[\"但是字典不容易随身携带且简单易懂\",{\"1\":{\"857\":1}}],[\"但是类名如果有复数含义\",{\"1\":{\"845\":1}}],[\"但是成员对象可以脱离整体对象而独立存在\",{\"1\":{\"831\":1}}],[\"但是办理具体业务却因人而异\",{\"1\":{\"800\":1}}],[\"但是自己却不知道\",{\"1\":{\"794\":1}}],[\"但是飞翔技术一般\",{\"1\":{\"789\":1}}],[\"但是显然这种做法对复杂的状态判断存在天然弊端\",{\"1\":{\"775\":1}}],[\"但是个数是有限制的\",{\"1\":{\"773\":1}}],[\"但是效率太低了\",{\"1\":{\"755\":1}}],[\"但是只能在单线程下使用\",{\"1\":{\"754\":1}}],[\"但是只会用到\",{\"1\":{\"723\":4}}],[\"但是可能造成内存浪费\",{\"1\":{\"753\":1}}],[\"但是可以作为一种参考和梳理依赖的手段\",{\"1\":{\"817\":1}}],[\"但是可以通过文档告诉你的用户在这里可能会有异常抛出\",{\"1\":{\"448\":1}}],[\"但是可以看到\",{\"1\":{\"311\":1}}],[\"但是可以实现多个接口\",{\"1\":{\"189\":1}}],[\"但是可以有多个\",{\"1\":{\"178\":1}}],[\"但是导致类装载的原因有很多种\",{\"1\":{\"752\":1}}],[\"但是注意\",{\"1\":{\"744\":1}}],[\"但是原来的对象成型\",{\"1\":{\"702\":1}}],[\"但是原来的目标对象成型\",{\"1\":{\"699\":1}}],[\"但是有时候目标对象只是一个\",{\"1\":{\"702\":1}}],[\"但是有一点我们可以确定的是\",{\"1\":{\"103\":1}}],[\"但是该方法需要接收三个参数\",{\"1\":{\"699\":1}}],[\"但是目标对象要实现接口\",{\"1\":{\"698\":1}}],[\"但是需要实现\",{\"1\":{\"686\":1}}],[\"但是每个聚合对象都要一个迭代器\",{\"1\":{\"652\":1}}],[\"但是相比较简单工厂模式\",{\"1\":{\"613\":1}}],[\"但是考虑到项目的规模\",{\"1\":{\"613\":1}}],[\"但是花费的代价非常小\",{\"1\":{\"610\":1}}],[\"但是为了测试代码能够正常编译\",{\"1\":{\"996\":1}}],[\"但是为了迎合\",{\"1\":{\"610\":1}}],[\"但是为了以命令的形式进行架构\",{\"1\":{\"560\":1}}],[\"但是并不知道请求的接收者是谁\",{\"1\":{\"560\":1}}],[\"但是产生的结果又不相同\",{\"1\":{\"558\":1}}],[\"但是要避免使用\",{\"1\":{\"845\":1}}],[\"但是要求都有些不同\",{\"1\":{\"633\":1}}],[\"但是要求不要相同的\",{\"1\":{\"552\":1}}],[\"但是要注意区分下面的一种情况\",{\"1\":{\"296\":1}}],[\"但是很可能你使用的\",{\"1\":{\"476\":1}}],[\"但是很难去维护它\",{\"1\":{\"474\":1}}],[\"但是对流行的\",{\"1\":{\"484\":1}}],[\"但是对\",{\"1\":{\"472\":1}}],[\"但是现在希望对程序进行\",{\"1\":{\"820\":1}}],[\"但是现在我等不急了\",{\"1\":{\"471\":1}}],[\"但是现在来看\",{\"1\":{\"464\":1}}],[\"但是我们需要包括\",{\"1\":{\"823\":1}}],[\"但是我们希望能重写这个类在运行时执行的\",{\"1\":{\"814\":1}}],[\"但是我的观点没那么极端\",{\"1\":{\"814\":1}}],[\"但是我用\",{\"1\":{\"485\":1}}],[\"但是我会尽力的\",{\"1\":{\"466\":1}}],[\"但是我只用过\",{\"1\":{\"460\":1}}],[\"但是我偏不\",{\"1\":{\"90\":1}}],[\"但是他们同样都没有像\",{\"1\":{\"458\":1}}],[\"但是别在为了\",{\"1\":{\"453\":1}}],[\"但是它真的能够帮你解决很复杂的\",{\"1\":{\"481\":1}}],[\"但是它的旗舰版加载了更多的牛逼的特性\",{\"1\":{\"480\":1}}],[\"但是它的父类person被注解\",{\"1\":{\"230\":1}}],[\"但是它们都有着各自的优缺点\",{\"1\":{\"461\":1}}],[\"但是它允许你可以这样写\",{\"1\":{\"450\":1}}],[\"但是一旦你调用了\",{\"1\":{\"446\":1}}],[\"但是一个学生只属于一个学校\",{\"1\":{\"217\":1}}],[\"但是似乎并没有什么人很享受用它\",{\"1\":{\"443\":1}}],[\"但是看起来非常有前途\",{\"1\":{\"427\":1}}],[\"但是也只能获取到public修饰的的字段\",{\"1\":{\"307\":1}}],[\"但是也有例外\",{\"1\":{\"132\":1}}],[\"但是泛型的出现就是为了消灭\",{\"1\":{\"294\":1}}],[\"但是在进行单元测试时\",{\"1\":{\"996\":1}}],[\"但是在方法级别上\",{\"1\":{\"718\":1}}],[\"但是在内部类\",{\"1\":{\"305\":1}}],[\"但是在异常声明中可以使用类型变量\",{\"1\":{\"297\":1}}],[\"但是在取出数据的时候却要做一次类型转换\",{\"1\":{\"294\":1}}],[\"但是在编译阶段会进行所谓的\",{\"1\":{\"278\":1,\"287\":1}}],[\"但是object类型不能存储int值\",{\"1\":{\"292\":1}}],[\"但是虚拟机却是允许这样做的\",{\"1\":{\"291\":1}}],[\"但是擦除类型后他们的就成为原始的pair类型了\",{\"1\":{\"289\":1}}],[\"但是会有警告\",{\"1\":{\"285\":2,\"294\":2}}],[\"但是没有做任何处理或者记录日志\",{\"1\":{\"269\":1}}],[\"但是没有关于不相等对象的任何规定\",{\"1\":{\"175\":1}}],[\"但是如果攻击人员使用的是特殊构造的字符串来验证\",{\"1\":{\"861\":1}}],[\"但是如果多写\",{\"1\":{\"851\":1}}],[\"但是如果子类对这些已经实现的方法任意修改\",{\"1\":{\"731\":1}}],[\"但是如果我们在其它的地方也有创建\",{\"1\":{\"609\":1}}],[\"但是如果你的产品足够大\",{\"1\":{\"458\":1}}],[\"但是如果结合注解将可以极大程度提高实现的优雅度\",{\"1\":{\"241\":1}}],[\"但是如果在程序中\",{\"1\":{\"832\":1}}],[\"但是如果在方法中改变对象的字段值会改变原对象该字段值\",{\"1\":{\"127\":1}}],[\"但是如果在判断条件中动一点点手脚\",{\"1\":{\"92\":1}}],[\"但是公司和员工就属于聚合关系了\",{\"1\":{\"216\":1}}],[\"但是整体和部分不是强依赖的\",{\"1\":{\"215\":1}}],[\"但是用这个修饰符也有一定的限制\",{\"1\":{\"204\":1}}],[\"但是通常会重写equals方法去实现对象内容的比较\",{\"1\":{\"191\":1}}],[\"但是最重要的一个是\",{\"1\":{\"189\":1}}],[\"但是什么时候调用\",{\"1\":{\"182\":1}}],[\"但是包含的字母相同的比较\",{\"1\":{\"180\":1}}],[\"但是不建议经常这么做\",{\"1\":{\"972\":1}}],[\"但是不建议使用\",{\"1\":{\"162\":1}}],[\"但是不同的version\",{\"1\":{\"869\":1}}],[\"但是不小心c\",{\"1\":{\"734\":1}}],[\"但是不管怎么\",{\"1\":{\"579\":1}}],[\"但是不可用\",{\"1\":{\"151\":1}}],[\"但是不能继承多个抽象类\",{\"1\":{\"133\":1}}],[\"但是这一行新增数据并不符合业务插入规则\",{\"1\":{\"860\":1}}],[\"但是这样做的改动很大\",{\"1\":{\"718\":1}}],[\"但是这些独立的模块却有可能是可用的\",{\"1\":{\"209\":1}}],[\"但是这个属性在数据提取时并没有置入具体值\",{\"1\":{\"848\":1}}],[\"但是这个区间之外的所有数据\",{\"1\":{\"848\":1}}],[\"但是这个值后面被其他人改变了\",{\"1\":{\"183\":1}}],[\"但是这个访问修饰符对于类没有意义\",{\"1\":{\"132\":1}}],[\"但是这是语言内置支持的操作\",{\"1\":{\"151\":1}}],[\"但是被引用的对象本身是可以修改的\",{\"1\":{\"143\":1}}],[\"但是因为\",{\"1\":{\"139\":1}}],[\"但是散列值相同的两个对象不一定等价\",{\"1\":{\"139\":1}}],[\"但是使用\",{\"1\":{\"129\":1}}],[\"但是跟spi有啥关系呢\",{\"1\":{\"103\":1}}],[\"但是\",{\"1\":{\"91\":1,\"151\":1,\"161\":1,\"168\":1,\"186\":1,\"188\":1,\"209\":1,\"264\":1,\"265\":1,\"450\":1,\"614\":1,\"627\":1,\"722\":1,\"727\":1,\"763\":2,\"765\":1,\"814\":1,\"819\":1,\"996\":1}}],[\"但是你可以很简单地仅仅使用它的\",{\"1\":{\"472\":1}}],[\"但是你永远不应该这样做\",{\"1\":{\"268\":1}}],[\"但是你的客户端仍然在使用老的值\",{\"1\":{\"183\":1}}],[\"但是你如果写成下面这样\",{\"1\":{\"89\":1}}],[\"但是你需要使用相对链接\",{\"1\":{\"33\":1}}],[\"邋遢的外表也会让人望而却步\",{\"1\":{\"36\":1}}],[\"注释一起使用\",{\"1\":{\"979\":1}}],[\"注释不会被包含在由星号或者其它字符绘制的框中\",{\"1\":{\"933\":1}}],[\"注释块可以是\",{\"1\":{\"933\":1}}],[\"注释块与它周围的代码拥有相同的缩进级别\",{\"1\":{\"933\":1}}],[\"注释块样式\",{\"0\":{\"933\":1}}],[\"注释和\",{\"1\":{\"911\":1}}],[\"注释中可以被复制粘贴到\",{\"1\":{\"905\":1}}],[\"注释是非常有必要的\",{\"1\":{\"885\":1}}],[\"注释是给自己看的\",{\"1\":{\"853\":1}}],[\"注释力求精简准确\",{\"1\":{\"853\":1}}],[\"注释也是给继任者看的\",{\"1\":{\"853\":1}}],[\"注释也要进行相应的修改\",{\"1\":{\"853\":1}}],[\"注释\",{\"0\":{\"932\":1},\"1\":{\"853\":2,\"877\":1}}],[\"注释规约\",{\"0\":{\"853\":1}}],[\"注释的双斜线与注释内容之间有且仅有一个空格\",{\"1\":{\"847\":1}}],[\"注释之前的内容被视为文章摘要\",{\"1\":{\"31\":1}}],[\"注册国家或地区受限\",{\"1\":{\"874\":1}}],[\"注册到\",{\"1\":{\"678\":1}}],[\"注册一个观察者\",{\"1\":{\"678\":1}}],[\"注\",{\"1\":{\"199\":1,\"271\":1,\"854\":1,\"869\":1}}],[\"注解的\",{\"1\":{\"477\":1}}],[\"注解的应用场景\",{\"0\":{\"239\":1}}],[\"注解实现的原理\",{\"0\":{\"238\":1}}],[\"注解支持继承吗\",{\"0\":{\"237\":1}}],[\"注解与反射接口\",{\"0\":{\"233\":1}}],[\"注解不常使用\",{\"1\":{\"232\":1}}],[\"注解不会也不能影响代码的实际逻辑\",{\"1\":{\"148\":1}}],[\"注解修饰成员变量\",{\"1\":{\"232\":1}}],[\"注解类型的命名没有特定的规则或者完善的约定\",{\"1\":{\"940\":1}}],[\"注解类型\",{\"1\":{\"877\":1}}],[\"注解类型进行注解的注解类\",{\"1\":{\"226\":1}}],[\"注解类\",{\"1\":{\"227\":2}}],[\"注解可以用于修饰\",{\"1\":{\"227\":1}}],[\"注解基础\",{\"0\":{\"221\":1}}],[\"注解是不支持继承的\",{\"1\":{\"237\":1}}],[\"注解是jdk1\",{\"1\":{\"220\":1,\"221\":1}}],[\"注解是附加在代码中的一些元信息\",{\"1\":{\"148\":1}}],[\"注解机制详解\",{\"0\":{\"220\":1},\"1\":{\"148\":1}}],[\"注解\",{\"0\":{\"148\":1,\"926\":1},\"1\":{\"135\":1,\"450\":2,\"949\":1,\"997\":1,\"998\":1,\"999\":1}}],[\"注意例如\",{\"1\":{\"947\":1}}],[\"注意在\",{\"1\":{\"924\":1}}],[\"注意在前面加一下super\",{\"1\":{\"848\":1}}],[\"注意对扩展开放\",{\"1\":{\"871\":1}}],[\"注意起始版本号必须为\",{\"1\":{\"869\":1}}],[\"注意超过\",{\"1\":{\"868\":1,\"873\":1}}],[\"注意它与utf8编码的区别\",{\"1\":{\"865\":1}}],[\"注意count\",{\"1\":{\"865\":1}}],[\"注意日志输出的级别\",{\"1\":{\"859\":1}}],[\"注意npe产生的场景\",{\"1\":{\"858\":1}}],[\"注意除零异常\",{\"1\":{\"855\":1}}],[\"注意取值的范围\",{\"1\":{\"855\":1}}],[\"注意math\",{\"1\":{\"855\":1}}],[\"注意如果是boolean包装类对象\",{\"1\":{\"855\":1}}],[\"注意均是浅拷贝\",{\"1\":{\"855\":1}}],[\"注意及时处理这些标记\",{\"1\":{\"853\":1}}],[\"注意与代码对齐\",{\"1\":{\"853\":1}}],[\"注意idea的\",{\"1\":{\"853\":1}}],[\"注意break是退出switch语句块\",{\"1\":{\"852\":1}}],[\"注意线程安全\",{\"1\":{\"851\":1}}],[\"注意负载因子\",{\"1\":{\"850\":1}}],[\"注意date\",{\"1\":{\"849\":1}}],[\"注意serialversionuid不一致会抛出序列化运行时异常\",{\"1\":{\"848\":1}}],[\"注意这仅适用于没有类似于\",{\"1\":{\"955\":1}}],[\"注意这与其它语言的\",{\"1\":{\"907\":1}}],[\"注意这可不是唯一标准\",{\"1\":{\"823\":1}}],[\"注意这里不要和继承的\",{\"1\":{\"284\":1}}],[\"注意代理的类不能为\",{\"1\":{\"703\":1}}],[\"注意划分内部状态和外部状态\",{\"1\":{\"638\":1}}],[\"注意月份下标从\",{\"1\":{\"618\":1}}],[\"注意不要包含敏感数据信息\",{\"1\":{\"854\":1}}],[\"注意不要过度使用\",{\"1\":{\"449\":1}}],[\"注意不包含父类的字段\",{\"1\":{\"307\":2}}],[\"注意修饰符为public才会获取\",{\"1\":{\"307\":1}}],[\"注意字段修饰符必须为public而且存在该字段\",{\"1\":{\"307\":1}}],[\"注意到\",{\"1\":{\"209\":1}}],[\"注意\",{\"1\":{\"41\":1,\"197\":1,\"233\":1,\"252\":1,\"421\":1,\"646\":1,\"727\":1,\"835\":1,\"845\":1,\"851\":1,\"863\":1,\"892\":1,\"898\":1,\"906\":1,\"907\":1,\"947\":2,\"972\":4,\"997\":1}}],[\"注意仪容仪表\",{\"1\":{\"36\":1}}],[\"相应地\",{\"1\":{\"741\":1}}],[\"相应的原始类型都会被自动提供\",{\"1\":{\"289\":1}}],[\"相近的功能都放到了一个类中\",{\"1\":{\"741\":1}}],[\"相近的功能往往会被同时修改\",{\"1\":{\"741\":1}}],[\"相互之间的调用关系会比较复杂\",{\"1\":{\"658\":1}}],[\"相似\",{\"1\":{\"642\":1}}],[\"相当于保护案发现场\",{\"1\":{\"868\":1}}],[\"相当于\",{\"1\":{\"788\":1}}],[\"相当于让请求流动起来\",{\"1\":{\"708\":1}}],[\"相当于代理对象的雏形\",{\"1\":{\"703\":1}}],[\"相当于jdk动态代理需要的\",{\"1\":{\"702\":1}}],[\"相当于一个相同网站的实例对象很多\",{\"1\":{\"635\":1}}],[\"相当于x除以2\",{\"1\":{\"203\":1}}],[\"相当于x乘以2\",{\"1\":{\"203\":1}}],[\"相同方式共享\",{\"1\":{\"993\":1}}],[\"相同的artifactid\",{\"1\":{\"869\":1}}],[\"相同的方法\",{\"1\":{\"558\":1}}],[\"相同\",{\"1\":{\"850\":1,\"929\":1}}],[\"相同业务含义\",{\"1\":{\"848\":1}}],[\"相同参数类型\",{\"1\":{\"848\":1}}],[\"相同功能的代码\",{\"1\":{\"797\":1}}],[\"相同对象只要保存一份\",{\"1\":{\"629\":1}}],[\"相片加相框等\",{\"1\":{\"579\":1}}],[\"相反地\",{\"1\":{\"918\":1}}],[\"相反它们把注入逻辑以注解的方式写到代码中\",{\"1\":{\"449\":1}}],[\"相反\",{\"1\":{\"445\":1,\"810\":1,\"818\":1}}],[\"相对具体的业务逻辑服务层\",{\"1\":{\"868\":1}}],[\"相对于编码规范\",{\"1\":{\"816\":1}}],[\"相对于细节的多变性\",{\"1\":{\"725\":1}}],[\"相对于直接\",{\"1\":{\"606\":1}}],[\"相对apache\",{\"1\":{\"385\":1}}],[\"相对客户的请求而言\",{\"1\":{\"265\":1}}],[\"相等为true\",{\"1\":{\"191\":1}}],[\"相等\",{\"1\":{\"175\":1}}],[\"相关的操作\",{\"1\":{\"814\":1}}],[\"相关的关键字\",{\"1\":{\"196\":1}}],[\"相关方法\",{\"1\":{\"600\":1}}],[\"相关文章\",{\"1\":{\"145\":1,\"146\":1,\"147\":1,\"148\":1}}],[\"相关信息\",{\"1\":{\"10\":1}}],[\"相乘可以转换成移位和减法\",{\"1\":{\"139\":1}}],[\"相乘相当于向左移一位\",{\"1\":{\"139\":1}}],[\"相信大家在掌握了这些技巧后\",{\"1\":{\"94\":1}}],[\"相信大家可以轻易理解\",{\"1\":{\"90\":1}}],[\"相比成功而言\",{\"1\":{\"36\":1}}],[\"不单单指的是数据\",{\"1\":{\"997\":1}}],[\"不易理解的\",{\"1\":{\"992\":1}}],[\"不易维护\",{\"1\":{\"783\":1}}],[\"不止运行一次\",{\"1\":{\"972\":1}}],[\"不使用下划线\",{\"1\":{\"939\":1}}],[\"不使用jni就可以使用原生开发库\",{\"1\":{\"417\":1}}],[\"不\",{\"1\":{\"937\":1,\"958\":1}}],[\"不全\",{\"1\":{\"920\":1}}],[\"不鼓励也不反对将单个空行出现在类的第一个成员或初始化方法的之前\",{\"1\":{\"910\":1}}],[\"不必\",{\"1\":{\"907\":1}}],[\"不必知道产品内部组成的细节\",{\"1\":{\"557\":1}}],[\"不论它显示得更宽或者更窄\",{\"1\":{\"905\":1}}],[\"不论发生什么异常\",{\"1\":{\"275\":1}}],[\"不应被分离\",{\"0\":{\"897\":1}}],[\"不应该表示实体数量\",{\"1\":{\"863\":1}}],[\"不应该影响父类方法的含义\",{\"1\":{\"748\":1}}],[\"不应该随着内部状态的改变而改变\",{\"1\":{\"638\":1}}],[\"不应该直接去\",{\"1\":{\"609\":1}}],[\"不应该使用异常控制应用的执行流程\",{\"1\":{\"272\":1}}],[\"不适用于\",{\"1\":{\"888\":1,\"891\":1}}],[\"不适合分布式\",{\"1\":{\"865\":1}}],[\"不适合使用组合模式\",{\"1\":{\"576\":1}}],[\"不规范\",{\"1\":{\"878\":1}}],[\"不稳定指的是提供方无法做到向下兼容\",{\"1\":{\"869\":1}}],[\"不依赖snapshot版本是保证应用发布的幂等性\",{\"1\":{\"869\":1}}],[\"不依赖不稳定的实现细节\",{\"1\":{\"808\":1,\"810\":1}}],[\"不预先分配存储空间\",{\"1\":{\"863\":1}}],[\"不建议项目发布后补充单元测试用例\",{\"1\":{\"860\":1}}],[\"不建议在方法里\",{\"1\":{\"744\":1}}],[\"不给数据库造成脏数据\",{\"1\":{\"860\":1}}],[\"不准使用system\",{\"1\":{\"860\":1}}],[\"不强制返回空集合\",{\"1\":{\"858\":1}}],[\"不安全\",{\"1\":{\"854\":1,\"870\":1}}],[\"不如用中文注释说清楚\",{\"1\":{\"853\":1}}],[\"不如在新对象中重用已有的代码\",{\"1\":{\"819\":1}}],[\"不进入方法即可悬浮提示方法\",{\"1\":{\"853\":1}}],[\"不符合第一个条件\",{\"1\":{\"850\":1}}],[\"不然arrays\",{\"1\":{\"850\":1}}],[\"不虚\",{\"1\":{\"835\":1}}],[\"不互相干扰\",{\"1\":{\"818\":1}}],[\"不定义实现\",{\"1\":{\"813\":1}}],[\"不就可以了吗\",{\"1\":{\"812\":1}}],[\"不让子类去覆盖\",{\"1\":{\"803\":1}}],[\"不添加任何的配料\",{\"1\":{\"803\":1}}],[\"不用换行\",{\"1\":{\"847\":1}}],[\"不用多次编写\",{\"1\":{\"797\":1}}],[\"不用重新初始化对象\",{\"1\":{\"690\":1}}],[\"不但节约数据库表空间\",{\"1\":{\"863\":1}}],[\"不但使条件语句变得很复杂\",{\"1\":{\"783\":1}}],[\"不但会产出很多\",{\"1\":{\"780\":1}}],[\"不但对应的子类很多\",{\"1\":{\"537\":1}}],[\"不停的变化\",{\"1\":{\"779\":1}}],[\"不知道你有没有发现\",{\"1\":{\"768\":1}}],[\"不知道接下来要走的是哪一个分支\",{\"1\":{\"91\":1}}],[\"不明白设计意图的人\",{\"1\":{\"764\":1}}],[\"不友好\",{\"1\":{\"764\":1}}],[\"不推荐使用\",{\"1\":{\"756\":1,\"866\":1}}],[\"不推荐\",{\"1\":{\"755\":1}}],[\"不和陌生人说话\",{\"1\":{\"748\":1}}],[\"不该有直接依赖关系的类之间\",{\"1\":{\"818\":1}}],[\"不该知道的不要知道\",{\"1\":{\"748\":1}}],[\"不该处理的传递给下一个对象完成\",{\"1\":{\"707\":1}}],[\"不暴露类的属性成员\",{\"1\":{\"741\":1}}],[\"不暴露其内部的结构\",{\"1\":{\"648\":1}}],[\"不相近的功能放到了一个类中\",{\"1\":{\"741\":1}}],[\"不相近的功能被分割到了多个类中\",{\"1\":{\"741\":1}}],[\"不相近的功能不要放到同一个类中\",{\"1\":{\"741\":1}}],[\"不对外泄露任何信息\",{\"1\":{\"741\":1}}],[\"不够灵活\",{\"1\":{\"686\":1}}],[\"不破坏封装性的前提下\",{\"1\":{\"663\":1}}],[\"不利于系统性能提升\",{\"1\":{\"859\":1}}],[\"不利于模块解耦\",{\"1\":{\"848\":1}}],[\"不利于理解\",{\"1\":{\"846\":1}}],[\"不利于程序的扩展\",{\"1\":{\"775\":1}}],[\"不利于代码的扩展和维护\",{\"1\":{\"709\":1}}],[\"不利于维护\",{\"1\":{\"677\":1}}],[\"不利于管理\",{\"1\":{\"666\":1}}],[\"不利于松耦合\",{\"1\":{\"658\":1}}],[\"不利于在\",{\"1\":{\"600\":1}}],[\"不存在\",{\"1\":{\"632\":2}}],[\"不存在也可以加载进来\",{\"1\":{\"145\":1}}],[\"不涉及我们要讲的理论知识\",{\"1\":{\"626\":1}}],[\"不只是简单的\",{\"1\":{\"614\":1}}],[\"不会总是出现在一个重写了父类方法的方法中\",{\"1\":{\"961\":1}}],[\"不会在原有代码交付物上进行任何形式的修改\",{\"1\":{\"871\":1}}],[\"不会在方法外可见\",{\"1\":{\"204\":1}}],[\"不会统计此列为null值的行\",{\"1\":{\"865\":1}}],[\"不会影响到另一个模块或类\",{\"1\":{\"818\":1}}],[\"不会轻易改变\",{\"1\":{\"814\":1}}],[\"不会飞不会叫\",{\"1\":{\"812\":1}}],[\"不会飞会叫\",{\"1\":{\"812\":1}}],[\"不会飞的鸟还有很多\",{\"1\":{\"812\":1}}],[\"不会飞翔\",{\"1\":{\"789\":1}}],[\"不会再\",{\"1\":{\"734\":1}}],[\"不会修改代码\",{\"1\":{\"678\":1}}],[\"不会修改其他的代码\",{\"1\":{\"613\":1}}],[\"不会随环境的改变而改变\",{\"1\":{\"631\":1}}],[\"不至于造成很多的类\",{\"1\":{\"583\":1}}],[\"不一定完全一样\",{\"1\":{\"574\":1}}],[\"不一样\",{\"1\":{\"284\":1}}],[\"不容易用继承的方法来增加构件的新功能\",{\"1\":{\"567\":1}}],[\"不容易限制容器中的构件\",{\"1\":{\"567\":1}}],[\"不变\",{\"1\":{\"528\":1}}],[\"不错的替代工具\",{\"1\":{\"458\":1}}],[\"不清楚是不是存在\",{\"1\":{\"450\":1}}],[\"不获取父类的字段\",{\"1\":{\"307\":1}}],[\"不包括继承的字段\",{\"1\":{\"307\":2}}],[\"不包括包名\",{\"1\":{\"305\":1}}],[\"不包含参数\",{\"1\":{\"306\":1}}],[\"不包含任何方法\",{\"1\":{\"163\":1}}],[\"不合法\",{\"1\":{\"291\":1}}],[\"不是varchar超长字段\",{\"1\":{\"863\":1}}],[\"不是唯一索引的字段\",{\"1\":{\"863\":1}}],[\"不是频繁修改的字段\",{\"1\":{\"863\":1}}],[\"不是\",{\"1\":{\"742\":1,\"918\":1}}],[\"不是直接朋友\",{\"1\":{\"742\":1}}],[\"不是接口\",{\"1\":{\"679\":1}}],[\"不是我们讲解的重点\",{\"1\":{\"626\":1}}],[\"不是继承\",{\"1\":{\"527\":1}}],[\"不是说泛型变量string会在编译的时候变为object类型吗\",{\"1\":{\"290\":1}}],[\"不是线程安全的操作\",{\"1\":{\"164\":1}}],[\"不是线程安全的\",{\"1\":{\"124\":1}}],[\"不指定泛型的时候\",{\"1\":{\"289\":2}}],[\"不得已使用继承的话\",{\"1\":{\"871\":1}}],[\"不得使用外键与级联\",{\"1\":{\"865\":1}}],[\"不得使用\",{\"1\":{\"853\":1}}],[\"不得手心冒点汗吗\",{\"1\":{\"848\":1}}],[\"不得不进行大规模重构\",{\"1\":{\"871\":1}}],[\"不得不通过catchnumberformatexception来实现\",{\"1\":{\"858\":1}}],[\"不得不将其他不需要的职责全都包含进来\",{\"1\":{\"716\":1}}],[\"不得不重新new一次\",{\"1\":{\"283\":1}}],[\"不得通过catch\",{\"1\":{\"263\":1}}],[\"不管传送的是什么物品\",{\"1\":{\"648\":1}}],[\"不管是不是自己的目标更新字段\",{\"1\":{\"866\":1}}],[\"不管是rpc\",{\"1\":{\"852\":1}}],[\"不管是阅读代码还是修改代码\",{\"1\":{\"816\":1}}],[\"不管是创建一个对象还是十个对象\",{\"1\":{\"622\":1}}],[\"不管是普通房子也好\",{\"1\":{\"555\":1}}],[\"不管\",{\"1\":{\"264\":1}}],[\"不管有木有异常抛出\",{\"1\":{\"197\":1}}],[\"不仅在软件行业\",{\"1\":{\"818\":1}}],[\"不仅可以指导细粒度的类和类之间关系的设计\",{\"1\":{\"816\":1}}],[\"不仅能应对当下的需求\",{\"1\":{\"808\":1}}],[\"不仅能避免多线程同步问题\",{\"1\":{\"759\":1}}],[\"不仅如此\",{\"1\":{\"622\":1}}],[\"不仅仅初学者很难理解\",{\"1\":{\"262\":1}}],[\"不仅会编译代码\",{\"1\":{\"89\":1}}],[\"不允许类的静态导入\",{\"0\":{\"893\":1}}],[\"不允许换行\",{\"0\":{\"891\":1}}],[\"不允许\",{\"1\":{\"890\":1,\"891\":1}}],[\"不允许通配符\",{\"0\":{\"890\":1}}],[\"不允许使用制表符缩进\",{\"1\":{\"883\":1}}],[\"不允许直接拿hashmap与hashtable作为查询结果集的输出\",{\"1\":{\"866\":1}}],[\"不允许写在业务代码目录下\",{\"1\":{\"860\":1}}],[\"不允许在应用中自行显式创建线程\",{\"1\":{\"851\":1}}],[\"不允许在程序任何地方中使用\",{\"1\":{\"849\":1}}],[\"不允许为null\",{\"1\":{\"850\":5}}],[\"不允许运行过程中重新赋值的局部变量\",{\"1\":{\"848\":1}}],[\"不允许被覆写的方法\",{\"1\":{\"848\":1}}],[\"不允许被继承的类\",{\"1\":{\"848\":1}}],[\"不允许修改引用的域对象\",{\"1\":{\"848\":1}}],[\"不允许修改方法签名\",{\"1\":{\"848\":1}}],[\"不允许任何魔法值\",{\"1\":{\"846\":1}}],[\"不允许与父类的成员变量名称相同\",{\"1\":{\"845\":1}}],[\"不允许与其它代码块中的money命名相同\",{\"1\":{\"845\":1}}],[\"不允许与本类成员变量同名\",{\"1\":{\"845\":1}}],[\"不允许用继承\",{\"1\":{\"590\":1}}],[\"不允许调用\",{\"1\":{\"310\":1}}],[\"不允许访问某类异常\",{\"1\":{\"261\":1}}],[\"不允许删除\",{\"1\":{\"242\":2}}],[\"不需保持其他所有处理者的引用\",{\"1\":{\"707\":1}}],[\"不需总是创建新对象\",{\"1\":{\"629\":1}}],[\"不需暴露太多内部异常细节\",{\"1\":{\"253\":1}}],[\"不需要在前面加\",{\"1\":{\"956\":1}}],[\"不需要打印日志\",{\"1\":{\"868\":1}}],[\"不需要进行参数校验\",{\"1\":{\"852\":1}}],[\"不需要改动任何其他类的代码\",{\"1\":{\"839\":1}}],[\"不需要了解太多其他模块或类的代码\",{\"1\":{\"816\":1}}],[\"不需要任何接口定义的改动\",{\"1\":{\"809\":1}}],[\"不需要任何重量级或自己使用的依赖关系\",{\"1\":{\"430\":1}}],[\"不需要依赖参数传递\",{\"1\":{\"765\":1}}],[\"不需要实现接口\",{\"1\":{\"698\":1,\"703\":1}}],[\"不需要知道具体收听者\",{\"1\":{\"680\":1}}],[\"不需要知道集合对象的底层表示\",{\"1\":{\"648\":1}}],[\"不需要重新创建\",{\"1\":{\"627\":1}}],[\"不需要事先在代码中写死要创建哪些对象\",{\"1\":{\"622\":1}}],[\"不需要修改原代码\",{\"1\":{\"616\":1}}],[\"不需要使用反射\",{\"1\":{\"397\":1}}],[\"不需要通用的接口抽象\",{\"1\":{\"309\":1}}],[\"不需要强制类型转换\",{\"1\":{\"279\":1}}],[\"不需要同步的stringbuilder效率更高\",{\"1\":{\"192\":1}}],[\"不需要再使用class\",{\"1\":{\"102\":1}}],[\"不再继续缩进\",{\"1\":{\"847\":1}}],[\"不再将图片存储到阿里云了\",{\"1\":{\"809\":1}}],[\"不再建议用户使用\",{\"1\":{\"224\":1}}],[\"不再需要在变量声明的右边申明泛型\",{\"1\":{\"186\":1}}],[\"不过这种改动是\",{\"1\":{\"912\":1}}],[\"不过这也是设计模式的通病\",{\"1\":{\"560\":1}}],[\"不过即使符合列限制的一行代码\",{\"1\":{\"906\":1}}],[\"不过会使得一些情况下的唯一主键变得不唯一\",{\"1\":{\"863\":1}}],[\"不过会有个编译时警告\",{\"1\":{\"290\":1}}],[\"不过其包含的组成元素比组合模式多\",{\"1\":{\"642\":1}}],[\"不过\",{\"1\":{\"291\":1,\"483\":1,\"606\":1,\"752\":1,\"769\":2,\"771\":1,\"809\":3,\"813\":1}}],[\"不过在第一种情况\",{\"1\":{\"290\":1}}],[\"不过当我们利用反射调用add\",{\"1\":{\"288\":1}}],[\"不过一个是arraylist<string>泛型类型的\",{\"1\":{\"288\":1}}],[\"不过一般情况下\",{\"1\":{\"204\":1}}],[\"不过你一定要确保抛出异常的条件与该异常的文档中描述的条件一致\",{\"1\":{\"265\":1}}],[\"不过切记\",{\"1\":{\"91\":1}}],[\"不溢出的情况下\",{\"1\":{\"203\":1}}],[\"不可能\",{\"1\":{\"950\":1}}],[\"不可能把某个应用要创建的对象写死在框架代码中\",{\"1\":{\"622\":1}}],[\"不可用时长持续很久\",{\"1\":{\"871\":1}}],[\"不可对其进行添加或者删除元素的操作\",{\"1\":{\"850\":1}}],[\"不可以对其进行添加元素操作\",{\"1\":{\"850\":1}}],[\"不可以在static环境中使用\",{\"1\":{\"200\":1}}],[\"不可共享\",{\"1\":{\"631\":1}}],[\"不可查异常\",{\"1\":{\"249\":1}}],[\"不可变对象指对象一旦被创建\",{\"1\":{\"173\":1}}],[\"不可变是因为\",{\"1\":{\"169\":1}}],[\"不可变性天生具备线程安全\",{\"1\":{\"123\":1}}],[\"不可变性可以保证参数不可变\",{\"1\":{\"123\":1}}],[\"不可变的值类型\",{\"1\":{\"942\":1}}],[\"不可变的特性可以使得\",{\"1\":{\"123\":1}}],[\"不可变的好处\",{\"0\":{\"123\":1}}],[\"不可变\",{\"1\":{\"122\":1,\"124\":2}}],[\"不像\",{\"1\":{\"186\":1}}],[\"不行\",{\"1\":{\"166\":1,\"177\":1}}],[\"不属于操作符重载\",{\"1\":{\"151\":1}}],[\"不支持的数据格式\",{\"1\":{\"874\":1}}],[\"不支持条件编译\",{\"1\":{\"151\":1}}],[\"不支持操作符重载\",{\"1\":{\"151\":1}}],[\"不支持多重继承\",{\"1\":{\"151\":1}}],[\"不支持\",{\"1\":{\"130\":1}}],[\"不同\",{\"1\":{\"897\":1}}],[\"不同浏览器对于url的最大长度限制略有不同\",{\"1\":{\"854\":1}}],[\"不同业务的代码之间插入一个空行\",{\"1\":{\"847\":1}}],[\"不同语义\",{\"1\":{\"847\":1}}],[\"不同语言之间一直存在鄙视链\",{\"1\":{\"93\":1}}],[\"不同逻辑\",{\"1\":{\"847\":1}}],[\"不同类型的可以创建多个对象\",{\"1\":{\"773\":1}}],[\"不同条件下创建不同实例\",{\"1\":{\"589\":1}}],[\"不同性别和职业的男女\",{\"1\":{\"537\":1}}],[\"不同品牌和功率的汽车\",{\"1\":{\"537\":1}}],[\"不同的类可能有不同的排序内容的方式\",{\"1\":{\"896\":1}}],[\"不同的观众对他们的评价也不同\",{\"1\":{\"837\":1}}],[\"不同的游客对同一个景点的评价可能不同\",{\"1\":{\"837\":1}}],[\"不同的情绪有不同的行为\",{\"1\":{\"775\":1}}],[\"不同的\",{\"1\":{\"773\":1}}],[\"不同的进程间共享同一个对象\",{\"1\":{\"772\":1}}],[\"不同的线程对应不同的对象\",{\"1\":{\"771\":1}}],[\"不同的披萨不一样\",{\"1\":{\"609\":1,\"613\":1}}],[\"不同的实现\",{\"1\":{\"563\":1}}],[\"不同的执行顺序\",{\"1\":{\"558\":1}}],[\"不同的是\",{\"1\":{\"311\":1}}],[\"不同的虚拟机对虚拟机的规范\",{\"1\":{\"125\":1}}],[\"不能忽略\",{\"0\":{\"950\":1}}],[\"不能假定每个阅读者都能熟记整个\",{\"1\":{\"913\":1}}],[\"不能假设数据库里的数据是存在的\",{\"1\":{\"860\":1}}],[\"不能受到外界环境的影响\",{\"1\":{\"860\":1}}],[\"不能超过\",{\"1\":{\"854\":1}}],[\"不能为static\",{\"1\":{\"972\":1}}],[\"不能为动词\",{\"1\":{\"854\":1}}],[\"不能为float\",{\"1\":{\"289\":1}}],[\"不能工作\",{\"1\":{\"853\":1}}],[\"不能在主线程try\",{\"1\":{\"851\":1}}],[\"不能使用其修改集合相关的方法\",{\"1\":{\"850\":1}}],[\"不能使用过时的类或方法\",{\"1\":{\"848\":1}}],[\"不能使用关键字extends来继承某个\",{\"1\":{\"237\":1}}],[\"不能是小写l\",{\"1\":{\"846\":1}}],[\"不能分离\",{\"1\":{\"832\":2}}],[\"不能飞\",{\"1\":{\"789\":1}}],[\"不能扣除积分\",{\"1\":{\"778\":1}}],[\"不能发放奖品\",{\"1\":{\"778\":3}}],[\"不能再扣\",{\"1\":{\"778\":1}}],[\"不能再catch子句中使用泛型变量\",{\"1\":{\"297\":1}}],[\"不能抽奖状态\",{\"1\":{\"778\":1}}],[\"不能抽奖\",{\"1\":{\"777\":1,\"778\":1}}],[\"不能创建同一个类的多个对象\",{\"1\":{\"772\":1}}],[\"不能出现其他表的增删改查\",{\"1\":{\"716\":1}}],[\"不能保证每个请求一定被处理\",{\"1\":{\"707\":1}}],[\"不能过多的或者不合理的使用外观模式\",{\"1\":{\"603\":1}}],[\"不能很好地限制客户使用子系统类\",{\"1\":{\"593\":1}}],[\"不能很好实现的管理的操作\",{\"1\":{\"573\":1}}],[\"不能充电~~\",{\"1\":{\"524\":1,\"528\":1}}],[\"不能抛出也不能捕获泛型类的对象\",{\"1\":{\"297\":1}}],[\"不能实例化泛型类型\",{\"1\":{\"293\":1}}],[\"不能放其它类型的元素\",{\"1\":{\"279\":1}}],[\"不能被实现类的对象调用\",{\"1\":{\"194\":1}}],[\"不能\",{\"1\":{\"176\":1,\"291\":1}}],[\"不能隐式执行向下转型\",{\"1\":{\"128\":1}}],[\"不能直接将\",{\"1\":{\"128\":1}}],[\"不能根据某个参数来获取对应的实现类\",{\"1\":{\"115\":1}}],[\"不能按需加载\",{\"1\":{\"115\":1}}],[\"不妨再看个例子\",{\"1\":{\"236\":1}}],[\"不妨看下jdk中serviceloader<s>方法的具体实现\",{\"1\":{\"114\":1}}],[\"不妨先试着定下10\",{\"1\":{\"36\":1}}],[\"不满足或运算中的第一个条件\",{\"1\":{\"92\":1}}],[\"不断地复盘自己\",{\"1\":{\"36\":1}}],[\"不断调整自己的思维和行为\",{\"1\":{\"36\":1}}],[\"不要担心因为一些程序可能不能正确地处理非\",{\"1\":{\"885\":1}}],[\"不要更新无改\",{\"1\":{\"866\":1}}],[\"不要写一个大而全的数据更新接口\",{\"1\":{\"866\":1}}],[\"不要用resultclass当返回参数\",{\"1\":{\"866\":1}}],[\"不要以为唯一索引影响了insert速度\",{\"1\":{\"864\":1}}],[\"不要对单元测试存在如下误解\",{\"1\":{\"860\":1}}],[\"不要抢模型和控制器的活\",{\"1\":{\"855\":1}}],[\"不要将x放大\",{\"1\":{\"855\":1}}],[\"不要将跟具体实现相关的方法搬移到接口中\",{\"1\":{\"809\":1}}],[\"不要增加业务逻辑\",{\"1\":{\"848\":1}}],[\"不要设定任何属性默认值\",{\"1\":{\"848\":1}}],[\"不要嫌名字长\",{\"1\":{\"845\":1}}],[\"不要有依赖\",{\"1\":{\"818\":1}}],[\"不要暴露任何实现细节\",{\"1\":{\"809\":1}}],[\"不要生搬硬套\",{\"1\":{\"797\":1}}],[\"不要使用不稳定的工具包或者utils类\",{\"1\":{\"869\":1}}],[\"不要使用count\",{\"1\":{\"865\":1}}],[\"不要使用windows格式\",{\"1\":{\"847\":1}}],[\"不要使用一个常量类维护所有常量\",{\"1\":{\"846\":1}}],[\"不要使用\",{\"1\":{\"754\":1,\"866\":1}}],[\"不要使用异常控制程序的流程\",{\"0\":{\"272\":1}}],[\"不要破坏继承体系\",{\"1\":{\"748\":1}}],[\"不要在视图模板中加入任何复杂的逻辑运算\",{\"1\":{\"855\":1}}],[\"不要在方法体内定义\",{\"1\":{\"855\":1}}],[\"不要在方法里\",{\"1\":{\"748\":1}}],[\"不要在其它表达式\",{\"1\":{\"852\":1}}],[\"不要在foreach循环里进行元素的remove\",{\"1\":{\"850\":1}}],[\"不要在finally块中使用return\",{\"0\":{\"273\":1},\"1\":{\"858\":1}}],[\"不要在括号前换行\",{\"1\":{\"847\":1}}],[\"不要和那些不需要变化的代码混在一起\",{\"1\":{\"746\":1}}],[\"不要覆盖基类中已经实现的方法\",{\"1\":{\"619\":1}}],[\"不要让类继承具体类\",{\"1\":{\"619\":1}}],[\"不要直接\",{\"1\":{\"619\":1}}],[\"不要再浪费时间重写这些东西了\",{\"1\":{\"465\":1}}],[\"不要忘了使你的部署实现自动化\",{\"1\":{\"462\":1}}],[\"不要命名一些像\",{\"1\":{\"452\":1}}],[\"不要返回\",{\"1\":{\"450\":1}}],[\"不要记录并抛出异常\",{\"0\":{\"270\":1}}],[\"不要忽略异常\",{\"0\":{\"269\":1}}],[\"不要捕获了却什么都不处理而抛弃之\",{\"1\":{\"858\":1}}],[\"不要捕获\",{\"0\":{\"268\":1}}],[\"不要共享可变对象的引用就可以了\",{\"1\":{\"174\":1}}],[\"不要被人发现\",{\"1\":{\"91\":1}}],[\"不要只想着抱怨\",{\"1\":{\"36\":1}}],[\"不要因为一次\",{\"1\":{\"36\":1}}],[\"不把手机带上床\",{\"1\":{\"36\":1}}],[\"在每个测试方法运行后都会被调用\",{\"1\":{\"997\":1}}],[\"在每个测试方法运行前都会被调用\",{\"1\":{\"997\":1}}],[\"在何处使用\",{\"0\":{\"959\":1}}],[\"在何处换行\",{\"0\":{\"907\":1}}],[\"在测试中并不使用的\",{\"1\":{\"996\":1}}],[\"在测试类里所有用例运行之后\",{\"1\":{\"972\":1}}],[\"在测试代码中\",{\"1\":{\"950\":1}}],[\"在测试时用spring这样的di框架注入一个本地\",{\"1\":{\"860\":1}}],[\"在合理范围之内\",{\"1\":{\"918\":1}}],[\"在注解和\",{\"1\":{\"911\":1}}],[\"在注释代码上方\",{\"1\":{\"855\":1}}],[\"在注释中用fixme标记某代码是错误的\",{\"1\":{\"853\":1}}],[\"在数组初始化的两个花括号的内侧\",{\"1\":{\"911\":1}}],[\"在数据库中不能使用物理删除操作\",{\"1\":{\"863\":1}}],[\"在数据库中\",{\"1\":{\"860\":1}}],[\"在以上类中我们可以看到\",{\"1\":{\"978\":1}}],[\"在以双斜线\",{\"1\":{\"911\":1}}],[\"在以下位置出现\",{\"1\":{\"911\":1}}],[\"在任何内容与以双斜线\",{\"1\":{\"911\":1}}],[\"在连续换行的多行代码中\",{\"1\":{\"908\":1}}],[\"在极少数情况下可能需要\",{\"1\":{\"905\":1}}],[\"在后续\",{\"1\":{\"898\":1}}],[\"在做无障碍产品设计时\",{\"1\":{\"871\":1}}],[\"在维护代码时\",{\"1\":{\"871\":1}}],[\"在维护一个遗留的大型系统时\",{\"1\":{\"603\":1}}],[\"在需求分析阶段\",{\"1\":{\"871\":1}}],[\"在需要时声明\",{\"0\":{\"918\":1}}],[\"在需要时进行恢复\",{\"1\":{\"591\":1}}],[\"在需要的时候提供这些内部状态给发起人\",{\"1\":{\"664\":1}}],[\"在需要表示一个对象整体与部分的层次结构的场合\",{\"1\":{\"577\":1}}],[\"在线上生产环境\",{\"1\":{\"870\":1}}],[\"在线程\",{\"1\":{\"771\":2}}],[\"在linux服务器上请通过变更\",{\"1\":{\"870\":1}}],[\"在long取值范围内\",{\"1\":{\"854\":1}}],[\"在lock对象的lock方法实现中可能抛出unchecked异常\",{\"1\":{\"851\":1}}],[\"在lock方法与try代码块之间的方法调用抛出异常\",{\"1\":{\"851\":1}}],[\"在本文档中\",{\"1\":{\"877\":1}}],[\"在本规约中\",{\"1\":{\"873\":1}}],[\"在本地调试时会使用各子项目指定的版本号\",{\"1\":{\"869\":1}}],[\"在本例中\",{\"1\":{\"283\":1}}],[\"在规定的版本号之后加\",{\"1\":{\"869\":1}}],[\"在升级时\",{\"1\":{\"869\":1}}],[\"在dao层\",{\"1\":{\"868\":1}}],[\"在drivermanager中有一个静态代码块如下\",{\"1\":{\"103\":1}}],[\"在表查询中\",{\"1\":{\"866\":1}}],[\"在预发布环境做数据库变更后\",{\"1\":{\"865\":1}}],[\"在某业务中\",{\"1\":{\"865\":1}}],[\"在某些集合中\",{\"1\":{\"850\":1}}],[\"在某些场景下\",{\"1\":{\"614\":1}}],[\"在某些情况下可以卸载这些生成的类\",{\"1\":{\"312\":1}}],[\"在建索引时\",{\"1\":{\"864\":1}}],[\"在建筑界\",{\"1\":{\"823\":1}}],[\"在建筑\",{\"1\":{\"818\":1}}],[\"在优化阶段即可读取到数据\",{\"1\":{\"864\":1}}],[\"在varchar字段上建立索引时\",{\"1\":{\"864\":1}}],[\"在存储的时候\",{\"1\":{\"863\":1}}],[\"在项目提测前完成单元测试\",{\"1\":{\"860\":1}}],[\"在项目中不用或者少用继承关系\",{\"1\":{\"813\":1}}],[\"在项目中这样写代码的时候\",{\"1\":{\"94\":1}}],[\"在基础技术部的内部单元测试中\",{\"1\":{\"860\":1}}],[\"在工程规约的应用分层中提到的dao层\",{\"1\":{\"860\":1}}],[\"在频繁调用出错的情况下\",{\"1\":{\"858\":1}}],[\"在频繁使用时性能更佳\",{\"1\":{\"409\":1}}],[\"在无法更加具体确定的错误场景中\",{\"1\":{\"857\":1}}],[\"在无泛型限制定义的集合赋值给泛型限制的集合时\",{\"1\":{\"850\":1}}],[\"在获取第三方服务错误码时\",{\"1\":{\"857\":1}}],[\"在接口路径中不要加入版本号\",{\"1\":{\"854\":1}}],[\"在接口上定义泛型\",{\"1\":{\"282\":1}}],[\"在翻页场景中\",{\"1\":{\"854\":1}}],[\"在取值范围之内\",{\"1\":{\"854\":1}}],[\"在取出时会发生类型转换异常\",{\"1\":{\"294\":1}}],[\"在服务器更新资源\",{\"1\":{\"854\":1}}],[\"在服务器新建一个资源\",{\"1\":{\"854\":1}}],[\"在被注释语句上方另起一行\",{\"1\":{\"853\":1}}],[\"在被访问的类里面加一个对外提供接待访问者的接口\",{\"1\":{\"837\":1}}],[\"在设置模板时\",{\"1\":{\"853\":1}}],[\"在设计评审阶段\",{\"1\":{\"860\":1}}],[\"在设计接口的时候\",{\"1\":{\"809\":1}}],[\"在设计模式中\",{\"1\":{\"545\":1}}],[\"在高并发访问下\",{\"1\":{\"870\":1}}],[\"在高并发场景中\",{\"1\":{\"852\":1}}],[\"在高并发情况下\",{\"1\":{\"850\":1}}],[\"在ide编辑窗口中\",{\"1\":{\"853\":1}}],[\"在ide中\",{\"1\":{\"290\":1,\"853\":1}}],[\"在if\",{\"1\":{\"852\":1}}],[\"在finally中无法解锁\",{\"1\":{\"851\":1}}],[\"在利用\",{\"1\":{\"851\":1}}],[\"在arraylist\",{\"1\":{\"850\":1}}],[\"在service层出现异常时\",{\"1\":{\"868\":1}}],[\"在sql\",{\"1\":{\"866\":1}}],[\"在sql语句中\",{\"1\":{\"865\":1}}],[\"在sublist场景中\",{\"1\":{\"850\":1}}],[\"在springboot的自动装配过程中\",{\"1\":{\"106\":1}}],[\"在闰年\",{\"1\":{\"849\":1}}],[\"在日志输出时\",{\"1\":{\"859\":1}}],[\"在日期格式中分清楚大写的m和小写的m\",{\"1\":{\"849\":1}}],[\"在日常应用中\",{\"1\":{\"797\":1}}],[\"在日常编码工作中\",{\"1\":{\"593\":1}}],[\"在getter\",{\"1\":{\"848\":1}}],[\"在glassfish中作为网络层使用\",{\"1\":{\"419\":1}}],[\"在方法中删除未使用的参数声明与内部变量\",{\"1\":{\"853\":1}}],[\"在方法中声明一个异常\",{\"1\":{\"252\":1}}],[\"在方法执行抛出异常时\",{\"1\":{\"848\":1}}],[\"在更新其它字段时又附带更新了此字段\",{\"1\":{\"848\":1}}],[\"在精确计算或值比较的场景中可能会导致业务逻辑异常\",{\"1\":{\"848\":1}}],[\"在变量比较多的情况下\",{\"1\":{\"847\":1}}],[\"在括号前不要换行\",{\"1\":{\"847\":1}}],[\"在逗号后进行\",{\"1\":{\"847\":1}}],[\"在进行类型强制转换时\",{\"1\":{\"847\":1}}],[\"在进程使用完这个对象之后\",{\"1\":{\"772\":1}}],[\"在进程间都只有一份对象存在\",{\"1\":{\"772\":1}}],[\"在进程间是不唯一的\",{\"1\":{\"770\":1}}],[\"在右大括号后直接结束\",{\"1\":{\"847\":1}}],[\"在命名时要体现出具体模式\",{\"1\":{\"845\":1}}],[\"在命名模式中\",{\"1\":{\"560\":1}}],[\"在常量与变量命名时\",{\"1\":{\"845\":1}}],[\"在同一方法体中\",{\"1\":{\"845\":1}}],[\"在延伸的信息中\",{\"1\":{\"843\":1}}],[\"在访问者模式中\",{\"1\":{\"837\":1}}],[\"在代码实现时\",{\"1\":{\"833\":1}}],[\"在代码中\",{\"1\":{\"694\":1,\"741\":1,\"763\":1,\"771\":1,\"773\":1,\"828\":1}}],[\"在组合关系中\",{\"1\":{\"832\":1}}],[\"在内的各种标准\",{\"1\":{\"823\":1}}],[\"在内存中动态构建子类\",{\"1\":{\"703\":1}}],[\"在内存中有且只有一个与之对应的class对象来描述其类型信息\",{\"1\":{\"302\":1}}],[\"在完成了第一版的程序后\",{\"1\":{\"820\":1}}],[\"在有依赖关系的两个模块或类之间\",{\"1\":{\"818\":1}}],[\"在有些情况下\",{\"1\":{\"692\":1}}],[\"在有些系统中\",{\"1\":{\"682\":1}}],[\"在引入中间层之后\",{\"1\":{\"818\":1}}],[\"在引入数据存储中间层之前\",{\"1\":{\"818\":1}}],[\"在刚刚这个场景中\",{\"1\":{\"812\":1}}],[\"在开发过程中注意规避此风险\",{\"1\":{\"851\":1}}],[\"在开发完之后\",{\"1\":{\"810\":1}}],[\"在开发的时候\",{\"1\":{\"810\":1}}],[\"在开始前先提一个问题\",{\"1\":{\"92\":1}}],[\"在定义接口的时候\",{\"1\":{\"809\":1}}],[\"在定义注解类时使用了\",{\"1\":{\"227\":1}}],[\"在平时的开发中特别经常被用到\",{\"1\":{\"807\":1}}],[\"在具体子类中可以继承或重写它\",{\"1\":{\"801\":1}}],[\"在具体的软件幵发中\",{\"1\":{\"797\":1}}],[\"在抽象类中已经实现\",{\"1\":{\"801\":2}}],[\"在抽象类中声明\",{\"1\":{\"801\":1}}],[\"在其巨著\",{\"1\":{\"797\":1}}],[\"在其中看到别人设计模式\",{\"1\":{\"794\":1}}],[\"在子类里具体设定行为对象\",{\"1\":{\"789\":1}}],[\"在子类中\",{\"1\":{\"291\":1}}],[\"在添加一种功能时\",{\"1\":{\"779\":1}}],[\"在添加一种状态时\",{\"1\":{\"779\":1}}],[\"在另外一个线程\",{\"1\":{\"771\":1}}],[\"在新进程中也会存在且只能存在一个对象\",{\"1\":{\"770\":1}}],[\"在新窗口打开\",{\"1\":{\"123\":1,\"127\":1,\"129\":1,\"130\":1,\"150\":1,\"151\":1}}],[\"在系统中不出现重复代码的情况\",{\"1\":{\"871\":1}}],[\"在系统中尽量使用\",{\"1\":{\"527\":1}}],[\"在系统设计初期\",{\"1\":{\"766\":1}}],[\"在函数中直接调用就可以了\",{\"1\":{\"765\":1}}],[\"在阅读代码的时候\",{\"1\":{\"765\":2}}],[\"在静态代码块中\",{\"1\":{\"753\":1}}],[\"在单例模式中大多数都是调用\",{\"1\":{\"752\":1}}],[\"在调用rpc\",{\"1\":{\"858\":1}}],[\"在调用泛型方法时\",{\"1\":{\"289\":1}}],[\"在调试过程中\",{\"1\":{\"750\":1}}],[\"在并发测试中\",{\"1\":{\"750\":1}}],[\"在计算机系统中\",{\"1\":{\"750\":1}}],[\"在计算机软硬件中也有相关例子\",{\"1\":{\"707\":1}}],[\"在对这个模块进行测试时\",{\"1\":{\"996\":1}}],[\"在对其他类的引用上\",{\"1\":{\"741\":1}}],[\"在对象被最终销毁之前\",{\"1\":{\"622\":1}}],[\"在运用迪米特法则时要注意以下\",{\"1\":{\"741\":1}}],[\"在运行结果中\",{\"1\":{\"972\":1}}],[\"在运行时动态选择具体要执行的行为\",{\"1\":{\"792\":1}}],[\"在运行时通过dsl\",{\"1\":{\"386\":1}}],[\"在运行时可以接收任何修改\",{\"1\":{\"307\":1}}],[\"在运行开始之前就可以确定\",{\"1\":{\"217\":1}}],[\"在可维护性和可读性上确实要好很多\",{\"1\":{\"741\":1}}],[\"在面向对象编程中\",{\"1\":{\"811\":1}}],[\"在面向对象的程序设计中\",{\"1\":{\"737\":1}}],[\"在面向对象程序设计过程中\",{\"1\":{\"629\":1,\"800\":1}}],[\"在适当的情况下\",{\"1\":{\"732\":1}}],[\"在所有的对象\",{\"1\":{\"732\":1}}],[\"在编写代码的时候\",{\"1\":{\"809\":1}}],[\"在编程中\",{\"1\":{\"731\":1}}],[\"在编译阶段正常\",{\"1\":{\"869\":1}}],[\"在编译原理中\",{\"1\":{\"641\":1}}],[\"在编译之后还是会变成throwable\",{\"1\":{\"297\":1}}],[\"在编译后的class文件中便不再存在\",{\"1\":{\"223\":1}}],[\"在编译时已经定义\",{\"1\":{\"747\":1}}],[\"在编译时\",{\"1\":{\"206\":1}}],[\"在水中行\",{\"1\":{\"718\":1}}],[\"在天空上运行\",{\"1\":{\"718\":1}}],[\"在公路上运行\",{\"1\":{\"718\":2}}],[\"在职责链模式中\",{\"1\":{\"707\":1}}],[\"在客户端的也需要变化\",{\"1\":{\"709\":1}}],[\"在客户端和目标对象之间增加一个代理对象\",{\"1\":{\"692\":1}}],[\"在客户端之间进行消息传递\",{\"1\":{\"414\":1}}],[\"在一定程度上降低了系统的耦合度\",{\"1\":{\"692\":1}}],[\"在一个switch块内\",{\"1\":{\"852\":2}}],[\"在一个抽象类公开定义了执行它的方法的模板\",{\"1\":{\"800\":1}}],[\"在一个对象中修改该成员变量会影响到另一个对象的该成员变量值\",{\"1\":{\"689\":1}}],[\"在一个页面中展示出学校的院系组成\",{\"1\":{\"573\":1,\"650\":1}}],[\"在一个\",{\"1\":{\"256\":1}}],[\"在实际使用中可能会出现异常\",{\"1\":{\"850\":1}}],[\"在实际应用中\",{\"1\":{\"797\":1}}],[\"在实际的项目开发中\",{\"1\":{\"814\":1}}],[\"在实际的项目中相对也不常用\",{\"1\":{\"606\":1}}],[\"在实际的项目中也比较常用\",{\"1\":{\"606\":1}}],[\"在实际的开发中\",{\"1\":{\"763\":1}}],[\"在实际开发中\",{\"1\":{\"754\":1,\"755\":1,\"757\":1}}],[\"在实际编程中\",{\"1\":{\"734\":1}}],[\"在实现深克隆的时候可能需要比较复杂的代码\",{\"1\":{\"690\":1}}],[\"在该类的\",{\"1\":{\"689\":1}}],[\"在该方式中\",{\"1\":{\"569\":1,\"570\":1}}],[\"在性能上比直接\",{\"1\":{\"682\":1}}],[\"在现实世界中\",{\"1\":{\"671\":1}}],[\"在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况\",{\"1\":{\"783\":1}}],[\"在现实生活中\",{\"1\":{\"518\":1,\"537\":1,\"567\":1,\"579\":1,\"655\":1,\"707\":1,\"837\":1}}],[\"在大战\",{\"1\":{\"665\":1}}],[\"在创建新的对象时\",{\"1\":{\"686\":1}}],[\"在创建\",{\"1\":{\"659\":1}}],[\"在创建对象的时候就设置好了\",{\"1\":{\"631\":1}}],[\"在前后端交互的json格式数据中\",{\"1\":{\"854\":1}}],[\"在前后端交互时起到了中间人的作用\",{\"1\":{\"655\":1}}],[\"在前面的代码中用了system\",{\"1\":{\"258\":1}}],[\"在聚合类中\",{\"1\":{\"652\":1}}],[\"在聚集查询和近似查询方面表现不俗\",{\"1\":{\"400\":1}}],[\"在分发时只需要一个个检查发送的目的地即可\",{\"1\":{\"648\":1}}],[\"在分布式系统中的数据库看起来就像是只有一个数据源\",{\"1\":{\"400\":1}}],[\"在语法树中的每个表达式节点类都是相似的\",{\"1\":{\"641\":1}}],[\"在享元模式这样理解\",{\"1\":{\"638\":1}}],[\"在启动的时候会根据代码自动地加载类\",{\"1\":{\"627\":1}}],[\"在最后一个语句组中\",{\"1\":{\"924\":1}}],[\"在最好的情况下\",{\"1\":{\"912\":1}}],[\"在最坏的情况下\",{\"1\":{\"912\":1}}],[\"在最底层\",{\"1\":{\"819\":1}}],[\"在最小原型中\",{\"1\":{\"624\":1}}],[\"在最开始就可以确定\",{\"1\":{\"217\":1}}],[\"在产品类型较多时\",{\"1\":{\"608\":1}}],[\"在简单工厂模式中创建实例的方法通常为静态\",{\"1\":{\"608\":1}}],[\"在今天的讲解中\",{\"1\":{\"606\":1,\"620\":1,\"624\":1}}],[\"在增加或者删除调料种类时\",{\"1\":{\"583\":1}}],[\"在安全式的组合模式中不声明访问和管理子类的接口\",{\"1\":{\"568\":1}}],[\"在透明式的组合模式中抽象构件还声明访问和管理子类的接口\",{\"1\":{\"568\":1}}],[\"在我们的例子中\",{\"1\":{\"562\":1}}],[\"在我们用list2取值的时候不会出现classcastexception\",{\"1\":{\"290\":1}}],[\"在指挥者中不涉及具体产品的信息\",{\"1\":{\"551\":1}}],[\"在指定泛型的情况下\",{\"1\":{\"289\":1}}],[\"在很多业务场景中符合开闭原则\",{\"1\":{\"518\":1}}],[\"在很多情况下\",{\"1\":{\"133\":1}}],[\"在软件系统中\",{\"1\":{\"680\":1}}],[\"在软件设计中\",{\"1\":{\"560\":1,\"692\":1}}],[\"在软件设计中也可能出现\",{\"1\":{\"518\":1}}],[\"在软件开发界\",{\"1\":{\"823\":1}}],[\"在软件开发过程中\",{\"1\":{\"579\":1,\"775\":1}}],[\"在软件开发过程中有时需要创建一个复杂的对象\",{\"1\":{\"549\":1}}],[\"在软件开发系统中\",{\"1\":{\"560\":1}}],[\"在软件开发中也常常遇到类似的情况\",{\"1\":{\"783\":1}}],[\"在软件开发中也是这样\",{\"1\":{\"567\":1}}],[\"在软件开发中\",{\"1\":{\"547\":1,\"608\":1,\"641\":1,\"808\":1}}],[\"在软件工程领域\",{\"1\":{\"449\":1}}],[\"在你的\",{\"1\":{\"459\":1}}],[\"在你这样做时\",{\"1\":{\"271\":1}}],[\"在自动化单元测试中创建测试对象\",{\"1\":{\"431\":1}}],[\"在模板方法模式的父类中\",{\"1\":{\"803\":1}}],[\"在模板中替换表达式的工具\",{\"1\":{\"430\":1}}],[\"在模块化设计中这个机制尤其重要\",{\"1\":{\"95\":1}}],[\"在云上进行客户端跨平台透明加密\",{\"1\":{\"427\":1}}],[\"在wildfly中作为网络层使用\",{\"1\":{\"419\":1}}],[\"在商用硬件集群上用来进行大规模数据存储的开源软件框架\",{\"1\":{\"413\":1}}],[\"在传统角色的基础上增加了另外一层抽象\",{\"1\":{\"399\":1}}],[\"在集群内动态管理应用程序的框架\",{\"1\":{\"387\":1}}],[\"在各自辉煌之后还在一直使用\",{\"1\":{\"384\":1}}],[\"在classdefiner\",{\"1\":{\"312\":1}}],[\"在第一个单词之前有一个\",{\"1\":{\"956\":1}}],[\"在第一次时调用\",{\"1\":{\"312\":1}}],[\"在第4行代码的时候\",{\"1\":{\"290\":1}}],[\"在上方详细说明\",{\"1\":{\"853\":1}}],[\"在上述代码中调用方法\",{\"1\":{\"308\":1}}],[\"在上面讲的工厂模式中\",{\"1\":{\"622\":1}}],[\"在上面的实例中\",{\"1\":{\"564\":1}}],[\"在上面的程序中\",{\"1\":{\"290\":1}}],[\"在上面\",{\"1\":{\"289\":1}}],[\"在通过getmethods方法获取method对象时\",{\"1\":{\"308\":1}}],[\"在反射包中\",{\"1\":{\"304\":1}}],[\"在看下面的定义\",{\"1\":{\"297\":1}}],[\"在泛型方法中使用的t是自己在方法中定义的\",{\"1\":{\"296\":1}}],[\"在不同的场合下\",{\"1\":{\"814\":1}}],[\"在不同的应用场景下会有不同的解读\",{\"1\":{\"808\":1}}],[\"在不同的口味点餐子类中具体实现\",{\"1\":{\"613\":1}}],[\"在不破坏封装性的前提下\",{\"1\":{\"798\":1}}],[\"在不修改目标对象的功能前提下\",{\"1\":{\"696\":1}}],[\"在不修改客户端代码的情况下更换和添加新的具体产品类\",{\"1\":{\"608\":1}}],[\"在不改变集合元素的前提下\",{\"1\":{\"798\":1}}],[\"在不改变原有对象的情况下\",{\"1\":{\"579\":1}}],[\"在不改变现有对象结构的情况下\",{\"1\":{\"579\":1}}],[\"在不指定泛型的情况下\",{\"1\":{\"289\":1}}],[\"在不创建新的类型的情况下\",{\"1\":{\"279\":1}}],[\"在程序上作出分门别类的判断\",{\"1\":{\"858\":1}}],[\"在程序设计中\",{\"1\":{\"792\":1}}],[\"在程序中我们定义实体\",{\"1\":{\"832\":1}}],[\"在程序中可以包含不同类型的pair\",{\"1\":{\"289\":1}}],[\"在程序中定义了一个arraylist泛型类型实例化为integer对象\",{\"1\":{\"288\":1}}],[\"在程序员的世界里\",{\"1\":{\"93\":1}}],[\"在这些规则允许以分号\",{\"1\":{\"901\":1}}],[\"在这些连接对象中有我们需要的则直接拿来用\",{\"1\":{\"629\":1}}],[\"在这种关系中\",{\"1\":{\"834\":1}}],[\"在这种情况下\",{\"1\":{\"689\":1,\"905\":1,\"960\":1}}],[\"在这里大家可能会疑问\",{\"1\":{\"823\":1}}],[\"在这里\",{\"1\":{\"625\":1,\"996\":1}}],[\"在这三种细分的工厂模式中\",{\"1\":{\"606\":1}}],[\"在这个子类中\",{\"1\":{\"291\":1}}],[\"在这个例子中\",{\"1\":{\"288\":1,\"996\":1}}],[\"在这段时间里专注于一件事\",{\"1\":{\"36\":1}}],[\"在类中删除未使用的任何字段和方法\",{\"1\":{\"853\":1}}],[\"在类中找个隐蔽的位置插入下面这段代码\",{\"1\":{\"91\":1}}],[\"在类型和变量的定义之间\",{\"1\":{\"911\":1}}],[\"在类型对齐时\",{\"1\":{\"852\":1}}],[\"在类型擦除中替换为类型参数的上界或者下界\",{\"1\":{\"287\":1}}],[\"在类型擦除中直接被替换为object\",{\"1\":{\"287\":1}}],[\"在类进行初始化时\",{\"1\":{\"758\":1}}],[\"在类装载时就实例化\",{\"1\":{\"752\":1}}],[\"在类装载的时候就完成实例化\",{\"1\":{\"752\":1}}],[\"在类的设计上\",{\"1\":{\"741\":1}}],[\"在类的结构设计上\",{\"1\":{\"741\":1}}],[\"在类的划分上\",{\"1\":{\"741\":1}}],[\"在类加载的时候\",{\"1\":{\"305\":1}}],[\"在抛出mybusinessexception\",{\"1\":{\"266\":1}}],[\"在许可的条件下\",{\"1\":{\"265\":1}}],[\"在禁止并发修改的情况下\",{\"1\":{\"265\":1}}],[\"在null被禁止的情况下参数值为null\",{\"1\":{\"265\":1}}],[\"在解析字符串形式的数字时\",{\"1\":{\"263\":1,\"858\":1}}],[\"在知道该如何处理的情况下了捕获异常\",{\"1\":{\"260\":1}}],[\"在恰当的级别处理问题\",{\"1\":{\"260\":1}}],[\"在timestamp属性fasttime和nanos分别存储秒和纳秒信息\",{\"1\":{\"849\":1}}],[\"在try语句块中是按照顺序来执行的\",{\"1\":{\"257\":1}}],[\"在testmethodannotation中添加main方法进行测试\",{\"1\":{\"234\":1}}],[\"在junit中\",{\"1\":{\"982\":1}}],[\"在junit4中\",{\"1\":{\"972\":1}}],[\"在junit3中\",{\"1\":{\"972\":1}}],[\"在java应用中程序以svg格式显示\",{\"1\":{\"408\":1}}],[\"在java\",{\"1\":{\"396\":1,\"850\":1}}],[\"在java8中新增一个默认的方法实现\",{\"1\":{\"308\":1}}],[\"在java中提供了一些异常用来描述经常发生的错误\",{\"1\":{\"261\":1}}],[\"在java中\",{\"1\":{\"252\":1,\"290\":1,\"304\":1}}],[\"在jdk7之后\",{\"1\":{\"851\":1}}],[\"在jdk7及以上\",{\"1\":{\"850\":1}}],[\"在jdk7版本及以上\",{\"1\":{\"850\":1}}],[\"在jdk中\",{\"1\":{\"845\":1}}],[\"在jdk\",{\"1\":{\"226\":2}}],[\"在jdk9中允许有private方法\",{\"1\":{\"194\":1}}],[\"在jdk9中允许有私有普通方法\",{\"1\":{\"194\":1}}],[\"在jdk8中\",{\"1\":{\"849\":1}}],[\"在jdk8中可以有静态方法\",{\"1\":{\"194\":1}}],[\"在jdk8可以有default方法\",{\"1\":{\"194\":2}}],[\"在jdbc4\",{\"1\":{\"98\":1}}],[\"在构造方法中的区别\",{\"0\":{\"200\":1}}],[\"在使用\",{\"1\":{\"885\":1}}],[\"在使用平台资源\",{\"1\":{\"861\":1}}],[\"在使用正则表达式时\",{\"1\":{\"855\":1}}],[\"在使用尝试机制来获取锁的方式中\",{\"1\":{\"851\":1}}],[\"在使用阻塞等待获取锁的方式中\",{\"1\":{\"851\":1}}],[\"在使用集合元素时\",{\"1\":{\"850\":1}}],[\"在使用java\",{\"1\":{\"850\":2}}],[\"在使用继承时\",{\"1\":{\"732\":1}}],[\"在使用中\",{\"1\":{\"636\":1}}],[\"在使用泛型的时候\",{\"1\":{\"284\":1}}],[\"在使用静态变量和方法时不用再指明\",{\"1\":{\"144\":1}}],[\"在使用这些基本类型对应的包装类型时\",{\"1\":{\"120\":1}}],[\"在覆盖\",{\"1\":{\"139\":1}}],[\"在将一个参数传入一个方法时\",{\"1\":{\"127\":1}}],[\"在加载类和结构到虚拟机后\",{\"1\":{\"125\":1}}],[\"在加载某接口时\",{\"1\":{\"96\":1}}],[\"在\",{\"0\":{\"264\":1},\"1\":{\"120\":1,\"133\":2,\"187\":1,\"211\":1,\"213\":1,\"214\":1,\"262\":1,\"266\":1,\"301\":1,\"449\":2,\"459\":1,\"472\":1,\"532\":1,\"534\":4,\"600\":1,\"601\":1,\"606\":1,\"622\":2,\"637\":2,\"646\":1,\"663\":1,\"677\":1,\"702\":1,\"711\":1,\"725\":1,\"732\":1,\"760\":1,\"809\":1,\"823\":1,\"824\":1,\"825\":1,\"830\":1,\"831\":1,\"832\":1,\"833\":1,\"834\":1,\"848\":1,\"877\":1,\"892\":1,\"907\":1,\"908\":1,\"911\":1,\"924\":1,\"937\":1,\"997\":1,\"998\":1}}],[\"在main参数中\",{\"1\":{\"845\":1}}],[\"在meta\",{\"1\":{\"110\":1}}],[\"在mysql的jar包mysql\",{\"1\":{\"100\":1}}],[\"在遍历的时候\",{\"1\":{\"103\":1}}],[\"在拿到这个对象后\",{\"1\":{\"93\":1}}],[\"在限定了上面的修饰语只调用\",{\"1\":{\"92\":1}}],[\"在失败中总结经验\",{\"1\":{\"36\":2}}],[\"在页面禁用功能与布局\",{\"1\":{\"6\":1}}],[\"做相应的小型重构\",{\"1\":{\"816\":1}}],[\"做任何事情都要讲求一个\",{\"1\":{\"810\":1}}],[\"做事\",{\"1\":{\"800\":2}}],[\"做事情的方法更灵活了\",{\"1\":{\"36\":1}}],[\"做个对比\",{\"1\":{\"772\":1}}],[\"做咖啡\",{\"1\":{\"657\":1}}],[\"做一个产品展示网站\",{\"1\":{\"633\":1}}],[\"做各种初始化操作的时候\",{\"1\":{\"614\":1}}],[\"做成抽象的\",{\"1\":{\"574\":1}}],[\"做的事情就是封装了我们的接口类型和类加载器\",{\"1\":{\"103\":1}}],[\"做早餐\",{\"1\":{\"36\":1}}],[\"久而久之\",{\"1\":{\"36\":1}}],[\"汲取他人身上的闪光点\",{\"1\":{\"36\":1}}],[\"补己之短\",{\"1\":{\"36\":1}}],[\"警醒自己的缺点\",{\"1\":{\"36\":1}}],[\"警告容器\",{\"1\":{\"14\":2}}],[\"欣赏别人的优点\",{\"1\":{\"36\":1}}],[\"踏踏实实地完成运动任务\",{\"1\":{\"36\":1}}],[\"从这个假对象中获取数据\",{\"1\":{\"996\":1}}],[\"从这个设计初衷上来看\",{\"1\":{\"810\":1}}],[\"从命名的文字构成开始\",{\"1\":{\"947\":1}}],[\"从不要求\",{\"0\":{\"912\":1}}],[\"从性能数据上分析\",{\"1\":{\"865\":1}}],[\"从服务器删除资源\",{\"1\":{\"854\":1}}],[\"从服务器取出资源\",{\"1\":{\"854\":1}}],[\"从第三行开始\",{\"1\":{\"847\":1}}],[\"从子类指向父类\",{\"1\":{\"835\":1}}],[\"从定义上\",{\"1\":{\"818\":1}}],[\"从图上可以看出\",{\"1\":{\"818\":1}}],[\"从图中我们也可以看出\",{\"1\":{\"741\":1}}],[\"从业务含义上\",{\"1\":{\"814\":1}}],[\"从理论上讲\",{\"1\":{\"813\":1}}],[\"从私有云下载图片\",{\"1\":{\"809\":1}}],[\"从阿里云下载图片\",{\"1\":{\"809\":2}}],[\"从本质上来看\",{\"1\":{\"808\":1}}],[\"从父类继承而来的实现是静态的\",{\"1\":{\"747\":1}}],[\"从备忘录对象\",{\"1\":{\"667\":1}}],[\"从备忘录对象恢复到大战前的状态\",{\"1\":{\"665\":1}}],[\"从上面的例子来看\",{\"1\":{\"814\":1}}],[\"从上面的代码中\",{\"1\":{\"625\":1}}],[\"从上面章节\",{\"1\":{\"289\":1}}],[\"从设计层面看\",{\"1\":{\"616\":1}}],[\"从设计层面上看\",{\"1\":{\"133\":1}}],[\"从当前这个案例来说\",{\"1\":{\"613\":1}}],[\"从大到小创建对象\",{\"1\":{\"574\":1}}],[\"从用户的角度看不到被适配者\",{\"1\":{\"520\":1}}],[\"从最近发布不久的\",{\"1\":{\"443\":1}}],[\"从最基本的层面增强开发流程\",{\"1\":{\"398\":1}}],[\"从xsl\",{\"1\":{\"421\":1}}],[\"从非结构化数据建立结构化信息并集成到已有数据库的工具\",{\"1\":{\"413\":1}}],[\"从编译的结果来看\",{\"1\":{\"291\":1}}],[\"从他们的\",{\"1\":{\"291\":1}}],[\"从一个简单的泛型类看起\",{\"1\":{\"281\":1}}],[\"从程序语法角度讲是必须进行处理的异常\",{\"1\":{\"248\":1}}],[\"从它的定义我们可以知道\",{\"1\":{\"224\":1}}],[\"从它的定义我们可以看到\",{\"1\":{\"223\":1}}],[\"从而在代码中添加若干数量的额外空格的做法\",{\"1\":{\"912\":1}}],[\"从而导致oom\",{\"1\":{\"851\":3}}],[\"从而导致测试结果互相影响的问题\",{\"1\":{\"767\":1}}],[\"从而限制\",{\"1\":{\"798\":1}}],[\"从而缩短软件的开发周期\",{\"1\":{\"797\":1}}],[\"从而让程序结构更加灵活\",{\"1\":{\"784\":1}}],[\"从而让另一方对象对此做出响应\",{\"1\":{\"680\":1}}],[\"从而避免重复的代码\",{\"1\":{\"783\":1}}],[\"从而实现不同的逻辑\",{\"1\":{\"779\":1}}],[\"从而实现对目标对象的调用\",{\"1\":{\"703\":1}}],[\"从而完成\",{\"1\":{\"758\":1}}],[\"从而完成反射调用功能\",{\"1\":{\"312\":1}}],[\"从而易于扩展和维护\",{\"1\":{\"737\":1}}],[\"从而造成冗余代码或代码的浪费\",{\"1\":{\"716\":1}}],[\"从而创建一个新的对象\",{\"1\":{\"683\":1}}],[\"从而降低了抽象和实现这两个可变维度的耦合度\",{\"1\":{\"798\":1}}],[\"从而降低了系统中细粒度对象给内存带来的压力\",{\"1\":{\"629\":1}}],[\"从而降低系统的耦合度\",{\"1\":{\"593\":1}}],[\"从而提高系统的复用程度\",{\"1\":{\"837\":1}}],[\"从而提高了类的可复用率和系统的扩展性\",{\"1\":{\"741\":1}}],[\"从而提高项目的扩展和维护性\",{\"1\":{\"619\":1}}],[\"从而提高项目的维护性\",{\"1\":{\"583\":1}}],[\"从而提高子系统的独立性和可移植性\",{\"1\":{\"604\":1}}],[\"从而产生更好的结构化系统\",{\"1\":{\"544\":1}}],[\"从而极大的提供了系统的灵活性\",{\"1\":{\"544\":1}}],[\"从而可以保持各部分的独立性以及应对他们的功能扩展\",{\"1\":{\"537\":1}}],[\"从而可以更好地定位具体错误信息\",{\"1\":{\"266\":1}}],[\"从而可以更好地避免或处理异常\",{\"1\":{\"266\":1}}],[\"从而保证数据隔离\",{\"1\":{\"313\":1}}],[\"从而每个类都可以获取method反射方法\",{\"1\":{\"313\":1}}],[\"从而使其行为也发生改变\",{\"1\":{\"775\":1}}],[\"从而使其\",{\"1\":{\"655\":1}}],[\"从而使其耦合松散\",{\"1\":{\"591\":1}}],[\"从而使得更容易控制反射类的生命周期\",{\"1\":{\"312\":1}}],[\"从而使用接口或方法进行调用实例功能了\",{\"1\":{\"310\":1}}],[\"从而使内存不够可以回收\",{\"1\":{\"310\":1}}],[\"从而获取当前的\",{\"1\":{\"310\":1}}],[\"从而获得\",{\"1\":{\"210\":1}}],[\"从而覆盖了原始异常\",{\"1\":{\"259\":1}}],[\"从而影响其他对象的行为\",{\"1\":{\"798\":1}}],[\"从而影响\",{\"1\":{\"218\":1}}],[\"从而简化代码\",{\"1\":{\"144\":1}}],[\"从而委托父类完成一些初始化的工作\",{\"1\":{\"134\":1}}],[\"从使用上来看\",{\"1\":{\"133\":1}}],[\"从\",{\"1\":{\"130\":1,\"133\":1,\"170\":1,\"228\":1,\"562\":1,\"625\":1,\"644\":1,\"650\":1}}],[\"从所有的jar包中找到meta\",{\"1\":{\"106\":1}}],[\"从classpath下的每个jar包中搜寻所有meta\",{\"1\":{\"106\":1}}],[\"从vm系统属性org\",{\"1\":{\"104\":1}}],[\"从系统变量中获取有关驱动的定义\",{\"1\":{\"103\":1}}],[\"从多散步十分钟或者每天做10个俯卧撑开始\",{\"1\":{\"36\":1}}],[\"从今天开始\",{\"1\":{\"36\":1}}],[\"变成\",{\"1\":{\"947\":1}}],[\"变更是必然的\",{\"1\":{\"717\":1}}],[\"变更引起的风险降低\",{\"1\":{\"717\":1}}],[\"变得复杂且难以维护\",{\"1\":{\"655\":1}}],[\"变得很重要\",{\"1\":{\"560\":1}}],[\"变化\",{\"1\":{\"565\":1}}],[\"变为原始类型object\",{\"1\":{\"291\":1}}],[\"变量声明\",{\"0\":{\"916\":1}}],[\"变量作用域太大\",{\"1\":{\"848\":1}}],[\"变量像自己的小孩\",{\"1\":{\"848\":1}}],[\"变量名\",{\"1\":{\"845\":1}}],[\"变量名称\",{\"1\":{\"644\":1}}],[\"变量的\",{\"1\":{\"729\":1}}],[\"变量的解释器\",{\"1\":{\"644\":1}}],[\"变量不要直接持有具体类的引用\",{\"1\":{\"619\":1}}],[\"变量可以用\",{\"1\":{\"451\":1}}],[\"变量c的类型就是class<user>\",{\"1\":{\"283\":1}}],[\"变量和文本\",{\"1\":{\"186\":1}}],[\"变量也就是我们所说的编译期常量\",{\"1\":{\"183\":1}}],[\"变量\",{\"1\":{\"128\":1,\"451\":1,\"848\":1,\"852\":1}}],[\"变健康\",{\"1\":{\"36\":1}}],[\"变优秀\",{\"1\":{\"36\":1}}],[\"变自律\",{\"1\":{\"36\":1}}],[\"都比较粗\",{\"1\":{\"991\":1}}],[\"都比较偏上层\",{\"1\":{\"808\":1}}],[\"都进行\",{\"1\":{\"866\":1}}],[\"都需要进行数行相同的参数校验操作\",{\"1\":{\"871\":1}}],[\"都需要能方便查到\",{\"1\":{\"869\":1}}],[\"都需要在列名前加表的别名\",{\"1\":{\"865\":1}}],[\"都需要创建一个对应的第三方的公告板对象\",{\"1\":{\"677\":1}}],[\"都不允许出现任何大写字母\",{\"1\":{\"863\":1}}],[\"都不要加is前缀\",{\"1\":{\"845\":1,\"863\":1}}],[\"都应该进行单元测试\",{\"1\":{\"860\":1}}],[\"都应指定大小\",{\"1\":{\"855\":1}}],[\"都必须包含一个default语句并且放在最后\",{\"1\":{\"852\":1}}],[\"都由使用者来保证\",{\"1\":{\"848\":1}}],[\"都要在每一个具体访问者类中增加相应的具体操作\",{\"1\":{\"837\":1}}],[\"都要对可能出现的问题进行检查\",{\"1\":{\"206\":1}}],[\"都继承\",{\"1\":{\"812\":1}}],[\"都继承这个抽象类\",{\"1\":{\"812\":1}}],[\"都有设计模式\",{\"1\":{\"795\":1}}],[\"都有类型为\",{\"1\":{\"732\":1}}],[\"都尽量将逻辑封装在类的内部\",{\"1\":{\"741\":1}}],[\"都代换成\",{\"1\":{\"732\":1}}],[\"都只和自己左右两个数字有关系\",{\"1\":{\"644\":1}}],[\"都还是一个煎饼\",{\"1\":{\"579\":1}}],[\"都可以操控这个变量\",{\"1\":{\"851\":1}}],[\"都可以在很短的时间内完成\",{\"1\":{\"818\":1}}],[\"都可以采用\",{\"1\":{\"655\":1}}],[\"都可以达成共享\",{\"1\":{\"635\":1}}],[\"都可以装配到一个对象中\",{\"1\":{\"558\":1}}],[\"都可以帮助你实现这个最佳实践\",{\"1\":{\"267\":1}}],[\"都会委派给实际的\",{\"1\":{\"996\":1}}],[\"都会在堆上产生\",{\"1\":{\"848\":1}}],[\"都会变得豁然开朗\",{\"1\":{\"810\":1}}],[\"都会问你在实际项目中\",{\"1\":{\"796\":1}}],[\"都会被打包成一个个箱子\",{\"1\":{\"648\":1}}],[\"都会创建一个新的对象返回\",{\"1\":{\"627\":1}}],[\"都会copy一份出来\",{\"1\":{\"313\":1}}],[\"都会给你带来意想不到的提升\",{\"1\":{\"36\":1}}],[\"都替换为具体的类型\",{\"1\":{\"278\":1,\"287\":1}}],[\"都调用30位置的处理者\",{\"1\":{\"275\":2}}],[\"都能够调用它的任意一个方法和属性\",{\"1\":{\"300\":1}}],[\"都能够知道这个类的所有属性和方法\",{\"1\":{\"300\":1}}],[\"都能够更容易被人阅读\",{\"1\":{\"266\":1}}],[\"都能自带代码混淆光环\",{\"1\":{\"94\":1}}],[\"都指的对象\",{\"1\":{\"200\":1}}],[\"都依赖于\",{\"1\":{\"179\":1}}],[\"都是正确的\",{\"1\":{\"947\":1}}],[\"都是有效的\",{\"1\":{\"911\":1}}],[\"都是把自己的思想描述给别人看\",{\"1\":{\"822\":1}}],[\"都是用它来表示一些全局唯一类\",{\"1\":{\"763\":1}}],[\"都是为了实现代码的松耦合\",{\"1\":{\"741\":1}}],[\"都是统一刷卡或者刷脸进站\",{\"1\":{\"648\":1}}],[\"都是\",{\"1\":{\"644\":1,\"689\":1,\"768\":1}}],[\"都是工厂模式联合着其它设计模式使用\",{\"1\":{\"606\":1}}],[\"都是装饰器模式\",{\"1\":{\"579\":1}}],[\"都是通过从列表中搜寻查找匹配的方法\",{\"1\":{\"313\":1}}],[\"都是先从缓存中获取方法\",{\"1\":{\"311\":1}}],[\"都是获取method对象所表示的方法的参数类型\",{\"1\":{\"308\":1}}],[\"都是runtimeexception类及其子类异常\",{\"1\":{\"248\":1}}],[\"都是对象\",{\"1\":{\"180\":1}}],[\"都是对接口driver的实现\",{\"1\":{\"110\":1}}],[\"都是上坡路\",{\"1\":{\"36\":1}}],[\"都在不同程度地变好看\",{\"1\":{\"36\":1}}],[\"锻炼\",{\"1\":{\"36\":1}}],[\"早起10分钟做些你想做的事\",{\"1\":{\"36\":1}}],[\"早起10分钟\",{\"1\":{\"36\":1}}],[\"早睡半小时\",{\"1\":{\"36\":2}}],[\"自解释的成员\",{\"0\":{\"960\":1}}],[\"自带类生成工具可能出现实心箭头\",{\"1\":{\"835\":1}}],[\"自带\",{\"1\":{\"833\":1,\"834\":1}}],[\"自带的原型模式基于内存二进制流的复制\",{\"1\":{\"682\":1}}],[\"自然其可读性会提高\",{\"1\":{\"717\":1}}],[\"自然语言处理\",{\"0\":{\"418\":1}}],[\"自己都没有意识到使用了设计模式\",{\"1\":{\"794\":1}}],[\"自己写了很多代码\",{\"1\":{\"794\":1}}],[\"自己在编写代码的时候自己保证不要创建两个类对象\",{\"1\":{\"769\":1}}],[\"自己刚刚到一个陌生城市找工作\",{\"1\":{\"655\":1}}],[\"自己价格\",{\"1\":{\"584\":1}}],[\"自由职业者\",{\"1\":{\"440\":1}}],[\"自动化的单元测试避免了代码出现回归\",{\"1\":{\"990\":1}}],[\"自动化的java对象序列化和克隆库\",{\"1\":{\"409\":1}}],[\"自动化\",{\"1\":{\"860\":1}}],[\"自动解箱抛npe\",{\"1\":{\"858\":1}}],[\"自动拆箱有可能产生npe反例\",{\"1\":{\"858\":1}}],[\"自动完成看电视的准备工作\",{\"1\":{\"657\":1}}],[\"自动完成功能超棒\",{\"1\":{\"480\":1}}],[\"自动屏幕\",{\"1\":{\"597\":1,\"601\":2}}],[\"自动产生\",{\"1\":{\"287\":1}}],[\"自动释放的资源需要是实现了\",{\"1\":{\"259\":1}}],[\"自反性\",{\"1\":{\"138\":1,\"181\":1}}],[\"自我提升九大招\",{\"0\":{\"36\":1}}],[\"自定义测试方法的顺序\",{\"1\":{\"983\":1}}],[\"自定义的控件类型需明确交互方式\",{\"1\":{\"871\":1}}],[\"自定义线程工厂\",{\"1\":{\"851\":1}}],[\"自定义对value的处理策略\",{\"1\":{\"850\":1}}],[\"自定义对齐\",{\"0\":{\"16\":1}}],[\"自定义log注解\",{\"1\":{\"242\":1}}],[\"自定义elementtype\",{\"1\":{\"236\":2}}],[\"自定义注解的包路径\",{\"1\":{\"242\":1}}],[\"自定义注解和aop\",{\"0\":{\"242\":1}}],[\"自定义注解\",{\"0\":{\"234\":1},\"1\":{\"221\":1}}],[\"自定义它们\",{\"1\":{\"34\":1}}],[\"自定义标题\",{\"1\":{\"14\":10}}],[\"自定义容器\",{\"0\":{\"14\":1}}],[\"此对象与数据库表结构一\",{\"1\":{\"873\":2}}],[\"此对象与数据库表结构一一对应\",{\"1\":{\"868\":1}}],[\"此原则说父类能够出现的地方子类一定能够出现\",{\"1\":{\"871\":1}}],[\"此种方式容易出现sql注入\",{\"1\":{\"866\":1}}],[\"此条约定有利于数据层面上的协作更加高效\",{\"1\":{\"854\":1}}],[\"此条规则优先于下一条\",{\"1\":{\"848\":1}}],[\"此情形中\",{\"1\":{\"852\":1}}],[\"此写法的泛型集合不能使用add方法\",{\"1\":{\"850\":1}}],[\"此方法将正常返回\",{\"1\":{\"978\":1}}],[\"此方法返回值只能是object\",{\"1\":{\"850\":1}}],[\"此方法内部其实执行了double的tostring\",{\"1\":{\"848\":1}}],[\"此方法会忽略注解对应的注解容器\",{\"1\":{\"233\":1}}],[\"此规则参考spring的框架结构\",{\"1\":{\"845\":1}}],[\"此模式让行为的变化独立于算法的使用者\",{\"1\":{\"789\":1}}],[\"此模式让\",{\"1\":{\"783\":1}}],[\"此弊端可使用\",{\"1\":{\"612\":1}}],[\"此变量的类型由外部决定\",{\"1\":{\"281\":2}}],[\"此处类的配置顺序会影响执行顺序\",{\"1\":{\"982\":1}}],[\"此处抛出classcastexception异常\",{\"1\":{\"850\":1}}],[\"此处泛型只能是数字类型\",{\"1\":{\"284\":1}}],[\"此处指定了两个泛型类型\",{\"1\":{\"281\":1}}],[\"此处可以随便写标识符号\",{\"1\":{\"281\":1}}],[\"此处不返回\",{\"1\":{\"273\":1,\"858\":1}}],[\"此异常将会抛给jvm处理\",{\"1\":{\"257\":1}}],[\"此类型为双精度浮点数\",{\"1\":{\"854\":1}}],[\"此类型包括类型声明和类型参数声明\",{\"1\":{\"236\":1}}],[\"此类随意缩写严重降低了代码的可阅读性\",{\"1\":{\"845\":1}}],[\"此类错误发生时\",{\"1\":{\"247\":1}}],[\"此类错误一般表示代码运行时\",{\"1\":{\"247\":1}}],[\"此时可以不校验参数\",{\"1\":{\"852\":1}}],[\"此时可以考虑为新系统开发一个\",{\"1\":{\"603\":1}}],[\"此时数据库id不支持存入负数抛出异常产生线上故障\",{\"1\":{\"848\":1}}],[\"此时我们就将这些对象的信息分为两个部分\",{\"1\":{\"631\":1}}],[\"此时的\",{\"1\":{\"610\":1}}],[\"此时\",{\"1\":{\"560\":1}}],[\"此时并没有返回运算后的值\",{\"1\":{\"197\":1}}],[\"此时并没有实例化具体的实现类\",{\"1\":{\"103\":1}}],[\"此时程序崩溃并且无法恢复\",{\"1\":{\"146\":1}}],[\"此时子类的方法不是重写基类方法\",{\"1\":{\"143\":1}}],[\"此时就会根据驱动名字具体实例化各个实现类了\",{\"1\":{\"103\":1}}],[\"此时满足if条件\",{\"1\":{\"92\":1}}],[\"此外也可以通过使用\",{\"1\":{\"295\":1}}],[\"此外由于t\",{\"1\":{\"293\":1}}],[\"此外\",{\"1\":{\"42\":1,\"417\":1,\"843\":1,\"854\":1,\"859\":1,\"870\":1}}],[\"此页面应当包含\",{\"1\":{\"34\":1}}],[\"此文字有脚注\",{\"1\":{\"18\":1}}],[\"徽章\",{\"1\":{\"33\":1}}],[\"徽章文字\",{\"1\":{\"33\":1}}],[\"标注一起使用\",{\"1\":{\"972\":1}}],[\"标识符只允许使用\",{\"1\":{\"937\":1}}],[\"标签与单词之间没有空格\",{\"1\":{\"956\":1}}],[\"标签返回到上一个缩进级别\",{\"1\":{\"923\":1}}],[\"标签之后会有一个换行\",{\"1\":{\"923\":1}}],[\"标签之后跟随着一条或多条语句\",{\"1\":{\"922\":1}}],[\"标签\",{\"1\":{\"922\":1,\"956\":2}}],[\"标签构建\",{\"1\":{\"460\":1}}],[\"标签为\",{\"1\":{\"32\":1}}],[\"标准日志输出与标准错误输出文件每次jboss重启时才滚动\",{\"1\":{\"859\":1}}],[\"标准中的\",{\"1\":{\"750\":1}}],[\"标准库的设计了\",{\"1\":{\"586\":1}}],[\"标准库中没有内置对元组的支持\",{\"1\":{\"468\":1}}],[\"标准库缺少的特性进行补充的扩展库\",{\"1\":{\"466\":1}}],[\"标准库曾经作出过惊人的改进\",{\"1\":{\"464\":1}}],[\"标准\",{\"1\":{\"420\":1}}],[\"标准资源都继承了这个接口\",{\"1\":{\"264\":1}}],[\"标志设置为指示的布尔值\",{\"1\":{\"307\":1}}],[\"标明要忽略的警告\",{\"1\":{\"221\":1}}],[\"标明某个类或方法过时\",{\"1\":{\"221\":1}}],[\"标题和页面信息\",{\"1\":{\"34\":1}}],[\"标记时\",{\"1\":{\"927\":1}}],[\"标记时间\",{\"1\":{\"853\":2}}],[\"标记人\",{\"1\":{\"853\":2}}],[\"标记\",{\"0\":{\"19\":1}}],[\"日后的改动需要调整一行代码\",{\"1\":{\"912\":1}}],[\"日后基本不会改\",{\"1\":{\"732\":1}}],[\"日常是把bigint转成long值\",{\"1\":{\"866\":1}}],[\"日注册\",{\"1\":{\"849\":1}}],[\"日期格式等\",{\"1\":{\"872\":1}}],[\"日期格式\",{\"1\":{\"859\":1}}],[\"日期格式中的这两对字母表意如下\",{\"1\":{\"849\":1}}],[\"日期格式化时\",{\"1\":{\"849\":2}}],[\"日期时间的闰年\",{\"1\":{\"872\":1}}],[\"日期时间\",{\"0\":{\"849\":1}}],[\"日志处理等\",{\"1\":{\"872\":1}}],[\"日志方式与dao层处理一致\",{\"1\":{\"868\":1}}],[\"日志排查问题时\",{\"1\":{\"859\":1}}],[\"日志打印时禁止直接用json工具将对象转换成string\",{\"1\":{\"859\":1}}],[\"日志描述\",{\"1\":{\"859\":1}}],[\"日志类型\",{\"1\":{\"859\":1}}],[\"日志保存\",{\"1\":{\"859\":1}}],[\"日志文件中的用户敏感信息需要进行脱敏处理\",{\"1\":{\"859\":1}}],[\"日志文件至少保存\",{\"1\":{\"859\":1}}],[\"日志文件管理工具\",{\"1\":{\"412\":1}}],[\"日志框架\",{\"1\":{\"859\":1}}],[\"日志规约\",{\"0\":{\"859\":1}}],[\"日志解决方案\",{\"1\":{\"473\":1}}],[\"日志抽象层\",{\"1\":{\"412\":1}}],[\"日志\",{\"0\":{\"412\":1},\"1\":{\"242\":1}}],[\"日志实例是通过logfactory的getlog\",{\"1\":{\"104\":1}}],[\"日\",{\"1\":{\"32\":1,\"618\":1,\"849\":2}}],[\"月份有\",{\"1\":{\"849\":1}}],[\"月问题\",{\"1\":{\"849\":1}}],[\"月在云栖厅发布\",{\"1\":{\"843\":1}}],[\"月\",{\"1\":{\"32\":1,\"618\":1,\"849\":3}}],[\"年杭州云栖大会上发布了配套的java开发规约ide插件\",{\"1\":{\"843\":1}}],[\"年代从建筑设计领域引入到计算机科学的\",{\"1\":{\"796\":1}}],[\"年的著作\",{\"1\":{\"736\":1}}],[\"年的\",{\"1\":{\"732\":1}}],[\"年龄区间\",{\"1\":{\"863\":1}}],[\"年龄为\",{\"1\":{\"684\":1}}],[\"年龄\",{\"1\":{\"281\":1}}],[\"年\",{\"1\":{\"32\":1,\"618\":1,\"808\":1,\"822\":1,\"843\":1,\"849\":2}}],[\"的最主要的原因就是在测试时某些组件不可用或运行速度太慢\",{\"1\":{\"996\":1}}],[\"的主要区别就是\",{\"1\":{\"996\":1}}],[\"的单元测试时\",{\"1\":{\"995\":1}}],[\"的单测来覆盖\",{\"1\":{\"991\":2}}],[\"的单例\",{\"1\":{\"772\":3}}],[\"的单例和\",{\"1\":{\"772\":1}}],[\"的成员\",{\"1\":{\"960\":1}}],[\"的位置缩进四个\",{\"1\":{\"957\":1}}],[\"的行\",{\"1\":{\"956\":1}}],[\"的行为没有发生变化\",{\"1\":{\"732\":1}}],[\"的异常\",{\"1\":{\"950\":1}}],[\"的格式命名\",{\"1\":{\"942\":1}}],[\"的格式\",{\"1\":{\"920\":1}}],[\"的冒号\",{\"1\":{\"907\":1}}],[\"的符号\",{\"1\":{\"907\":1,\"911\":1}}],[\"的等值比较\",{\"1\":{\"872\":1}}],[\"的示例等\",{\"1\":{\"872\":1}}],[\"的判断\",{\"1\":{\"872\":1}}],[\"的限定词\",{\"1\":{\"872\":1}}],[\"的限制\",{\"1\":{\"865\":1}}],[\"的详细说明以及正反例\",{\"1\":{\"872\":1}}],[\"的适用场景描述\",{\"1\":{\"872\":1}}],[\"的适配器模式剖析\",{\"0\":{\"533\":1}}],[\"的适配\",{\"1\":{\"527\":1}}],[\"的前后矛盾\",{\"1\":{\"872\":1}}],[\"的前缀来标识单元测试相关代码\",{\"1\":{\"860\":1}}],[\"的子集合\",{\"1\":{\"866\":1}}],[\"的子类型\",{\"1\":{\"732\":1}}],[\"的子类的列表\",{\"1\":{\"284\":1}}],[\"的子类\",{\"1\":{\"267\":1,\"586\":4,\"651\":1}}],[\"的顺序依次命名\",{\"1\":{\"865\":1}}],[\"的返回结果为null\",{\"1\":{\"865\":1}}],[\"的返回结果为\",{\"1\":{\"865\":1}}],[\"的区分度来确定\",{\"1\":{\"864\":1}}],[\"的区别是\",{\"1\":{\"996\":1}}],[\"的区别之处\",{\"1\":{\"771\":1}}],[\"的区别\",{\"0\":{\"151\":1,\"165\":1,\"185\":1},\"1\":{\"771\":1}}],[\"的区别在于\",{\"1\":{\"120\":1}}],[\"的索引\",{\"1\":{\"864\":1}}],[\"的属性字段必须是私有且不可变\",{\"1\":{\"855\":1}}],[\"的属性和方法\",{\"1\":{\"210\":1}}],[\"的若干倍然后取整\",{\"1\":{\"855\":1}}],[\"的指数次的整数都是绝对不会存在精度损失的\",{\"1\":{\"854\":1}}],[\"的数值转化为javascript的number时\",{\"1\":{\"854\":1}}],[\"的数据结构如下\",{\"1\":{\"310\":1}}],[\"的设置统一为yyyy\",{\"1\":{\"853\":1}}],[\"的设计原则\",{\"1\":{\"187\":1,\"736\":1}}],[\"的设计者认为字符串使用非常频繁\",{\"1\":{\"169\":1}}],[\"的设计初衷是对那些只有少数的几个值进行等值判断\",{\"1\":{\"130\":1}}],[\"的用户id数组过来后\",{\"1\":{\"852\":1}}],[\"的情况\",{\"1\":{\"852\":1}}],[\"的空数组\",{\"1\":{\"850\":1}}],[\"的程序员对此知识点都有错误的认知\",{\"1\":{\"850\":1}}],[\"的表示方式\",{\"1\":{\"848\":1}}],[\"的编码方式\",{\"1\":{\"848\":1}}],[\"的常量\",{\"1\":{\"846\":1}}],[\"的理由\",{\"1\":{\"960\":1}}],[\"的理念\",{\"1\":{\"843\":1}}],[\"的理解\",{\"1\":{\"808\":1}}],[\"的接口\",{\"1\":{\"838\":1}}],[\"的标准类关系图中\",{\"1\":{\"835\":1}}],[\"的改动\",{\"1\":{\"820\":1}}],[\"的开发者都必须重新开发或移植代码\",{\"1\":{\"820\":1}}],[\"的版本\",{\"1\":{\"820\":1}}],[\"的版本号\",{\"1\":{\"459\":1}}],[\"的版本号是正常的\",{\"1\":{\"458\":1}}],[\"的风险也就减少了很多\",{\"1\":{\"816\":1}}],[\"的特性可以让我们聚焦在某一模块或类中\",{\"1\":{\"816\":1}}],[\"的特性之一就是调试的时候能够按照时间跟踪回来\",{\"1\":{\"481\":1}}],[\"的使用举例\",{\"1\":{\"809\":1}}],[\"的使用方式\",{\"1\":{\"859\":1,\"872\":1}}],[\"的使用方式违背了基于接口而非实现的设计原则\",{\"1\":{\"764\":1}}],[\"的使用方法和前面讲过的一样\",{\"1\":{\"679\":1}}],[\"的原则\",{\"1\":{\"809\":1}}],[\"的原因分析\",{\"1\":{\"533\":1}}],[\"的内容\",{\"1\":{\"942\":1}}],[\"的内容每天可能不同\",{\"1\":{\"800\":1}}],[\"的内容是\",{\"1\":{\"742\":1}}],[\"的精要\",{\"1\":{\"797\":1}}],[\"的各种问题\",{\"1\":{\"796\":1}}],[\"的所有实现的方法\",{\"1\":{\"788\":1}}],[\"的所有方法\",{\"1\":{\"532\":1}}],[\"的执行\",{\"1\":{\"766\":1}}],[\"的抽象特性\",{\"1\":{\"764\":1}}],[\"的四大特性是封装\",{\"1\":{\"764\":1}}],[\"的作者\",{\"1\":{\"759\":1}}],[\"的作用和地位等价于我们前面讲过的\",{\"1\":{\"679\":1}}],[\"的作用和地位等价于我们前面讲过\",{\"1\":{\"679\":1}}],[\"的实现\",{\"1\":{\"814\":1}}],[\"的实现方式\",{\"1\":{\"310\":1,\"445\":1}}],[\"的实例化\",{\"1\":{\"758\":1}}],[\"的效果\",{\"1\":{\"752\":2,\"754\":1}}],[\"的回收站\",{\"1\":{\"750\":1}}],[\"的三个方法\",{\"1\":{\"745\":2}}],[\"的直接朋友\",{\"1\":{\"741\":1,\"742\":1}}],[\"的目的是制定好\",{\"1\":{\"725\":1}}],[\"的中心思想是\",{\"1\":{\"725\":1}}],[\"的中介者\",{\"1\":{\"655\":1}}],[\"的粒度分解为\",{\"1\":{\"716\":1}}],[\"的拦截器\",{\"1\":{\"707\":1}}],[\"的框架使用\",{\"1\":{\"702\":1}}],[\"的框中设置文本\",{\"1\":{\"42\":1}}],[\"的克隆\",{\"1\":{\"689\":1}}],[\"的观察者模式剖析\",{\"0\":{\"679\":1}}],[\"的状态类\",{\"1\":{\"839\":1}}],[\"的状态\",{\"1\":{\"667\":1}}],[\"的责任分开\",{\"1\":{\"652\":1}}],[\"的类图\",{\"1\":{\"826\":1}}],[\"的类\",{\"1\":{\"651\":1}}],[\"的类型系统很差劲\",{\"1\":{\"483\":1}}],[\"的迭代器模式剖析\",{\"0\":{\"651\":1}}],[\"的值的类型不一致\",{\"1\":{\"852\":1}}],[\"的值只要有一个是原始类型\",{\"1\":{\"852\":1}}],[\"的值\",{\"1\":{\"643\":1,\"644\":1}}],[\"的享元模式剖析\",{\"0\":{\"637\":1}}],[\"的朋友感觉效果不错\",{\"1\":{\"633\":1}}],[\"的创建\",{\"1\":{\"621\":1,\"688\":1}}],[\"的时候\",{\"1\":{\"620\":1,\"769\":1,\"949\":1}}],[\"的基础上再创建一个大的工厂\",{\"1\":{\"614\":1}}],[\"的典型应用\",{\"1\":{\"593\":1}}],[\"的装饰者模式剖析\",{\"0\":{\"585\":1}}],[\"的来计算不同种类咖啡的费用\",{\"1\":{\"581\":1}}],[\"的模式\",{\"1\":{\"579\":1}}],[\"的模式让你的数据库访问变得轻而易举\",{\"1\":{\"474\":1}}],[\"的定义方式\",{\"1\":{\"845\":1}}],[\"的定义\",{\"1\":{\"579\":1,\"671\":1}}],[\"的层次关系\",{\"1\":{\"567\":1}}],[\"的关系强关系\",{\"1\":{\"835\":1}}],[\"的关系弱关系\",{\"1\":{\"835\":1}}],[\"的关系\",{\"1\":{\"567\":1,\"831\":1,\"833\":1}}],[\"的命令模式分析\",{\"0\":{\"563\":1}}],[\"的功能\",{\"1\":{\"545\":1}}],[\"的桥接模式剖析\",{\"0\":{\"543\":1}}],[\"的方法调用是否符合预期\",{\"1\":{\"996\":1}}],[\"的方法体内第一行代码isdisabled\",{\"1\":{\"859\":1}}],[\"的方法\",{\"1\":{\"679\":1,\"734\":1,\"855\":1,\"960\":1,\"996\":1}}],[\"的方法进行默认实现\",{\"1\":{\"532\":1}}],[\"的方式\",{\"1\":{\"850\":1,\"851\":1,\"885\":1}}],[\"的方式把double值转化为bigdecimal对象\",{\"1\":{\"848\":1}}],[\"的方式将它替换掉\",{\"1\":{\"767\":1}}],[\"的方式来写一些可变的集合\",{\"1\":{\"466\":1}}],[\"的方式来处理\",{\"1\":{\"263\":1}}],[\"的方式新建了两个不同对象\",{\"1\":{\"125\":1}}],[\"的局限性问题\",{\"1\":{\"529\":1}}],[\"的灵活性增强了\",{\"1\":{\"525\":1}}],[\"的电压\",{\"1\":{\"524\":1,\"528\":1}}],[\"的代码可测试性也更加好\",{\"1\":{\"816\":1}}],[\"的代码就不难看懂了\",{\"1\":{\"627\":1}}],[\"的代码\",{\"1\":{\"477\":1,\"609\":2}}],[\"的代码覆盖率工具\",{\"1\":{\"460\":1}}],[\"的奇葩项目\",{\"1\":{\"473\":1}}],[\"的安全性\",{\"1\":{\"469\":1}}],[\"的支持\",{\"1\":{\"480\":1}}],[\"的支持尤其的好\",{\"1\":{\"472\":1}}],[\"的支持还是很好用的\",{\"1\":{\"472\":1}}],[\"的支持也能写出流畅的代码\",{\"1\":{\"466\":1}}],[\"的支持并不是很好\",{\"1\":{\"450\":1}}],[\"的话\",{\"1\":{\"466\":1,\"655\":1,\"905\":1}}],[\"的也可供选择\",{\"1\":{\"462\":1}}],[\"的依赖对象\",{\"1\":{\"996\":1}}],[\"的依赖改成注入\",{\"1\":{\"860\":1}}],[\"的依赖\",{\"1\":{\"459\":1}}],[\"的部署并不容易\",{\"1\":{\"457\":1}}],[\"的部署问题确实有点棘手\",{\"1\":{\"456\":1}}],[\"的处理仍然是必要的\",{\"1\":{\"450\":1}}],[\"的集合的设计灵感来源于\",{\"1\":{\"469\":1}}],[\"的集合\",{\"1\":{\"450\":2}}],[\"的集合类\",{\"1\":{\"181\":1,\"575\":1,\"648\":1}}],[\"的可能性\",{\"1\":{\"447\":1}}],[\"的可用性\",{\"1\":{\"262\":1}}],[\"的动态语言\",{\"1\":{\"411\":1}}],[\"的无缝扩展\",{\"1\":{\"398\":1}}],[\"的静态方法\",{\"1\":{\"310\":1}}],[\"的公共静态方法\",{\"1\":{\"981\":2}}],[\"的公共\",{\"1\":{\"308\":1}}],[\"的字符\",{\"1\":{\"884\":1}}],[\"的字符串\",{\"1\":{\"306\":2,\"307\":1,\"308\":1}}],[\"的字段\",{\"1\":{\"305\":1}}],[\"的字节码内容我们可以得出以下两点结论\",{\"1\":{\"228\":1}}],[\"的一类数据结构时\",{\"1\":{\"841\":1}}],[\"的一种途径\",{\"1\":{\"305\":1}}],[\"的一个改进机制\",{\"1\":{\"639\":1}}],[\"的一个\",{\"1\":{\"141\":1}}],[\"的形式还是通过泛型通配符的形式初始化泛型数组实例都是存在警告的\",{\"1\":{\"295\":1}}],[\"的泛型数组初始化时数组类型不能是具体的泛型类型\",{\"1\":{\"294\":1}}],[\"的事情\",{\"1\":{\"291\":1}}],[\"的问题\",{\"1\":{\"287\":1,\"655\":1,\"848\":1,\"851\":1}}],[\"的范围是<e\",{\"1\":{\"284\":1}}],[\"的某个子类型\",{\"1\":{\"284\":1}}],[\"的消费者\",{\"1\":{\"284\":2}}],[\"的生产者\",{\"1\":{\"284\":1}}],[\"的输入参数上使用通配符\",{\"1\":{\"284\":1}}],[\"的策略模式剖析\",{\"0\":{\"790\":1}}],[\"的策略\",{\"1\":{\"278\":1,\"287\":1}}],[\"的信息\",{\"1\":{\"275\":1,\"308\":1}}],[\"的父接口\",{\"1\":{\"233\":1}}],[\"的注解信息\",{\"1\":{\"228\":1}}],[\"的不同之处\",{\"0\":{\"182\":1}}],[\"的规定\",{\"1\":{\"176\":1,\"179\":1}}],[\"的替代方案\",{\"1\":{\"141\":1}}],[\"的对象\",{\"1\":{\"138\":1,\"549\":1,\"732\":2,\"745\":2,\"789\":1,\"790\":1}}],[\"的比较\",{\"1\":{\"138\":1}}],[\"的计算结果进行了向下转型\",{\"1\":{\"129\":1}}],[\"的参数是以值传递的形式传入方法中\",{\"1\":{\"127\":1}}],[\"的需要\",{\"1\":{\"123\":1}}],[\"的meta\",{\"1\":{\"95\":1}}],[\"的\",{\"1\":{\"32\":1,\"123\":2,\"127\":1,\"133\":3,\"141\":1,\"151\":1,\"228\":1,\"254\":1,\"264\":1,\"267\":1,\"310\":1,\"449\":2,\"451\":1,\"466\":1,\"472\":1,\"477\":1,\"543\":3,\"574\":1,\"585\":2,\"600\":1,\"606\":1,\"644\":1,\"651\":1,\"679\":1,\"686\":1,\"698\":1,\"707\":1,\"710\":1,\"750\":1,\"768\":1,\"790\":3,\"808\":1,\"863\":1,\"872\":2,\"878\":1,\"880\":1,\"912\":1,\"950\":1,\"952\":1,\"998\":1}}],[\"↩︎\",{\"1\":{\"30\":1}}],[\"幻灯片\",{\"0\":{\"30\":1}}],[\"幻灯片页\",{\"0\":{\"1\":1}}],[\"导航性与多重性\",{\"1\":{\"831\":1}}],[\"导航性\",{\"1\":{\"830\":1}}],[\"导航栏\",{\"1\":{\"6\":1,\"34\":1}}],[\"导致代码不够干净\",{\"1\":{\"972\":1}}],[\"导致新的连接无法建立\",{\"1\":{\"870\":1}}],[\"导致索引失效\",{\"1\":{\"864\":1}}],[\"导致数据库更新时\",{\"1\":{\"861\":1}}],[\"导致测试结果异常\",{\"1\":{\"860\":1}}],[\"导致运行到某段核心逻辑时\",{\"1\":{\"858\":1}}],[\"导致部分商品未能正确退货\",{\"1\":{\"854\":1}}],[\"导致调用方传了一个\",{\"1\":{\"852\":1}}],[\"导致cpu飙升\",{\"1\":{\"851\":1}}],[\"导致在finally代码块中\",{\"1\":{\"851\":1}}],[\"导致创建时间被修改成当前时间\",{\"1\":{\"848\":1}}],[\"导致线上问题\",{\"1\":{\"846\":1,\"866\":1}}],[\"导致出现故障\",{\"1\":{\"846\":1}}],[\"导致属性获取不到\",{\"1\":{\"845\":1}}],[\"导致它们发生的原因也不少\",{\"1\":{\"820\":1}}],[\"导致类的个数增加\",{\"1\":{\"804\":1}}],[\"导致类装载\",{\"1\":{\"752\":1}}],[\"导致无法实现\",{\"1\":{\"767\":1}}],[\"导致其他\",{\"1\":{\"766\":1}}],[\"导致双方高耦合\",{\"1\":{\"727\":1}}],[\"导致系统难以管理与维护\",{\"1\":{\"641\":1}}],[\"导致系统变得很庞大\",{\"1\":{\"557\":1}}],[\"导入文件\",{\"0\":{\"27\":1}}],[\"图胜于表\",{\"1\":{\"843\":1}}],[\"图分类\",{\"1\":{\"822\":1}}],[\"图与写文章差不多\",{\"1\":{\"822\":1}}],[\"图中最核心的\",{\"1\":{\"822\":1}}],[\"图中右边部分的代码设计中\",{\"1\":{\"741\":1}}],[\"图中左边部分的代码设计中\",{\"1\":{\"741\":1}}],[\"图中左边部分的代码结构是\",{\"1\":{\"741\":1}}],[\"图像中的坐标点或颜色\",{\"1\":{\"629\":1}}],[\"图像处理\",{\"0\":{\"408\":1}}],[\"图解\",{\"1\":{\"553\":1,\"685\":1}}],[\"图参考自\",{\"1\":{\"283\":1}}],[\"图谱\",{\"0\":{\"154\":1}}],[\"图片包含违禁信息\",{\"1\":{\"874\":1}}],[\"图片经过处理之后被上传到阿里云上\",{\"1\":{\"809\":1}}],[\"图片验证码\",{\"1\":{\"432\":1}}],[\"图片\",{\"1\":{\"88\":1,\"89\":2,\"90\":1,\"91\":1,\"92\":1,\"93\":1}}],[\"图片增强\",{\"0\":{\"21\":1}}],[\"图形接口有计算面积和周长的抽象方法\",{\"1\":{\"826\":1}}],[\"图形化的软件中可以指一个窗口或一个菜单等\",{\"1\":{\"989\":1}}],[\"图形化\",{\"1\":{\"822\":1}}],[\"图形\",{\"0\":{\"43\":1}}],[\"图表\",{\"0\":{\"22\":1}}],[\"脚注\",{\"0\":{\"18\":1}}],[\"hh\",{\"1\":{\"849\":1,\"854\":1}}],[\"hprof\",{\"1\":{\"485\":3}}],[\"hppc\",{\"1\":{\"406\":1}}],[\"hbase\",{\"1\":{\"400\":1,\"868\":1}}],[\"hbase针对低延时应用程序的高性能关系数据库层\",{\"1\":{\"394\":1}}],[\"hystrix\",{\"1\":{\"399\":1}}],[\"hydra\",{\"1\":{\"89\":3,\"92\":2}}],[\"hk2\",{\"1\":{\"397\":1}}],[\"h2\",{\"1\":{\"394\":1}}],[\"h2o\",{\"1\":{\"17\":1,\"413\":1}}],[\"humidity\",{\"1\":{\"676\":10,\"678\":17}}],[\"huaweifactory\",{\"1\":{\"617\":6}}],[\"huaweimirouter\",{\"1\":{\"617\":2}}],[\"huaweiphone\",{\"1\":{\"617\":2}}],[\"hutool\",{\"1\":{\"432\":1}}],[\"hudson\",{\"1\":{\"384\":1}}],[\"hubei\",{\"1\":{\"219\":1}}],[\"hguisu\",{\"1\":{\"277\":1}}],[\"hw=null\",{\"1\":{\"241\":1}}],[\"hw=new\",{\"1\":{\"241\":1}}],[\"hw\",{\"1\":{\"241\":10}}],[\"hierarchy\",{\"1\":{\"732\":1}}],[\"hibernate的技术社区非常活跃\",{\"1\":{\"420\":1}}],[\"hibernate\",{\"1\":{\"420\":1,\"442\":1,\"705\":1,\"750\":1}}],[\"hikaricp\",{\"1\":{\"394\":1}}],[\"hiway2\",{\"1\":{\"306\":2}}],[\"hiway\",{\"1\":{\"306\":2}}],[\"hidden\",{\"1\":{\"854\":1}}],[\"hide\",{\"1\":{\"225\":1}}],[\"hiding\",{\"1\":{\"225\":1}}],[\"highbuilding\",{\"1\":{\"555\":5}}],[\"highlights\",{\"1\":{\"150\":2}}],[\"high\",{\"1\":{\"120\":7,\"145\":1,\"406\":1}}],[\"h\",{\"1\":{\"120\":3,\"699\":1,\"700\":2}}],[\"href\",{\"1\":{\"77\":4}}],[\"http1\",{\"1\":{\"854\":1}}],[\"http请求通过body传递内容时\",{\"1\":{\"854\":1}}],[\"http请求通过url传递参数时\",{\"1\":{\"854\":1}}],[\"http接口\",{\"1\":{\"852\":1}}],[\"http服务提供方便测试的java\",{\"1\":{\"431\":1}}],[\"http\",{\"1\":{\"116\":1,\"212\":1,\"219\":1,\"287\":1,\"419\":2,\"432\":1,\"591\":1,\"947\":1,\"974\":4,\"996\":2}}],[\"https\",{\"1\":{\"77\":8,\"116\":6,\"155\":3,\"219\":2,\"238\":2,\"243\":6,\"276\":1,\"277\":6,\"283\":1,\"294\":1,\"299\":9,\"314\":7,\"447\":1,\"875\":1,\"984\":4,\"1000\":3}}],[\"htmldto\",{\"1\":{\"845\":2}}],[\"html5等\",{\"1\":{\"407\":1}}],[\"html在新窗口打开\",{\"1\":{\"294\":1}}],[\"htmllabels\",{\"1\":{\"77\":1}}],[\"html\",{\"1\":{\"73\":1,\"77\":1,\"116\":1,\"219\":2,\"243\":2,\"277\":3,\"283\":1,\"299\":4,\"309\":1,\"314\":3,\"591\":1,\"875\":1,\"956\":1,\"984\":1,\"1000\":1}}],[\"hao\",{\"1\":{\"847\":1}}],[\"hangzhou等国际通用的名称\",{\"1\":{\"845\":1}}],[\"handsize的值太大\",{\"1\":{\"265\":1}}],[\"handsize\",{\"1\":{\"265\":1}}],[\"handling\",{\"1\":{\"150\":1}}],[\"handletextresponse\",{\"1\":{\"950\":1}}],[\"handlenumericresponse\",{\"1\":{\"950\":1}}],[\"handlelargenumber\",{\"1\":{\"924\":1}}],[\"handlelog\",{\"1\":{\"242\":3}}],[\"handleonetwoorthree\",{\"1\":{\"924\":1}}],[\"handlebars\",{\"1\":{\"430\":1}}],[\"handlerexecutionchain\",{\"1\":{\"710\":1}}],[\"handlerequest\",{\"1\":{\"708\":6}}],[\"handler2\",{\"1\":{\"708\":2}}],[\"handler1\",{\"1\":{\"708\":3}}],[\"handleradapter\",{\"1\":{\"533\":2}}],[\"handler\",{\"1\":{\"275\":1,\"708\":10,\"711\":1}}],[\"handle\",{\"1\":{\"104\":1,\"256\":4,\"259\":1,\"776\":9}}],[\"handles\",{\"1\":{\"77\":1}}],[\"hatter\",{\"1\":{\"440\":1}}],[\"hat开发\",{\"1\":{\"429\":1}}],[\"hamcrest\",{\"1\":{\"431\":1,\"978\":3}}],[\"hadoop\",{\"1\":{\"413\":1}}],[\"hazelcast\",{\"1\":{\"399\":1}}],[\"happen\",{\"1\":{\"269\":2}}],[\"happyframework\",{\"1\":{\"116\":1}}],[\"harnesses\",{\"1\":{\"145\":1}}],[\"hard\",{\"1\":{\"86\":1,\"209\":1,\"763\":1}}],[\"harder\",{\"1\":{\"68\":1}}],[\"hasglobaltimeouttest\",{\"1\":{\"980\":1}}],[\"hasitems\",{\"1\":{\"978\":1}}],[\"hasextensions\",{\"1\":{\"618\":1}}],[\"hasmilk\",{\"1\":{\"583\":1}}],[\"hasmoreelements\",{\"1\":{\"104\":1,\"106\":1,\"114\":1}}],[\"hassize\",{\"1\":{\"478\":1}}],[\"haskell\",{\"1\":{\"469\":1}}],[\"hascode\",{\"1\":{\"139\":1}}],[\"hashimpltest\",{\"1\":{\"940\":1}}],[\"hashintegrationtest\",{\"1\":{\"940\":1}}],[\"hashtable就异常重要了\",{\"1\":{\"181\":1}}],[\"hashtable\",{\"1\":{\"181\":1,\"638\":1,\"850\":1}}],[\"hashset<string>\",{\"1\":{\"942\":1}}],[\"hashset<>\",{\"1\":{\"139\":1}}],[\"hashset<equalexample>\",{\"1\":{\"139\":1}}],[\"hashset\",{\"0\":{\"320\":1},\"1\":{\"139\":1,\"179\":1,\"181\":1}}],[\"hashcode=968514068\",{\"1\":{\"752\":2}}],[\"hashcode=\",{\"1\":{\"752\":2,\"753\":2,\"754\":2,\"755\":2,\"756\":2,\"757\":2,\"758\":2}}],[\"hashcode重要吗\",{\"1\":{\"181\":1}}],[\"hashcode的作用\",{\"1\":{\"181\":1}}],[\"hashcode\",{\"0\":{\"139\":1,\"175\":1,\"177\":1,\"179\":1,\"181\":1},\"1\":{\"137\":1,\"139\":3,\"175\":2,\"177\":1,\"179\":2,\"181\":1,\"190\":1,\"308\":1,\"687\":4,\"689\":4,\"752\":2,\"753\":2,\"754\":2,\"755\":2,\"756\":2,\"757\":2,\"758\":2,\"759\":2,\"850\":1,\"929\":1}}],[\"hashmap在容量不够进行resize时由于高并发可能出现死链\",{\"1\":{\"851\":1}}],[\"hashmap是unorder\",{\"1\":{\"850\":1}}],[\"hashmap需要放置\",{\"1\":{\"850\":1}}],[\"hashmap使用构造方法hashmap\",{\"1\":{\"850\":1}}],[\"hashmap的merge方法里会进行如下的判断\",{\"1\":{\"850\":1}}],[\"hashmap<string\",{\"1\":{\"632\":2,\"636\":1,\"644\":9,\"659\":4,\"850\":1}}],[\"hashmap<>\",{\"1\":{\"466\":1,\"636\":1,\"644\":1,\"773\":1,\"850\":2,\"866\":1}}],[\"hashmap\",{\"0\":{\"320\":1},\"1\":{\"123\":1,\"175\":1,\"179\":1,\"181\":1,\"184\":2,\"575\":1,\"638\":1,\"644\":2,\"659\":1,\"771\":2,\"850\":1,\"872\":1}}],[\"hash\",{\"0\":{\"176\":1},\"1\":{\"123\":3,\"170\":1,\"176\":1,\"181\":3,\"406\":1}}],[\"has\",{\"1\":{\"104\":1,\"141\":1,\"145\":1,\"275\":1,\"310\":1,\"312\":1,\"768\":1,\"813\":1,\"831\":1,\"835\":1}}],[\"hasnextservice\",{\"1\":{\"114\":4}}],[\"hasnext\",{\"1\":{\"96\":1,\"103\":3,\"111\":1,\"114\":6,\"284\":1,\"649\":5,\"650\":4,\"838\":1,\"850\":1}}],[\"have\",{\"1\":{\"59\":1,\"80\":1,\"82\":1,\"104\":1,\"133\":1,\"145\":1,\"310\":1,\"997\":1}}],[\"height\",{\"1\":{\"846\":1}}],[\"helper\",{\"1\":{\"851\":10}}],[\"helm\",{\"1\":{\"795\":1}}],[\"helloreflect\",{\"1\":{\"309\":2}}],[\"helloworldtest\",{\"1\":{\"241\":2,\"975\":1}}],[\"helloworld\",{\"1\":{\"241\":5}}],[\"hello\",{\"0\":{\"975\":1},\"1\":{\"96\":2,\"241\":4,\"284\":1,\"309\":1,\"622\":1,\"700\":1,\"703\":1,\"727\":3,\"819\":1,\"847\":1,\"848\":1,\"855\":1,\"975\":1}}],[\"hearts\",{\"1\":{\"915\":1}}],[\"heapdump\",{\"1\":{\"485\":2}}],[\"heap\",{\"1\":{\"485\":2,\"488\":1}}],[\"head\",{\"0\":{\"60\":1,\"63\":1},\"1\":{\"419\":1,\"832\":7}}],[\"hermes\",{\"1\":{\"414\":1}}],[\"here\",{\"1\":{\"73\":1,\"104\":2,\"133\":3,\"310\":1,\"312\":1,\"451\":1,\"478\":2,\"955\":1}}],[\"hence\",{\"1\":{\"86\":1,\"310\":1,\"312\":2}}],[\"hexagon\",{\"0\":{\"53\":1}}],[\"holds\",{\"1\":{\"732\":1}}],[\"holding\",{\"1\":{\"659\":1}}],[\"hour\",{\"1\":{\"618\":1}}],[\"housedirector\",{\"1\":{\"555\":9}}],[\"housebuilder\",{\"1\":{\"555\":19}}],[\"house\",{\"1\":{\"488\":1,\"555\":10}}],[\"hook\",{\"1\":{\"482\":1}}],[\"hornetq\",{\"1\":{\"414\":1}}],[\"horizontal\",{\"1\":{\"71\":1,\"912\":1}}],[\"hotswapagent\",{\"1\":{\"398\":1}}],[\"hotspot考虑逐渐去永久代\",{\"1\":{\"125\":1}}],[\"hotspot也是发展的\",{\"1\":{\"125\":1}}],[\"hotspot\",{\"1\":{\"125\":1}}],[\"hotspot中字符串常量池保存哪里\",{\"1\":{\"125\":1}}],[\"however\",{\"1\":{\"86\":1}}],[\"how\",{\"1\":{\"77\":1,\"87\":1}}],[\"hope\",{\"1\":{\"32\":1}}],[\"hometheaterfacade\",{\"1\":{\"601\":8}}],[\"home\",{\"1\":{\"0\":1,\"859\":1}}],[\"上传恶意文件到服务器\",{\"1\":{\"861\":1}}],[\"上传下载流程改变\",{\"1\":{\"809\":1}}],[\"上传\",{\"1\":{\"809\":1}}],[\"上传图片到私有云\",{\"1\":{\"809\":1}}],[\"上传图片到指定的\",{\"1\":{\"809\":1}}],[\"上传图片到阿里云\",{\"1\":{\"809\":2}}],[\"上游系统的代码基本上不需要做改动\",{\"1\":{\"808\":1,\"810\":1}}],[\"上游系统面向接口而非实现编程\",{\"1\":{\"808\":1,\"810\":1}}],[\"上方代码违反了\",{\"1\":{\"742\":1}}],[\"上方代码优缺点\",{\"1\":{\"738\":1}}],[\"上方只是简单介绍依赖倒转原则的基本使用\",{\"1\":{\"728\":1}}],[\"上发表的一篇文章\",{\"1\":{\"732\":1}}],[\"上课前先备课\",{\"1\":{\"695\":1}}],[\"上安装软件的时候经常有一键安装选项\",{\"1\":{\"601\":1}}],[\"上班族大多都有睡懒觉的习惯\",{\"1\":{\"579\":1}}],[\"上网\",{\"1\":{\"539\":1}}],[\"上下文环境\",{\"1\":{\"854\":1}}],[\"上下界\",{\"1\":{\"287\":1}}],[\"上下角标\",{\"0\":{\"17\":1}}],[\"上限\",{\"1\":{\"284\":1}}],[\"上边界\",{\"1\":{\"284\":1}}],[\"上述方法可能是较为常用的\",{\"1\":{\"307\":1}}],[\"上述方法需要注意的是\",{\"1\":{\"307\":1}}],[\"上述代码中的类型参数\",{\"1\":{\"284\":1}}],[\"上述from和to之前发生异常后的异常处理者的位置\",{\"1\":{\"275\":1}}],[\"上述内置注解的定义中使用了一些元注解\",{\"1\":{\"226\":1}}],[\"上级部门不能是自己\",{\"1\":{\"242\":1}}],[\"上面\",{\"1\":{\"839\":1}}],[\"上面设置回调的\",{\"1\":{\"703\":1}}],[\"上面我们讲到\",{\"1\":{\"622\":1}}],[\"上面我们讲了两种情况\",{\"1\":{\"620\":1}}],[\"上面讲的工厂模式中\",{\"1\":{\"621\":1}}],[\"上面有\",{\"1\":{\"610\":1}}],[\"上面已经介绍\",{\"1\":{\"586\":1}}],[\"上面图片桥接模式的代码如下\",{\"1\":{\"538\":1}}],[\"上面提到了\",{\"1\":{\"290\":1}}],[\"上面例子中\",{\"1\":{\"259\":1}}],[\"上面代码没有了加载驱动的代码\",{\"1\":{\"103\":1}}],[\"上面说了\",{\"1\":{\"102\":1}}],[\"上面的解决思路就可以使用\",{\"1\":{\"635\":1}}],[\"上面的披萨案例抽象工厂类图\",{\"1\":{\"616\":1}}],[\"上面的这样使用是没问题的\",{\"1\":{\"297\":1}}],[\"上面的三条异常表item的意思为\",{\"1\":{\"275\":1}}],[\"上面的语句相当于将\",{\"1\":{\"129\":1}}],[\"上面的使用方法\",{\"1\":{\"103\":1}}],[\"上面的代码实现稍微有点问题\",{\"1\":{\"768\":1}}],[\"上面的代码是一个很简单的例子\",{\"1\":{\"275\":1}}],[\"上面的代码主要步骤是\",{\"1\":{\"103\":1}}],[\"上面的代码可以直接获取数据库连接进行操作\",{\"1\":{\"103\":1}}],[\"上面的代码会打印\",{\"1\":{\"93\":1}}],[\"上面的代码中\",{\"1\":{\"93\":2}}],[\"上面的代码解析完后实际是这样的\",{\"1\":{\"89\":1}}],[\"上面的\",{\"1\":{\"89\":1}}],[\"上一篇\",{\"1\":{\"6\":1}}],[\"我个人是比较推荐单元测试与具体实现代码同步进行这个方案的\",{\"1\":{\"991\":1}}],[\"我个人认为\",{\"1\":{\"816\":1}}],[\"我的实践经验告诉我\",{\"1\":{\"991\":1}}],[\"我从网上搜集和总结了相关的概念\",{\"1\":{\"988\":1}}],[\"我总结了下面两点\",{\"1\":{\"809\":1}}],[\"我用伪代码实现了一下这个过程\",{\"1\":{\"772\":1}}],[\"我举个例子来解释一下\",{\"1\":{\"771\":1}}],[\"我来详细地解释一下\",{\"1\":{\"770\":1}}],[\"我怎么才能保证这个类的对象全局唯一呢\",{\"1\":{\"769\":1}}],[\"我怎么知道我取出来的到底是string类型的\",{\"1\":{\"290\":1}}],[\"我业务上有表示全局唯一类的需求\",{\"1\":{\"769\":1}}],[\"我画了一张对比图来解释\",{\"1\":{\"741\":1}}],[\"我使用推送模式\",{\"1\":{\"676\":1,\"678\":2}}],[\"我中有你\",{\"1\":{\"658\":1,\"797\":1}}],[\"我是不是需要给每个实现类都定义对应的接口呢\",{\"1\":{\"810\":1}}],[\"我是cglib代理\",{\"1\":{\"703\":1}}],[\"我是中国人\",{\"1\":{\"641\":1}}],[\"我是居中的\",{\"1\":{\"16\":1}}],[\"我会带你一块搞清楚这样几个问题\",{\"1\":{\"620\":1}}],[\"我想说\",{\"1\":{\"591\":1}}],[\"我最喜欢\",{\"1\":{\"481\":1}}],[\"我最喜欢的是\",{\"1\":{\"473\":1}}],[\"我不喜欢重量级的\",{\"1\":{\"474\":1}}],[\"我也喜欢用\",{\"1\":{\"466\":1}}],[\"我认为你应该仔细看看这个\",{\"1\":{\"462\":1}}],[\"我曾经也写了一个叫\",{\"1\":{\"462\":1}}],[\"我喜欢用一个根\",{\"1\":{\"458\":1}}],[\"我高度推荐\",{\"1\":{\"453\":1}}],[\"我更喜欢\",{\"1\":{\"445\":1}}],[\"我决定收集一些库\",{\"1\":{\"443\":1}}],[\"我这里找了一个开源项目中的例子\",{\"1\":{\"242\":1}}],[\"我能在不进行强制转换的情况下将一个\",{\"0\":{\"166\":1}}],[\"我在鸵鸟这个子类中重写\",{\"1\":{\"812\":1}}],[\"我在之前的产品中还没有用过\",{\"1\":{\"471\":1}}],[\"我在测试项目中添加了两个jar包\",{\"1\":{\"103\":1}}],[\"我在右对齐\",{\"1\":{\"16\":1}}],[\"我说会打印fasle\",{\"1\":{\"91\":1}}],[\"我为什么不直接用integer\",{\"1\":{\"90\":1}}],[\"我们显然不太可能专门开一个\",{\"1\":{\"996\":1}}],[\"我们举一个例子来展示什么是\",{\"1\":{\"996\":1}}],[\"我们开始学习junit4单元测试实例\",{\"1\":{\"973\":1}}],[\"我们开发有连接数据库的时候\",{\"1\":{\"98\":1}}],[\"我们留在设计模式模块中慢慢讲解\",{\"1\":{\"818\":1}}],[\"我们明显可以看出\",{\"1\":{\"818\":1}}],[\"我们前面提到\",{\"1\":{\"818\":1}}],[\"我们前面讲的依赖注入\",{\"1\":{\"741\":1}}],[\"我们前面讲过的单一职责原则是实现代码高内聚非常有效的设计原则\",{\"1\":{\"741\":1}}],[\"我们已经多次听到过这个设计思想\",{\"1\":{\"818\":1}}],[\"我们已经写了一个对象\",{\"1\":{\"699\":1,\"702\":1}}],[\"我们该怎么判断代码的耦合程度呢\",{\"1\":{\"817\":1}}],[\"我们该如何修改代码呢\",{\"1\":{\"809\":1}}],[\"我们过度使用继承\",{\"1\":{\"814\":1}}],[\"我们完全可以替换掉继承\",{\"1\":{\"813\":1}}],[\"我们完全没必要将它拆分成单独的函数或者类\",{\"1\":{\"614\":1}}],[\"我们又该如何来解决呢\",{\"1\":{\"812\":1}}],[\"我们又该如何设计类之间的继承关系呢\",{\"1\":{\"812\":1}}],[\"我们越是要在代码的扩展性\",{\"1\":{\"810\":1}}],[\"我们做权衡的根本依据\",{\"1\":{\"810\":1}}],[\"我们做成抽象方法\",{\"1\":{\"609\":1,\"613\":1}}],[\"我们按照这个思路\",{\"1\":{\"809\":1}}],[\"我们对上传\",{\"1\":{\"809\":1}}],[\"我们要定义更多的类和接口\",{\"1\":{\"814\":1}}],[\"我们要多思考一下\",{\"1\":{\"809\":1}}],[\"我们要修改项目中所有使用到这两个方法的代码\",{\"1\":{\"809\":1}}],[\"我们要根据交通工具运行方法不同\",{\"1\":{\"718\":1}}],[\"我们一块来看看都有哪些\",{\"1\":{\"809\":1}}],[\"我们一般会选择使用工厂模式\",{\"1\":{\"620\":1}}],[\"我们经常说\",{\"1\":{\"809\":1}}],[\"我们经常需要向某些对象发送请求\",{\"1\":{\"560\":1}}],[\"我们自建了私有云\",{\"1\":{\"809\":1}}],[\"我们封装了图片存储相关的代码逻辑\",{\"1\":{\"809\":1}}],[\"我们理解这条原则的时候\",{\"1\":{\"808\":1}}],[\"我们连续抽\",{\"1\":{\"778\":1}}],[\"我们编写的代码\",{\"1\":{\"770\":1}}],[\"我们重新看一下单例的定义\",{\"1\":{\"770\":1}}],[\"我们重写的getvalue方法\",{\"1\":{\"291\":1}}],[\"我们重写的setvalue方法\",{\"1\":{\"291\":1}}],[\"我们放到后面讲解\",{\"1\":{\"769\":1}}],[\"我们既可以通过单例模式来强制保证\",{\"1\":{\"769\":1}}],[\"我们可能要从根上\",{\"1\":{\"769\":1}}],[\"我们可以创建一个测试套件\",{\"1\":{\"999\":1}}],[\"我们可以创建一个单例对象\",{\"1\":{\"771\":1}}],[\"我们可以使用\",{\"1\":{\"997\":1}}],[\"我们可以分下面四个阶段来完成接口的修改\",{\"1\":{\"818\":1}}],[\"我们可以分步查看\",{\"1\":{\"284\":1}}],[\"我们可以聚焦于这个模块或者类\",{\"1\":{\"816\":1}}],[\"我们可以针对三个接口再定义三个实现类\",{\"1\":{\"813\":1}}],[\"我们可以类似地定义\",{\"1\":{\"813\":1}}],[\"我们可以定义一个\",{\"1\":{\"813\":1}}],[\"我们可以定义一个方法\",{\"1\":{\"803\":1}}],[\"我们可以利用组合\",{\"1\":{\"813\":1}}],[\"我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能\",{\"1\":{\"783\":1}}],[\"我们可以看出\",{\"1\":{\"625\":2}}],[\"我们可以看到如下代码会在编译器中报错\",{\"1\":{\"293\":1}}],[\"我们可以认为这会更加简单\",{\"1\":{\"445\":1}}],[\"我们可以通过组合和接口的\",{\"1\":{\"813\":1}}],[\"我们可以通过配置\",{\"1\":{\"622\":1}}],[\"我们可以通过class类的提供的方法来获取代表字段信息的field对象\",{\"1\":{\"307\":1}}],[\"我们可以通过下面的方式定义一个0\",{\"1\":{\"90\":1}}],[\"我们可以明白\",{\"1\":{\"290\":1}}],[\"我们可以为传入的泛型类型实参进行上下边界的限制\",{\"1\":{\"284\":1}}],[\"我们可以复用为一个方法\",{\"1\":{\"279\":1}}],[\"我们可以在系统中创建两个数据库连接池\",{\"1\":{\"766\":1}}],[\"我们可以在\",{\"0\":{\"177\":1},\"1\":{\"170\":1}}],[\"我们可以做强制转换\",{\"1\":{\"161\":1}}],[\"我们没法通过参数来指定连接池的大小\",{\"1\":{\"768\":1}}],[\"我们没有权限去修改这部分代码\",{\"1\":{\"814\":1}}],[\"我们没有arraylist<int>\",{\"1\":{\"292\":1}}],[\"我们没有写有关具体驱动的硬编码class\",{\"1\":{\"103\":1}}],[\"我们把相同的属性和方法\",{\"1\":{\"814\":1}}],[\"我们把这些规定了流程或格式的实例定义成模板\",{\"1\":{\"800\":1}}],[\"我们把这种对象称为有状态的对象\",{\"1\":{\"775\":1}}],[\"我们把数据库连接池类设计成了单例类\",{\"1\":{\"766\":1}}],[\"我们把迭代器分开\",{\"1\":{\"652\":1}}],[\"我们觉得系统中只应该有一个数据库连接池\",{\"1\":{\"766\":1}}],[\"我们拿数据库连接池来举例解释一下\",{\"1\":{\"766\":1}}],[\"我们也需要一套标准来帮助我们做好软件开发的工作\",{\"1\":{\"823\":1}}],[\"我们也确实经常用到它\",{\"1\":{\"763\":1}}],[\"我们也可以明白arraylist被擦除类型后\",{\"1\":{\"289\":1}}],[\"我们进行了两次\",{\"1\":{\"757\":1}}],[\"我们称出现成员变量\",{\"1\":{\"741\":1}}],[\"我们仍然想使用\",{\"1\":{\"734\":1}}],[\"我们常常会通过重写父类的方法完成新的功能\",{\"1\":{\"734\":1}}],[\"我们常用的类主要有constructor类表示的是class\",{\"1\":{\"304\":1}}],[\"我们发现原来运行正常的相减功能发生了错误\",{\"1\":{\"734\":1}}],[\"我们应当遵守单一职责原则\",{\"1\":{\"719\":1}}],[\"我们首先需要旧对象的基因\",{\"1\":{\"699\":1}}],[\"我们增加观察者\",{\"1\":{\"678\":1}}],[\"我们平时乘坐交通工具\",{\"1\":{\"648\":1}}],[\"我们需要修改它的定义\",{\"1\":{\"818\":1}}],[\"我们需要修改所有用到\",{\"1\":{\"764\":1}}],[\"我们需要做到下面这\",{\"1\":{\"809\":1}}],[\"我们需要做如下修改\",{\"1\":{\"738\":1}}],[\"我们需要重新设计实现一个存储图片到私有云的\",{\"1\":{\"809\":1}}],[\"我们需要手动添加\",{\"1\":{\"779\":1}}],[\"我们需要把这个单例对象序列化并存储到外部共享存储区\",{\"1\":{\"772\":1}}],[\"我们需要在代码中创建两个实例或多个实例\",{\"1\":{\"766\":1}}],[\"我们需要在程序运行期间\",{\"1\":{\"627\":1}}],[\"我们需要测试这三个依赖类\",{\"1\":{\"741\":1}}],[\"我们需要将它标记为可用状态\",{\"1\":{\"631\":1}}],[\"我们需要利用\",{\"1\":{\"627\":1}}],[\"我们需要通过一种形式\",{\"1\":{\"622\":1}}],[\"我们就应该做好了从头开始优化重写代码的准备\",{\"1\":{\"820\":1}}],[\"我们就尽量使用组合来替代继承\",{\"1\":{\"814\":1}}],[\"我们就围绕着这三个问题\",{\"1\":{\"811\":1}}],[\"我们就需要仔细查看每个函数的代码实现\",{\"1\":{\"765\":1}}],[\"我们就具体看看到底有哪些问题\",{\"1\":{\"763\":1}}],[\"我们就说这两个对象之间是朋友关系\",{\"1\":{\"741\":1}}],[\"我们就可以大胆地使用继承\",{\"1\":{\"814\":1}}],[\"我们就可以考虑选用享元模式\",{\"1\":{\"638\":1}}],[\"我们就可以对内存为所欲为了\",{\"1\":{\"93\":1}}],[\"我们就详细讲讲\",{\"1\":{\"621\":1}}],[\"我们就推荐使用工厂方法模式\",{\"1\":{\"614\":1}}],[\"我们推荐使用工厂方法模式\",{\"1\":{\"614\":1}}],[\"我们沿用第一种分类方法\",{\"1\":{\"606\":1}}],[\"我们都能找到期望的方法运行\",{\"1\":{\"839\":1}}],[\"我们都需要重写\",{\"1\":{\"812\":1}}],[\"我们都会自觉地创建一个新的类封装这些子系统\",{\"1\":{\"593\":1}}],[\"我们都在有意无意的大量使用外观模式\",{\"1\":{\"593\":1}}],[\"我们每按下一个按键都要判空\",{\"1\":{\"564\":1}}],[\"我们希望将慢\",{\"1\":{\"766\":1}}],[\"我们希望将这两个对象当成一样的\",{\"1\":{\"139\":1}}],[\"我们希望一眼就能看出类与类之间的依赖关系\",{\"1\":{\"765\":1}}],[\"我们希望针对不同的业务采用不同的\",{\"1\":{\"764\":1}}],[\"我们希望只要一个\",{\"1\":{\"562\":1}}],[\"我们不使用术语\",{\"1\":{\"877\":1}}],[\"我们不需要创建对象\",{\"1\":{\"763\":1}}],[\"我们不想针对每一种家电都安装一个\",{\"1\":{\"562\":1}}],[\"我们不能用getcanonicalname去加载类对象\",{\"1\":{\"305\":1}}],[\"我们不能违背它的初衷\",{\"1\":{\"290\":1}}],[\"我们买了一套智能家电\",{\"1\":{\"562\":1}}],[\"我们去餐厅吃饭\",{\"1\":{\"560\":1}}],[\"我们只能采用继承来实现了\",{\"1\":{\"814\":1}}],[\"我们只关注\",{\"1\":{\"812\":1}}],[\"我们只支持下面配置文件中涉及的配置语法\",{\"1\":{\"624\":1}}],[\"我们只实现一个\",{\"1\":{\"624\":1}}],[\"我们只需要测试这一个依赖类是否还能正常工作就行了\",{\"1\":{\"741\":1}}],[\"我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了\",{\"1\":{\"622\":1}}],[\"我们只需要调整内部的层次关系\",{\"1\":{\"576\":1}}],[\"我们只需在程序运行时指定具体的请求接收者即可\",{\"1\":{\"560\":1}}],[\"我们只要在手机上安装\",{\"1\":{\"562\":1}}],[\"我们只想监听\",{\"1\":{\"532\":1}}],[\"我们分不清该使用继承还是组合\",{\"1\":{\"545\":1}}],[\"我们知道继承主要有三个作用\",{\"1\":{\"813\":1}}],[\"我们知道\",{\"1\":{\"545\":1,\"627\":1,\"764\":1,\"765\":1,\"766\":1,\"772\":1,\"812\":1,\"813\":1,\"818\":1}}],[\"我们将这个设计思路翻译成\",{\"1\":{\"813\":1}}],[\"我们将单例生成的对象\",{\"1\":{\"769\":1}}],[\"我们将需要由\",{\"1\":{\"622\":1}}],[\"我们将\",{\"1\":{\"532\":1,\"812\":1}}],[\"我们会用一些功能较为简单的并且其行为和实际对象类似的假对象来作为\",{\"1\":{\"996\":1}}],[\"我们会给你打电话的\",{\"1\":{\"819\":1}}],[\"我们会讲\",{\"1\":{\"622\":1}}],[\"我们会如下写\",{\"1\":{\"532\":1}}],[\"我们会引用具体厂商的jar包来实现我们的功能\",{\"1\":{\"111\":1}}],[\"我们有一些工具就是为此而生\",{\"1\":{\"485\":1}}],[\"我们期望\",{\"1\":{\"477\":1}}],[\"我们看看如下的代码\",{\"1\":{\"294\":1}}],[\"我们看下具体的先关接口\",{\"1\":{\"233\":1}}],[\"我们看下它是怎么解耦的\",{\"1\":{\"104\":1}}],[\"我们本意重写setvalue和getvalue方法的子类\",{\"1\":{\"291\":1}}],[\"我们用javap\",{\"1\":{\"291\":1}}],[\"我们的\",{\"1\":{\"528\":1}}],[\"我们的目标是\",{\"1\":{\"524\":1}}],[\"我们的本意是进行重写\",{\"1\":{\"291\":1}}],[\"我们的本意是将泛型类变为如下\",{\"1\":{\"291\":1}}],[\"我们的原意是这样的\",{\"1\":{\"291\":1}}],[\"我们传入父类的泛型类型是date\",{\"1\":{\"291\":1}}],[\"我们覆盖了父类的两个方法\",{\"1\":{\"291\":1}}],[\"我们设定父类的泛型类型为pair<date>\",{\"1\":{\"291\":1}}],[\"我们使用了泛型\",{\"1\":{\"290\":1}}],[\"我们使用spi机制的缺陷\",{\"1\":{\"115\":1}}],[\"我们先造出代理对象的雏形\",{\"1\":{\"702\":1}}],[\"我们先来看一下\",{\"1\":{\"771\":1}}],[\"我们先来看一下这个注解类型的定义\",{\"1\":{\"223\":1}}],[\"我们先来看下oracle官网提供的一个例子\",{\"1\":{\"294\":1}}],[\"我们先假设它编译没错\",{\"1\":{\"290\":1}}],[\"我们先看第一种情况\",{\"1\":{\"290\":1}}],[\"我们先看看参数化类型和原始类型的兼容\",{\"1\":{\"290\":1}}],[\"我们定义了两个arraylist数组\",{\"1\":{\"288\":1}}],[\"我们通过覆盖重写\",{\"1\":{\"788\":1}}],[\"我们通过查看函数的定义\",{\"1\":{\"765\":1}}],[\"我们通过list1对象和list2对象的getclass\",{\"1\":{\"288\":1}}],[\"我们通过两个例子证明java类型的类型擦除\",{\"1\":{\"288\":1}}],[\"我们通过泛型背后的类型擦除以及相关的问题来进一步理解泛型\",{\"1\":{\"286\":1}}],[\"我们通过一个例子来解释一下\",{\"1\":{\"812\":1}}],[\"我们通过一个例子来阐述\",{\"1\":{\"279\":1}}],[\"我们通过一个\",{\"1\":{\"771\":1}}],[\"我们通过一些例子来学习泛型的使用\",{\"1\":{\"280\":1}}],[\"我们泛型数组相关的申明\",{\"1\":{\"285\":1}}],[\"我们来一块简单了解都有哪些原则\",{\"1\":{\"818\":1}}],[\"我们来看下都有哪些解决方案\",{\"1\":{\"768\":1}}],[\"我们来看一下\",{\"1\":{\"741\":1}}],[\"我们来看一下为什么finally会执行\",{\"1\":{\"275\":1}}],[\"我们来看\",{\"1\":{\"627\":1}}],[\"我们来看对象的生命周期管理\",{\"1\":{\"622\":1}}],[\"我们来看配置解析\",{\"1\":{\"622\":1}}],[\"我们来学习一个创建对象的\",{\"1\":{\"620\":1}}],[\"我们来测试下这个注解\",{\"1\":{\"230\":1}}],[\"我们还希望制作纯豆浆\",{\"1\":{\"803\":1}}],[\"我们还是要根据具体的情况\",{\"1\":{\"814\":1}}],[\"我们还是将它跟\",{\"1\":{\"772\":1}}],[\"我们还是先来解释一下\",{\"1\":{\"772\":1}}],[\"我们还是通过一个例子来解释一下\",{\"1\":{\"773\":1}}],[\"我们还是通过\",{\"1\":{\"764\":1}}],[\"我们还可以重新创建一个新的单例对象\",{\"1\":{\"771\":1}}],[\"我们还可以用静态方法来实现\",{\"1\":{\"769\":1}}],[\"我们还可以配置对象的\",{\"1\":{\"622\":1}}],[\"我们还可以配置对象是否支持懒加载\",{\"1\":{\"622\":1}}],[\"我们还常常和finally做结合使用\",{\"1\":{\"275\":1}}],[\"我们还能整出不少活来\",{\"1\":{\"90\":1}}],[\"我们很难看出什么高深之处\",{\"1\":{\"275\":1}}],[\"我们暂且不急于介绍异常表\",{\"1\":{\"275\":1}}],[\"我们再来看下\",{\"1\":{\"772\":1}}],[\"我们再来看看有没有其他办法\",{\"1\":{\"769\":1}}],[\"我们再来看一下\",{\"1\":{\"741\":1}}],[\"我们再来看对象创建\",{\"1\":{\"622\":1}}],[\"我们再次调一下代码来看一下\",{\"1\":{\"275\":1}}],[\"我们再深入理解下异常\",{\"1\":{\"274\":1}}],[\"我们再具体看下这几个内置注解\",{\"1\":{\"222\":1}}],[\"我们是不应该实现任何新的error子类的\",{\"1\":{\"247\":1}}],[\"我们是可以创建一个包含可变对象的不可变对象的\",{\"1\":{\"174\":1}}],[\"我们实现单元测试时将更为优雅\",{\"1\":{\"241\":1}}],[\"我们从其它角度深入理解注解\",{\"1\":{\"235\":1}}],[\"我们从最为常见的java内置的注解开始说起\",{\"1\":{\"222\":1}}],[\"我们便可以开始自定义注解了\",{\"1\":{\"234\":1}}],[\"我们具体看下注解的常见分类\",{\"1\":{\"221\":1}}],[\"我们能创建泛型数组也必然是在\",{\"1\":{\"295\":1}}],[\"我们能创建一个包含可变对象的不可变对象吗\",{\"0\":{\"174\":1}}],[\"我们能够使用list\",{\"1\":{\"292\":1}}],[\"我们能在\",{\"0\":{\"170\":1}}],[\"我们能将\",{\"0\":{\"161\":1,\"162\":1}}],[\"我们想要使用\",{\"1\":{\"132\":1}}],[\"我们深入理解下spi相关内容\",{\"1\":{\"107\":1}}],[\"我们项目中也用到的这种思想\",{\"1\":{\"105\":1}}],[\"我们主要关注2\",{\"1\":{\"103\":1}}],[\"我们怎么去确定使用哪个数据库连接的驱动呢\",{\"1\":{\"103\":1}}],[\"我们在进行重构的时候\",{\"1\":{\"818\":1}}],[\"我们在做软件开发的时候\",{\"1\":{\"809\":1}}],[\"我们在写单元测试的时候\",{\"1\":{\"767\":1}}],[\"我们在项目中使用单例\",{\"1\":{\"763\":1}}],[\"我们在使用\",{\"1\":{\"809\":1}}],[\"我们在使用这个单例类的时候\",{\"1\":{\"768\":1}}],[\"我们在使用时根据情况选择即可\",{\"1\":{\"308\":1}}],[\"我们在使用到泛型数组的场景下应该尽量使用列表集合替换\",{\"1\":{\"295\":1}}],[\"我们在使用上述list中\",{\"1\":{\"279\":1}}],[\"我们在一个main方法测试一下\",{\"1\":{\"291\":1}}],[\"我们在子类中重写这两个方法一点问题也没有\",{\"1\":{\"291\":1}}],[\"我们在代码中的catch的顺序决定了异常处理者在异常表的位置\",{\"1\":{\"275\":1}}],[\"我们在java中写连接数据库的代码的时候\",{\"1\":{\"102\":1}}],[\"我们在实现int\",{\"1\":{\"93\":1}}],[\"我们现在需要使用一个内容搜索接口\",{\"1\":{\"96\":1}}],[\"我们所做的所有事都是为了提升自我\",{\"1\":{\"36\":1}}],[\"我就是玩\",{\"1\":{\"90\":1}}],[\"我打赌你肯定想不到\",{\"1\":{\"89\":1}}],[\"我发现好处还是挺多的\",{\"1\":{\"88\":1}}],[\"ibatis自带的queryforlist\",{\"1\":{\"866\":1}}],[\"iae\",{\"1\":{\"618\":1}}],[\"ireceiver\",{\"1\":{\"727\":7}}],[\"irouterproduct1\",{\"1\":{\"617\":5}}],[\"irouterproduct\",{\"1\":{\"617\":13}}],[\"ir\",{\"1\":{\"561\":2}}],[\"ivoltage5v\",{\"1\":{\"524\":6,\"528\":6}}],[\"izpack\",{\"1\":{\"401\":1}}],[\"ii\",{\"1\":{\"305\":2}}],[\"i<s>\",{\"1\":{\"298\":1}}],[\"iyangyuan\",{\"1\":{\"283\":1,\"299\":1}}],[\"icyfenix\",{\"1\":{\"276\":1}}],[\"icon\",{\"1\":{\"85\":1}}],[\"icons\",{\"1\":{\"85\":2}}],[\"ipv6\",{\"1\":{\"947\":2}}],[\"ipv4\",{\"1\":{\"870\":1}}],[\"ipaddress\",{\"1\":{\"622\":4}}],[\"iproductfactory\",{\"1\":{\"617\":3}}],[\"iphoneproduct1\",{\"1\":{\"617\":5}}],[\"iphoneproduct\",{\"1\":{\"617\":13}}],[\"ip\",{\"1\":{\"242\":2,\"874\":1}}],[\"illegalstateexception异常\",{\"1\":{\"850\":1}}],[\"illegalstateexception\",{\"1\":{\"198\":1,\"265\":1}}],[\"illegalargumentexception\",{\"1\":{\"198\":1,\"261\":1,\"265\":1,\"267\":3,\"310\":5,\"312\":7,\"618\":1,\"703\":1}}],[\"illegalaccessexception\",{\"1\":{\"91\":1,\"261\":1,\"293\":1,\"305\":1,\"309\":1,\"310\":3,\"312\":2,\"627\":1}}],[\"illegal\",{\"1\":{\"114\":3,\"144\":1,\"145\":1}}],[\"ie2\",{\"1\":{\"133\":2}}],[\"ie1\",{\"1\":{\"133\":1}}],[\"ie\",{\"1\":{\"104\":1,\"663\":1}}],[\"ios\",{\"1\":{\"947\":3}}],[\"ioc\",{\"1\":{\"769\":3}}],[\"iopenandclose3\",{\"1\":{\"728\":2}}],[\"iopenandclose2\",{\"1\":{\"728\":2}}],[\"iopenandclose1\",{\"1\":{\"728\":2}}],[\"ioutils\",{\"1\":{\"465\":1}}],[\"iot开发者\",{\"1\":{\"440\":1}}],[\"io知识体系详解♥\",{\"0\":{\"336\":1}}],[\"io多路复用详解\",{\"0\":{\"333\":1}}],[\"ioexception\",{\"1\":{\"114\":1,\"198\":1,\"252\":2,\"253\":1,\"256\":4,\"257\":2,\"259\":3,\"261\":2,\"264\":3,\"625\":1,\"644\":3}}],[\"io\",{\"0\":{\"325\":1,\"326\":1,\"327\":1,\"328\":1,\"329\":1,\"330\":1,\"331\":2,\"332\":1,\"585\":1,\"1006\":1},\"1\":{\"104\":1,\"122\":1,\"234\":2,\"275\":18,\"302\":1,\"465\":1,\"585\":2,\"875\":1}}],[\"ignoretest\",{\"1\":{\"977\":2}}],[\"ignore\",{\"1\":{\"104\":2,\"120\":1,\"972\":1,\"977\":6}}],[\"ignored\",{\"1\":{\"78\":1}}],[\"imagestore\",{\"1\":{\"809\":11}}],[\"images\",{\"1\":{\"809\":2}}],[\"imageprocessingjob\",{\"1\":{\"809\":2}}],[\"image\",{\"1\":{\"520\":1,\"521\":1,\"523\":1,\"524\":1,\"527\":1,\"528\":1,\"532\":1,\"533\":1,\"538\":1,\"539\":1,\"540\":1,\"542\":1,\"543\":2,\"547\":1,\"551\":1,\"553\":1,\"555\":1,\"556\":1,\"561\":1,\"562\":1,\"563\":2,\"569\":1,\"570\":1,\"571\":1,\"572\":1,\"573\":1,\"574\":1,\"575\":1,\"580\":1,\"582\":1,\"583\":1,\"584\":2,\"585\":1,\"595\":1,\"599\":1,\"601\":2,\"602\":2,\"608\":1,\"609\":1,\"610\":1,\"612\":1,\"613\":1,\"616\":2,\"617\":1,\"632\":2,\"634\":1,\"636\":1,\"637\":1,\"642\":1,\"643\":1,\"644\":1,\"649\":1,\"650\":1,\"651\":2,\"656\":1,\"658\":1,\"659\":1,\"664\":1,\"666\":1,\"667\":1,\"672\":1,\"675\":2,\"678\":1,\"679\":1,\"683\":1,\"685\":1,\"688\":1,\"692\":1,\"694\":1,\"695\":1,\"699\":1,\"700\":1,\"702\":1,\"703\":1,\"708\":2,\"710\":1,\"721\":1,\"723\":1,\"734\":1,\"738\":1,\"745\":3,\"776\":1,\"777\":1,\"778\":1,\"784\":1,\"786\":1,\"789\":1,\"790\":1,\"801\":1,\"802\":1,\"809\":20,\"824\":1,\"825\":2,\"826\":2,\"828\":1,\"830\":1,\"831\":1,\"832\":2,\"833\":1,\"834\":1,\"838\":1,\"839\":1}}],[\"im4java\",{\"1\":{\"408\":1}}],[\"im\",{\"1\":{\"314\":1}}],[\"immutablelist<string>\",{\"1\":{\"942\":1}}],[\"immutablelist\",{\"1\":{\"445\":1,\"451\":1,\"466\":1,\"940\":1,\"942\":1}}],[\"immutablemap<string\",{\"1\":{\"942\":1}}],[\"immutablemap\",{\"1\":{\"445\":1,\"451\":1,\"466\":1,\"942\":2}}],[\"immutableset\",{\"1\":{\"942\":1}}],[\"immutableset<somemutabletype>\",{\"1\":{\"942\":1}}],[\"immutablesortedmultiset\",{\"1\":{\"466\":1}}],[\"immutables\",{\"1\":{\"398\":1,\"447\":3}}],[\"immutable类的所有的属性都应该是final的\",{\"1\":{\"173\":1}}],[\"immutable对象的状态在创建之后就不能发生改变\",{\"1\":{\"173\":1}}],[\"immutable\",{\"0\":{\"169\":1,\"173\":1,\"447\":1,\"451\":1},\"1\":{\"123\":1,\"466\":1,\"851\":1,\"942\":2}}],[\"impelents\",{\"1\":{\"813\":1}}],[\"importer\",{\"1\":{\"947\":1}}],[\"important\",{\"1\":{\"145\":1,\"312\":1}}],[\"import\",{\"0\":{\"889\":1},\"1\":{\"144\":1,\"229\":3,\"234\":9,\"305\":1,\"308\":1,\"859\":4,\"886\":1,\"891\":2,\"892\":3,\"905\":2,\"910\":1,\"975\":2,\"976\":1,\"977\":2,\"978\":7,\"979\":1,\"980\":7,\"981\":7,\"982\":4,\"983\":3}}],[\"imple\",{\"1\":{\"538\":9}}],[\"implementor\",{\"1\":{\"538\":9}}],[\"implementations\",{\"1\":{\"104\":4}}],[\"implementation\",{\"0\":{\"834\":1},\"1\":{\"104\":6,\"312\":1,\"537\":1,\"808\":1,\"877\":1,\"932\":1}}],[\"implements\",{\"1\":{\"96\":2,\"104\":1,\"114\":2,\"122\":1,\"133\":1,\"141\":3,\"214\":1,\"259\":1,\"282\":1,\"302\":1,\"305\":1,\"306\":1,\"524\":1,\"528\":1,\"532\":2,\"538\":1,\"542\":2,\"561\":1,\"562\":5,\"563\":1,\"571\":4,\"580\":2,\"617\":6,\"625\":1,\"626\":1,\"632\":1,\"642\":2,\"649\":2,\"650\":4,\"672\":2,\"678\":3,\"687\":1,\"689\":2,\"695\":2,\"700\":1,\"703\":1,\"723\":4,\"727\":2,\"728\":6,\"779\":1,\"784\":2,\"789\":3,\"809\":2,\"813\":3,\"834\":1,\"838\":4,\"851\":1}}],[\"implicitly\",{\"1\":{\"310\":1}}],[\"impl\",{\"1\":{\"104\":2}}],[\"improve\",{\"1\":{\"86\":1}}],[\"imgscalr\",{\"1\":{\"408\":1}}],[\"img\",{\"1\":{\"95\":1,\"103\":1,\"112\":1,\"113\":2,\"123\":1,\"146\":1,\"156\":1,\"213\":1,\"214\":1,\"215\":1,\"216\":1,\"217\":1,\"218\":1,\"245\":1,\"257\":1,\"283\":2,\"287\":3,\"303\":2,\"309\":1}}],[\"i++\",{\"1\":{\"93\":1,\"141\":5,\"276\":3,\"288\":1,\"306\":1,\"310\":1,\"311\":1,\"312\":1,\"562\":1,\"644\":1,\"678\":1,\"742\":2,\"743\":2,\"778\":1,\"845\":1,\"848\":1,\"981\":1}}],[\"i2\",{\"1\":{\"76\":1,\"284\":3,\"305\":3}}],[\"i1\",{\"1\":{\"76\":1,\"284\":4,\"305\":3}}],[\"i\",{\"1\":{\"71\":1,\"93\":3,\"114\":4,\"120\":9,\"141\":20,\"276\":6,\"282\":3,\"285\":2,\"288\":3,\"289\":1,\"294\":1,\"306\":4,\"307\":2,\"310\":4,\"311\":3,\"312\":5,\"432\":1,\"562\":4,\"571\":7,\"586\":1,\"627\":7,\"644\":4,\"659\":1,\"678\":3,\"723\":24,\"742\":6,\"743\":6,\"778\":3,\"812\":1,\"838\":3,\"845\":2,\"848\":2,\"860\":1,\"950\":2,\"981\":3}}],[\"ifnull\",{\"1\":{\"865\":1,\"872\":1}}],[\"ifndef\",{\"1\":{\"151\":1}}],[\"ifdef\",{\"1\":{\"151\":1}}],[\"iftest\",{\"1\":{\"92\":3}}],[\"if\",{\"1\":{\"68\":1,\"84\":1,\"90\":4,\"91\":1,\"92\":2,\"103\":1,\"104\":37,\"114\":17,\"120\":3,\"130\":1,\"138\":5,\"145\":1,\"209\":1,\"234\":1,\"242\":11,\"253\":1,\"257\":1,\"263\":1,\"264\":1,\"284\":3,\"306\":1,\"310\":41,\"311\":12,\"312\":23,\"451\":2,\"453\":1,\"455\":1,\"524\":2,\"528\":3,\"533\":1,\"610\":6,\"613\":4,\"614\":2,\"618\":7,\"620\":1,\"625\":2,\"627\":7,\"632\":1,\"636\":1,\"644\":2,\"649\":2,\"650\":2,\"656\":2,\"659\":10,\"678\":1,\"707\":2,\"708\":4,\"710\":4,\"738\":4,\"754\":2,\"755\":1,\"756\":1,\"757\":4,\"768\":4,\"772\":1,\"775\":3,\"778\":3,\"779\":5,\"780\":2,\"783\":1,\"789\":1,\"790\":4,\"791\":2,\"803\":1,\"845\":1,\"847\":4,\"848\":5,\"850\":4,\"851\":3,\"852\":8,\"858\":1,\"859\":1,\"900\":1,\"901\":2,\"902\":1,\"911\":1,\"981\":1}}],[\"in操作能避免则避免\",{\"1\":{\"865\":1}}],[\"inheritance\",{\"1\":{\"732\":1}}],[\"inherited注解\",{\"1\":{\"230\":2}}],[\"inherited注解的作用\",{\"1\":{\"230\":1}}],[\"inherited修饰的annotation\",{\"1\":{\"230\":1,\"237\":1}}],[\"inherited用于标明注解可继承\",{\"1\":{\"221\":1}}],[\"inherited\",{\"0\":{\"230\":1},\"1\":{\"221\":1,\"226\":1,\"230\":1,\"237\":1}}],[\"injection框架\",{\"0\":{\"620\":1}}],[\"injection\",{\"0\":{\"449\":1},\"1\":{\"620\":1}}],[\"inversion\",{\"1\":{\"725\":1}}],[\"invalidated\",{\"1\":{\"310\":1}}],[\"invocationhandler\",{\"1\":{\"699\":1,\"700\":3}}],[\"invocationtargetexception\",{\"1\":{\"309\":1,\"310\":4,\"312\":6,\"627\":1}}],[\"invokemethod\",{\"1\":{\"979\":2,\"980\":2}}],[\"invokeexplosively\",{\"1\":{\"979\":1,\"980\":1}}],[\"invoker\",{\"1\":{\"560\":1,\"561\":5}}],[\"invokedescriptoridx\",{\"1\":{\"312\":1}}],[\"invokeidx\",{\"1\":{\"312\":1}}],[\"invoke0\",{\"1\":{\"312\":4,\"979\":1,\"980\":1}}],[\"invoke时\",{\"1\":{\"312\":1}}],[\"invokevirtual\",{\"1\":{\"275\":12,\"291\":2}}],[\"invokestatic\",{\"1\":{\"275\":4}}],[\"invokespecial\",{\"1\":{\"228\":1,\"291\":3}}],[\"invoke\",{\"0\":{\"312\":1},\"1\":{\"145\":1,\"288\":1,\"308\":4,\"309\":2,\"310\":1,\"312\":13,\"700\":2,\"703\":2,\"979\":3,\"980\":3}}],[\"involves\",{\"1\":{\"104\":1,\"145\":1}}],[\"inputnumber\",{\"1\":{\"981\":6}}],[\"inputparams\",{\"1\":{\"859\":1}}],[\"inputuserid\",{\"1\":{\"845\":1}}],[\"input\",{\"1\":{\"266\":1,\"270\":3,\"271\":1,\"468\":1,\"924\":2}}],[\"inputstreamreader\",{\"1\":{\"104\":2,\"114\":1,\"644\":2}}],[\"inputstream\",{\"0\":{\"326\":1},\"1\":{\"104\":1,\"114\":1,\"264\":11,\"585\":4,\"586\":1,\"625\":1,\"626\":4}}],[\"init=\",{\"1\":{\"624\":1}}],[\"init=false\",{\"1\":{\"622\":1}}],[\"init=true\",{\"1\":{\"622\":1}}],[\"initargs\",{\"1\":{\"306\":1,\"310\":2}}],[\"init\",{\"1\":{\"305\":1,\"622\":3,\"768\":6}}],[\"initcause\",{\"1\":{\"253\":1,\"257\":1,\"297\":1,\"310\":1}}],[\"initialvalue\",{\"1\":{\"851\":1}}],[\"initialcapacity\",{\"1\":{\"850\":2}}],[\"initialization\",{\"1\":{\"302\":1}}],[\"initialized\",{\"1\":{\"103\":1,\"133\":1}}],[\"initialize\",{\"1\":{\"77\":1,\"103\":3,\"302\":1,\"981\":1}}],[\"initialordertest\",{\"1\":{\"144\":1}}],[\"innerstopwatch\",{\"1\":{\"947\":2}}],[\"inner\",{\"1\":{\"225\":1,\"305\":8,\"947\":1}}],[\"innerclass\",{\"1\":{\"132\":6,\"144\":7}}],[\"independent\",{\"1\":{\"860\":1}}],[\"indexoutofbounds\",{\"1\":{\"297\":1}}],[\"indexoutofboundsexception等等\",{\"1\":{\"263\":1,\"858\":1}}],[\"indexoutofboundsexception\",{\"1\":{\"198\":1,\"248\":1,\"265\":1}}],[\"indexof\",{\"1\":{\"114\":3}}],[\"index\",{\"1\":{\"141\":12,\"295\":4,\"299\":1,\"649\":4,\"650\":4,\"864\":3,\"943\":1}}],[\"indiscriminately\",{\"1\":{\"145\":1}}],[\"insert做前缀\",{\"1\":{\"845\":1}}],[\"insertdept\",{\"1\":{\"242\":1}}],[\"insert\",{\"1\":{\"242\":1}}],[\"insideone\",{\"1\":{\"201\":6}}],[\"insure\",{\"1\":{\"145\":1}}],[\"inst\",{\"1\":{\"310\":2}}],[\"instruments\",{\"1\":{\"211\":4}}],[\"instrument\",{\"1\":{\"211\":11}}],[\"instantiation\",{\"1\":{\"618\":1}}],[\"instantiationexception\",{\"1\":{\"261\":1,\"293\":1,\"305\":1,\"309\":1,\"310\":6,\"312\":1,\"627\":1}}],[\"instantiated\",{\"1\":{\"133\":2}}],[\"instance2\",{\"1\":{\"752\":5,\"753\":4,\"754\":4,\"755\":4,\"756\":4,\"757\":4,\"758\":4,\"759\":3}}],[\"instanceof\",{\"1\":{\"659\":8}}],[\"instances\",{\"1\":{\"145\":1,\"771\":3,\"773\":3}}],[\"instance\",{\"1\":{\"80\":1,\"104\":5,\"150\":1,\"310\":2,\"601\":12,\"752\":9,\"753\":7,\"754\":9,\"755\":8,\"756\":8,\"757\":9,\"758\":8,\"759\":7,\"768\":14,\"772\":5,\"974\":1}}],[\"instead\",{\"1\":{\"80\":1,\"310\":1,\"311\":1,\"466\":1}}],[\"incrementandget\",{\"1\":{\"769\":1,\"771\":1,\"772\":1}}],[\"increment\",{\"1\":{\"310\":1}}],[\"incorrect\",{\"1\":{\"225\":1,\"947\":1}}],[\"incomplete\",{\"1\":{\"225\":1}}],[\"incompatible\",{\"1\":{\"130\":1}}],[\"including\",{\"1\":{\"78\":1}}],[\"infield\",{\"1\":{\"865\":1}}],[\"infinispan\",{\"1\":{\"400\":1}}],[\"inflationthreshold\",{\"1\":{\"310\":1,\"312\":2}}],[\"inflate\",{\"1\":{\"310\":1,\"312\":2}}],[\"inference\",{\"1\":{\"150\":1}}],[\"inf\",{\"1\":{\"95\":2,\"96\":3,\"100\":1,\"103\":2,\"104\":3,\"105\":1,\"106\":4,\"110\":1,\"114\":3}}],[\"info级别的日志输出\",{\"1\":{\"859\":1}}],[\"infocolleageiterator\",{\"1\":{\"650\":3}}],[\"infocollege\",{\"1\":{\"650\":6}}],[\"infoengineercollege\",{\"1\":{\"574\":5}}],[\"infoq\",{\"1\":{\"442\":1,\"489\":1}}],[\"info<\",{\"1\":{\"284\":1}}],[\"info<object>\",{\"1\":{\"284\":2}}],[\"info<integer>\",{\"1\":{\"284\":2}}],[\"info<t\",{\"1\":{\"284\":1}}],[\"info<t>\",{\"1\":{\"282\":2,\"284\":1}}],[\"info<string>\",{\"1\":{\"282\":1,\"284\":2}}],[\"infoimpl<string>\",{\"1\":{\"282\":1}}],[\"infoimpl<t>\",{\"1\":{\"282\":1}}],[\"infoimpl\",{\"1\":{\"282\":1}}],[\"information\",{\"1\":{\"145\":1,\"312\":2}}],[\"info\",{\"1\":{\"14\":1,\"305\":6,\"312\":65,\"632\":9,\"642\":4}}],[\"intresult\",{\"1\":{\"468\":1}}],[\"introduced\",{\"1\":{\"86\":1}}],[\"intvalue\",{\"1\":{\"312\":1}}],[\"intecept\",{\"1\":{\"703\":1}}],[\"intent\",{\"1\":{\"431\":1}}],[\"integration\",{\"0\":{\"460\":1},\"1\":{\"414\":1}}],[\"integer对象\",{\"1\":{\"858\":1}}],[\"integer对象是在integercache\",{\"1\":{\"848\":1}}],[\"integer>返回\",{\"1\":{\"298\":2}}],[\"integer>\",{\"1\":{\"281\":2,\"468\":1,\"644\":9,\"942\":1}}],[\"integer及其它包装类\",{\"1\":{\"173\":1}}],[\"integercachehighpropvalue\",{\"1\":{\"120\":3}}],[\"integercache\",{\"1\":{\"120\":6,\"637\":1}}],[\"integer\",{\"0\":{\"168\":1,\"637\":1},\"1\":{\"119\":1,\"120\":26,\"130\":1,\"132\":1,\"138\":4,\"168\":2,\"285\":1,\"288\":1,\"294\":4,\"295\":2,\"298\":2,\"308\":2,\"312\":1,\"637\":18,\"644\":1,\"790\":6,\"826\":1,\"828\":1,\"848\":1,\"850\":1,\"852\":5,\"950\":1,\"978\":2,\"981\":3}}],[\"intellij\",{\"0\":{\"480\":1},\"1\":{\"407\":1,\"450\":1,\"480\":1,\"481\":2,\"484\":1,\"979\":4}}],[\"interger\",{\"1\":{\"834\":2}}],[\"intercept\",{\"1\":{\"703\":4}}],[\"intermap\",{\"1\":{\"659\":10}}],[\"intermediate\",{\"1\":{\"310\":1}}],[\"interpret\",{\"1\":{\"642\":4}}],[\"interpreter\",{\"1\":{\"591\":1,\"641\":1,\"644\":13,\"798\":1}}],[\"interviews\",{\"1\":{\"489\":1}}],[\"intersperse\",{\"1\":{\"469\":1}}],[\"interruptedexception\",{\"1\":{\"137\":3,\"308\":3,\"980\":1}}],[\"internal\",{\"1\":{\"979\":4,\"980\":4}}],[\"internalerror\",{\"1\":{\"312\":2}}],[\"internalservererror\",{\"1\":{\"854\":1}}],[\"internals\",{\"1\":{\"145\":1}}],[\"intern\",{\"0\":{\"125\":1},\"1\":{\"125\":5,\"311\":1}}],[\"internedname\",{\"1\":{\"311\":2}}],[\"interned\",{\"1\":{\"120\":1,\"618\":1}}],[\"interface3\",{\"1\":{\"723\":5}}],[\"interface2\",{\"1\":{\"723\":5}}],[\"interface1\",{\"1\":{\"721\":4,\"723\":25}}],[\"interface4\",{\"1\":{\"532\":3}}],[\"interfacemethodref\",{\"1\":{\"312\":1}}],[\"interfaces\",{\"1\":{\"310\":1,\"312\":2,\"699\":1,\"700\":2}}],[\"interface在新窗口打开\",{\"1\":{\"133\":2}}],[\"interfaceimplementexample\",{\"1\":{\"133\":2}}],[\"interfaceexample\",{\"1\":{\"133\":7}}],[\"interface\",{\"1\":{\"95\":2,\"96\":1,\"104\":2,\"114\":1,\"133\":2,\"214\":1,\"218\":1,\"223\":1,\"224\":1,\"225\":1,\"228\":3,\"229\":1,\"230\":1,\"234\":1,\"236\":2,\"237\":2,\"242\":1,\"259\":1,\"282\":1,\"298\":1,\"302\":1,\"305\":4,\"308\":1,\"524\":1,\"528\":1,\"532\":2,\"538\":1,\"542\":1,\"561\":1,\"562\":1,\"571\":2,\"580\":1,\"616\":1,\"617\":3,\"619\":1,\"625\":1,\"626\":1,\"632\":1,\"642\":1,\"649\":2,\"650\":1,\"672\":1,\"678\":2,\"695\":1,\"700\":1,\"721\":1,\"723\":4,\"727\":1,\"728\":6,\"779\":1,\"784\":1,\"789\":2,\"808\":2,\"809\":1,\"813\":4,\"825\":1,\"834\":1,\"838\":2,\"877\":1}}],[\"interactive\",{\"1\":{\"77\":1}}],[\"interaction\",{\"0\":{\"77\":1}}],[\"into\",{\"1\":{\"104\":1,\"120\":1,\"312\":1,\"853\":1}}],[\"int\",{\"0\":{\"161\":1,\"168\":1},\"1\":{\"89\":1,\"90\":3,\"93\":2,\"114\":8,\"119\":2,\"120\":9,\"129\":2,\"130\":1,\"132\":4,\"133\":7,\"134\":8,\"137\":2,\"138\":6,\"139\":2,\"140\":2,\"141\":31,\"143\":1,\"144\":10,\"161\":2,\"165\":5,\"168\":1,\"193\":1,\"209\":3,\"230\":1,\"253\":1,\"273\":2,\"276\":5,\"279\":3,\"285\":1,\"288\":1,\"289\":3,\"295\":4,\"302\":4,\"305\":21,\"306\":13,\"307\":5,\"308\":10,\"310\":8,\"311\":3,\"312\":4,\"446\":3,\"452\":1,\"469\":1,\"471\":1,\"524\":6,\"528\":6,\"562\":4,\"571\":5,\"583\":1,\"622\":3,\"624\":1,\"627\":1,\"636\":1,\"644\":7,\"649\":1,\"650\":3,\"659\":8,\"667\":14,\"678\":1,\"685\":4,\"687\":4,\"710\":6,\"734\":21,\"738\":2,\"739\":1,\"742\":2,\"743\":2,\"768\":16,\"773\":2,\"778\":6,\"779\":3,\"790\":2,\"845\":6,\"846\":3,\"847\":4,\"848\":5,\"849\":3,\"850\":2,\"858\":3,\"859\":1,\"863\":1,\"866\":2,\"901\":1,\"911\":2,\"912\":2,\"917\":1,\"920\":4,\"929\":1,\"942\":1,\"950\":1,\"955\":1,\"978\":4,\"979\":4,\"981\":1}}],[\"in\",{\"0\":{\"48\":1,\"49\":1,\"50\":1,\"51\":1,\"76\":1},\"1\":{\"47\":2,\"48\":2,\"50\":2,\"51\":2,\"52\":2,\"53\":2,\"54\":2,\"55\":2,\"58\":2,\"68\":4,\"71\":7,\"72\":4,\"75\":1,\"76\":1,\"77\":6,\"80\":6,\"82\":1,\"83\":2,\"86\":1,\"87\":1,\"104\":11,\"114\":3,\"120\":1,\"123\":1,\"141\":1,\"145\":11,\"150\":4,\"155\":5,\"225\":2,\"234\":5,\"270\":1,\"284\":1,\"301\":1,\"310\":5,\"312\":2,\"438\":3,\"474\":1,\"487\":1,\"585\":1,\"625\":6,\"644\":4,\"849\":1,\"850\":1,\"902\":1,\"976\":6,\"979\":4,\"980\":1,\"982\":2,\"997\":1}}],[\"isxxx\",{\"1\":{\"852\":1}}],[\"isbadtemper\",{\"1\":{\"852\":1}}],[\"isugly\",{\"1\":{\"852\":1}}],[\"islocked\",{\"1\":{\"851\":2}}],[\"islazyinit\",{\"1\":{\"627\":1}}],[\"isdebugenabled\",{\"1\":{\"859\":1}}],[\"isdeleted的属性\",{\"1\":{\"845\":1}}],[\"isdiagnosticsenabled\",{\"1\":{\"104\":16}}],[\"ispoor\",{\"1\":{\"852\":1}}],[\"isp\",{\"0\":{\"720\":1}}],[\"ispresent\",{\"1\":{\"450\":1}}],[\"isprimitive\",{\"1\":{\"312\":1}}],[\"isempty\",{\"1\":{\"627\":1,\"850\":1}}],[\"isenumconstant\",{\"1\":{\"307\":1}}],[\"isref\",{\"1\":{\"626\":1}}],[\"isconstructor\",{\"1\":{\"312\":7}}],[\"isvmanonymousclass\",{\"1\":{\"310\":1,\"312\":3}}],[\"isvarargs\",{\"1\":{\"308\":1}}],[\"isinterface\",{\"1\":{\"305\":2,\"310\":1,\"312\":1}}],[\"issingleton\",{\"1\":{\"626\":1,\"627\":3}}],[\"isstanding\",{\"1\":{\"284\":1}}],[\"issaverequestdata\",{\"1\":{\"242\":2}}],[\"isannotationpresent\",{\"1\":{\"233\":1,\"234\":1}}],[\"isassignablefrom\",{\"1\":{\"114\":1,\"311\":1}}],[\"isjavaidentifierpart\",{\"1\":{\"114\":1}}],[\"isjavaidentifierstart\",{\"1\":{\"114\":1}}],[\"isnull\",{\"1\":{\"865\":1,\"872\":1}}],[\"isnotempty\",{\"1\":{\"242\":1}}],[\"isnotnull\",{\"1\":{\"242\":1}}],[\"isn\",{\"1\":{\"104\":1}}],[\"is\",{\"1\":{\"43\":2,\"47\":2,\"48\":2,\"50\":2,\"51\":3,\"52\":2,\"53\":2,\"54\":2,\"55\":2,\"58\":2,\"59\":1,\"62\":4,\"68\":2,\"70\":1,\"71\":6,\"72\":3,\"73\":2,\"75\":1,\"77\":10,\"78\":1,\"80\":4,\"81\":1,\"82\":4,\"83\":1,\"84\":1,\"85\":2,\"86\":7,\"87\":3,\"104\":17,\"120\":1,\"122\":1,\"123\":1,\"127\":1,\"133\":5,\"145\":4,\"152\":2,\"209\":1,\"210\":2,\"211\":3,\"284\":1,\"302\":2,\"310\":5,\"312\":4,\"451\":1,\"485\":1,\"601\":3,\"618\":1,\"627\":2,\"659\":1,\"812\":1,\"813\":2,\"833\":1,\"849\":1,\"859\":2,\"865\":3,\"872\":1,\"902\":3,\"912\":1,\"933\":2,\"942\":1,\"958\":1,\"981\":1,\"997\":1}}],[\"id更新\",{\"1\":{\"865\":1}}],[\"id则为外键\",{\"1\":{\"865\":1}}],[\"id是主键\",{\"1\":{\"865\":1}}],[\"idx\",{\"1\":{\"863\":1}}],[\"idcard\",{\"1\":{\"828\":2,\"832\":7}}],[\"idgeneator\",{\"1\":{\"772\":2}}],[\"idgenerator使用举例\",{\"1\":{\"772\":1}}],[\"idgenerator>\",{\"1\":{\"771\":1}}],[\"idgenerator\",{\"1\":{\"763\":1,\"764\":7,\"767\":1,\"769\":10,\"771\":6,\"772\":9}}],[\"id=\",{\"1\":{\"622\":2,\"624\":2,\"710\":4}}],[\"ide中文件的换行符使用unix格式\",{\"1\":{\"847\":1}}],[\"ide的text\",{\"1\":{\"847\":1}}],[\"identification\",{\"1\":{\"301\":1}}],[\"identify\",{\"1\":{\"104\":1}}],[\"ide\",{\"0\":{\"407\":1},\"1\":{\"267\":1,\"407\":1,\"445\":1,\"480\":1,\"484\":2,\"835\":1,\"872\":2,\"912\":1,\"925\":1,\"975\":1}}],[\"ideptservice\",{\"1\":{\"242\":1}}],[\"ideatestrunner\",{\"1\":{\"979\":1}}],[\"ideatestrunner$repeater\",{\"1\":{\"979\":1}}],[\"idea下单元测试详解\",{\"0\":{\"967\":1}}],[\"idea设置tab为\",{\"1\":{\"847\":1}}],[\"idea\",{\"0\":{\"480\":1},\"1\":{\"104\":1,\"407\":1,\"450\":1,\"480\":1,\"825\":1,\"833\":1,\"834\":1}}],[\"ide1\",{\"1\":{\"74\":1}}],[\"id2\",{\"1\":{\"81\":1}}],[\"ids\",{\"1\":{\"80\":2,\"848\":1}}],[\"id1>this\",{\"1\":{\"51\":1}}],[\"id1\",{\"1\":{\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"52\":1,\"53\":1,\"54\":1,\"55\":1,\"58\":1,\"72\":1,\"81\":2}}],[\"id\",{\"1\":{\"41\":1,\"42\":1,\"74\":1,\"77\":1,\"104\":5,\"132\":8,\"474\":2,\"485\":1,\"626\":1,\"710\":5,\"742\":14,\"743\":12,\"763\":1,\"764\":10,\"767\":1,\"769\":6,\"771\":3,\"772\":3,\"826\":1,\"833\":1,\"834\":2,\"846\":3,\"859\":4,\"863\":1,\"864\":3,\"865\":5,\"947\":1,\"958\":2}}],[\"itv接口\",{\"1\":{\"728\":1}}],[\"itv3\",{\"1\":{\"728\":5}}],[\"itv2\",{\"1\":{\"728\":4}}],[\"itv\",{\"1\":{\"728\":2}}],[\"itv1\",{\"1\":{\"728\":4}}],[\"itr\",{\"1\":{\"651\":1}}],[\"iteacherdao\",{\"1\":{\"695\":8,\"700\":6}}],[\"itext\",{\"1\":{\"421\":1}}],[\"item\",{\"1\":{\"295\":2,\"850\":4}}],[\"iteye\",{\"1\":{\"276\":1}}],[\"iterable<s>\",{\"1\":{\"114\":1}}],[\"iteratorpattern\",{\"1\":{\"649\":1}}],[\"iterator<element>\",{\"1\":{\"838\":1}}],[\"iterator<college>\",{\"1\":{\"650\":1}}],[\"iterator<\",{\"1\":{\"284\":1}}],[\"iterator<map\",{\"1\":{\"114\":1}}],[\"iterator<s>\",{\"1\":{\"114\":3}}],[\"iterator<string>\",{\"1\":{\"114\":2,\"259\":1,\"850\":1}}],[\"iterator<search>\",{\"1\":{\"96\":1}}],[\"iterator<driver>\",{\"1\":{\"103\":2,\"111\":1}}],[\"iterator\",{\"1\":{\"96\":4,\"103\":2,\"111\":1,\"114\":3,\"115\":1,\"284\":5,\"591\":1,\"648\":1,\"649\":6,\"650\":14,\"651\":4,\"798\":1,\"838\":1,\"850\":5}}],[\"itpub\",{\"1\":{\"116\":1}}],[\"its\",{\"1\":{\"51\":1,\"86\":2,\"104\":1}}],[\"it\",{\"1\":{\"11\":2,\"59\":1,\"68\":4,\"71\":6,\"72\":1,\"73\":2,\"75\":1,\"77\":2,\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":1,\"87\":1,\"104\":7,\"120\":1,\"145\":3,\"152\":1,\"234\":1,\"281\":1,\"310\":1,\"312\":3,\"649\":4,\"659\":2,\"796\":1,\"852\":2,\"855\":1,\"912\":1,\"950\":1}}],[\"p1\",{\"1\":{\"955\":1}}],[\"p3c\",{\"1\":{\"872\":1}}],[\"pk\",{\"1\":{\"863\":1}}],[\"p2\",{\"1\":{\"689\":8}}],[\"pc\",{\"1\":{\"601\":1}}],[\"pdfbox\",{\"1\":{\"421\":1}}],[\"pdf\",{\"0\":{\"421\":1}}],[\"pdai所有\",{\"1\":{\"243\":1,\"277\":1,\"299\":1,\"314\":1}}],[\"pdai\",{\"1\":{\"95\":1,\"117\":1,\"154\":1,\"207\":1,\"220\":1,\"234\":10,\"239\":1,\"243\":1,\"244\":1,\"277\":1,\"278\":1,\"280\":1,\"286\":1,\"299\":1,\"300\":1,\"314\":1,\"975\":2,\"976\":1,\"977\":1,\"978\":2,\"979\":2,\"980\":3,\"981\":2,\"982\":3,\"983\":1}}],[\"python\",{\"1\":{\"419\":1,\"472\":1}}],[\"photoshop\",{\"1\":{\"537\":1,\"663\":1,\"669\":1}}],[\"phoneproduct\",{\"1\":{\"617\":5}}],[\"phone4\",{\"1\":{\"542\":4}}],[\"phone3\",{\"1\":{\"542\":4}}],[\"phone2\",{\"1\":{\"542\":4}}],[\"phone1\",{\"1\":{\"542\":4}}],[\"phone\",{\"1\":{\"524\":5,\"528\":5,\"542\":7}}],[\"phoenix\",{\"1\":{\"394\":1}}],[\"phaser详解\",{\"0\":{\"503\":1}}],[\"php专业\",{\"1\":{\"650\":2}}],[\"php\",{\"1\":{\"419\":1,\"795\":1}}],[\"pizaa\",{\"1\":{\"610\":1}}],[\"pizza4\",{\"1\":{\"613\":2}}],[\"pizza3\",{\"1\":{\"613\":2}}],[\"pizza2\",{\"1\":{\"613\":1}}],[\"pizza2=\",{\"1\":{\"613\":1}}],[\"pizza1\",{\"1\":{\"613\":2}}],[\"pizzastore\",{\"1\":{\"613\":1}}],[\"pizza\",{\"1\":{\"609\":9,\"610\":32,\"613\":41}}],[\"pippo\",{\"1\":{\"434\":1}}],[\"pipelines\",{\"1\":{\"150\":1}}],[\"picketlink是一个针对java应用进行安全和身份认证管理的大型项目\",{\"1\":{\"427\":1}}],[\"picketlink\",{\"1\":{\"427\":1}}],[\"picasso\",{\"1\":{\"408\":1}}],[\"ppt\",{\"1\":{\"402\":1}}],[\"pptx\",{\"1\":{\"402\":1}}],[\"pmd\",{\"1\":{\"388\":1,\"484\":2}}],[\"please\",{\"1\":{\"485\":1}}],[\"place\",{\"1\":{\"997\":1}}],[\"plain\",{\"1\":{\"873\":1}}],[\"plantuml\",{\"1\":{\"212\":1}}],[\"plantuml在新窗口打开\",{\"1\":{\"212\":1}}],[\"playing\",{\"1\":{\"211\":3,\"601\":1}}],[\"play\",{\"0\":{\"472\":1},\"1\":{\"211\":7,\"434\":1,\"457\":1,\"472\":2,\"600\":1,\"601\":4,\"728\":9}}],[\"platform\",{\"1\":{\"145\":1}}],[\"plugin>\",{\"1\":{\"974\":1}}],[\"plugin<\",{\"1\":{\"974\":1}}],[\"plugins>\",{\"1\":{\"974\":1}}],[\"plugins<\",{\"1\":{\"974\":1}}],[\"plugins\",{\"1\":{\"13\":1}}],[\"plugin\",{\"1\":{\"0\":2,\"13\":1,\"105\":1,\"460\":1}}],[\"pojo专指只有setter\",{\"1\":{\"873\":1}}],[\"pojo\",{\"1\":{\"873\":1}}],[\"pojo类的布尔属性不能加is\",{\"1\":{\"866\":1}}],[\"pojo类的setter方法\",{\"1\":{\"848\":1}}],[\"pojo类的域变量\",{\"1\":{\"848\":1}}],[\"pojo类必须写tostring方法\",{\"1\":{\"848\":1}}],[\"pojo类属性没有初值是提醒使用者在需要使用时\",{\"1\":{\"848\":1}}],[\"pojo类中的任何布尔类型的变量\",{\"1\":{\"845\":1,\"863\":1}}],[\"pojo是do\",{\"1\":{\"845\":1}}],[\"po\",{\"1\":{\"845\":1,\"848\":1,\"873\":1}}],[\"port\",{\"1\":{\"622\":4}}],[\"portability\",{\"1\":{\"145\":1}}],[\"poping\",{\"1\":{\"601\":1}}],[\"pop\",{\"1\":{\"601\":2,\"644\":3,\"950\":1}}],[\"popcorn\",{\"1\":{\"601\":14}}],[\"podcasts\",{\"0\":{\"488\":1}}],[\"pom\",{\"1\":{\"458\":6,\"974\":2}}],[\"powermock\",{\"1\":{\"431\":1}}],[\"powerful\",{\"1\":{\"145\":1}}],[\"poi\",{\"1\":{\"402\":1}}],[\"point<string>\",{\"1\":{\"281\":2}}],[\"point<t>\",{\"1\":{\"281\":1}}],[\"pointcut\",{\"1\":{\"242\":2}}],[\"pool\",{\"1\":{\"123\":3,\"125\":3,\"312\":1,\"636\":5}}],[\"position\",{\"1\":{\"650\":5}}],[\"posse\",{\"1\":{\"439\":1,\"488\":1}}],[\"possibility\",{\"1\":{\"70\":1}}],[\"possible\",{\"1\":{\"44\":1,\"51\":1,\"59\":1,\"68\":2,\"72\":1,\"73\":1,\"75\":1,\"77\":2,\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"85\":1,\"87\":1,\"104\":1,\"145\":1}}],[\"post\",{\"1\":{\"314\":1,\"419\":1,\"854\":1}}],[\"postmapping\",{\"1\":{\"242\":2}}],[\"postgresql\",{\"1\":{\"101\":1}}],[\"postgresql实现\",{\"0\":{\"101\":1}}],[\"p\",{\"1\":{\"114\":3,\"116\":2,\"219\":2,\"277\":1,\"281\":3,\"299\":1,\"309\":1,\"314\":1,\"580\":3,\"689\":15,\"732\":2,\"839\":6,\"984\":1}}],[\"pr\",{\"1\":{\"443\":1}}],[\"practices\",{\"1\":{\"453\":1}}],[\"practice\",{\"1\":{\"438\":1,\"487\":1}}],[\"prose\",{\"1\":{\"947\":1}}],[\"producer\",{\"1\":{\"850\":1}}],[\"product\",{\"1\":{\"550\":2,\"551\":1,\"608\":1,\"612\":1,\"616\":1}}],[\"proved\",{\"1\":{\"732\":1}}],[\"provided\",{\"1\":{\"312\":1}}],[\"provides\",{\"1\":{\"152\":1}}],[\"providers\",{\"1\":{\"114\":5}}],[\"provider只用在提交的jar包里的meta\",{\"1\":{\"96\":1}}],[\"provider\",{\"1\":{\"95\":2,\"114\":3,\"427\":1,\"618\":3}}],[\"proxyinstance=\",{\"1\":{\"700\":1}}],[\"proxyinstance=class\",{\"1\":{\"700\":1}}],[\"proxyinstance\",{\"1\":{\"700\":4,\"703\":2}}],[\"proxyfactory\",{\"1\":{\"700\":3,\"703\":3}}],[\"proxy\",{\"1\":{\"590\":1,\"692\":1,\"694\":1,\"699\":2,\"700\":3,\"702\":1,\"798\":1}}],[\"project>\",{\"1\":{\"974\":1}}],[\"projector\",{\"1\":{\"601\":14}}],[\"project\",{\"1\":{\"427\":1,\"458\":1,\"863\":1}}],[\"profiler\",{\"1\":{\"422\":1}}],[\"professional\",{\"1\":{\"153\":1}}],[\"prototype\",{\"1\":{\"589\":1,\"626\":1,\"627\":1,\"682\":1,\"683\":1,\"798\":1}}],[\"protobuf\",{\"1\":{\"395\":1}}],[\"protégé\",{\"1\":{\"432\":1}}],[\"protection\",{\"1\":{\"312\":1}}],[\"protected\",{\"1\":{\"132\":2,\"133\":4,\"134\":2,\"137\":2,\"141\":7,\"194\":1,\"241\":2,\"242\":1,\"305\":4,\"310\":3,\"538\":3,\"542\":3,\"555\":1,\"574\":10,\"585\":1,\"609\":1,\"613\":1,\"627\":1,\"644\":2,\"656\":1,\"672\":1,\"687\":1,\"689\":2,\"779\":1,\"845\":2,\"848\":1,\"851\":1,\"934\":1,\"959\":1}}],[\"prone\",{\"1\":{\"388\":1}}],[\"probably\",{\"1\":{\"312\":2}}],[\"problemexception\",{\"1\":{\"901\":1}}],[\"problem<object>\",{\"1\":{\"297\":2}}],[\"problem<number>\",{\"1\":{\"297\":1}}],[\"problem<integer>\",{\"1\":{\"297\":1}}],[\"problem<t>\",{\"1\":{\"297\":1}}],[\"problem\",{\"1\":{\"284\":1}}],[\"problems\",{\"1\":{\"104\":1}}],[\"processrequest\",{\"1\":{\"710\":10}}],[\"process\",{\"1\":{\"485\":1,\"809\":2}}],[\"processing\",{\"1\":{\"238\":1,\"243\":1,\"859\":1}}],[\"processlist\",{\"1\":{\"222\":1}}],[\"programming\",{\"1\":{\"453\":1,\"873\":1}}],[\"programs\",{\"1\":{\"152\":1}}],[\"program\",{\"1\":{\"123\":1,\"152\":1,\"808\":1}}],[\"proposition\",{\"1\":{\"431\":1}}],[\"propagate\",{\"1\":{\"310\":1,\"312\":1}}],[\"propagated\",{\"1\":{\"310\":1,\"311\":1}}],[\"props\",{\"1\":{\"104\":8}}],[\"propertynames\",{\"1\":{\"104\":1}}],[\"property\",{\"1\":{\"104\":12,\"120\":2,\"732\":1}}],[\"propertiesloaderutils\",{\"1\":{\"106\":1}}],[\"properties的org\",{\"1\":{\"104\":1}}],[\"properties中查找org\",{\"1\":{\"104\":1}}],[\"properties是否配置use\",{\"1\":{\"104\":1}}],[\"properties\",{\"1\":{\"104\":12,\"105\":1,\"106\":3}}],[\"principle\",{\"1\":{\"716\":1,\"721\":1,\"725\":1,\"732\":1,\"736\":2,\"741\":1,\"745\":2,\"812\":1}}],[\"printmessage\",{\"1\":{\"982\":2}}],[\"printemployee\",{\"1\":{\"743\":2}}],[\"printallemployee\",{\"1\":{\"742\":2,\"743\":2}}],[\"printdepartment\",{\"1\":{\"650\":2}}],[\"printcollege\",{\"1\":{\"650\":2}}],[\"printwriter\",{\"1\":{\"586\":1}}],[\"print\",{\"1\":{\"281\":2,\"284\":1,\"285\":2,\"306\":3,\"574\":11,\"613\":4,\"632\":1,\"644\":2,\"649\":2}}],[\"printstream\",{\"1\":{\"275\":18}}],[\"printstacktrace\",{\"1\":{\"91\":1,\"141\":3,\"234\":2,\"242\":1,\"246\":1,\"257\":1,\"275\":7,\"309\":5,\"689\":1,\"859\":1}}],[\"println\",{\"1\":{\"89\":3,\"91\":2,\"92\":4,\"93\":4,\"96\":2,\"103\":5,\"120\":4,\"125\":3,\"127\":7,\"130\":4,\"133\":5,\"134\":2,\"138\":2,\"139\":2,\"140\":1,\"141\":3,\"144\":4,\"209\":2,\"211\":3,\"230\":1,\"234\":3,\"241\":3,\"252\":1,\"257\":3,\"275\":11,\"276\":3,\"279\":4,\"281\":1,\"282\":1,\"284\":1,\"288\":2,\"298\":1,\"305\":18,\"306\":18,\"307\":7,\"308\":9,\"309\":1,\"524\":4,\"528\":6,\"532\":1,\"538\":2,\"542\":15,\"553\":3,\"555\":8,\"561\":3,\"562\":11,\"571\":2,\"574\":3,\"580\":4,\"584\":13,\"596\":3,\"601\":19,\"609\":4,\"610\":3,\"613\":4,\"617\":18,\"618\":6,\"622\":1,\"632\":3,\"636\":2,\"637\":6,\"644\":1,\"649\":1,\"650\":2,\"656\":5,\"659\":6,\"664\":3,\"667\":5,\"672\":4,\"676\":4,\"678\":10,\"685\":5,\"687\":6,\"689\":5,\"695\":3,\"700\":5,\"703\":6,\"708\":4,\"710\":4,\"718\":7,\"723\":16,\"727\":2,\"728\":3,\"734\":13,\"738\":5,\"739\":4,\"742\":4,\"743\":5,\"752\":3,\"753\":3,\"754\":4,\"755\":4,\"756\":4,\"757\":4,\"758\":4,\"759\":4,\"776\":2,\"778\":15,\"779\":4,\"784\":3,\"787\":6,\"788\":4,\"789\":11,\"790\":2,\"801\":3,\"803\":8,\"838\":5,\"839\":8,\"847\":3,\"848\":3,\"850\":1,\"851\":1,\"852\":7,\"855\":1,\"976\":6,\"977\":1,\"979\":2,\"980\":1,\"981\":1,\"982\":2,\"983\":3}}],[\"price\",{\"1\":{\"584\":5,\"710\":5}}],[\"primenumbers\",{\"1\":{\"981\":1}}],[\"primenumbercheckertest\",{\"1\":{\"981\":2}}],[\"primenumberchecker\",{\"1\":{\"981\":7}}],[\"primefaces\",{\"1\":{\"434\":1}}],[\"primitive\",{\"1\":{\"312\":6}}],[\"priorityqueue源码解析\",{\"0\":{\"317\":1}}],[\"privileged\",{\"1\":{\"312\":1}}],[\"privilegedaction<magicaccessorimpl>\",{\"1\":{\"312\":1}}],[\"privilegedaction<s>\",{\"1\":{\"114\":2}}],[\"privilegedaction<string>\",{\"1\":{\"103\":1}}],[\"privilegedaction<boolean>\",{\"1\":{\"114\":2}}],[\"privilegedaction<void>\",{\"1\":{\"103\":1,\"310\":1}}],[\"privateimagestore\",{\"1\":{\"809\":7}}],[\"privategetdeclaredmethods\",{\"1\":{\"311\":2}}],[\"privategetdeclaredconstructors\",{\"1\":{\"310\":3}}],[\"private和proteced\",{\"1\":{\"305\":1}}],[\"private\",{\"1\":{\"103\":1,\"114\":16,\"122\":1,\"127\":2,\"132\":4,\"133\":6,\"134\":1,\"138\":3,\"140\":1,\"141\":9,\"143\":2,\"144\":4,\"145\":2,\"147\":1,\"209\":3,\"210\":1,\"241\":2,\"242\":5,\"252\":1,\"253\":1,\"256\":2,\"257\":1,\"259\":1,\"273\":1,\"275\":1,\"276\":1,\"279\":4,\"281\":3,\"282\":1,\"284\":3,\"289\":2,\"291\":3,\"295\":1,\"298\":1,\"302\":6,\"305\":10,\"306\":5,\"307\":2,\"308\":3,\"310\":6,\"311\":3,\"312\":7,\"445\":1,\"446\":2,\"450\":2,\"471\":1,\"477\":1,\"528\":1,\"542\":1,\"555\":3,\"561\":2,\"562\":2,\"571\":4,\"574\":2,\"580\":1,\"584\":2,\"596\":3,\"601\":12,\"618\":1,\"622\":3,\"625\":3,\"626\":8,\"627\":2,\"632\":3,\"636\":3,\"642\":3,\"644\":2,\"649\":3,\"650\":2,\"656\":1,\"659\":3,\"664\":3,\"667\":5,\"676\":7,\"678\":10,\"685\":3,\"687\":4,\"689\":3,\"695\":1,\"700\":1,\"703\":1,\"708\":1,\"710\":3,\"728\":1,\"734\":1,\"742\":2,\"743\":2,\"752\":2,\"753\":2,\"754\":2,\"755\":2,\"756\":2,\"757\":2,\"758\":4,\"760\":3,\"768\":12,\"769\":1,\"771\":3,\"772\":5,\"773\":7,\"776\":1,\"779\":3,\"784\":1,\"809\":5,\"813\":2,\"814\":2,\"826\":2,\"828\":1,\"830\":4,\"831\":2,\"832\":4,\"838\":1,\"839\":1,\"845\":1,\"846\":1,\"848\":1,\"851\":4,\"858\":1,\"859\":2,\"871\":1,\"897\":1,\"912\":4,\"915\":2,\"934\":1,\"980\":1,\"981\":3}}],[\"precondition\",{\"1\":{\"997\":1}}],[\"predicate\",{\"1\":{\"907\":1}}],[\"predicate<string>\",{\"1\":{\"907\":1}}],[\"predefine\",{\"1\":{\"83\":1}}],[\"preparestreamsandstart\",{\"1\":{\"979\":1}}],[\"prepareoneortwo\",{\"1\":{\"924\":1}}],[\"prepare\",{\"1\":{\"609\":4,\"613\":5}}],[\"pressure\",{\"1\":{\"676\":10,\"678\":17}}],[\"presto\",{\"1\":{\"394\":1}}],[\"presentations\",{\"1\":{\"489\":1}}],[\"presentation\",{\"1\":{\"447\":1}}],[\"present\",{\"1\":{\"104\":1,\"145\":1,\"310\":1,\"312\":1}}],[\"prevents\",{\"1\":{\"302\":2}}],[\"prev\",{\"1\":{\"114\":3}}],[\"previously\",{\"1\":{\"104\":1}}],[\"previous\",{\"1\":{\"71\":1}}],[\"preferable\",{\"1\":{\"145\":1}}],[\"prefix\",{\"1\":{\"114\":2,\"242\":1}}],[\"prefaced\",{\"1\":{\"78\":1}}],[\"pre\",{\"1\":{\"14\":1}}],[\"peanutsoyamilk\",{\"1\":{\"803\":4}}],[\"peace\",{\"1\":{\"85\":2}}],[\"pekingduck\",{\"1\":{\"787\":1,\"789\":8}}],[\"pepper\",{\"1\":{\"613\":4}}],[\"pending\",{\"1\":{\"114\":5}}],[\"persistent\",{\"1\":{\"873\":1}}],[\"persons\",{\"1\":{\"839\":4}}],[\"personservice\",{\"1\":{\"834\":2}}],[\"personservicebean2\",{\"1\":{\"833\":1}}],[\"personservicebean\",{\"1\":{\"828\":1,\"834\":1}}],[\"person1\",{\"1\":{\"828\":1}}],[\"personid\",{\"1\":{\"828\":1}}],[\"persondao\",{\"1\":{\"828\":3}}],[\"person\",{\"1\":{\"209\":3,\"230\":2,\"279\":1,\"307\":5,\"689\":1,\"727\":14,\"826\":1,\"828\":2,\"832\":6,\"839\":6,\"927\":1}}],[\"perons\",{\"1\":{\"727\":1}}],[\"perfcounter\",{\"1\":{\"310\":3}}],[\"performed\",{\"1\":{\"145\":1}}],[\"performance\",{\"1\":{\"145\":3}}],[\"perform\",{\"1\":{\"145\":2,\"618\":1}}],[\"percussion\",{\"1\":{\"211\":5}}],[\"percent\",{\"1\":{\"78\":1}}],[\"permitted\",{\"1\":{\"912\":1}}],[\"permission\",{\"1\":{\"145\":1}}],[\"permgen\",{\"1\":{\"150\":1}}],[\"perhaps\",{\"1\":{\"85\":2}}],[\"per\",{\"1\":{\"68\":2,\"69\":1,\"82\":2,\"980\":1}}],[\"pay\",{\"1\":{\"779\":3}}],[\"payorderevent\",{\"1\":{\"779\":6}}],[\"paid\",{\"1\":{\"779\":3}}],[\"paidstate\",{\"1\":{\"779\":2}}],[\"pairarraylist\",{\"1\":{\"850\":9}}],[\"pair<>\",{\"1\":{\"850\":5}}],[\"pair<string\",{\"1\":{\"468\":1}}],[\"pair<java\",{\"1\":{\"291\":1}}],[\"pair<date>\",{\"1\":{\"291\":2}}],[\"pair<t\",{\"1\":{\"289\":1}}],[\"pair<t>\",{\"1\":{\"289\":1,\"291\":1}}],[\"pair这样声明的话\",{\"1\":{\"289\":1}}],[\"pair\",{\"1\":{\"289\":1,\"291\":5,\"468\":1,\"850\":4}}],[\"pair的原始类型为\",{\"1\":{\"289\":1}}],[\"pause\",{\"1\":{\"600\":1,\"601\":4}}],[\"paul\",{\"1\":{\"440\":1}}],[\"patch\",{\"1\":{\"419\":1}}],[\"patterns\",{\"1\":{\"415\":1}}],[\"pattern\",{\"0\":{\"446\":1},\"1\":{\"414\":1,\"518\":1,\"531\":1,\"537\":1,\"549\":2,\"555\":1,\"560\":1,\"567\":1,\"579\":1,\"589\":4,\"590\":7,\"591\":12,\"593\":1,\"608\":2,\"629\":1,\"641\":1,\"648\":1,\"655\":1,\"663\":1,\"671\":1,\"682\":1,\"692\":1,\"707\":1,\"763\":1,\"775\":1,\"783\":1,\"788\":1,\"795\":1,\"796\":1,\"798\":23,\"800\":2,\"814\":4,\"837\":1,\"855\":3}}],[\"pathvariable\",{\"1\":{\"242\":1}}],[\"path\",{\"1\":{\"104\":1}}],[\"packr\",{\"1\":{\"401\":1}}],[\"packages\",{\"1\":{\"227\":1}}],[\"package\",{\"0\":{\"888\":1},\"1\":{\"150\":1,\"224\":1,\"227\":1,\"234\":2,\"305\":3,\"886\":1,\"888\":2,\"905\":2,\"975\":1,\"976\":1,\"977\":1,\"978\":2,\"979\":1,\"980\":2,\"981\":2,\"982\":3,\"983\":1}}],[\"passed\",{\"1\":{\"310\":2}}],[\"passes\",{\"1\":{\"294\":1}}],[\"passenger>\",{\"1\":{\"284\":1}}],[\"pass\",{\"1\":{\"127\":2}}],[\"passbyvalueexample\",{\"1\":{\"127\":2}}],[\"password\",{\"1\":{\"102\":1}}],[\"parimenumber\",{\"1\":{\"981\":3}}],[\"parleys\",{\"1\":{\"489\":1}}],[\"partial\",{\"1\":{\"930\":1}}],[\"particular\",{\"1\":{\"104\":1}}],[\"party<\",{\"1\":{\"458\":1}}],[\"parquet\",{\"1\":{\"395\":1}}],[\"parselong\",{\"1\":{\"160\":1,\"270\":1}}],[\"parseline\",{\"1\":{\"114\":2}}],[\"parsed\",{\"1\":{\"120\":1}}],[\"parseint\",{\"1\":{\"120\":1,\"950\":1}}],[\"parse\",{\"1\":{\"114\":2,\"625\":1,\"626\":5}}],[\"parsers\",{\"1\":{\"393\":1}}],[\"parser\",{\"1\":{\"78\":1}}],[\"parentrunner$2\",{\"1\":{\"979\":1}}],[\"parentrunner$1\",{\"1\":{\"979\":1}}],[\"parentrunner$3\",{\"1\":{\"979\":1}}],[\"parentrunner\",{\"1\":{\"979\":11}}],[\"parent\",{\"1\":{\"77\":1,\"104\":1,\"310\":4,\"312\":6}}],[\"paraschiv\",{\"1\":{\"440\":1}}],[\"parallellockmap\",{\"1\":{\"310\":2}}],[\"parallel\",{\"1\":{\"150\":1}}],[\"parallelogram\",{\"0\":{\"54\":1,\"55\":1}}],[\"param2\",{\"1\":{\"848\":1}}],[\"param1\",{\"1\":{\"848\":1}}],[\"paramb\",{\"1\":{\"768\":16}}],[\"parama\",{\"1\":{\"768\":16}}],[\"params\",{\"1\":{\"242\":2}}],[\"param==null\",{\"1\":{\"92\":1}}],[\"param\",{\"1\":{\"92\":2,\"242\":7,\"285\":2,\"306\":2,\"768\":4,\"848\":3,\"852\":2,\"866\":1,\"957\":1}}],[\"parameterized\",{\"1\":{\"972\":1,\"981\":9}}],[\"parameterizedtype\",{\"1\":{\"298\":4}}],[\"parameterannotations\",{\"1\":{\"310\":1}}],[\"parametertypes\",{\"1\":{\"306\":2,\"308\":2,\"310\":4,\"311\":5,\"312\":7}}],[\"parameter类型\",{\"1\":{\"236\":1}}],[\"parameter注解\",{\"1\":{\"236\":1}}],[\"parameters使用junit的参数化功能\",{\"1\":{\"972\":1,\"981\":1}}],[\"parameters\",{\"1\":{\"87\":1,\"972\":1,\"981\":3}}],[\"parameter\",{\"1\":{\"77\":1,\"224\":1,\"225\":1,\"227\":2,\"236\":3,\"242\":1,\"312\":6}}],[\"pageanalyzer\",{\"1\":{\"814\":4}}],[\"pages\",{\"1\":{\"384\":1}}],[\"page\",{\"1\":{\"77\":1,\"87\":1}}],[\"puresoyamilk\",{\"1\":{\"803\":4}}],[\"purchaserequest\",{\"1\":{\"710\":30}}],[\"push\",{\"1\":{\"644\":4}}],[\"pub\",{\"1\":{\"488\":1}}],[\"publishstate\",{\"1\":{\"779\":4}}],[\"published\",{\"1\":{\"474\":1,\"779\":3}}],[\"public也不要加\",{\"1\":{\"845\":1}}],[\"publicmethods\",{\"1\":{\"310\":1}}],[\"publicfields\",{\"1\":{\"310\":1}}],[\"publicconstructors\",{\"1\":{\"310\":3}}],[\"publiconly\",{\"1\":{\"310\":4,\"311\":4}}],[\"public\",{\"1\":{\"33\":1,\"89\":3,\"90\":2,\"91\":4,\"92\":4,\"96\":8,\"103\":2,\"104\":2,\"106\":2,\"114\":15,\"120\":1,\"122\":1,\"127\":4,\"132\":9,\"133\":13,\"134\":6,\"137\":9,\"138\":3,\"139\":1,\"140\":2,\"141\":17,\"144\":14,\"147\":3,\"183\":1,\"201\":5,\"209\":4,\"211\":8,\"222\":4,\"223\":1,\"224\":1,\"225\":1,\"227\":1,\"228\":16,\"229\":3,\"230\":3,\"234\":12,\"236\":5,\"241\":16,\"242\":14,\"252\":1,\"253\":1,\"254\":3,\"259\":3,\"264\":3,\"266\":1,\"267\":1,\"268\":1,\"269\":2,\"270\":1,\"271\":1,\"273\":1,\"275\":7,\"276\":6,\"281\":10,\"282\":6,\"284\":20,\"285\":5,\"288\":4,\"289\":9,\"290\":3,\"291\":19,\"295\":5,\"296\":5,\"297\":4,\"298\":5,\"302\":1,\"305\":17,\"306\":11,\"307\":11,\"308\":20,\"309\":3,\"310\":11,\"311\":2,\"312\":8,\"445\":7,\"446\":7,\"450\":4,\"452\":3,\"469\":2,\"471\":1,\"477\":2,\"524\":10,\"528\":11,\"532\":27,\"538\":6,\"542\":23,\"553\":11,\"555\":26,\"561\":8,\"562\":36,\"571\":27,\"574\":20,\"580\":10,\"584\":29,\"596\":6,\"601\":39,\"609\":6,\"610\":7,\"613\":10,\"617\":31,\"618\":4,\"622\":5,\"624\":2,\"625\":4,\"626\":8,\"627\":3,\"632\":7,\"636\":14,\"637\":2,\"642\":5,\"644\":21,\"649\":12,\"650\":36,\"656\":13,\"659\":34,\"664\":11,\"667\":19,\"672\":8,\"676\":12,\"678\":24,\"685\":11,\"687\":12,\"689\":9,\"695\":8,\"700\":11,\"703\":9,\"708\":7,\"710\":23,\"718\":13,\"723\":32,\"727\":10,\"728\":18,\"734\":11,\"738\":11,\"739\":8,\"741\":6,\"742\":8,\"743\":9,\"752\":3,\"753\":3,\"754\":3,\"755\":3,\"756\":3,\"757\":3,\"758\":3,\"759\":3,\"760\":2,\"764\":8,\"768\":10,\"769\":4,\"771\":3,\"772\":4,\"773\":6,\"776\":9,\"778\":31,\"779\":41,\"784\":8,\"787\":11,\"788\":5,\"789\":29,\"790\":5,\"801\":8,\"803\":6,\"809\":17,\"812\":4,\"813\":16,\"814\":10,\"826\":3,\"828\":4,\"830\":2,\"831\":3,\"832\":8,\"833\":2,\"834\":4,\"838\":13,\"839\":24,\"845\":5,\"846\":7,\"847\":1,\"848\":3,\"850\":1,\"851\":4,\"852\":6,\"855\":1,\"858\":2,\"901\":1,\"915\":1,\"927\":1,\"928\":1,\"929\":2,\"934\":1,\"944\":1,\"955\":1,\"959\":2,\"975\":2,\"976\":7,\"977\":2,\"978\":15,\"979\":3,\"980\":7,\"981\":7,\"982\":5,\"983\":4,\"998\":1}}],[\"puppet\",{\"1\":{\"462\":1}}],[\"puzzlers\",{\"1\":{\"438\":1}}],[\"putifabsent\",{\"1\":{\"310\":1,\"627\":2,\"771\":1,\"773\":1}}],[\"putint\",{\"1\":{\"93\":2}}],[\"putting\",{\"1\":{\"104\":1}}],[\"put\",{\"1\":{\"72\":1,\"114\":1,\"295\":1,\"419\":1,\"632\":1,\"636\":1,\"644\":1,\"659\":5,\"773\":3,\"846\":1,\"853\":2,\"854\":1,\"866\":2}}],[\"危险容器\",{\"1\":{\"14\":2}}],[\"提升协作效率\",{\"1\":{\"843\":1}}],[\"提升为\",{\"1\":{\"165\":1}}],[\"提倡什么样的编码和实现方式\",{\"1\":{\"843\":1}}],[\"提倡的方式\",{\"1\":{\"759\":1}}],[\"提取方法或者局部变量或许可以避免换行的问题\",{\"1\":{\"906\":1}}],[\"提取到不同的状态对象中\",{\"1\":{\"775\":1}}],[\"提取出来\",{\"1\":{\"775\":1}}],[\"提出增新功能\",{\"1\":{\"796\":1}}],[\"提出\",{\"1\":{\"736\":1}}],[\"提交请求\",{\"1\":{\"708\":1}}],[\"提交\",{\"1\":{\"703\":2}}],[\"提高阅读效率\",{\"1\":{\"853\":1}}],[\"提高代码的扩展性\",{\"1\":{\"810\":1}}],[\"提高代码的可读性\",{\"1\":{\"748\":1}}],[\"提高扩展性\",{\"1\":{\"808\":1}}],[\"提高了模块的相对独立性\",{\"1\":{\"741\":1}}],[\"提高了程序的可维护性\",{\"1\":{\"593\":1}}],[\"提高程序的维护性\",{\"1\":{\"733\":1}}],[\"提高耦合度\",{\"1\":{\"732\":1}}],[\"提高系统的可维护性\",{\"1\":{\"717\":1}}],[\"提高系统的灵活性和可维护性\",{\"1\":{\"722\":1}}],[\"提高系统的灵活性\",{\"1\":{\"655\":2,\"711\":1}}],[\"提高类的可读性\",{\"1\":{\"717\":1,\"719\":1}}],[\"提高其内聚性\",{\"1\":{\"717\":1}}],[\"提高效率\",{\"1\":{\"638\":1}}],[\"提高复用性\",{\"1\":{\"603\":1}}],[\"提高软件的可重用性\",{\"1\":{\"209\":1}}],[\"提到jvm处理异常的机制\",{\"1\":{\"275\":1}}],[\"提供数据的假对象就叫做\",{\"1\":{\"996\":1}}],[\"提供数据的假对象\",{\"1\":{\"996\":1}}],[\"提供准确的文档\",{\"1\":{\"990\":1}}],[\"提供断言来测试预期结果\",{\"1\":{\"970\":1}}],[\"提供注解来识别测试方法\",{\"1\":{\"970\":1}}],[\"提供让访问者对象遍历容器中的所有元素的方法\",{\"1\":{\"838\":1}}],[\"提供新的接口定义\",{\"1\":{\"818\":1}}],[\"提供如何定义语言的文法\",{\"1\":{\"798\":1}}],[\"提供具体的算法实现\",{\"1\":{\"784\":1}}],[\"提供具体统计算法的工具\",{\"1\":{\"413\":1}}],[\"提供一个用户批量查询的接口\",{\"1\":{\"852\":1}}],[\"提供一个方法\",{\"1\":{\"839\":1}}],[\"提供一个创建产品族的接口\",{\"1\":{\"798\":1}}],[\"提供一个静态的公有方法\",{\"1\":{\"754\":1,\"755\":1,\"756\":1,\"757\":1,\"758\":1}}],[\"提供一个公有的静态方法\",{\"1\":{\"752\":1,\"753\":1}}],[\"提供一种方法来顺序访问聚合对象中的一系列数据\",{\"1\":{\"798\":1}}],[\"提供一种方法顺序访问一个聚合对象中的各个元素\",{\"1\":{\"591\":1}}],[\"提供一种遍历集合元素的统一接口\",{\"1\":{\"648\":1}}],[\"提供方\",{\"1\":{\"738\":1}}],[\"提供温度\",{\"1\":{\"673\":1}}],[\"提供保存与获取备忘录的功能\",{\"1\":{\"664\":1}}],[\"提供创建备忘录和恢复备忘录数据的功能\",{\"1\":{\"664\":1}}],[\"提供同事对象交互的抽象方法\",{\"1\":{\"656\":1}}],[\"提供的反射语法自己去编写代码\",{\"1\":{\"627\":1}}],[\"提供执行入口\",{\"0\":{\"625\":1}}],[\"提供精简的接口\",{\"1\":{\"593\":1}}],[\"提供依赖注入相关组件并支持面向切面编程\",{\"1\":{\"434\":1}}],[\"提供免费和带支持的商业版本\",{\"1\":{\"434\":1}}],[\"提供存在论\",{\"1\":{\"432\":1}}],[\"提供tuple支持\",{\"1\":{\"432\":1}}],[\"提供各种用途的函数\",{\"1\":{\"432\":1}}],[\"提供html页面模板\",{\"1\":{\"430\":1}}],[\"提供兼容jdk的高性能对象图形序列化\",{\"1\":{\"428\":1}}],[\"提供描述\",{\"1\":{\"424\":1}}],[\"提供平台中jvm暂停的日志和记录\",{\"1\":{\"422\":1}}],[\"提供对json解析和序列化\",{\"1\":{\"409\":1}}],[\"提供持久化数据类型和函数式控制结构\",{\"1\":{\"403\":1}}],[\"提供开源免费版本和几种商业收费版本\",{\"1\":{\"401\":1}}],[\"提供可靠的消息传递和集群创建的工具\",{\"1\":{\"399\":1}}],[\"提供延迟和容错\",{\"1\":{\"399\":1}}],[\"提供有限的免费模式\",{\"1\":{\"392\":1}}],[\"提供有关类或接口的单个字段的信息\",{\"1\":{\"307\":1}}],[\"提供托管服务\",{\"1\":{\"392\":2}}],[\"提供关于类或接口上单独某个方法\",{\"1\":{\"308\":1}}],[\"提供编译前的检查\",{\"1\":{\"279\":1}}],[\"提供了系统的设计蓝图\",{\"1\":{\"824\":1}}],[\"提供了一个统一的\",{\"1\":{\"809\":1}}],[\"提供了一种可以恢复状态的机制\",{\"1\":{\"663\":1}}],[\"提供了与真实主题相同的接口\",{\"1\":{\"694\":1}}],[\"提供了同事对象注册与转发同事对象信息的抽象方法\",{\"1\":{\"656\":1}}],[\"提供了创建产品的接口\",{\"1\":{\"612\":1,\"616\":1}}],[\"提供了完整的查询引擎和索引引擎\",{\"1\":{\"426\":1}}],[\"提供了restful\",{\"1\":{\"426\":1}}],[\"提供了众多缺失的类型和一组丰富的顺序流api\",{\"1\":{\"403\":1}}],[\"提供了更优雅的方式来实现资源的自动释放\",{\"1\":{\"259\":1}}],[\"提供了从trace到fatal方法\",{\"1\":{\"104\":1}}],[\"提供更加丰富的写作功能\",{\"1\":{\"13\":1}}],[\"提示信息\",{\"1\":{\"857\":1}}],[\"提示信息可以包括错误原因\",{\"1\":{\"854\":1}}],[\"提示友好\",{\"1\":{\"854\":1}}],[\"提示\",{\"1\":{\"33\":1,\"107\":1,\"235\":1,\"239\":1,\"250\":1,\"262\":1,\"274\":1,\"280\":1,\"286\":1,\"304\":1,\"885\":2,\"906\":1,\"912\":1,\"933\":1,\"952\":1,\"958\":1}}],[\"提示容器\",{\"1\":{\"14\":2}}],[\"=l3\",{\"1\":{\"773\":1}}],[\"=>\",{\"1\":{\"644\":1,\"650\":1,\"796\":3}}],[\"=clazz\",{\"1\":{\"306\":1,\"308\":2}}],[\"=null\",{\"1\":{\"252\":1,\"257\":1}}],[\"==前置通知异常==\",{\"1\":{\"242\":1}}],[\"==和equals都是比较栈内存中的地址是否相等\",{\"1\":{\"191\":1}}],[\"==用于比较值是否相等\",{\"1\":{\"191\":1}}],[\"==是一个运算符\",{\"1\":{\"191\":1}}],[\"===百度网站====\",{\"1\":{\"678\":1}}],[\"===>\",{\"1\":{\"71\":1}}],[\"====>\",{\"1\":{\"71\":1}}],[\"=======给的是待定的测评========\",{\"1\":{\"839\":1}}],[\"============天气情况变化=============\",{\"1\":{\"676\":1}}],[\"===============\",{\"1\":{\"839\":1}}],[\"===========================\",{\"1\":{\"584\":1}}],[\"=========================================\",{\"1\":{\"308\":2}}],[\"=======================\",{\"1\":{\"542\":1}}],[\"================getdeclaredfields====================\",{\"1\":{\"307\":2}}],[\"==============\",{\"1\":{\"542\":2}}],[\"=========使用遥控器操作电视机==========\",{\"1\":{\"562\":1}}],[\"========数据库日志=========\",{\"1\":{\"242\":1}}],[\"=====\",{\"1\":{\"71\":1,\"650\":1}}],[\"====\",{\"1\":{\"71\":1,\"524\":1,\"528\":1}}],[\"===\",{\"1\":{\"71\":1,\"524\":1,\"528\":1,\"650\":1}}],[\"==\",{\"0\":{\"167\":1},\"1\":{\"67\":1,\"103\":1,\"104\":6,\"114\":7,\"120\":4,\"125\":3,\"138\":9,\"139\":1,\"209\":1,\"242\":1,\"253\":1,\"284\":1,\"288\":1,\"306\":1,\"310\":14,\"311\":9,\"312\":1,\"524\":1,\"528\":1,\"618\":6,\"625\":1,\"627\":3,\"637\":5,\"650\":1,\"659\":2,\"738\":4,\"752\":1,\"753\":1,\"754\":3,\"755\":2,\"756\":2,\"757\":5,\"758\":1,\"759\":1,\"768\":3,\"772\":1,\"778\":1,\"790\":1,\"847\":3,\"848\":5,\"850\":3,\"851\":2,\"852\":1,\"981\":1}}],[\"==>\",{\"1\":{\"66\":1,\"67\":1,\"71\":1}}],[\"=\",{\"0\":{\"162\":1,\"165\":1},\"1\":{\"14\":1,\"77\":3,\"91\":4,\"93\":7,\"96\":3,\"102\":2,\"103\":8,\"104\":29,\"106\":8,\"111\":2,\"114\":49,\"119\":2,\"120\":20,\"125\":5,\"127\":5,\"128\":2,\"129\":6,\"130\":2,\"132\":2,\"133\":8,\"134\":4,\"138\":9,\"139\":7,\"140\":2,\"141\":31,\"143\":4,\"144\":15,\"147\":1,\"165\":3,\"201\":2,\"210\":1,\"211\":1,\"222\":1,\"230\":4,\"234\":9,\"241\":2,\"242\":26,\"252\":3,\"253\":1,\"257\":6,\"258\":1,\"259\":1,\"263\":1,\"264\":9,\"273\":1,\"276\":8,\"279\":6,\"281\":6,\"282\":3,\"284\":9,\"285\":8,\"288\":4,\"289\":9,\"290\":16,\"291\":5,\"293\":2,\"294\":18,\"295\":4,\"298\":4,\"302\":3,\"305\":7,\"306\":14,\"307\":10,\"308\":8,\"309\":3,\"310\":64,\"311\":22,\"312\":45,\"445\":2,\"446\":3,\"450\":4,\"451\":2,\"455\":2,\"466\":2,\"467\":3,\"471\":1,\"474\":1,\"477\":3,\"478\":1,\"524\":4,\"528\":7,\"532\":3,\"538\":3,\"542\":5,\"553\":1,\"555\":11,\"561\":5,\"562\":20,\"571\":14,\"574\":9,\"580\":3,\"584\":20,\"596\":4,\"601\":13,\"609\":2,\"610\":11,\"613\":13,\"617\":6,\"618\":12,\"622\":3,\"624\":2,\"625\":6,\"626\":5,\"627\":18,\"632\":13,\"636\":10,\"637\":6,\"644\":23,\"649\":12,\"650\":23,\"656\":5,\"659\":9,\"664\":6,\"667\":11,\"672\":4,\"676\":9,\"678\":14,\"685\":11,\"687\":19,\"689\":22,\"695\":3,\"700\":4,\"703\":7,\"708\":5,\"710\":13,\"718\":4,\"723\":2,\"727\":2,\"728\":8,\"734\":5,\"738\":7,\"739\":5,\"741\":1,\"742\":11,\"743\":11,\"752\":3,\"753\":3,\"754\":3,\"755\":3,\"756\":3,\"757\":3,\"758\":3,\"759\":2,\"760\":1,\"764\":6,\"768\":19,\"769\":5,\"770\":1,\"771\":3,\"772\":7,\"773\":10,\"776\":3,\"778\":17,\"779\":5,\"784\":4,\"789\":12,\"790\":3,\"801\":1,\"803\":3,\"809\":9,\"813\":2,\"814\":3,\"828\":1,\"831\":1,\"832\":5,\"838\":5,\"839\":5,\"845\":5,\"846\":8,\"847\":11,\"848\":21,\"849\":3,\"850\":24,\"851\":13,\"852\":10,\"855\":2,\"858\":2,\"859\":2,\"864\":7,\"865\":2,\"866\":4,\"885\":4,\"901\":1,\"907\":2,\"911\":1,\"942\":12,\"950\":1,\"951\":1,\"978\":12,\"979\":6,\"980\":3,\"981\":4}}],[\"ctest\",{\"1\":{\"972\":1,\"981\":1}}],[\"ctrl+z\",{\"1\":{\"663\":1,\"669\":1}}],[\"c3\",{\"1\":{\"866\":1}}],[\"c反例\",{\"1\":{\"864\":1}}],[\"c表示错误来源于第三方服务\",{\"1\":{\"857\":1}}],[\"c依次全部加锁后才可以进行更新操作\",{\"1\":{\"851\":1}}],[\"cxmtains\",{\"1\":{\"832\":1}}],[\"cxis\",{\"1\":{\"110\":2,\"116\":1}}],[\"c0503\",{\"1\":{\"874\":1}}],[\"c0502\",{\"1\":{\"874\":1}}],[\"c0501\",{\"1\":{\"874\":1}}],[\"c0500\",{\"1\":{\"874\":1}}],[\"c0402\",{\"1\":{\"874\":1}}],[\"c0401\",{\"1\":{\"874\":1}}],[\"c0400\",{\"1\":{\"874\":1}}],[\"c0341\",{\"1\":{\"874\":1}}],[\"c0331\",{\"1\":{\"874\":1}}],[\"c0321\",{\"1\":{\"874\":1}}],[\"c0312\",{\"1\":{\"874\":1}}],[\"c0311\",{\"1\":{\"874\":1}}],[\"c0300\",{\"1\":{\"874\":1}}],[\"c0250\",{\"1\":{\"874\":1}}],[\"c0240\",{\"1\":{\"874\":1}}],[\"c0230\",{\"1\":{\"874\":1}}],[\"c0220\",{\"1\":{\"874\":1}}],[\"c0210\",{\"1\":{\"874\":1}}],[\"c0200\",{\"1\":{\"874\":1}}],[\"c0154\",{\"1\":{\"874\":1}}],[\"c0153\",{\"1\":{\"874\":1}}],[\"c0152\",{\"1\":{\"874\":1}}],[\"c0151\",{\"1\":{\"874\":1}}],[\"c0150\",{\"1\":{\"874\":1}}],[\"c0140\",{\"1\":{\"874\":1}}],[\"c0134\",{\"1\":{\"874\":1}}],[\"c0133\",{\"1\":{\"874\":1}}],[\"c0132\",{\"1\":{\"874\":1}}],[\"c0131\",{\"1\":{\"874\":1}}],[\"c0130\",{\"1\":{\"874\":1}}],[\"c0124\",{\"1\":{\"874\":1}}],[\"c0123\",{\"1\":{\"874\":1}}],[\"c0122\",{\"1\":{\"874\":1}}],[\"c0121\",{\"1\":{\"874\":1}}],[\"c0120\",{\"1\":{\"874\":1}}],[\"c0113\",{\"1\":{\"874\":1}}],[\"c0112\",{\"1\":{\"874\":1}}],[\"c0111\",{\"1\":{\"874\":1}}],[\"c0110\",{\"1\":{\"874\":1}}],[\"c0100\",{\"1\":{\"874\":1}}],[\"c0001\",{\"1\":{\"857\":1,\"874\":1}}],[\"c0\",{\"1\":{\"571\":8}}],[\"c0=\",{\"1\":{\"571\":1}}],[\"cmd\",{\"1\":{\"561\":2}}],[\"cdn服务出错\",{\"1\":{\"874\":1}}],[\"cdh\",{\"1\":{\"446\":1}}],[\"cdi扩展框架\",{\"1\":{\"397\":1}}],[\"cyclicbarrier详解\",{\"0\":{\"501\":1}}],[\"cyclops\",{\"1\":{\"403\":1}}],[\"cylindrical\",{\"0\":{\"49\":1}}],[\"cglibbeancopier\",{\"1\":{\"855\":1}}],[\"cglib\",{\"0\":{\"701\":1,\"702\":1,\"703\":1},\"1\":{\"384\":1,\"692\":1,\"702\":6,\"703\":7}}],[\"ceo\",{\"1\":{\"589\":1,\"750\":1}}],[\"ceylon\",{\"1\":{\"411\":1}}],[\"central\",{\"1\":{\"401\":1}}],[\"cell\",{\"1\":{\"305\":2}}],[\"certain\",{\"1\":{\"145\":1}}],[\"cross\",{\"1\":{\"861\":1}}],[\"cron\",{\"1\":{\"387\":1}}],[\"crp\",{\"0\":{\"745\":1},\"1\":{\"745\":1}}],[\"cr\",{\"1\":{\"664\":3}}],[\"crawler\",{\"1\":{\"814\":4}}],[\"crawler4j\",{\"1\":{\"433\":1}}],[\"crash\",{\"1\":{\"432\":1}}],[\"crate\",{\"1\":{\"394\":1}}],[\"cryptomator\",{\"1\":{\"427\":1}}],[\"cry\",{\"1\":{\"305\":11}}],[\"creek\",{\"1\":{\"123\":1}}],[\"creation\",{\"1\":{\"150\":1}}],[\"creating\",{\"1\":{\"104\":2,\"145\":1}}],[\"createbucketifnotexisting\",{\"1\":{\"809\":6}}],[\"createbean\",{\"1\":{\"627\":5}}],[\"creatememento\",{\"1\":{\"664\":2,\"667\":2}}],[\"createiterator\",{\"1\":{\"650\":4}}],[\"createcalendar\",{\"1\":{\"618\":2}}],[\"createpizza2\",{\"1\":{\"610\":1}}],[\"createpizza\",{\"1\":{\"610\":3,\"613\":9}}],[\"created\",{\"1\":{\"310\":1,\"312\":1,\"485\":1,\"768\":1}}],[\"creates\",{\"1\":{\"302\":1}}],[\"create\",{\"1\":{\"104\":3,\"295\":2,\"310\":3,\"312\":1,\"474\":1,\"618\":2,\"703\":1,\"764\":4,\"863\":2}}],[\"c++\",{\"0\":{\"151\":1},\"1\":{\"151\":9,\"163\":1,\"769\":1,\"795\":1,\"797\":3,\"907\":1}}],[\"csrf\",{\"1\":{\"861\":1}}],[\"csv\",{\"1\":{\"854\":1}}],[\"csv解析\",{\"0\":{\"393\":1}}],[\"cs3\",{\"1\":{\"306\":2}}],[\"cs2\",{\"1\":{\"306\":2}}],[\"cs2=clazz\",{\"1\":{\"306\":1}}],[\"cs1\",{\"1\":{\"306\":2}}],[\"csdn\",{\"1\":{\"116\":1,\"219\":1,\"238\":1,\"243\":2,\"277\":3,\"299\":4,\"305\":1,\"314\":3,\"984\":2,\"1000\":1}}],[\"cssclass\",{\"1\":{\"83\":2}}],[\"css\",{\"0\":{\"83\":1},\"1\":{\"83\":1}}],[\"cnblogs\",{\"1\":{\"116\":1,\"219\":2,\"277\":1,\"283\":1,\"299\":2,\"309\":1,\"314\":1,\"984\":1}}],[\"cn\",{\"1\":{\"114\":4,\"287\":1,\"622\":2,\"624\":2,\"1000\":1}}],[\"cpi\",{\"1\":{\"312\":21}}],[\"cpool\",{\"1\":{\"312\":4}}],[\"cpu\",{\"1\":{\"187\":1,\"549\":1,\"635\":1}}],[\"cp\",{\"1\":{\"114\":7}}],[\"ci\",{\"1\":{\"114\":3,\"460\":2}}],[\"circleci\",{\"1\":{\"392\":1}}],[\"circle\",{\"0\":{\"50\":1,\"58\":1},\"1\":{\"50\":2,\"58\":2,\"308\":13,\"738\":6,\"739\":3}}],[\"cut\",{\"1\":{\"609\":1}}],[\"cucumber\",{\"1\":{\"431\":1}}],[\"customer\",{\"1\":{\"947\":1,\"958\":2}}],[\"customerwantcondiments\",{\"1\":{\"803\":3}}],[\"customizedfeignclient\",{\"1\":{\"814\":2}}],[\"customising\",{\"1\":{\"104\":1}}],[\"custom\",{\"1\":{\"104\":4}}],[\"curcount\",{\"1\":{\"778\":2}}],[\"curtains\",{\"1\":{\"659\":13}}],[\"currenttimemillis\",{\"1\":{\"849\":1}}],[\"currentthreadid\",{\"1\":{\"771\":3}}],[\"currentthread\",{\"1\":{\"114\":1,\"771\":1}}],[\"currentruntime\",{\"1\":{\"760\":2}}],[\"currentconditions\",{\"1\":{\"675\":1,\"676\":15,\"678\":7}}],[\"currentuser\",{\"1\":{\"242\":6}}],[\"current\",{\"1\":{\"104\":1,\"310\":1,\"859\":1}}],[\"currently\",{\"1\":{\"51\":1}}],[\"curve\",{\"1\":{\"77\":1}}],[\"cursor\",{\"1\":{\"0\":1}}],[\"cj\",{\"1\":{\"100\":1}}],[\"clubs\",{\"1\":{\"915\":1}}],[\"cleaner\",{\"1\":{\"952\":1}}],[\"clean\",{\"1\":{\"487\":1}}],[\"clear方法会抛出unsupportedoperationexception异常\",{\"1\":{\"850\":1}}],[\"cleared\",{\"1\":{\"310\":1}}],[\"clear\",{\"1\":{\"114\":1}}],[\"clojure\",{\"1\":{\"411\":1,\"469\":1}}],[\"cloneclass\",{\"1\":{\"689\":4}}],[\"cloneconstructorexample\",{\"1\":{\"141\":8}}],[\"clonename\",{\"1\":{\"689\":4}}],[\"clonenotsupportedexception\",{\"1\":{\"137\":1,\"141\":10,\"689\":2}}],[\"cloneexample\",{\"1\":{\"141\":13}}],[\"cloneable\",{\"0\":{\"163\":1},\"1\":{\"141\":8,\"163\":1,\"686\":1,\"687\":1,\"689\":2}}],[\"clone\",{\"0\":{\"141\":1,\"163\":1},\"1\":{\"137\":1,\"141\":22,\"163\":2,\"190\":1,\"682\":3,\"686\":2,\"687\":7,\"689\":15}}],[\"closed\",{\"1\":{\"736\":3}}],[\"closeresourceinfinally\",{\"1\":{\"264\":1}}],[\"closeable\",{\"1\":{\"259\":2}}],[\"close\",{\"1\":{\"104\":1,\"252\":1,\"257\":1,\"259\":5,\"264\":2,\"542\":13,\"625\":1,\"689\":4}}],[\"cl\",{\"1\":{\"114\":10,\"404\":1,\"656\":3}}],[\"claz\",{\"1\":{\"306\":1}}],[\"clazzs\",{\"1\":{\"306\":7}}],[\"clazz\",{\"1\":{\"104\":2,\"230\":2,\"293\":2,\"306\":5,\"307\":11,\"308\":7,\"310\":4,\"312\":2}}],[\"classdiagram\",{\"1\":{\"826\":1}}],[\"classdefiner\",{\"1\":{\"312\":2}}],[\"classdef\",{\"1\":{\"82\":2,\"84\":1}}],[\"classloder\",{\"1\":{\"752\":1}}],[\"classloader\",{\"1\":{\"103\":1,\"104\":10,\"106\":5,\"114\":11,\"302\":3,\"310\":6,\"699\":1,\"700\":2}}],[\"classfileassembler\",{\"1\":{\"312\":1}}],[\"classredefinedcount\",{\"1\":{\"310\":10}}],[\"classtest\",{\"1\":{\"305\":1}}],[\"class对象是可以说是反射中最常用的\",{\"1\":{\"305\":1}}],[\"class的文件中\",{\"1\":{\"302\":1}}],[\"class类与field对象相关方法如下\",{\"1\":{\"307\":1}}],[\"class类与constructor相关的主要方法如下\",{\"1\":{\"306\":1}}],[\"class类与java\",{\"1\":{\"304\":1}}],[\"class类对象的获取\",{\"0\":{\"305\":1}}],[\"class类的方法\",{\"1\":{\"305\":1}}],[\"class类的对象作用是运行时提供或获得某个对象的类型信息\",{\"1\":{\"302\":1}}],[\"class类的实例表示java应用运行时的类\",{\"1\":{\"302\":1}}],[\"class类只存私有构造函数\",{\"1\":{\"302\":1}}],[\"class类也是类的一种\",{\"1\":{\"302\":1}}],[\"class类也是一个实实在在的类\",{\"1\":{\"302\":1}}],[\"class类\",{\"0\":{\"302\":1},\"1\":{\"301\":1,\"302\":1}}],[\"classpolicy\",{\"1\":{\"228\":4}}],[\"classpathxmlapplicationcontext\",{\"1\":{\"624\":1,\"625\":5}}],[\"classpath\",{\"1\":{\"104\":1,\"625\":1}}],[\"classpath根目录下commons\",{\"1\":{\"104\":1}}],[\"classpath根目录下寻找commons\",{\"1\":{\"104\":1}}],[\"classnotfoundexception\",{\"1\":{\"198\":1,\"234\":1,\"261\":1,\"291\":1,\"305\":1,\"307\":1,\"308\":1,\"309\":1,\"310\":7,\"627\":1}}],[\"classname的方式反编译下dateinter子类的字节码\",{\"1\":{\"291\":1}}],[\"classname\",{\"1\":{\"82\":4,\"144\":2,\"242\":2,\"306\":1,\"310\":4,\"626\":1}}],[\"class<dog>\",{\"1\":{\"305\":1}}],[\"class<t>的作用就是指明泛型的具体类型\",{\"1\":{\"283\":1}}],[\"class<t>\",{\"1\":{\"233\":4,\"285\":1,\"295\":2,\"297\":2,\"302\":1}}],[\"class<s>\",{\"1\":{\"114\":7}}],[\"class<\",{\"1\":{\"106\":1,\"114\":6,\"137\":1,\"233\":1,\"306\":7,\"307\":4,\"308\":4,\"310\":12,\"311\":3,\"312\":11,\"700\":2}}],[\"classcastexception异常\",{\"1\":{\"279\":1}}],[\"classcastexception\",{\"1\":{\"104\":2,\"198\":1,\"261\":1,\"294\":3,\"312\":1}}],[\"classes\",{\"0\":{\"79\":1,\"82\":1,\"83\":1,\"452\":1},\"1\":{\"83\":1,\"84\":1,\"104\":2,\"145\":3,\"225\":1,\"312\":2}}],[\"class=\",{\"1\":{\"77\":1,\"622\":2,\"624\":2}}],[\"class\",{\"0\":{\"84\":1,\"894\":1},\"1\":{\"77\":1,\"82\":8,\"83\":1,\"84\":2,\"85\":1,\"91\":3,\"92\":1,\"93\":1,\"96\":5,\"103\":3,\"104\":26,\"111\":1,\"114\":5,\"122\":1,\"127\":3,\"132\":4,\"133\":5,\"134\":2,\"138\":1,\"140\":1,\"141\":6,\"144\":7,\"145\":11,\"147\":1,\"201\":4,\"209\":1,\"211\":4,\"213\":3,\"214\":2,\"215\":4,\"216\":3,\"217\":2,\"218\":1,\"222\":2,\"225\":1,\"228\":4,\"230\":4,\"233\":1,\"234\":4,\"236\":1,\"241\":4,\"242\":4,\"254\":1,\"259\":1,\"275\":2,\"276\":1,\"281\":4,\"282\":2,\"284\":7,\"285\":1,\"288\":3,\"289\":4,\"290\":1,\"291\":7,\"293\":1,\"295\":2,\"296\":2,\"297\":1,\"298\":4,\"302\":8,\"305\":27,\"306\":16,\"307\":7,\"308\":18,\"309\":3,\"310\":17,\"311\":1,\"312\":32,\"445\":2,\"446\":2,\"450\":1,\"452\":1,\"467\":1,\"469\":2,\"471\":1,\"477\":3,\"524\":4,\"528\":4,\"532\":3,\"538\":4,\"542\":6,\"553\":3,\"555\":6,\"561\":4,\"562\":9,\"563\":1,\"571\":6,\"574\":5,\"580\":4,\"584\":11,\"596\":5,\"601\":8,\"609\":4,\"610\":2,\"613\":9,\"617\":7,\"618\":3,\"622\":2,\"624\":1,\"625\":1,\"626\":4,\"627\":6,\"632\":4,\"636\":5,\"637\":1,\"642\":3,\"644\":7,\"649\":3,\"650\":7,\"656\":6,\"659\":8,\"664\":4,\"667\":4,\"672\":5,\"676\":3,\"678\":4,\"685\":2,\"687\":2,\"689\":3,\"695\":3,\"699\":1,\"700\":3,\"703\":3,\"708\":4,\"710\":7,\"716\":1,\"718\":8,\"723\":10,\"727\":7,\"728\":7,\"734\":7,\"738\":11,\"739\":7,\"741\":2,\"742\":5,\"743\":5,\"752\":2,\"753\":2,\"754\":2,\"755\":2,\"756\":3,\"757\":3,\"758\":3,\"759\":1,\"760\":1,\"764\":4,\"768\":4,\"769\":1,\"771\":1,\"772\":3,\"773\":5,\"776\":5,\"778\":7,\"779\":9,\"784\":4,\"787\":3,\"788\":1,\"789\":8,\"790\":1,\"801\":5,\"803\":5,\"809\":5,\"812\":2,\"813\":4,\"814\":5,\"826\":2,\"828\":5,\"830\":2,\"831\":2,\"832\":6,\"833\":2,\"834\":1,\"838\":6,\"839\":9,\"845\":5,\"851\":2,\"852\":1,\"859\":2,\"877\":4,\"886\":1,\"972\":8,\"975\":1,\"976\":3,\"977\":1,\"978\":2,\"979\":3,\"980\":2,\"981\":11,\"982\":6,\"983\":1,\"999\":1}}],[\"cliff\",{\"1\":{\"406\":1}}],[\"clienttest\",{\"1\":{\"600\":2,\"644\":1,\"659\":1,\"778\":1,\"779\":1}}],[\"client\",{\"1\":{\"284\":1,\"419\":1,\"524\":1,\"528\":1,\"532\":1,\"542\":1,\"553\":2,\"555\":2,\"562\":1,\"574\":1,\"595\":1,\"601\":1,\"617\":1,\"636\":1,\"642\":1,\"650\":1,\"667\":1,\"676\":1,\"678\":1,\"683\":1,\"685\":2,\"687\":2,\"689\":2,\"695\":1,\"700\":1,\"703\":1,\"708\":1,\"710\":1,\"789\":1,\"803\":1,\"814\":3,\"839\":1,\"869\":1}}],[\"cli\",{\"1\":{\"87\":2}}],[\"click\",{\"1\":{\"77\":17,\"406\":1}}],[\"calculator\",{\"1\":{\"644\":6}}],[\"caltype\",{\"1\":{\"618\":3}}],[\"cal\",{\"1\":{\"618\":16}}],[\"calendar等日期相关类的月份month取值范围从\",{\"1\":{\"849\":1}}],[\"calendarprovider\",{\"1\":{\"618\":2}}],[\"calendar\",{\"0\":{\"618\":1},\"1\":{\"618\":17,\"849\":9}}],[\"caller\",{\"1\":{\"310\":9,\"312\":2}}],[\"callersensitive\",{\"1\":{\"310\":3,\"311\":1,\"312\":1}}],[\"called\",{\"1\":{\"77\":1,\"145\":1,\"310\":1}}],[\"call\",{\"1\":{\"77\":3,\"145\":1,\"309\":1,\"310\":2,\"477\":2,\"542\":13,\"561\":2,\"617\":5,\"980\":2}}],[\"callback\",{\"1\":{\"77\":15}}],[\"cachingexception\",{\"1\":{\"451\":1}}],[\"cacheseconds\",{\"1\":{\"854\":1}}],[\"cacheserviceimpl实现cacheservice接口\",{\"1\":{\"845\":1}}],[\"cache产生\",{\"1\":{\"848\":1}}],[\"cachebuilder\",{\"1\":{\"466\":1}}],[\"cachedthreadpool\",{\"1\":{\"851\":1}}],[\"cachedfoowidget\",{\"1\":{\"451\":1}}],[\"cached\",{\"1\":{\"310\":1,\"311\":1,\"451\":1}}],[\"cachedconstructor\",{\"1\":{\"310\":3}}],[\"cachefactory\",{\"1\":{\"104\":1}}],[\"cache\",{\"1\":{\"104\":1,\"120\":5,\"310\":1,\"466\":1,\"845\":1,\"846\":2,\"854\":1}}],[\"camel\",{\"1\":{\"414\":1}}],[\"camera\",{\"1\":{\"85\":1}}],[\"ca\",{\"1\":{\"310\":4,\"618\":1}}],[\"card\",{\"1\":{\"832\":1}}],[\"cardinal\",{\"1\":{\"77\":1}}],[\"carp\",{\"1\":{\"745\":1}}],[\"caretaker\",{\"1\":{\"664\":4,\"667\":7}}],[\"car\",{\"1\":{\"213\":2}}],[\"category\",{\"1\":{\"618\":1}}],[\"cat\",{\"1\":{\"210\":5}}],[\"catch用的类却是exception\",{\"1\":{\"858\":1}}],[\"catch用来捕获try语句块中发生的异常\",{\"1\":{\"251\":1}}],[\"catch时请分清稳定代码和非稳定代码\",{\"1\":{\"858\":1}}],[\"catch是否可以移至循环体外\",{\"1\":{\"852\":1}}],[\"catch操作\",{\"1\":{\"852\":1}}],[\"catch到\",{\"1\":{\"851\":1}}],[\"catchexception\",{\"1\":{\"276\":2}}],[\"catch先后顺序的问题\",{\"1\":{\"275\":1}}],[\"catch部分提取finally代码\",{\"1\":{\"275\":1}}],[\"catch外\",{\"1\":{\"275\":1}}],[\"catchmostspecificexceptionfirst\",{\"1\":{\"267\":1}}],[\"catch中返回阻止了jvm实现本来可能要执行的某些特定的优化\",{\"1\":{\"263\":1}}],[\"catch和finally都不能单独使用\",{\"1\":{\"260\":1}}],[\"catch语句块执行完后\",{\"1\":{\"257\":1}}],[\"catch语句块里有处理此异常的情况\",{\"1\":{\"257\":1}}],[\"catch语句块里没有处理此异常的情况\",{\"1\":{\"257\":1}}],[\"catch语句块所捕获\",{\"1\":{\"198\":1}}],[\"catch语句捕获\",{\"1\":{\"252\":1}}],[\"catch语句捕获它\",{\"1\":{\"248\":1,\"249\":1}}],[\"catch参数\",{\"1\":{\"227\":1}}],[\"catch子句捕获并执行catch块\",{\"1\":{\"196\":1}}],[\"catch\",{\"0\":{\"256\":1,\"257\":1},\"1\":{\"91\":1,\"103\":3,\"104\":4,\"120\":1,\"141\":3,\"146\":1,\"182\":1,\"186\":1,\"196\":1,\"234\":2,\"241\":1,\"242\":1,\"251\":1,\"253\":2,\"255\":2,\"256\":6,\"257\":4,\"259\":1,\"260\":2,\"263\":1,\"264\":7,\"267\":7,\"268\":3,\"269\":2,\"270\":2,\"271\":1,\"275\":6,\"276\":1,\"297\":8,\"309\":5,\"310\":3,\"312\":1,\"448\":1,\"451\":2,\"469\":1,\"618\":1,\"625\":1,\"627\":1,\"687\":1,\"689\":2,\"779\":1,\"858\":3,\"901\":1,\"902\":2,\"907\":1,\"911\":3,\"950\":3}}],[\"caused\",{\"1\":{\"979\":1}}],[\"cause\",{\"1\":{\"104\":1,\"114\":2}}],[\"caught\",{\"1\":{\"104\":1,\"275\":1}}],[\"cas操作包含三个操作数\",{\"1\":{\"873\":1}}],[\"cas操作等实用的功能\",{\"1\":{\"93\":1}}],[\"cassandra\",{\"1\":{\"400\":1}}],[\"casreflectiondata\",{\"1\":{\"310\":1}}],[\"cas\",{\"0\":{\"490\":1},\"1\":{\"310\":1,\"850\":1,\"873\":1}}],[\"case\",{\"0\":{\"998\":1},\"1\":{\"130\":4,\"170\":1,\"225\":1,\"618\":3,\"644\":2,\"775\":2,\"783\":1,\"822\":1,\"852\":2,\"922\":1,\"924\":4,\"942\":1,\"976\":2}}],[\"castle\",{\"1\":{\"427\":1}}],[\"casting\",{\"1\":{\"129\":1}}],[\"cast\",{\"1\":{\"114\":1,\"225\":2,\"488\":1,\"850\":1}}],[\"castable\",{\"1\":{\"104\":1}}],[\"cainiao\",{\"1\":{\"96\":3}}],[\"canonical\",{\"1\":{\"960\":2}}],[\"canrafflestate\",{\"1\":{\"778\":4}}],[\"cannot\",{\"1\":{\"104\":1,\"114\":1,\"120\":1,\"133\":2,\"143\":1,\"144\":4,\"165\":1,\"310\":1,\"850\":1}}],[\"can\",{\"1\":{\"59\":1,\"68\":1,\"71\":2,\"73\":1,\"74\":1,\"76\":1,\"77\":2,\"78\":1,\"83\":1,\"86\":1,\"87\":1,\"104\":3,\"130\":1,\"145\":4,\"209\":1,\"310\":5,\"312\":6,\"466\":1,\"625\":1,\"812\":1,\"933\":1,\"942\":1}}],[\"c2\",{\"1\":{\"75\":1,\"656\":4,\"866\":1}}],[\"c1\",{\"1\":{\"74\":3,\"75\":2,\"571\":8,\"656\":4,\"866\":1}}],[\"coolshell\",{\"1\":{\"1000\":1}}],[\"coffeemachine\",{\"1\":{\"659\":13}}],[\"coffeebar\",{\"1\":{\"584\":1}}],[\"coffee\",{\"1\":{\"584\":5,\"659\":1}}],[\"cost\",{\"1\":{\"582\":2,\"584\":10}}],[\"cobertura\",{\"1\":{\"460\":2}}],[\"co\",{\"1\":{\"440\":1}}],[\"corematchers\",{\"1\":{\"978\":1}}],[\"core\",{\"1\":{\"869\":1,\"978\":2}}],[\"corenlp\",{\"1\":{\"418\":1}}],[\"corresponding\",{\"1\":{\"87\":1}}],[\"correct\",{\"1\":{\"85\":1,\"145\":1,\"294\":1,\"310\":1,\"860\":1,\"947\":1}}],[\"column3\",{\"1\":{\"865\":1}}],[\"column1\",{\"1\":{\"865\":1}}],[\"column\",{\"1\":{\"865\":4}}],[\"columnar\",{\"1\":{\"395\":1}}],[\"col2\",{\"1\":{\"865\":1}}],[\"col1\",{\"1\":{\"865\":1}}],[\"col\",{\"1\":{\"865\":3}}],[\"colleaguemap\",{\"1\":{\"659\":11}}],[\"colleague>\",{\"1\":{\"659\":2}}],[\"colleaguename\",{\"1\":{\"659\":13}}],[\"colleagues\",{\"1\":{\"656\":4}}],[\"colleague\",{\"1\":{\"656\":17,\"659\":15}}],[\"colleage\",{\"1\":{\"574\":1}}],[\"collegeemployee\",{\"1\":{\"742\":7,\"743\":5}}],[\"collegemanager\",{\"1\":{\"742\":4,\"743\":4}}],[\"collegeapprover\",{\"1\":{\"710\":7}}],[\"collegelist\",{\"1\":{\"650\":10}}],[\"college\",{\"1\":{\"574\":4,\"650\":6}}],[\"collectors类的tomap\",{\"1\":{\"850\":2}}],[\"collectors\",{\"1\":{\"455\":1,\"850\":3,\"872\":1}}],[\"collect\",{\"1\":{\"455\":1,\"469\":1,\"850\":3}}],[\"collections类返回的对象\",{\"1\":{\"850\":1}}],[\"collections2\",{\"1\":{\"466\":1}}],[\"collections\",{\"1\":{\"406\":1,\"469\":1,\"850\":1}}],[\"collection\",{\"0\":{\"315\":1,\"316\":1,\"317\":1,\"318\":1,\"319\":1,\"1005\":1},\"1\":{\"406\":1,\"981\":4}}],[\"colebourne\",{\"1\":{\"440\":1}}],[\"color=\",{\"1\":{\"685\":1,\"687\":1}}],[\"color\",{\"1\":{\"80\":1,\"81\":2,\"685\":9,\"687\":9,\"912\":4}}],[\"copied\",{\"1\":{\"310\":1,\"311\":1}}],[\"copyright\",{\"0\":{\"887\":1},\"1\":{\"886\":1}}],[\"copyobj\",{\"1\":{\"689\":2}}],[\"copyonwritearraylist详解\",{\"0\":{\"494\":1}}],[\"copydirectory\",{\"1\":{\"465\":1}}],[\"copymethod\",{\"1\":{\"311\":2}}],[\"copymemory\",{\"1\":{\"93\":1}}],[\"copy\",{\"1\":{\"310\":4,\"311\":1}}],[\"copy一份constructor返回\",{\"1\":{\"310\":1}}],[\"copyconstructor\",{\"1\":{\"310\":4}}],[\"council\",{\"1\":{\"439\":1}}],[\"countdownlatch\",{\"1\":{\"873\":1,\"980\":3}}],[\"countdownlatch详解\",{\"0\":{\"500\":1}}],[\"countdown\",{\"1\":{\"872\":1}}],[\"count反例\",{\"1\":{\"845\":1}}],[\"country\",{\"1\":{\"618\":1}}],[\"count=15\",{\"1\":{\"308\":1}}],[\"count=\",{\"1\":{\"308\":1}}],[\"count\",{\"1\":{\"308\":4,\"312\":3,\"773\":2,\"778\":7,\"845\":3,\"851\":2,\"852\":1,\"864\":1,\"865\":4}}],[\"counterparts\",{\"1\":{\"145\":1}}],[\"couples\",{\"1\":{\"420\":1}}],[\"couldn\",{\"1\":{\"451\":1}}],[\"could\",{\"1\":{\"68\":1}}],[\"coverage\",{\"1\":{\"145\":1}}],[\"codeurs\",{\"1\":{\"488\":1}}],[\"codec\",{\"1\":{\"465\":1}}],[\"codepointat\",{\"1\":{\"114\":2}}],[\"codercto\",{\"1\":{\"277\":1,\"314\":1}}],[\"coder\",{\"1\":{\"89\":3}}],[\"code\",{\"0\":{\"176\":1,\"484\":1},\"1\":{\"77\":1,\"104\":3,\"145\":9,\"170\":1,\"176\":1,\"181\":1,\"225\":1,\"228\":4,\"253\":1,\"256\":2,\"259\":1,\"275\":4,\"291\":5,\"310\":1,\"312\":4,\"442\":1,\"487\":1,\"763\":1,\"854\":1,\"857\":1,\"958\":1}}],[\"codeship\",{\"1\":{\"392\":1}}],[\"codes\",{\"0\":{\"73\":1}}],[\"combinablematcher\",{\"1\":{\"978\":2}}],[\"combination\",{\"1\":{\"144\":1}}],[\"computedvalues\",{\"1\":{\"943\":1}}],[\"computercollegeiterator\",{\"1\":{\"650\":3}}],[\"computercollege\",{\"1\":{\"574\":5,\"650\":6}}],[\"computer\",{\"1\":{\"215\":4,\"832\":3}}],[\"complicateddataholder\",{\"1\":{\"446\":5}}],[\"comprehension\",{\"1\":{\"403\":1}}],[\"compile\",{\"1\":{\"855\":1}}],[\"compiler\",{\"1\":{\"152\":1,\"485\":1,\"974\":1}}],[\"compilation\",{\"1\":{\"284\":1}}],[\"compilings\",{\"1\":{\"275\":1}}],[\"compositepattern\",{\"1\":{\"571\":2}}],[\"composite\",{\"1\":{\"567\":1,\"568\":1,\"571\":8,\"590\":1,\"745\":1,\"798\":1,\"814\":1}}],[\"composition\",{\"0\":{\"216\":1,\"832\":1},\"1\":{\"216\":1,\"403\":1,\"745\":1,\"813\":1,\"832\":1}}],[\"componenttype\",{\"1\":{\"295\":1}}],[\"component\",{\"1\":{\"242\":1,\"568\":1,\"571\":31,\"580\":16}}],[\"compound\",{\"1\":{\"129\":1}}],[\"company\",{\"1\":{\"216\":3,\"845\":1}}],[\"comparable>\",{\"1\":{\"289\":1}}],[\"comparable<\",{\"1\":{\"284\":4}}],[\"comparable<string>\",{\"1\":{\"122\":1}}],[\"comparable\",{\"0\":{\"178\":1},\"1\":{\"178\":2}}],[\"comparator实现类要满足如下三个条件\",{\"1\":{\"850\":1}}],[\"comparator<student>\",{\"1\":{\"850\":1}}],[\"comparator<\",{\"1\":{\"790\":1}}],[\"comparator<integer>\",{\"1\":{\"790\":4}}],[\"comparator\",{\"0\":{\"178\":1},\"1\":{\"178\":2,\"790\":4,\"872\":1}}],[\"compare\",{\"1\":{\"790\":2,\"850\":1,\"873\":1}}],[\"compareto\",{\"1\":{\"133\":1,\"284\":1,\"790\":1,\"848\":1,\"872\":1}}],[\"compareable\",{\"1\":{\"133\":1}}],[\"compatibility\",{\"1\":{\"104\":1}}],[\"compatible\",{\"1\":{\"85\":1,\"104\":2,\"431\":1}}],[\"commit\",{\"1\":{\"845\":2}}],[\"comma\",{\"1\":{\"942\":1}}],[\"commandpattern\",{\"1\":{\"561\":1}}],[\"command\",{\"1\":{\"560\":2,\"561\":16,\"562\":13,\"563\":1,\"591\":1,\"798\":1}}],[\"commadelimitedlisttostringarray\",{\"1\":{\"106\":1}}],[\"commonhouse\",{\"1\":{\"553\":6,\"555\":5}}],[\"commons\",{\"0\":{\"465\":1},\"1\":{\"104\":14,\"432\":1,\"465\":4,\"859\":4}}],[\"common\",{\"0\":{\"104\":1},\"1\":{\"104\":1,\"312\":2}}],[\"comment\",{\"1\":{\"78\":3,\"877\":1}}],[\"commentstring\",{\"1\":{\"847\":1}}],[\"comments\",{\"0\":{\"78\":1},\"1\":{\"78\":2,\"104\":1,\"310\":1,\"877\":2,\"932\":1}}],[\"com\",{\"1\":{\"77\":8,\"96\":2,\"98\":2,\"102\":1,\"103\":1,\"116\":4,\"144\":1,\"145\":1,\"155\":2,\"212\":1,\"219\":2,\"234\":10,\"238\":1,\"242\":1,\"243\":3,\"270\":2,\"276\":1,\"277\":2,\"283\":1,\"291\":6,\"294\":1,\"299\":4,\"305\":17,\"306\":7,\"309\":2,\"314\":2,\"442\":1,\"447\":1,\"700\":1,\"859\":1,\"869\":2,\"939\":3,\"978\":1,\"979\":4,\"984\":2,\"993\":1,\"1000\":1}}],[\"comes\",{\"1\":{\"68\":1}}],[\"conf文件去修改该缺省值\",{\"1\":{\"870\":1}}],[\"confusingname\",{\"1\":{\"845\":2}}],[\"configflag反例\",{\"1\":{\"854\":1}}],[\"configcontent\",{\"1\":{\"626\":2}}],[\"configlocation\",{\"1\":{\"625\":5}}],[\"configured\",{\"1\":{\"120\":1}}],[\"configuration>\",{\"1\":{\"974\":1}}],[\"configuration类\",{\"1\":{\"106\":1}}],[\"configuration\",{\"0\":{\"87\":1,\"462\":1},\"1\":{\"87\":1,\"114\":1,\"602\":1}}],[\"configs\",{\"1\":{\"114\":6}}],[\"config\",{\"1\":{\"77\":2,\"87\":1,\"104\":1,\"390\":1,\"625\":1,\"768\":4,\"859\":1,\"863\":2}}],[\"condition\",{\"1\":{\"451\":1,\"452\":1,\"845\":2,\"848\":1,\"852\":2,\"901\":2,\"978\":2}}],[\"convergence\",{\"0\":{\"459\":1}}],[\"convert\",{\"1\":{\"165\":1}}],[\"convenient\",{\"1\":{\"82\":1}}],[\"concise\",{\"1\":{\"902\":1}}],[\"concurrency\",{\"1\":{\"438\":1,\"487\":1}}],[\"concurrentlinkedqueue详解\",{\"0\":{\"493\":1}}],[\"concurrenthashmap\",{\"1\":{\"850\":1}}],[\"concurrenthashmap<long\",{\"1\":{\"771\":1}}],[\"concurrenthashmap<>\",{\"1\":{\"627\":2,\"771\":1,\"773\":1}}],[\"concurrenthashmap<string\",{\"1\":{\"627\":2,\"773\":1}}],[\"concurrenthashmap详解\",{\"0\":{\"492\":1}}],[\"concurrenthashmap来保存锁\",{\"1\":{\"310\":1}}],[\"concurrentmodificationexception\",{\"1\":{\"265\":1}}],[\"concurrent\",{\"1\":{\"150\":1,\"980\":5}}],[\"concerns\",{\"1\":{\"145\":1}}],[\"concreteelementb\",{\"1\":{\"838\":5}}],[\"concreteelementa\",{\"1\":{\"838\":5}}],[\"concreteelement\",{\"1\":{\"838\":1}}],[\"concretevisitorb\",{\"1\":{\"838\":2}}],[\"concretevisitora\",{\"1\":{\"838\":2}}],[\"concretevisitor\",{\"1\":{\"838\":1}}],[\"concreteclass\",{\"1\":{\"801\":2}}],[\"concretecolleague2\",{\"1\":{\"656\":2}}],[\"concretecolleague1\",{\"1\":{\"656\":2}}],[\"concretecomponent\",{\"1\":{\"580\":4}}],[\"concretecommand\",{\"1\":{\"561\":3}}],[\"concretestrategyb\",{\"1\":{\"784\":2}}],[\"concretestrategya\",{\"1\":{\"784\":2}}],[\"concretestateb\",{\"1\":{\"776\":2}}],[\"concretestatea\",{\"1\":{\"776\":3}}],[\"concretesubject\",{\"1\":{\"672\":2}}],[\"concretehandler2\",{\"1\":{\"708\":2}}],[\"concretehandler1\",{\"1\":{\"708\":2}}],[\"concreteprototype\",{\"1\":{\"683\":1}}],[\"concreteproduct\",{\"1\":{\"608\":1,\"612\":1,\"616\":1}}],[\"concreteobserver2\",{\"1\":{\"672\":2}}],[\"concreteobserver1\",{\"1\":{\"672\":2}}],[\"concretemediator\",{\"1\":{\"656\":2,\"659\":7}}],[\"concreteiterator\",{\"1\":{\"649\":3}}],[\"concreteimplementora\",{\"1\":{\"538\":2}}],[\"concretelterator\",{\"1\":{\"649\":1}}],[\"concreteaggregate\",{\"1\":{\"649\":3}}],[\"concretewebsite>\",{\"1\":{\"636\":1}}],[\"concretewebsite\",{\"1\":{\"636\":3}}],[\"concreteflyweight\",{\"1\":{\"632\":4}}],[\"concretefactory\",{\"1\":{\"612\":1}}],[\"concretedecorator\",{\"1\":{\"580\":4}}],[\"concretebuilder\",{\"1\":{\"550\":1}}],[\"concrete\",{\"1\":{\"104\":3,\"538\":2,\"551\":1,\"561\":1,\"616\":1,\"632\":1,\"656\":2,\"672\":2,\"708\":1,\"776\":1,\"784\":1,\"801\":1}}],[\"consumer\",{\"1\":{\"850\":1}}],[\"cons\",{\"1\":{\"306\":3}}],[\"consideration\",{\"1\":{\"145\":1}}],[\"consistent\",{\"1\":{\"104\":1}}],[\"consequently\",{\"1\":{\"145\":1}}],[\"consts单表中最多只有一个匹配行\",{\"1\":{\"864\":1}}],[\"construct\",{\"1\":{\"898\":1}}],[\"construction\",{\"1\":{\"736\":1}}],[\"constructiontest\",{\"1\":{\"306\":1}}],[\"constructhouse\",{\"1\":{\"555\":3}}],[\"constructorarg>\",{\"1\":{\"627\":1}}],[\"constructorarg\",{\"1\":{\"626\":1,\"627\":1}}],[\"constructorargs\",{\"1\":{\"626\":1}}],[\"constructoraccessorimpl\",{\"1\":{\"310\":2,\"312\":2}}],[\"constructoraccessor\",{\"1\":{\"310\":5,\"312\":1}}],[\"constructors\",{\"1\":{\"310\":3,\"626\":2}}],[\"constructor对象表示的构造方法的类\",{\"1\":{\"306\":1}}],[\"constructor对象表示的构造函数来创建新实例\",{\"1\":{\"306\":1}}],[\"constructor对象构造函数的形参类型\",{\"1\":{\"306\":1}}],[\"constructor<>\",{\"1\":{\"310\":1}}],[\"constructor<t>\",{\"1\":{\"310\":15}}],[\"constructor<\",{\"1\":{\"306\":3,\"310\":1}}],[\"constructor类存在于反射包\",{\"1\":{\"306\":1}}],[\"constructor类及其用法\",{\"0\":{\"306\":1}}],[\"constructor\",{\"1\":{\"145\":2,\"224\":1,\"225\":1,\"227\":1,\"302\":3,\"306\":9,\"310\":21,\"312\":7,\"446\":1,\"877\":1}}],[\"constants\",{\"1\":{\"942\":2}}],[\"constant\",{\"1\":{\"125\":1,\"312\":66}}],[\"const\",{\"1\":{\"14\":1}}],[\"continuous\",{\"0\":{\"460\":1}}],[\"continue\",{\"1\":{\"104\":1,\"924\":1,\"950\":1}}],[\"contortion\",{\"1\":{\"310\":1}}],[\"containing\",{\"1\":{\"469\":1}}],[\"containingclass\",{\"1\":{\"311\":2}}],[\"containsstring\",{\"1\":{\"978\":3}}],[\"contains\",{\"1\":{\"114\":1,\"478\":4,\"627\":1,\"656\":1,\"678\":1,\"835\":1}}],[\"containskey\",{\"1\":{\"114\":1,\"636\":1,\"644\":1}}],[\"container\",{\"1\":{\"104\":1,\"620\":1}}],[\"controller层\",{\"1\":{\"868\":1}}],[\"controller\",{\"1\":{\"242\":1,\"533\":2,\"655\":1}}],[\"controllerlog\",{\"1\":{\"242\":3}}],[\"control\",{\"1\":{\"104\":1,\"854\":1}}],[\"content\",{\"1\":{\"626\":2,\"885\":1}}],[\"contents\",{\"1\":{\"104\":2}}],[\"contextclassloader\",{\"1\":{\"104\":13}}],[\"context\",{\"1\":{\"77\":1,\"104\":8,\"144\":4,\"145\":1,\"477\":4,\"642\":3,\"750\":1,\"776\":18,\"778\":1,\"779\":85,\"784\":4,\"791\":1,\"869\":1}}],[\"conn\",{\"1\":{\"102\":1}}],[\"connection\",{\"1\":{\"102\":1}}],[\"connector\",{\"1\":{\"100\":1,\"103\":1}}],[\"connected\",{\"1\":{\"59\":1}}],[\"c\",{\"0\":{\"162\":4,\"921\":1},\"1\":{\"68\":5,\"69\":1,\"70\":2,\"71\":4,\"77\":5,\"78\":1,\"86\":3,\"114\":4,\"151\":2,\"163\":1,\"259\":1,\"275\":1,\"289\":1,\"291\":1,\"310\":17,\"312\":5,\"419\":1,\"445\":1,\"571\":14,\"591\":1,\"643\":2,\"644\":2,\"655\":1,\"716\":2,\"721\":3,\"723\":15,\"732\":2,\"784\":5,\"790\":6,\"818\":1,\"848\":3,\"850\":1,\"851\":1,\"852\":2,\"854\":2,\"857\":1,\"860\":1,\"864\":3}}],[\"ch\",{\"1\":{\"644\":6}}],[\"chronon\",{\"0\":{\"481\":1},\"1\":{\"480\":1,\"481\":1}}],[\"christmas\",{\"1\":{\"56\":2}}],[\"chen\",{\"1\":{\"847\":3}}],[\"cheese\",{\"1\":{\"610\":2,\"613\":4}}],[\"cheesepizza\",{\"1\":{\"609\":5,\"610\":3}}],[\"cheesepizz\",{\"1\":{\"609\":1}}],[\"chef\",{\"1\":{\"462\":1}}],[\"checknonempty\",{\"1\":{\"947\":2}}],[\"checkname\",{\"1\":{\"310\":1}}],[\"checkparam\",{\"1\":{\"871\":1}}],[\"checkpackageaccess\",{\"1\":{\"310\":1}}],[\"checkfailevent\",{\"1\":{\"779\":6}}],[\"checkevent\",{\"1\":{\"779\":5}}],[\"checker\",{\"0\":{\"483\":1},\"1\":{\"483\":1}}],[\"checked异常\",{\"1\":{\"858\":1}}],[\"checkedexceptions\",{\"1\":{\"312\":3}}],[\"checked\",{\"0\":{\"249\":1},\"1\":{\"198\":1,\"252\":1,\"312\":1,\"851\":1}}],[\"checkaccess\",{\"1\":{\"310\":1,\"312\":1}}],[\"checkinitted\",{\"1\":{\"310\":1,\"311\":1,\"312\":1}}],[\"checking\",{\"1\":{\"104\":1,\"477\":1}}],[\"checkstyle\",{\"1\":{\"388\":1,\"484\":1}}],[\"checks\",{\"1\":{\"310\":1}}],[\"checkmemberaccess\",{\"1\":{\"310\":1,\"311\":1}}],[\"checkcast\",{\"1\":{\"291\":2}}],[\"checkreturn\",{\"1\":{\"273\":1,\"858\":1}}],[\"checkdeptexistuser\",{\"1\":{\"242\":1}}],[\"checkdeptnameunique\",{\"1\":{\"242\":2}}],[\"check\",{\"1\":{\"85\":1,\"92\":1,\"294\":1,\"310\":4,\"312\":1,\"757\":1,\"871\":1}}],[\"chocolate\",{\"1\":{\"581\":1,\"583\":1,\"584\":4}}],[\"choco\",{\"1\":{\"391\":1}}],[\"children\",{\"1\":{\"571\":10}}],[\"child\",{\"1\":{\"104\":1,\"310\":1}}],[\"chainofresponsibilitypattern\",{\"1\":{\"708\":1}}],[\"chain\",{\"1\":{\"591\":1,\"707\":1,\"798\":1}}],[\"chaining\",{\"0\":{\"68\":1}}],[\"champion等\",{\"1\":{\"440\":1}}],[\"champion\",{\"1\":{\"440\":6}}],[\"chararray\",{\"1\":{\"644\":7}}],[\"character\",{\"1\":{\"73\":1,\"114\":4,\"122\":1,\"130\":1,\"312\":1,\"847\":1,\"865\":1,\"940\":1}}],[\"characters\",{\"0\":{\"72\":1,\"73\":1},\"1\":{\"71\":1,\"72\":1,\"73\":1}}],[\"charging\",{\"1\":{\"524\":2,\"528\":2}}],[\"charvalue\",{\"1\":{\"312\":1}}],[\"charsequence\",{\"1\":{\"122\":1}}],[\"charcount\",{\"1\":{\"114\":2}}],[\"char\",{\"1\":{\"73\":2,\"119\":1,\"120\":1,\"122\":2,\"130\":1,\"302\":1,\"644\":2,\"978\":2}}],[\"change\",{\"1\":{\"51\":1,\"77\":1,\"145\":1,\"716\":1,\"850\":1,\"942\":1}}],[\"与它之前的右花括号\",{\"1\":{\"911\":1}}],[\"与它们之后的开括号\",{\"1\":{\"911\":1}}],[\"与它的实现清晰地隔离开来\",{\"1\":{\"132\":1}}],[\"与服务器的内存数量相关\",{\"1\":{\"870\":1}}],[\"与底层mysql\",{\"1\":{\"868\":1}}],[\"与底层源码解析融会贯通\",{\"1\":{\"843\":1}}],[\"与dao层交互\",{\"1\":{\"868\":1}}],[\"与全表扫描是小巫见大巫\",{\"1\":{\"864\":1}}],[\"与设计文档相结合\",{\"1\":{\"860\":1}}],[\"与get0bject\",{\"1\":{\"848\":1}}],[\"与gson类似\",{\"1\":{\"409\":1}}],[\"与右括号不需要空格\",{\"1\":{\"847\":1}}],[\"与其它编程规范指南类似\",{\"1\":{\"876\":1}}],[\"与其用半吊子英文来注释\",{\"1\":{\"853\":1}}],[\"与其反复从头开发\",{\"1\":{\"819\":1}}],[\"与其他\",{\"1\":{\"766\":1}}],[\"与实际的写代码离得有点远\",{\"1\":{\"808\":1}}],[\"与代理对象一起实现相同的接口或者是继承相同父类\",{\"1\":{\"694\":1}}],[\"与行为实现\",{\"1\":{\"537\":1}}],[\"与tapestry类似带有状态显示gui\",{\"1\":{\"434\":1}}],[\"与具体数据库独立的追踪\",{\"1\":{\"384\":1}}],[\"与class关键字是不一样的\",{\"1\":{\"302\":1}}],[\"与前面几行\",{\"1\":{\"264\":1}}],[\"与此接口中的其他方法不同\",{\"1\":{\"233\":3}}],[\"与运行过程的状态无关\",{\"1\":{\"217\":1}}],[\"与\",{\"0\":{\"128\":1,\"151\":1,\"165\":1,\"178\":1,\"181\":1,\"185\":1},\"1\":{\"14\":1,\"120\":1,\"138\":2,\"179\":2,\"182\":1,\"187\":1,\"560\":1,\"832\":1,\"848\":1,\"852\":1,\"972\":2}}],[\"vpn服务出错\",{\"1\":{\"874\":1}}],[\"v能不能存储null值的情况\",{\"1\":{\"850\":1}}],[\"v值组合的set集合\",{\"1\":{\"850\":1}}],[\"v2\",{\"1\":{\"850\":4}}],[\"vlissides\",{\"1\":{\"795\":1}}],[\"vlad\",{\"1\":{\"442\":1}}],[\"vs\",{\"1\":{\"557\":1}}],[\"v0\",{\"1\":{\"459\":1}}],[\"v1\",{\"1\":{\"459\":1,\"850\":2}}],[\"vjug\",{\"1\":{\"437\":1,\"488\":1}}],[\"vo等pojo类时\",{\"1\":{\"848\":1}}],[\"vo的统称\",{\"1\":{\"845\":1}}],[\"vo\",{\"1\":{\"845\":1,\"868\":1,\"873\":2}}],[\"voltageadapter\",{\"1\":{\"524\":2,\"528\":3}}],[\"voltage220v\",{\"1\":{\"524\":2,\"528\":11}}],[\"volatile解决多线程内存不可见问题对于一写多读\",{\"1\":{\"851\":1}}],[\"volatile详解\",{\"0\":{\"507\":1}}],[\"volatile\",{\"1\":{\"310\":10,\"312\":1,\"585\":1,\"757\":1,\"758\":1,\"851\":2,\"934\":1}}],[\"voxxed\",{\"1\":{\"442\":1}}],[\"void\",{\"1\":{\"89\":3,\"90\":2,\"91\":1,\"92\":3,\"93\":3,\"96\":1,\"103\":2,\"114\":6,\"127\":5,\"132\":1,\"133\":7,\"134\":2,\"137\":6,\"141\":3,\"144\":6,\"147\":1,\"201\":1,\"209\":1,\"211\":4,\"222\":3,\"228\":6,\"229\":1,\"230\":1,\"234\":6,\"241\":14,\"242\":6,\"252\":2,\"253\":1,\"256\":2,\"257\":1,\"259\":2,\"264\":3,\"266\":1,\"267\":1,\"268\":1,\"269\":2,\"270\":1,\"271\":1,\"275\":6,\"276\":4,\"281\":5,\"282\":2,\"284\":13,\"285\":2,\"288\":2,\"289\":4,\"290\":2,\"291\":9,\"295\":1,\"297\":3,\"298\":2,\"302\":1,\"305\":5,\"306\":3,\"307\":3,\"308\":14,\"309\":2,\"310\":1,\"312\":2,\"445\":1,\"452\":1,\"477\":1,\"524\":2,\"528\":2,\"532\":26,\"538\":5,\"542\":19,\"553\":8,\"555\":14,\"561\":6,\"562\":21,\"571\":18,\"574\":13,\"580\":6,\"584\":3,\"596\":5,\"601\":24,\"609\":4,\"610\":1,\"613\":6,\"617\":25,\"618\":1,\"622\":1,\"624\":1,\"625\":1,\"627\":1,\"632\":4,\"636\":4,\"637\":1,\"642\":4,\"644\":1,\"649\":5,\"650\":10,\"656\":12,\"659\":18,\"664\":5,\"667\":8,\"672\":8,\"676\":5,\"678\":14,\"685\":4,\"687\":4,\"689\":1,\"695\":4,\"700\":5,\"703\":1,\"708\":5,\"710\":7,\"718\":10,\"723\":40,\"727\":4,\"728\":15,\"734\":2,\"738\":9,\"739\":7,\"741\":2,\"742\":4,\"743\":5,\"752\":1,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"757\":1,\"758\":1,\"759\":2,\"764\":4,\"772\":1,\"773\":1,\"776\":6,\"778\":13,\"779\":34,\"784\":6,\"787\":7,\"788\":4,\"789\":17,\"790\":2,\"801\":7,\"803\":9,\"809\":5,\"812\":2,\"813\":12,\"814\":3,\"826\":1,\"828\":2,\"830\":1,\"831\":2,\"832\":2,\"833\":2,\"834\":2,\"838\":13,\"839\":15,\"845\":2,\"847\":1,\"848\":1,\"852\":4,\"855\":1,\"901\":1,\"902\":2,\"972\":4,\"975\":1,\"976\":6,\"977\":1,\"978\":21,\"979\":2,\"980\":3,\"981\":2,\"982\":2,\"983\":3,\"998\":1}}],[\"v>\",{\"1\":{\"281\":1}}],[\"velocity调用pojo类的属性时\",{\"1\":{\"855\":1}}],[\"velocity\",{\"1\":{\"430\":1,\"872\":1}}],[\"vec\",{\"1\":{\"312\":4}}],[\"vehicle2\",{\"1\":{\"718\":7}}],[\"vehicle\",{\"1\":{\"218\":3,\"718\":22}}],[\"vehical\",{\"1\":{\"213\":3}}],[\"verburg\",{\"1\":{\"440\":1}}],[\"verbose\",{\"1\":{\"228\":1}}],[\"vert\",{\"1\":{\"398\":1}}],[\"vertex\",{\"1\":{\"86\":1}}],[\"vertices\",{\"0\":{\"86\":1},\"1\":{\"86\":1}}],[\"vertical\",{\"1\":{\"71\":1}}],[\"version>\",{\"1\":{\"974\":2}}],[\"version=\",{\"1\":{\"974\":1}}],[\"version=6\",{\"1\":{\"850\":1}}],[\"version和scope都读取自父pom\",{\"1\":{\"869\":1}}],[\"version2\",{\"1\":{\"850\":1}}],[\"version1\",{\"1\":{\"850\":1}}],[\"versions\",{\"1\":{\"85\":1}}],[\"version\",{\"1\":{\"77\":1,\"85\":1,\"104\":1,\"485\":1,\"760\":2,\"850\":3,\"869\":2,\"873\":1}}],[\"very\",{\"1\":{\"68\":1,\"209\":1,\"951\":1}}],[\"vm\",{\"1\":{\"120\":1,\"310\":3,\"311\":1,\"312\":2,\"872\":1}}],[\"vanilla\",{\"1\":{\"442\":1}}],[\"vaadin\",{\"1\":{\"434\":1}}],[\"value1\",{\"1\":{\"866\":1}}],[\"valueanimator\",{\"1\":{\"532\":11}}],[\"value为integer\",{\"1\":{\"281\":1}}],[\"value=1234\",{\"1\":{\"622\":1,\"624\":1}}],[\"value=\",{\"1\":{\"224\":1,\"622\":1,\"624\":1}}],[\"values=\",{\"1\":{\"230\":1}}],[\"values\",{\"1\":{\"120\":4,\"230\":2,\"850\":2}}],[\"value3\",{\"1\":{\"106\":1,\"866\":1}}],[\"value2\",{\"1\":{\"106\":1,\"866\":1}}],[\"value\",{\"1\":{\"104\":2,\"120\":3,\"122\":4,\"127\":1,\"141\":6,\"143\":1,\"225\":1,\"229\":1,\"230\":2,\"242\":1,\"253\":3,\"281\":5,\"289\":10,\"291\":23,\"302\":1,\"307\":2,\"310\":3,\"311\":2,\"447\":1,\"451\":1,\"644\":1,\"771\":1,\"779\":5,\"846\":1,\"849\":1,\"850\":2,\"851\":3,\"852\":1,\"874\":1,\"907\":1,\"978\":2}}],[\"valueof\",{\"1\":{\"91\":1,\"104\":2,\"120\":7,\"132\":1,\"637\":8,\"644\":7,\"848\":3,\"978\":1}}],[\"value>>32\",{\"1\":{\"90\":1}}],[\"value>>31>>1\",{\"1\":{\"90\":1}}],[\"validate\",{\"1\":{\"981\":2}}],[\"validated\",{\"1\":{\"242\":2}}],[\"valid\",{\"1\":{\"86\":2}}],[\"varchar是可变长字符串\",{\"1\":{\"863\":1}}],[\"varexpression\",{\"1\":{\"644\":6}}],[\"variant\",{\"1\":{\"618\":1}}],[\"variable\",{\"1\":{\"14\":2,\"133\":1,\"143\":1,\"204\":1,\"224\":1,\"225\":2,\"227\":1,\"312\":1}}],[\"var5\",{\"1\":{\"310\":4}}],[\"var4\",{\"1\":{\"310\":3}}],[\"var3\",{\"1\":{\"310\":3}}],[\"var2\",{\"1\":{\"310\":3,\"790\":2,\"978\":3}}],[\"var1\",{\"1\":{\"310\":7,\"790\":2,\"978\":3}}],[\"var的类型由t指定\",{\"1\":{\"281\":1}}],[\"var\",{\"1\":{\"77\":3,\"281\":5,\"282\":7,\"284\":12,\"471\":1,\"644\":19,\"848\":1,\"855\":2}}],[\"viceschoolmasterapprover\",{\"1\":{\"710\":7}}],[\"vit\",{\"1\":{\"667\":16}}],[\"visit\",{\"1\":{\"838\":10}}],[\"visitorpattern\",{\"1\":{\"838\":1}}],[\"visitor\",{\"1\":{\"591\":1,\"798\":1,\"837\":2,\"838\":21,\"841\":1}}],[\"visiblefortesting\",{\"1\":{\"627\":1}}],[\"visualvm\",{\"1\":{\"422\":1}}],[\"visual\",{\"1\":{\"145\":2}}],[\"vivo手机打电话\",{\"1\":{\"542\":1}}],[\"vivo手机关机\",{\"1\":{\"542\":1}}],[\"vivo手机开机\",{\"1\":{\"542\":1}}],[\"vivo\",{\"1\":{\"542\":3}}],[\"videos\",{\"0\":{\"489\":1}}],[\"virtualjug创始人\",{\"1\":{\"440\":1}}],[\"virtual\",{\"1\":{\"145\":1,\"247\":1,\"302\":1}}],[\"view\",{\"1\":{\"591\":1,\"655\":1,\"868\":1,\"873\":1}}],[\"viewspace\",{\"1\":{\"116\":1}}],[\"viewed\",{\"1\":{\"77\":1}}],[\"via\",{\"1\":{\"85\":1,\"104\":3,\"145\":1,\"310\":1,\"311\":1}}],[\"v\",{\"1\":{\"14\":1,\"228\":1,\"275\":16,\"281\":3,\"291\":3,\"312\":13,\"655\":1}}],[\"vuepress\",{\"0\":{\"12\":1},\"1\":{\"0\":3,\"8\":2,\"10\":2,\"11\":1,\"12\":2,\"13\":1,\"33\":1}}],[\"evaluate\",{\"1\":{\"979\":4,\"980\":1}}],[\"even\",{\"1\":{\"933\":1}}],[\"event\",{\"1\":{\"77\":1}}],[\"everything\",{\"1\":{\"997\":1}}],[\"everyitem\",{\"1\":{\"978\":1}}],[\"every\",{\"1\":{\"82\":1}}],[\"egyptian\",{\"1\":{\"901\":1}}],[\"egglayability\",{\"1\":{\"813\":6}}],[\"egglayable\",{\"1\":{\"813\":6}}],[\"espress\",{\"1\":{\"582\":1}}],[\"espresso\",{\"1\":{\"581\":1,\"584\":2}}],[\"especially\",{\"1\":{\"489\":1,\"955\":1}}],[\"escape\",{\"0\":{\"73\":1},\"1\":{\"73\":1}}],[\"etc\",{\"1\":{\"446\":1,\"452\":2,\"870\":1}}],[\"eugen\",{\"1\":{\"440\":1}}],[\"ejb\",{\"1\":{\"420\":1}}],[\"ebean\",{\"1\":{\"420\":1}}],[\"ebcdic\",{\"1\":{\"104\":1}}],[\"ei\",{\"1\":{\"845\":1}}],[\"eip\",{\"1\":{\"414\":1}}],[\"either\",{\"1\":{\"77\":1}}],[\"ee的开发过程\",{\"1\":{\"434\":1}}],[\"ee容器\",{\"1\":{\"431\":1}}],[\"ee功能\",{\"1\":{\"429\":1}}],[\"ee\",{\"1\":{\"407\":1,\"429\":1,\"440\":4}}],[\"ee参考实现\",{\"1\":{\"384\":1}}],[\"emp\",{\"1\":{\"742\":6,\"743\":6}}],[\"employee\",{\"1\":{\"742\":5,\"743\":4}}],[\"emptystack\",{\"1\":{\"950\":1}}],[\"emptylist\",{\"1\":{\"850\":2}}],[\"empty\",{\"1\":{\"310\":2,\"450\":2,\"902\":1,\"942\":1,\"947\":1}}],[\"email\",{\"1\":{\"727\":9}}],[\"email模板和通用开源代码生成器模板\",{\"1\":{\"430\":1}}],[\"emoji\",{\"1\":{\"432\":1}}],[\"emitinvoke\",{\"1\":{\"312\":1}}],[\"emitboxingcontantpoolentries\",{\"1\":{\"312\":1}}],[\"emitconstructor\",{\"1\":{\"312\":1}}],[\"emitconstantpoolmethodref\",{\"1\":{\"312\":2}}],[\"emitconstantpoolinterfacemethodref\",{\"1\":{\"312\":1}}],[\"emitconstantpoolnameandtype\",{\"1\":{\"312\":1}}],[\"emitconstantpoolclass\",{\"1\":{\"312\":5}}],[\"emitconstantpoolutf8\",{\"1\":{\"312\":13}}],[\"emitcommonconstantpoolentries\",{\"1\":{\"312\":1}}],[\"emitshort\",{\"1\":{\"312\":8}}],[\"emitmagicandversion\",{\"1\":{\"312\":1}}],[\"effictive\",{\"1\":{\"284\":1}}],[\"effective\",{\"1\":{\"141\":1,\"153\":1,\"438\":1,\"487\":1,\"489\":2,\"759\":1,\"797\":1,\"952\":1}}],[\"effects\",{\"1\":{\"0\":1,\"145\":1}}],[\"e>>\",{\"1\":{\"284\":2}}],[\"e>\",{\"1\":{\"284\":6}}],[\"err输出或使用e\",{\"1\":{\"859\":1}}],[\"error级别只记录系统逻辑出错\",{\"1\":{\"859\":1}}],[\"errormessage是前后端错误追踪机制的体现\",{\"1\":{\"854\":1}}],[\"errormessage\",{\"1\":{\"854\":4,\"859\":1}}],[\"errorcode\",{\"1\":{\"854\":4}}],[\"error不需要捕获\",{\"1\":{\"198\":1}}],[\"error的\",{\"1\":{\"198\":1}}],[\"error\",{\"0\":{\"247\":1},\"1\":{\"146\":2,\"150\":1,\"165\":1,\"242\":5,\"246\":1,\"247\":1,\"249\":1,\"264\":6,\"267\":2,\"269\":1,\"270\":3,\"271\":1,\"275\":3,\"293\":1,\"294\":1,\"388\":1,\"451\":1,\"625\":1,\"854\":3,\"857\":2,\"859\":1,\"860\":1}}],[\"erich\",{\"1\":{\"795\":1,\"796\":1}}],[\"erasure\",{\"1\":{\"278\":1,\"287\":2}}],[\"eder\",{\"1\":{\"440\":1}}],[\"ed\",{\"1\":{\"440\":1,\"942\":3}}],[\"edu\",{\"1\":{\"287\":1}}],[\"edits\",{\"1\":{\"912\":1}}],[\"editsave\",{\"1\":{\"242\":1}}],[\"edition\",{\"1\":{\"438\":1}}],[\"edit\",{\"1\":{\"242\":2}}],[\"edgedecisionresult\",{\"1\":{\"86\":1}}],[\"edgeround\",{\"1\":{\"86\":1}}],[\"edge\",{\"1\":{\"86\":2}}],[\"edges\",{\"0\":{\"46\":1},\"1\":{\"59\":1,\"75\":1,\"86\":2}}],[\"elephant\",{\"1\":{\"853\":2}}],[\"element\",{\"1\":{\"838\":21,\"850\":1}}],[\"elementtype\",{\"1\":{\"223\":1,\"227\":1,\"229\":3,\"230\":2,\"234\":2,\"236\":5,\"242\":2,\"927\":1}}],[\"elasticsearch\",{\"1\":{\"426\":1}}],[\"else的逻辑判断代码可以使用卫语句\",{\"1\":{\"852\":1}}],[\"else方式\",{\"1\":{\"852\":1}}],[\"else\",{\"1\":{\"90\":2,\"91\":1,\"92\":2,\"104\":4,\"114\":3,\"209\":1,\"242\":1,\"306\":1,\"310\":6,\"311\":1,\"312\":8,\"451\":2,\"524\":1,\"528\":1,\"533\":1,\"610\":4,\"613\":2,\"614\":1,\"618\":2,\"620\":1,\"627\":2,\"632\":1,\"649\":1,\"650\":2,\"659\":7,\"707\":1,\"708\":4,\"710\":4,\"738\":2,\"775\":3,\"778\":2,\"779\":4,\"780\":2,\"783\":1,\"790\":4,\"791\":2,\"847\":1,\"848\":1,\"852\":3,\"900\":1,\"901\":3,\"902\":1,\"911\":1}}],[\"eofexception\",{\"1\":{\"198\":1,\"261\":1}}],[\"e2\",{\"1\":{\"139\":3,\"141\":10,\"297\":2,\"689\":2}}],[\"e1\",{\"1\":{\"139\":3,\"141\":13,\"284\":3,\"297\":2}}],[\"eckel\",{\"1\":{\"153\":1}}],[\"eclipselink\",{\"1\":{\"420\":1}}],[\"eclipse\",{\"0\":{\"485\":1},\"1\":{\"407\":1,\"480\":1,\"484\":1,\"485\":1,\"663\":1,\"669\":1}}],[\"eclipse并不需要知道插件具体是怎样开发的\",{\"1\":{\"105\":1}}],[\"eclipse使用osgi作为插件系统的基础\",{\"1\":{\"105\":1}}],[\"echarts\",{\"0\":{\"23\":1}}],[\"ear\",{\"1\":{\"457\":1,\"461\":1}}],[\"earlier\",{\"1\":{\"104\":1}}],[\"eagerly\",{\"1\":{\"310\":1}}],[\"each\",{\"1\":{\"71\":1,\"310\":1}}],[\"equalto\",{\"1\":{\"978\":7}}],[\"equally\",{\"1\":{\"902\":1}}],[\"equal\",{\"1\":{\"474\":2,\"978\":1}}],[\"equalexample\",{\"1\":{\"138\":4,\"139\":5}}],[\"equals不能直接用于基本数据类型的比较\",{\"1\":{\"191\":1}}],[\"equals是object类的方法\",{\"1\":{\"191\":1}}],[\"equals与==的区别\",{\"0\":{\"191\":1}}],[\"equals方法遵循的原则\",{\"1\":{\"181\":1}}],[\"equals\",{\"0\":{\"138\":1,\"179\":1,\"180\":1,\"181\":1},\"1\":{\"71\":1,\"92\":1,\"103\":1,\"104\":1,\"137\":1,\"138\":16,\"139\":3,\"179\":2,\"180\":2,\"181\":10,\"190\":1,\"242\":3,\"308\":1,\"610\":4,\"613\":4,\"626\":1,\"637\":1,\"656\":1,\"708\":2,\"846\":1,\"848\":5,\"850\":1,\"872\":1}}],[\"equivalent\",{\"1\":{\"71\":1}}],[\"exclusive\",{\"1\":{\"852\":1}}],[\"exchanger详解\",{\"0\":{\"502\":1}}],[\"excel读写\",{\"1\":{\"432\":1}}],[\"exceptionfailtest\",{\"1\":{\"979\":2}}],[\"exceptiontypes\",{\"1\":{\"310\":1}}],[\"exceptiontest\",{\"1\":{\"276\":4,\"979\":4}}],[\"exception来实现\",{\"1\":{\"263\":1}}],[\"exception是因为java编译器要进行检查\",{\"1\":{\"198\":1}}],[\"exceptions\",{\"0\":{\"249\":2,\"448\":1},\"1\":{\"104\":1,\"198\":2,\"312\":2}}],[\"exception\",{\"0\":{\"248\":1},\"1\":{\"103\":2,\"104\":5,\"146\":3,\"150\":1,\"198\":2,\"241\":4,\"242\":6,\"246\":1,\"248\":1,\"252\":2,\"254\":1,\"257\":1,\"259\":1,\"266\":1,\"270\":1,\"271\":1,\"275\":14,\"276\":3,\"277\":1,\"288\":1,\"297\":1,\"305\":1,\"306\":1,\"312\":1,\"469\":1,\"687\":1,\"689\":3,\"779\":10,\"868\":1,\"902\":1,\"979\":7,\"980\":3}}],[\"exercise\",{\"1\":{\"997\":1}}],[\"executors返回的线程池对象的弊端如下\",{\"1\":{\"851\":1}}],[\"execute\",{\"1\":{\"242\":1,\"474\":1,\"561\":4,\"562\":8,\"563\":1,\"564\":1}}],[\"exe\",{\"1\":{\"770\":1}}],[\"exemplified\",{\"1\":{\"73\":1}}],[\"existed\",{\"1\":{\"852\":2}}],[\"exists\",{\"1\":{\"104\":2}}],[\"exit\",{\"1\":{\"197\":1,\"258\":1}}],[\"examine\",{\"1\":{\"145\":1}}],[\"example<\",{\"1\":{\"974\":1}}],[\"examples\",{\"1\":{\"77\":1}}],[\"example\",{\"1\":{\"71\":2,\"72\":1,\"74\":1,\"76\":1,\"77\":1,\"80\":1,\"82\":1,\"83\":3,\"140\":2,\"270\":2,\"306\":7,\"885\":1,\"939\":3}}],[\"externalizable\",{\"0\":{\"185\":1},\"1\":{\"185\":1}}],[\"external\",{\"1\":{\"145\":1}}],[\"extension\",{\"1\":{\"736\":1}}],[\"extensibility\",{\"1\":{\"145\":2}}],[\"extends\",{\"1\":{\"133\":1,\"134\":1,\"211\":2,\"213\":1,\"222\":1,\"230\":1,\"233\":5,\"241\":1,\"242\":1,\"254\":1,\"259\":1,\"279\":1,\"284\":15,\"287\":2,\"289\":1,\"291\":2,\"297\":4,\"298\":1,\"305\":2,\"307\":1,\"308\":1,\"312\":2,\"524\":1,\"532\":1,\"538\":1,\"542\":2,\"553\":1,\"555\":2,\"574\":3,\"580\":1,\"584\":9,\"609\":2,\"613\":6,\"636\":1,\"644\":4,\"656\":3,\"659\":5,\"672\":1,\"708\":2,\"710\":4,\"734\":3,\"738\":5,\"739\":4,\"776\":2,\"778\":4,\"779\":7,\"787\":2,\"788\":1,\"789\":3,\"801\":1,\"803\":3,\"812\":1,\"814\":1,\"833\":1,\"835\":1,\"839\":5,\"845\":1,\"850\":3,\"872\":1,\"911\":1}}],[\"extra列会出现\",{\"1\":{\"864\":1}}],[\"extraslibrary\",{\"1\":{\"452\":1}}],[\"extra\",{\"1\":{\"71\":3,\"294\":1,\"299\":1}}],[\"ex\",{\"1\":{\"103\":3,\"104\":2,\"234\":2,\"253\":3,\"257\":3}}],[\"explain表的结果\",{\"1\":{\"864\":1}}],[\"explicitly\",{\"1\":{\"618\":1}}],[\"explicit\",{\"1\":{\"74\":1}}],[\"expired\",{\"1\":{\"845\":2}}],[\"expstr\",{\"1\":{\"644\":9}}],[\"exp2\",{\"1\":{\"642\":1}}],[\"exp1\",{\"1\":{\"642\":1}}],[\"expectexception\",{\"1\":{\"979\":4}}],[\"expectedresult\",{\"1\":{\"981\":5}}],[\"expected<java\",{\"1\":{\"979\":1}}],[\"expectedarray\",{\"1\":{\"978\":1}}],[\"expected\",{\"1\":{\"950\":2,\"978\":4,\"979\":4}}],[\"expected=numberformatexception\",{\"1\":{\"241\":1}}],[\"expectations\",{\"1\":{\"477\":1}}],[\"exp\",{\"1\":{\"242\":3,\"642\":1}}],[\"expression4j\",{\"1\":{\"646\":1}}],[\"expression\",{\"1\":{\"642\":3,\"644\":20}}],[\"expressions\",{\"1\":{\"150\":1}}],[\"expressive\",{\"1\":{\"68\":2,\"431\":1}}],[\"exposure\",{\"1\":{\"145\":1}}],[\"e\",{\"1\":{\"71\":4,\"86\":1,\"91\":2,\"104\":6,\"134\":2,\"141\":6,\"152\":1,\"234\":2,\"241\":1,\"242\":7,\"253\":2,\"256\":4,\"257\":5,\"259\":1,\"263\":1,\"264\":12,\"267\":4,\"269\":3,\"270\":5,\"271\":4,\"275\":7,\"276\":1,\"284\":9,\"297\":3,\"309\":10,\"310\":5,\"312\":2,\"451\":3,\"469\":2,\"625\":1,\"627\":2,\"643\":2,\"687\":2,\"689\":2,\"742\":4,\"743\":4,\"779\":2,\"849\":1,\"858\":1,\"859\":2,\"860\":1,\"868\":2,\"901\":1,\"902\":1,\"907\":1,\"911\":1,\"946\":1}}],[\"ensure\",{\"1\":{\"732\":1}}],[\"ensurememberaccess\",{\"1\":{\"310\":1}}],[\"encoding=\",{\"1\":{\"974\":1}}],[\"encoding设置为utf\",{\"1\":{\"847\":1}}],[\"encodestr\",{\"1\":{\"848\":1}}],[\"encode\",{\"1\":{\"814\":5,\"848\":1}}],[\"encoded\",{\"1\":{\"73\":1}}],[\"enclosingone\",{\"1\":{\"201\":5}}],[\"enumerate\",{\"1\":{\"145\":1}}],[\"enumeration<url>\",{\"1\":{\"106\":1,\"114\":1}}],[\"enumeration\",{\"1\":{\"104\":1}}],[\"enum\",{\"1\":{\"130\":1,\"225\":1,\"227\":1,\"228\":1,\"302\":2,\"310\":2,\"626\":1,\"759\":1,\"779\":1,\"846\":1,\"872\":1,\"877\":1,\"915\":2,\"925\":1}}],[\"environments\",{\"1\":{\"145\":2}}],[\"environment\",{\"1\":{\"104\":1}}],[\"enough\",{\"1\":{\"104\":1}}],[\"entities\",{\"1\":{\"736\":1}}],[\"entity\",{\"0\":{\"73\":1},\"1\":{\"833\":1}}],[\"enterprise\",{\"1\":{\"414\":1,\"488\":1}}],[\"entered\",{\"1\":{\"78\":1}}],[\"entries\",{\"1\":{\"225\":1,\"312\":9}}],[\"entry是一个嵌套静态类\",{\"1\":{\"184\":1}}],[\"entryset\",{\"1\":{\"114\":1,\"850\":2}}],[\"entry<string\",{\"1\":{\"114\":1}}],[\"entry\",{\"1\":{\"104\":2,\"184\":1}}],[\"enables\",{\"1\":{\"310\":1}}],[\"enabled\",{\"1\":{\"77\":1}}],[\"enableall\",{\"1\":{\"13\":1}}],[\"engine\",{\"1\":{\"71\":1,\"150\":1}}],[\"enduml\",{\"1\":{\"213\":1,\"214\":1,\"215\":1,\"216\":1,\"217\":1,\"218\":1}}],[\"ending\",{\"1\":{\"86\":1}}],[\"end\",{\"1\":{\"71\":2,\"74\":5,\"75\":3,\"76\":3,\"86\":1,\"104\":1,\"600\":1,\"601\":2}}],[\"enhancer\",{\"1\":{\"703\":7}}],[\"enhance\",{\"1\":{\"13\":2}}],[\"müller\",{\"1\":{\"947\":1}}],[\"mname\",{\"1\":{\"937\":1}}],[\"mppserver应用中单独监控时区转换异常\",{\"1\":{\"859\":1}}],[\"mppserver\",{\"1\":{\"859\":3}}],[\"mpressure\",{\"1\":{\"676\":1,\"678\":1}}],[\"mm\",{\"1\":{\"849\":3,\"851\":1,\"853\":1,\"854\":2,\"859\":1}}],[\"mhumidity\",{\"1\":{\"676\":1,\"678\":1}}],[\"mtemperature\",{\"1\":{\"676\":1,\"678\":1}}],[\"m×n\",{\"1\":{\"537\":1}}],[\"m4\",{\"1\":{\"532\":2}}],[\"m3\",{\"1\":{\"532\":2}}],[\"m2\",{\"1\":{\"532\":2}}],[\"mvc\",{\"1\":{\"472\":1,\"655\":1}}],[\"m1\",{\"1\":{\"308\":3,\"532\":4}}],[\"mcellpublic\",{\"1\":{\"305\":2}}],[\"mcryeasy\",{\"1\":{\"305\":1,\"314\":1}}],[\"m\",{\"1\":{\"120\":4,\"153\":2,\"308\":15,\"311\":5,\"312\":1,\"537\":1,\"655\":1,\"664\":4,\"738\":11,\"739\":5,\"830\":3}}],[\"mylambda<string\",{\"1\":{\"907\":1}}],[\"myclass\",{\"1\":{\"901\":1,\"942\":1}}],[\"mycommand\",{\"1\":{\"560\":1}}],[\"mybatis\",{\"0\":{\"602\":1},\"1\":{\"420\":1,\"602\":1,\"873\":1}}],[\"mybusinessexception\",{\"1\":{\"266\":2,\"270\":2,\"271\":2}}],[\"myexception\",{\"1\":{\"253\":3,\"254\":3,\"257\":3}}],[\"mynotnull\",{\"1\":{\"236\":4}}],[\"mynotempty\",{\"1\":{\"236\":5}}],[\"mymethodannotation\",{\"1\":{\"234\":10}}],[\"mymethoddoc\",{\"1\":{\"229\":1}}],[\"mydriver\",{\"1\":{\"110\":2}}],[\"mysql并不是跳过offset行\",{\"1\":{\"864\":1}}],[\"mysql在windows下不区分大小写\",{\"1\":{\"863\":1}}],[\"mysql数据库\",{\"0\":{\"862\":1},\"1\":{\"843\":1}}],[\"mysql和postgresql的都被加载了\",{\"1\":{\"103\":1}}],[\"mysql和postgresql都有不同的实现提供给用户\",{\"1\":{\"95\":1}}],[\"mysql实现\",{\"0\":{\"100\":1}}],[\"mysql\",{\"1\":{\"98\":2,\"100\":1,\"102\":1,\"103\":2,\"145\":1,\"543\":1}}],[\"mf\",{\"1\":{\"105\":2}}],[\"monitor\",{\"1\":{\"859\":2}}],[\"moniter\",{\"1\":{\"832\":8}}],[\"money\",{\"1\":{\"845\":2}}],[\"month\",{\"1\":{\"618\":2,\"849\":1}}],[\"monad\",{\"1\":{\"403\":1}}],[\"mockery\",{\"1\":{\"477\":2}}],[\"mock\",{\"1\":{\"477\":3,\"767\":2,\"816\":2,\"930\":1,\"996\":8}}],[\"mockito\",{\"0\":{\"986\":1},\"1\":{\"431\":1}}],[\"mojarra是jsf标准的一个开源实现\",{\"1\":{\"384\":1}}],[\"modify\",{\"1\":{\"828\":1}}],[\"modification\",{\"1\":{\"736\":1}}],[\"modifier\",{\"1\":{\"133\":4,\"310\":1}}],[\"modifiers\",{\"1\":{\"91\":1,\"144\":1,\"310\":6,\"312\":7}}],[\"modifiersfield\",{\"1\":{\"91\":3}}],[\"modelversion>\",{\"1\":{\"974\":1}}],[\"modeling\",{\"1\":{\"822\":1}}],[\"model\",{\"1\":{\"310\":1,\"458\":1,\"655\":1,\"979\":3,\"980\":4}}],[\"move\",{\"1\":{\"218\":3}}],[\"movebehavior\",{\"1\":{\"214\":3,\"218\":4}}],[\"mouse\",{\"1\":{\"215\":2,\"832\":8}}],[\"more\",{\"1\":{\"31\":1,\"71\":1,\"72\":1,\"82\":1,\"209\":1,\"312\":1,\"446\":1,\"716\":1,\"978\":1,\"979\":1}}],[\"muellers\",{\"1\":{\"947\":1}}],[\"mutableinstance2\",{\"1\":{\"942\":1}}],[\"mutableinstance\",{\"1\":{\"942\":1}}],[\"mutablevalues\",{\"1\":{\"942\":1}}],[\"mutable\",{\"1\":{\"942\":1}}],[\"mutableelements\",{\"1\":{\"942\":1}}],[\"mutablecollection\",{\"1\":{\"942\":1}}],[\"mu\",{\"1\":{\"885\":1}}],[\"music\",{\"1\":{\"211\":1}}],[\"mustache\",{\"1\":{\"430\":1}}],[\"must\",{\"1\":{\"71\":1,\"78\":1,\"120\":1,\"310\":2,\"311\":2}}],[\"multitenant\",{\"1\":{\"426\":1}}],[\"multidirectional\",{\"1\":{\"70\":1}}],[\"multi\",{\"0\":{\"70\":1},\"1\":{\"902\":2}}],[\"multiple\",{\"1\":{\"68\":1,\"150\":1,\"955\":1}}],[\"much\",{\"1\":{\"68\":1}}],[\"mean\",{\"1\":{\"873\":1}}],[\"means\",{\"1\":{\"68\":1,\"104\":2}}],[\"menulist\",{\"1\":{\"854\":1}}],[\"meyer\",{\"1\":{\"736\":1}}],[\"mediatorpattern\",{\"1\":{\"656\":1}}],[\"mediator\",{\"1\":{\"591\":1,\"655\":1,\"656\":13,\"659\":32,\"798\":1}}],[\"mementopattern\",{\"1\":{\"664\":1}}],[\"memento\",{\"1\":{\"591\":1,\"663\":1,\"664\":12,\"667\":18,\"798\":1}}],[\"memory\",{\"0\":{\"485\":1},\"1\":{\"310\":1,\"485\":1,\"873\":1}}],[\"member\",{\"1\":{\"308\":1,\"310\":3,\"311\":12,\"877\":1}}],[\"members\",{\"1\":{\"145\":2,\"311\":6}}],[\"message来承载\",{\"1\":{\"857\":1}}],[\"messagepack\",{\"1\":{\"428\":1}}],[\"message\",{\"1\":{\"267\":1,\"270\":1,\"271\":1,\"854\":2,\"857\":1,\"858\":1,\"978\":8}}],[\"me\",{\"0\":{\"1002\":1},\"1\":{\"116\":1,\"242\":1,\"284\":1}}],[\"metrics\",{\"1\":{\"412\":1}}],[\"methodproxy\",{\"1\":{\"703\":3}}],[\"methodinterceptor\",{\"1\":{\"703\":2}}],[\"method=updateconfigfile\",{\"1\":{\"622\":1}}],[\"method=loadproperties\",{\"1\":{\"622\":1}}],[\"method3\",{\"1\":{\"596\":2}}],[\"methodref\",{\"1\":{\"312\":23}}],[\"methodfiltermap\",{\"1\":{\"311\":2}}],[\"methodaccessorimpl\",{\"1\":{\"312\":11}}],[\"methodaccessor\",{\"1\":{\"312\":13}}],[\"methodaccessorgenerator\",{\"1\":{\"310\":1,\"312\":3}}],[\"methodanno\",{\"1\":{\"234\":2}}],[\"method2需要依赖method1的执行\",{\"1\":{\"860\":1}}],[\"method2\",{\"1\":{\"308\":2,\"596\":2,\"741\":1}}],[\"method1\",{\"1\":{\"308\":6,\"596\":2,\"741\":1}}],[\"method类及其用法\",{\"0\":{\"308\":1}}],[\"method表示class对象所表示的类的成员方法\",{\"1\":{\"304\":1}}],[\"methodname\",{\"1\":{\"242\":2}}],[\"method和constructor\",{\"1\":{\"233\":1}}],[\"methodsorters\",{\"1\":{\"983\":2}}],[\"methods1\",{\"1\":{\"308\":1}}],[\"methods1=clazz\",{\"1\":{\"308\":1}}],[\"methodsignature\",{\"1\":{\"242\":4}}],[\"methods\",{\"1\":{\"145\":1,\"150\":1,\"234\":2,\"308\":2,\"311\":7,\"312\":5,\"851\":1}}],[\"method\",{\"0\":{\"611\":1},\"1\":{\"104\":1,\"145\":2,\"223\":1,\"224\":1,\"225\":1,\"227\":1,\"228\":1,\"229\":1,\"230\":1,\"234\":28,\"242\":5,\"252\":1,\"253\":1,\"257\":2,\"263\":1,\"266\":1,\"275\":17,\"284\":1,\"291\":5,\"308\":30,\"309\":4,\"310\":4,\"311\":16,\"312\":37,\"596\":2,\"608\":1,\"622\":4,\"700\":3,\"703\":6,\"741\":1,\"798\":1,\"800\":1,\"847\":2,\"848\":3,\"852\":2,\"858\":2,\"870\":2,\"877\":1,\"901\":2,\"955\":1,\"958\":1,\"979\":3,\"980\":5}}],[\"metaobject\",{\"1\":{\"602\":1}}],[\"meta\",{\"1\":{\"104\":2,\"105\":1,\"106\":1,\"114\":2}}],[\"mechanism\",{\"1\":{\"104\":1}}],[\"mechanisms\",{\"1\":{\"104\":1}}],[\"mermaidcli\",{\"1\":{\"87\":1}}],[\"mermaidtooltip\",{\"1\":{\"77\":1}}],[\"mermaid\",{\"0\":{\"25\":1},\"1\":{\"77\":2,\"85\":1,\"87\":2}}],[\"milliseconds\",{\"1\":{\"980\":1}}],[\"milk\",{\"1\":{\"581\":1,\"582\":1,\"583\":1,\"584\":4,\"585\":1}}],[\"mihalcea\",{\"1\":{\"442\":1}}],[\"mixin\",{\"1\":{\"434\":1}}],[\"misusecatchexception\",{\"1\":{\"275\":1}}],[\"missing\",{\"0\":{\"464\":1},\"1\":{\"225\":3}}],[\"miscutils\",{\"1\":{\"452\":1}}],[\"miscutil\",{\"1\":{\"452\":1}}],[\"misc\",{\"1\":{\"120\":1,\"310\":4,\"311\":1}}],[\"middle\",{\"1\":{\"71\":1}}],[\"minutes\",{\"1\":{\"659\":1}}],[\"minute\",{\"1\":{\"618\":1}}],[\"min\",{\"1\":{\"120\":1}}],[\"minimum\",{\"0\":{\"71\":1}}],[\"mind\",{\"1\":{\"68\":1,\"145\":1}}],[\"might\",{\"1\":{\"51\":1,\"80\":1,\"133\":1,\"310\":2}}],[\"mirror\",{\"1\":{\"51\":1}}],[\"msg\",{\"1\":{\"114\":6,\"254\":2,\"452\":1}}],[\"ms\",{\"1\":{\"32\":1,\"870\":1}}],[\"mdogdefault\",{\"1\":{\"305\":2}}],[\"mdogprotected\",{\"1\":{\"305\":2}}],[\"mdogprivate\",{\"1\":{\"305\":2}}],[\"mdogpublic\",{\"1\":{\"305\":3}}],[\"mdenhance\",{\"1\":{\"13\":1}}],[\"md\",{\"1\":{\"13\":2,\"243\":1,\"277\":1,\"299\":1,\"314\":1,\"656\":3}}],[\"march等来指代相应月份来进行传参或比较\",{\"1\":{\"849\":1}}],[\"martin\",{\"1\":{\"716\":1}}],[\"martijn\",{\"1\":{\"440\":1}}],[\"mark\",{\"1\":{\"440\":1,\"885\":1}}],[\"markdown\",{\"0\":{\"8\":1,\"9\":1,\"10\":1,\"11\":1},\"1\":{\"5\":1,\"8\":2,\"9\":3,\"10\":1,\"11\":3,\"12\":2,\"13\":1,\"14\":2,\"32\":1,\"33\":2,\"68\":1}}],[\"mario\",{\"1\":{\"440\":1}}],[\"magazine\",{\"1\":{\"440\":1}}],[\"magicaccessorimpl\",{\"1\":{\"312\":3}}],[\"mallet\",{\"1\":{\"418\":1}}],[\"mahout\",{\"1\":{\"413\":1}}],[\"maven包引入\",{\"0\":{\"974\":1}}],[\"maven坐标\",{\"1\":{\"873\":1}}],[\"maven默认使用central\",{\"1\":{\"401\":1}}],[\"maven是一款声明式构建及依赖管理工具\",{\"1\":{\"385\":1}}],[\"maven\",{\"0\":{\"458\":1,\"461\":1},\"1\":{\"385\":1,\"458\":5,\"459\":2,\"460\":2,\"461\":1,\"484\":1,\"974\":5}}],[\"ma\",{\"1\":{\"312\":5}}],[\"mac\",{\"1\":{\"820\":1}}],[\"macwx\",{\"1\":{\"277\":1}}],[\"machineerror\",{\"1\":{\"247\":1}}],[\"machine\",{\"1\":{\"145\":1,\"302\":1}}],[\"mapping\",{\"1\":{\"873\":1}}],[\"map<integer\",{\"1\":{\"850\":1}}],[\"map<long\",{\"1\":{\"773\":1}}],[\"map<string\",{\"1\":{\"242\":1,\"466\":2,\"850\":3,\"866\":1,\"942\":1}}],[\"maps和sets\",{\"1\":{\"466\":1}}],[\"maps\",{\"1\":{\"466\":1}}],[\"maple\",{\"1\":{\"440\":1}}],[\"mapdb\",{\"1\":{\"394\":1}}],[\"map源码解析\",{\"0\":{\"321\":1}}],[\"map\",{\"0\":{\"320\":1,\"321\":1,\"322\":1,\"323\":1},\"1\":{\"186\":1,\"242\":2,\"406\":1,\"445\":1,\"455\":1,\"466\":2,\"469\":1,\"627\":3,\"644\":4,\"838\":1,\"850\":6,\"866\":3}}],[\"makepriceevent\",{\"1\":{\"779\":5}}],[\"makes\",{\"1\":{\"310\":1}}],[\"make\",{\"1\":{\"145\":2,\"312\":1,\"803\":5}}],[\"making\",{\"1\":{\"68\":1,\"145\":1}}],[\"matchers\",{\"1\":{\"978\":2}}],[\"match\",{\"1\":{\"469\":1,\"863\":1}}],[\"math\",{\"1\":{\"120\":2,\"848\":1}}],[\"matters\",{\"1\":{\"312\":1}}],[\"matter\",{\"1\":{\"0\":1,\"312\":1}}],[\"mania\",{\"1\":{\"469\":1}}],[\"manimalpublic\",{\"1\":{\"305\":2}}],[\"manimalprotected\",{\"1\":{\"305\":1}}],[\"manimalprivate\",{\"1\":{\"305\":1}}],[\"manimaldefault\",{\"1\":{\"305\":1}}],[\"manifest\",{\"1\":{\"105\":1}}],[\"management\",{\"0\":{\"462\":1}}],[\"manage\",{\"1\":{\"242\":1}}],[\"manager层与service同机部署\",{\"1\":{\"868\":1}}],[\"manager层\",{\"1\":{\"860\":1,\"868\":1}}],[\"manager\",{\"1\":{\"145\":1}}],[\"man\",{\"1\":{\"209\":1,\"839\":12,\"852\":5}}],[\"many\",{\"1\":{\"68\":1,\"870\":1}}],[\"maxage=\",{\"1\":{\"854\":1}}],[\"maxage告诉服务器进行缓存\",{\"1\":{\"854\":1}}],[\"maximum\",{\"1\":{\"120\":1}}],[\"max\",{\"1\":{\"90\":2,\"120\":3,\"284\":1,\"845\":2,\"851\":3,\"852\":1,\"980\":1}}],[\"main\",{\"1\":{\"89\":3,\"91\":1,\"92\":1,\"96\":1,\"127\":2,\"144\":3,\"151\":1,\"201\":1,\"211\":2,\"234\":1,\"270\":2,\"275\":1,\"276\":1,\"281\":2,\"282\":1,\"284\":3,\"285\":1,\"288\":2,\"289\":2,\"290\":2,\"291\":1,\"298\":1,\"305\":2,\"306\":1,\"307\":1,\"308\":1,\"309\":1,\"524\":1,\"528\":1,\"532\":1,\"538\":1,\"542\":1,\"553\":1,\"555\":1,\"561\":1,\"562\":1,\"571\":2,\"574\":1,\"580\":1,\"584\":1,\"596\":1,\"600\":1,\"601\":1,\"609\":1,\"610\":1,\"613\":1,\"617\":1,\"618\":1,\"624\":1,\"632\":1,\"636\":1,\"637\":1,\"644\":1,\"649\":1,\"650\":1,\"656\":1,\"659\":1,\"664\":1,\"667\":1,\"672\":1,\"676\":1,\"678\":1,\"685\":1,\"687\":1,\"689\":1,\"695\":1,\"700\":1,\"703\":1,\"708\":1,\"710\":1,\"718\":4,\"723\":2,\"727\":2,\"728\":1,\"734\":2,\"738\":2,\"739\":1,\"742\":1,\"743\":1,\"752\":1,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"757\":1,\"758\":1,\"759\":1,\"776\":1,\"778\":1,\"779\":1,\"784\":1,\"789\":1,\"790\":1,\"801\":1,\"803\":1,\"838\":1,\"839\":1,\"847\":1,\"852\":1,\"979\":1}}],[\"made\",{\"1\":{\"71\":1}}],[\"maybe\",{\"1\":{\"915\":1}}],[\"maybegetfoowidget\",{\"1\":{\"450\":1}}],[\"mayers\",{\"1\":{\"797\":1}}],[\"may\",{\"1\":{\"71\":1,\"104\":2,\"120\":1,\"145\":5,\"310\":1,\"912\":1}}],[\"主流的linux服务器默认所支持最大fd数量为\",{\"1\":{\"870\":1}}],[\"主流操作系统的设计是将tcp\",{\"1\":{\"870\":1}}],[\"主版本号\",{\"1\":{\"869\":2}}],[\"主键冲突\",{\"1\":{\"874\":1}}],[\"主键或者唯一索引\",{\"1\":{\"864\":1}}],[\"主键索引名为pk\",{\"1\":{\"863\":1}}],[\"主人要看电视时\",{\"1\":{\"657\":1}}],[\"主板\",{\"1\":{\"549\":1}}],[\"主的目的是兼容性\",{\"1\":{\"518\":1}}],[\"主页\",{\"0\":{\"39\":1}}],[\"主题\",{\"1\":{\"549\":1}}],[\"主题建模等\",{\"1\":{\"418\":1}}],[\"主题包含了一个自定义徽章章可以使用\",{\"1\":{\"33\":1}}],[\"主题扩展了更多\",{\"1\":{\"13\":1}}],[\"主题扩展\",{\"0\":{\"13\":1}}],[\"主要目的是降低理解难度\",{\"1\":{\"835\":1}}],[\"主要看\",{\"1\":{\"743\":1}}],[\"主要阐述了有关继承的一些原则\",{\"1\":{\"732\":1}}],[\"主要针对抽象和程序整体框架的构建\",{\"1\":{\"721\":1}}],[\"主要用于一些独立于用例之间的准备工作\",{\"1\":{\"972\":1}}],[\"主要用于调用目标对象时\",{\"1\":{\"705\":1}}],[\"主要用于输出\",{\"1\":{\"305\":1}}],[\"主要使用在多线程编程中\",{\"1\":{\"704\":1}}],[\"主要有三种\",{\"1\":{\"692\":1}}],[\"主要有两种方式\",{\"1\":{\"301\":1}}],[\"主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树\",{\"1\":{\"642\":1}}],[\"主要包含解释方法\",{\"1\":{\"642\":1}}],[\"主要角色\",{\"1\":{\"608\":1,\"612\":1,\"616\":1}}],[\"主要缺点\",{\"1\":{\"518\":1,\"537\":1,\"549\":1,\"560\":1,\"567\":1,\"579\":1,\"593\":1,\"608\":1,\"612\":1,\"616\":1,\"629\":1,\"641\":1,\"648\":1,\"655\":1,\"663\":1,\"671\":1,\"682\":1,\"692\":1,\"707\":1,\"750\":1,\"775\":1,\"783\":1,\"800\":1,\"837\":1}}],[\"主要优点\",{\"1\":{\"518\":1,\"537\":1,\"549\":1,\"560\":1,\"567\":1,\"579\":1,\"593\":1,\"608\":1,\"612\":1,\"629\":1,\"641\":1,\"648\":1,\"655\":1,\"663\":1,\"671\":1,\"682\":1,\"692\":1,\"707\":1,\"741\":1,\"750\":1,\"775\":1,\"783\":1,\"800\":1,\"837\":1}}],[\"主要分为三类\",{\"1\":{\"518\":1}}],[\"主要集中于发现你的代码中可能导致产生\",{\"1\":{\"484\":1}}],[\"主要解决\",{\"1\":{\"427\":1}}],[\"主要做了三件事\",{\"1\":{\"310\":1}}],[\"主要是对访问控制进行转发\",{\"1\":{\"868\":1}}],[\"主要是实现抽象工厂中的多个抽象方法\",{\"1\":{\"616\":1}}],[\"主要是实现抽象工厂中的抽象方法\",{\"1\":{\"612\":1}}],[\"主要是定义了一个高层接口\",{\"1\":{\"594\":1}}],[\"主要是先获取\",{\"1\":{\"310\":1}}],[\"主要是被框架的开发人员使用\",{\"1\":{\"95\":2}}],[\"主要原因有三点\",{\"1\":{\"263\":1}}],[\"主要从\",{\"1\":{\"8\":1}}],[\"主要功能与配置演示\",{\"0\":{\"4\":1}}],[\"请先仔细阅读和理解\",{\"1\":{\"952\":1}}],[\"请先阅读\",{\"1\":{\"9\":1}}],[\"请见往下的第\",{\"1\":{\"911\":1}}],[\"请见\",{\"1\":{\"905\":1,\"915\":1,\"928\":1,\"946\":1}}],[\"请稍后重试\",{\"1\":{\"871\":1}}],[\"请稍等\",{\"1\":{\"778\":1}}],[\"请尽可能在应用端来解决类冲突和加载问题\",{\"1\":{\"869\":1}}],[\"请尽情添加其他意见并提交\",{\"1\":{\"443\":1}}],[\"请把等号条件的列前置\",{\"1\":{\"864\":1}}],[\"请把这些类放到它应该在的地方去并积极重构\",{\"1\":{\"452\":1}}],[\"请及时修正\",{\"1\":{\"860\":1}}],[\"请将该异常抛给它的调用者\",{\"1\":{\"858\":1}}],[\"请注意利用索引的有序性\",{\"1\":{\"864\":1}}],[\"请注意在双斜线之后有一个空格\",{\"1\":{\"847\":1}}],[\"请注明标记人与标记时间\",{\"1\":{\"853\":1}}],[\"请一并说明\",{\"1\":{\"853\":1}}],[\"请勿超过\",{\"1\":{\"852\":1}}],[\"请勿勾选use\",{\"1\":{\"847\":1}}],[\"请设置为\",{\"1\":{\"850\":1}}],[\"请放在init方法中\",{\"1\":{\"848\":1}}],[\"请不要在创建表时就分库分表\",{\"1\":{\"863\":1}}],[\"请不要在此场景打出error级别\",{\"1\":{\"859\":1}}],[\"请不要修改serialversionuid字段\",{\"1\":{\"848\":1}}],[\"请不要这样使用\",{\"1\":{\"29\":1}}],[\"请使用程序插入或者导入数据的方式来准备数据\",{\"1\":{\"860\":1}}],[\"请使用\",{\"1\":{\"802\":1}}],[\"请使用绝对链接\",{\"1\":{\"33\":1}}],[\"请下次再参加\",{\"1\":{\"778\":3}}],[\"请假流程等\",{\"1\":{\"707\":1}}],[\"请编写程序创建和\",{\"1\":{\"684\":1}}],[\"请中介者转发\",{\"1\":{\"656\":2}}],[\"请输入\",{\"1\":{\"644\":1}}],[\"请输入e的值\",{\"1\":{\"643\":1}}],[\"请输入d的值\",{\"1\":{\"643\":1}}],[\"请输入c的值\",{\"1\":{\"643\":1}}],[\"请输入b的值\",{\"1\":{\"643\":1}}],[\"请输入a的值\",{\"1\":{\"643\":1}}],[\"请输入表达式\",{\"1\":{\"643\":1,\"644\":1}}],[\"请考虑使用\",{\"1\":{\"450\":1}}],[\"请考虑用注解处理器的方式从它们的接口自动生成\",{\"1\":{\"447\":1}}],[\"请考虑构建器模式\",{\"1\":{\"446\":1}}],[\"请求版本过\",{\"1\":{\"874\":2}}],[\"请求版本不\",{\"1\":{\"874\":1}}],[\"请求并发数超出限制\",{\"1\":{\"874\":1}}],[\"请求次数超出限制\",{\"1\":{\"874\":1}}],[\"请求批量处理总个数\",{\"1\":{\"874\":1}}],[\"请求参数值超出允许\",{\"1\":{\"874\":1}}],[\"请求必填参数为空\",{\"1\":{\"874\":1}}],[\"请求资源不存在\",{\"1\":{\"854\":1}}],[\"请求要求身份验证\",{\"1\":{\"854\":1}}],[\"请求内容\",{\"1\":{\"854\":2}}],[\"请求方法已经表达动作意义\",{\"1\":{\"854\":1}}],[\"请求方法\",{\"1\":{\"854\":2}}],[\"请求无法响应\",{\"1\":{\"766\":1}}],[\"请求金额\",{\"1\":{\"710\":1}}],[\"请求类型\",{\"1\":{\"710\":1}}],[\"请求类\",{\"1\":{\"710\":2}}],[\"请求编号\",{\"1\":{\"710\":4}}],[\"请求的处理可能涉及多个处理对象\",{\"1\":{\"707\":1}}],[\"请求的地址\",{\"1\":{\"242\":1}}],[\"请求会自动进行传递\",{\"1\":{\"707\":1}}],[\"请求调用者需要与请求接收者解耦时\",{\"1\":{\"565\":1}}],[\"请求执行者\",{\"1\":{\"564\":1}}],[\"请求发起者\",{\"1\":{\"564\":1}}],[\"请求发送者与请求接收者消除彼此之间的耦合\",{\"1\":{\"560\":1}}],[\"请求者\",{\"1\":{\"561\":1}}],[\"请求\",{\"1\":{\"419\":1,\"874\":1}}],[\"请求库\",{\"1\":{\"419\":1}}],[\"请参考mysql官方保留字\",{\"1\":{\"863\":1}}],[\"请参考这篇文章\",{\"1\":{\"276\":1}}],[\"请参考java\",{\"1\":{\"236\":2}}],[\"请确保将原始异常设置为原因\",{\"1\":{\"271\":1}}],[\"请记住\",{\"1\":{\"237\":1}}],[\"请阅读\",{\"1\":{\"12\":1}}],[\"对同样的功能代码\",{\"1\":{\"991\":1}}],[\"对捕获的异常不做任何响应是很少正确的\",{\"1\":{\"950\":1}}],[\"对齐\",{\"1\":{\"908\":1}}],[\"对此并没有一个统一正确的标准\",{\"1\":{\"896\":1}}],[\"对剩余的非\",{\"1\":{\"885\":1}}],[\"对手册的页码\",{\"1\":{\"872\":1}}],[\"对修改闭合\",{\"1\":{\"871\":1}}],[\"对修改关闭\",{\"1\":{\"736\":1,\"738\":1,\"748\":2,\"791\":1}}],[\"对service层通用能力的下沉\",{\"1\":{\"868\":1}}],[\"对第三方平台封装的层\",{\"1\":{\"868\":1}}],[\"对多个dao的组合复用\",{\"1\":{\"868\":1}}],[\"对多个资源\",{\"1\":{\"851\":1}}],[\"对多表进行查询记录\",{\"1\":{\"865\":1}}],[\"对全库进行更新\",{\"1\":{\"861\":1}}],[\"对调用者来说\",{\"1\":{\"858\":1}}],[\"对大段代码进行try\",{\"1\":{\"858\":1}}],[\"对具体操作的定义\",{\"1\":{\"854\":1}}],[\"对具体类而非接口的依赖和硬编码的行为都会降低代码的灵活性\",{\"1\":{\"819\":1}}],[\"对子类的实现要求\",{\"1\":{\"853\":1}}],[\"对某个对象引用的volatile字段进行原子更新的类名为atomicreferencefieldupdater\",{\"1\":{\"845\":1}}],[\"对某个类只能存在一个对象实例\",{\"1\":{\"750\":1}}],[\"对软件来说\",{\"1\":{\"843\":1}}],[\"对软件测试的影响\",{\"1\":{\"737\":1}}],[\"对规约做了适当扩展和解释\",{\"1\":{\"843\":1}}],[\"对歌手进行测评\",{\"1\":{\"839\":1}}],[\"对该类右键\",{\"1\":{\"826\":1}}],[\"对整个代码的改动并不大\",{\"1\":{\"809\":1}}],[\"对每个不同的实现都需要定义一个子类\",{\"1\":{\"800\":1}}],[\"对银行工作人员进行评分等\",{\"1\":{\"800\":1}}],[\"对原来的功能没有影响\",{\"1\":{\"797\":2}}],[\"对请求做处理\",{\"1\":{\"776\":1}}],[\"对有状态的对象\",{\"1\":{\"775\":1}}],[\"对有返回值得方法操作\",{\"1\":{\"308\":1}}],[\"对这个新对象的所有方法调用\",{\"1\":{\"996\":1}}],[\"对这种有状态的对象编程\",{\"1\":{\"775\":1}}],[\"对这些简单对象与复合对象的处理\",{\"1\":{\"567\":1}}],[\"对自己依赖的类\",{\"1\":{\"741\":1}}],[\"对自定义注解log作切点进行拦截\",{\"1\":{\"242\":1}}],[\"对使用方\",{\"1\":{\"736\":1,\"748\":1}}],[\"对提供方\",{\"1\":{\"736\":1,\"748\":1}}],[\"对扩展开放\",{\"1\":{\"736\":1,\"748\":2,\"791\":1}}],[\"对类的局部改动\",{\"1\":{\"788\":1}}],[\"对类来说的\",{\"1\":{\"716\":1}}],[\"对类图的角色分析和说明\",{\"1\":{\"651\":1}}],[\"对比较长的职责链\",{\"1\":{\"707\":1}}],[\"对引用类型的属性\",{\"1\":{\"689\":1}}],[\"对备忘录进行管理\",{\"1\":{\"664\":1}}],[\"对终结符表达式的处理\",{\"1\":{\"642\":1}}],[\"对分层结构系统构建时\",{\"1\":{\"604\":1}}],[\"对外提供的开放接口\",{\"1\":{\"852\":1}}],[\"对外提供一个包裹所有上传\",{\"1\":{\"809\":1}}],[\"对外提供一个统一的接口用来访问子系统\",{\"1\":{\"590\":1}}],[\"对外除了提供的\",{\"1\":{\"741\":1}}],[\"对外屏蔽了子系统的细节\",{\"1\":{\"603\":1}}],[\"对源码中使用到的外观模式的角色类图\",{\"1\":{\"602\":1}}],[\"对源代码分析查找不良的编程习惯\",{\"1\":{\"388\":1}}],[\"对客户屏蔽了子系统组件\",{\"1\":{\"593\":1}}],[\"对客户端来说是透明的\",{\"1\":{\"569\":1}}],[\"对电灯的操作\",{\"1\":{\"562\":1}}],[\"对我们程序员来说\",{\"1\":{\"445\":1}}],[\"对运行中的应用程序信息提供了可视化界面\",{\"1\":{\"422\":1}}],[\"对opengl\",{\"1\":{\"404\":1}}],[\"对应于do类名也是单数形式\",{\"1\":{\"863\":1}}],[\"对应地\",{\"1\":{\"773\":1}}],[\"对应不同的\",{\"1\":{\"563\":1}}],[\"对应用程序而言\",{\"1\":{\"400\":1}}],[\"对应的属性名称是deleted\",{\"1\":{\"845\":1}}],[\"对应的类图\",{\"1\":{\"828\":1}}],[\"对应的代码如下\",{\"1\":{\"103\":1}}],[\"对应的代码是\",{\"1\":{\"103\":1}}],[\"对应的二进制如下\",{\"1\":{\"93\":1}}],[\"对过去一段时间内的数据进行统计\",{\"1\":{\"388\":1}}],[\"对相应开发者的帮助会更大\",{\"1\":{\"383\":1}}],[\"对带有指定参数的指定对象调用由此\",{\"1\":{\"308\":1}}],[\"对私有无参方法的操作\",{\"1\":{\"308\":1}}],[\"对异常进行文档说明\",{\"0\":{\"266\":1}}],[\"对异常的总结\",{\"1\":{\"260\":1}}],[\"对数组进行遍历的标准模式并不会导致冗余的检查\",{\"1\":{\"263\":1}}],[\"对任何不是\",{\"1\":{\"138\":1}}],[\"对称性\",{\"1\":{\"138\":1,\"181\":1}}],[\"对象将多个测试用例组装成一个测试套件\",{\"1\":{\"999\":1}}],[\"对象领域模型与底层数据之间的转换\",{\"1\":{\"873\":1}}],[\"对象关系映射\",{\"1\":{\"873\":1}}],[\"对象关联的方法\",{\"1\":{\"145\":1}}],[\"对象关联的字段\",{\"1\":{\"145\":1}}],[\"对象同时加锁时\",{\"1\":{\"851\":1}}],[\"对象clone方法默认是浅拷贝\",{\"1\":{\"848\":1}}],[\"对象结构包含很多类型的对象\",{\"1\":{\"841\":1}}],[\"对象结构中的对象需要提供多种不同且不相关的操作\",{\"1\":{\"841\":1}}],[\"对象结构相对稳定\",{\"1\":{\"841\":1}}],[\"对象结构角色\",{\"1\":{\"838\":1}}],[\"对象结构\",{\"1\":{\"838\":1}}],[\"对象图\",{\"1\":{\"822\":1}}],[\"对象了\",{\"1\":{\"771\":1}}],[\"对象间\",{\"1\":{\"744\":1}}],[\"对象间存在一对多关系\",{\"1\":{\"680\":1}}],[\"对象序列化\",{\"1\":{\"689\":1}}],[\"对象进行深拷贝要对整个对象\",{\"1\":{\"689\":1}}],[\"对象进行转型\",{\"1\":{\"138\":1}}],[\"对象复制一份\",{\"1\":{\"686\":1}}],[\"对象中\",{\"1\":{\"659\":1}}],[\"对象中解耦出来\",{\"1\":{\"562\":1}}],[\"对象在应用启动的时候就事先创建好\",{\"1\":{\"622\":1}}],[\"对象在真正被使用到的时候\",{\"1\":{\"622\":1}}],[\"对象创建和对象生命周期管理\",{\"1\":{\"622\":1}}],[\"对象生命周期的管理\",{\"1\":{\"621\":1}}],[\"对象封装到一个类中\",{\"1\":{\"609\":1}}],[\"对象使用到外观模式\",{\"1\":{\"602\":1}}],[\"对象什么都不做\",{\"1\":{\"562\":1}}],[\"对象适配器\",{\"1\":{\"534\":1}}],[\"对象适配器和类适配器其实算是同一种思想\",{\"1\":{\"529\":1}}],[\"对象适配器模式注意事项和细节\",{\"0\":{\"529\":1}}],[\"对象适配器模式应用实例\",{\"0\":{\"528\":1}}],[\"对象适配器模式是适配器模式常用的一种\",{\"1\":{\"527\":1}}],[\"对象适配器模式介绍\",{\"0\":{\"527\":1}}],[\"对象适配器模式\",{\"0\":{\"526\":1},\"1\":{\"518\":1,\"528\":1}}],[\"对象本身不是不可变的\",{\"1\":{\"451\":1}}],[\"对象不会意外地被重新赋值了\",{\"1\":{\"451\":1}}],[\"对象不支持客户请求的方法\",{\"1\":{\"265\":1}}],[\"对象表示的方法名称\",{\"1\":{\"308\":1}}],[\"对象表示的底层方法\",{\"1\":{\"308\":1}}],[\"对象表示的类或接口声明的所有方法\",{\"1\":{\"308\":1}}],[\"对象表示的字段\",{\"1\":{\"307\":1}}],[\"对象表示的字段的名称\",{\"1\":{\"307\":1}}],[\"对象表示的字段设置为指定的新值\",{\"1\":{\"307\":1}}],[\"对象表示的构造方法的类\",{\"1\":{\"306\":1}}],[\"对象表示此\",{\"1\":{\"306\":1}}],[\"对象所表示方法的正式返回类型的\",{\"1\":{\"308\":1}}],[\"对象所表示字段的声明类型\",{\"1\":{\"307\":1}}],[\"对象所表示的方法的正式返回类型\",{\"1\":{\"308\":1}}],[\"对象所表示的方法的形参类型的\",{\"1\":{\"308\":1}}],[\"对象所表示的方法的形参类型\",{\"1\":{\"306\":1,\"308\":1}}],[\"对象所表示的类或接口\",{\"1\":{\"308\":1}}],[\"对象所表示的类或接口的指定公共成员方法\",{\"1\":{\"308\":1}}],[\"对象所表示的类或接口的指定已声明方法\",{\"1\":{\"308\":1}}],[\"对象所表示的类的一个新实例\",{\"1\":{\"306\":1}}],[\"对象所表示的类的构造方法\",{\"1\":{\"304\":1,\"306\":1}}],[\"对象所表示构造方法的形参类型\",{\"1\":{\"306\":1}}],[\"对象都没有创建\",{\"1\":{\"296\":1}}],[\"对象检测到并发修改\",{\"1\":{\"265\":1}}],[\"对象应该是final的\",{\"1\":{\"173\":1}}],[\"对象引用在对象创建过程中不能泄露\",{\"1\":{\"173\":1}}],[\"对象必须被正确的创建\",{\"1\":{\"173\":1}}],[\"对象会占用更多的内存\",{\"1\":{\"168\":1}}],[\"对象支持加法运算\",{\"1\":{\"151\":1}}],[\"对象的编程处理方式\",{\"1\":{\"873\":1}}],[\"对象的代理对象\",{\"1\":{\"703\":1}}],[\"对象的代码就不需要修改了\",{\"1\":{\"609\":1}}],[\"对象的hashmap\",{\"1\":{\"659\":2}}],[\"对象的实例化推迟到子类\",{\"1\":{\"612\":1}}],[\"对象的类\",{\"1\":{\"610\":1}}],[\"对象的各个部件指定的接口\",{\"1\":{\"550\":1}}],[\"对象的状态是可变的\",{\"1\":{\"446\":1}}],[\"对象的数组\",{\"1\":{\"308\":3}}],[\"对象的一个方法\",{\"1\":{\"996\":1}}],[\"对象的一个数组\",{\"1\":{\"308\":1}}],[\"对象的一个类\",{\"1\":{\"302\":1}}],[\"对象的\",{\"1\":{\"209\":1,\"659\":1}}],[\"对象的加载\",{\"1\":{\"145\":1}}],[\"对象的那一方以为现在连接的是其它主机\",{\"1\":{\"123\":1}}],[\"对象\",{\"1\":{\"130\":1,\"145\":3,\"187\":1,\"210\":1,\"211\":1,\"302\":2,\"305\":1,\"306\":4,\"307\":2,\"308\":3,\"600\":1,\"644\":1,\"659\":1,\"682\":1,\"738\":2,\"739\":1,\"742\":1,\"743\":1,\"750\":1,\"770\":2,\"779\":1,\"790\":2,\"809\":2,\"826\":2,\"863\":1,\"996\":2}}],[\"对象已经被创建过了\",{\"1\":{\"123\":1}}],[\"对象操作\",{\"1\":{\"93\":1}}],[\"对于名为\",{\"1\":{\"960\":1}}],[\"对于最后一个语句组\",{\"1\":{\"922\":1}}],[\"对于同一段代码\",{\"1\":{\"906\":1}}],[\"对于多行注释\",{\"1\":{\"933\":1}}],[\"对于多个构造方法\",{\"1\":{\"897\":1}}],[\"对于多例模式\",{\"1\":{\"773\":1}}],[\"对于任何含有\",{\"1\":{\"884\":1}}],[\"对于任意一个对象\",{\"1\":{\"300\":1}}],[\"对于任意一个类\",{\"1\":{\"300\":1}}],[\"对于文件上传功能\",{\"1\":{\"861\":1}}],[\"对于存在csrf漏洞的应用\",{\"1\":{\"861\":1}}],[\"对于不可测的代码在适当的时机做必要的重构\",{\"1\":{\"860\":1}}],[\"对于不同版本的jdk\",{\"1\":{\"125\":1}}],[\"对于单元测试中单元的含义\",{\"1\":{\"989\":1}}],[\"对于单元测试\",{\"1\":{\"860\":1}}],[\"对于单例存在的其他问题\",{\"1\":{\"769\":1}}],[\"对于trace\",{\"1\":{\"859\":1}}],[\"对于当天日志\",{\"1\":{\"859\":1}}],[\"对于调用端解决问题的帮助不会太多\",{\"1\":{\"858\":1}}],[\"对于公司外的http\",{\"1\":{\"858\":1}}],[\"对于非空语句块和块状结构\",{\"1\":{\"901\":1}}],[\"对于非稳定代码的catch尽可能进行区分异常类型\",{\"1\":{\"858\":1}}],[\"对于非setter\",{\"1\":{\"845\":1}}],[\"对于暂时被注释掉\",{\"1\":{\"855\":1}}],[\"对于垃圾代码或过时配置\",{\"1\":{\"855\":1}}],[\"对于需要使用超大整数的场景\",{\"1\":{\"854\":1}}],[\"对于注释的要求\",{\"1\":{\"853\":1}}],[\"对于代码的理解至关重要\",{\"1\":{\"852\":1}}],[\"对于代码来说\",{\"1\":{\"635\":1}}],[\"对于session中获取的数据\",{\"1\":{\"858\":1}}],[\"对于service和dao类\",{\"1\":{\"845\":1}}],[\"对于sublist的所有操作最终会反映到原列表上\",{\"1\":{\"850\":1}}],[\"对于integer\",{\"1\":{\"848\":1}}],[\"对于继承结构比较复杂的代码\",{\"1\":{\"818\":1}}],[\"对于一个大型复杂系统来说\",{\"1\":{\"818\":1}}],[\"对于一些控制硬件级别的操作\",{\"1\":{\"762\":1}}],[\"对于一些需要频繁创建销毁的对象\",{\"1\":{\"761\":1}}],[\"对于会叫\",{\"1\":{\"813\":1}}],[\"对于这些不会飞的鸟来说\",{\"1\":{\"812\":1}}],[\"对于这些异常\",{\"1\":{\"261\":1}}],[\"对于是否应该在项目中使用继承\",{\"1\":{\"812\":1}}],[\"对于简单的程序开发\",{\"1\":{\"797\":1}}],[\"对于可以切换状态的状态模式\",{\"1\":{\"775\":1}}],[\"对于替代方案工厂模式\",{\"1\":{\"769\":1}}],[\"对于被依赖的类不管多么复杂\",{\"1\":{\"741\":1}}],[\"对于类似\",{\"1\":{\"960\":1}}],[\"对于类\",{\"1\":{\"721\":1,\"723\":1}}],[\"对于数据库中表记录的查询和变更\",{\"1\":{\"865\":1}}],[\"对于数据库相关的查询\",{\"1\":{\"860\":1}}],[\"对于数据类型是引用数据类型的成员变量\",{\"1\":{\"689\":1}}],[\"对于数据类型是基本数据类型的成员变量\",{\"1\":{\"689\":1}}],[\"对于数组\",{\"1\":{\"181\":1}}],[\"对于硬盘\",{\"1\":{\"635\":1}}],[\"对于新产品的创建\",{\"1\":{\"612\":1}}],[\"对于增加新的产品\",{\"1\":{\"606\":1}}],[\"对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统\",{\"1\":{\"545\":1}}],[\"对于系统的高层部分\",{\"1\":{\"544\":1}}],[\"对于用到这些api的程序而言\",{\"1\":{\"265\":1}}],[\"对于引用类型\",{\"1\":{\"138\":1,\"143\":1}}],[\"对于基本类型\",{\"1\":{\"138\":1,\"143\":1}}],[\"对于\",{\"1\":{\"33\":1,\"232\":1,\"762\":1}}],[\"对\",{\"1\":{\"12\":1,\"217\":1,\"463\":1,\"465\":1,\"543\":1,\"700\":1,\"736\":1}}],[\"为前缀\",{\"1\":{\"998\":1}}],[\"为\",{\"1\":{\"996\":1}}],[\"为变量赋值\",{\"1\":{\"981\":1}}],[\"为测试类声明一个使用注解\",{\"1\":{\"981\":2}}],[\"为测试类声明一个带有参数的公共构造函数\",{\"1\":{\"981\":2}}],[\"为测试类声明几个变量\",{\"1\":{\"981\":1}}],[\"为准备使用参数化测试的测试类指定特殊的运行器\",{\"1\":{\"981\":1}}],[\"为避免应用二方库的依赖冲突问题\",{\"1\":{\"869\":1}}],[\"为真时\",{\"1\":{\"859\":1}}],[\"为频次发生的特点\",{\"1\":{\"859\":1}}],[\"为binaryoperator\",{\"1\":{\"850\":1}}],[\"为对象结构中的元素添加新的功能\",{\"1\":{\"837\":1}}],[\"为对象添加新功能\",{\"1\":{\"590\":1}}],[\"为数据结构中的每个元素提供多种访问方式\",{\"1\":{\"837\":1}}],[\"为目的\",{\"1\":{\"818\":1}}],[\"为实现类定义抽象的接口\",{\"1\":{\"809\":1}}],[\"为一个集合中的每个元素提供多种访问方式\",{\"1\":{\"798\":1}}],[\"为一个对象提供一个替身\",{\"1\":{\"692\":1}}],[\"为某对象提供一种代理以控制对该对象的访问\",{\"1\":{\"798\":1}}],[\"为所有引用数据类型的成员变量申请存储空间\",{\"1\":{\"689\":1}}],[\"为遍历不同的聚合结构提供一个统一的接口\",{\"1\":{\"648\":1}}],[\"为具体享元规范需要实现的公共接口\",{\"1\":{\"632\":1}}],[\"为具体构件角色增加额外的功能addedfunction\",{\"1\":{\"580\":1}}],[\"为多个复杂的子系统提供一个一致的接口\",{\"1\":{\"798\":1}}],[\"为多个子系统对外提供一个共同的接口\",{\"1\":{\"595\":1}}],[\"为多种技术提供集成化支持\",{\"1\":{\"407\":1}}],[\"为其他对象提供一种代理以控制对这个对象的访问\",{\"1\":{\"590\":1}}],[\"为其提供额外的功能\",{\"1\":{\"580\":1}}],[\"为抽象建造者\",{\"1\":{\"556\":1}}],[\"为运行进行提供cli\",{\"1\":{\"432\":1}}],[\"为web应用程序提供可移植软件测试框架\",{\"1\":{\"431\":1}}],[\"为selenium提供精准的周边api\",{\"1\":{\"431\":1}}],[\"为sql\",{\"1\":{\"394\":1}}],[\"为rest\",{\"1\":{\"431\":1}}],[\"为tdd或bdd提供支持\",{\"1\":{\"431\":1}}],[\"为浏览器应用和restful\",{\"1\":{\"427\":1}}],[\"为高吞吐量通信进行了优化\",{\"1\":{\"426\":1}}],[\"为开发者提供功能强大\",{\"1\":{\"420\":1}}],[\"为跨平台部署建立创作工具\",{\"1\":{\"401\":1}}],[\"为jvm提供轻量级线程和角色\",{\"1\":{\"399\":1}}],[\"为jdk提供更具特点的时间和日期api\",{\"1\":{\"396\":1}}],[\"为flatzinc语言提供了一个接口\",{\"1\":{\"391\":1}}],[\"为获取匹配的构造方器\",{\"1\":{\"310\":1}}],[\"为何\",{\"1\":{\"292\":1}}],[\"为object\",{\"1\":{\"289\":1}}],[\"为number\",{\"1\":{\"289\":1}}],[\"为什么说是语言呢\",{\"1\":{\"823\":1}}],[\"为什么不推荐使用继承\",{\"0\":{\"812\":1},\"1\":{\"811\":1}}],[\"为什么不能扩展throwable\",{\"1\":{\"297\":1}}],[\"为什么不能存别的类型呢\",{\"1\":{\"290\":1}}],[\"为什么这么说呢\",{\"1\":{\"764\":1}}],[\"为什么要写单元测试\",{\"0\":{\"990\":1}}],[\"为什么要使用泛型方法呢\",{\"1\":{\"283\":1}}],[\"为什么要使用接口而不是直接使用具体类\",{\"0\":{\"188\":1}}],[\"为什么要用变量c来创建对象呢\",{\"1\":{\"283\":1}}],[\"为什么会有这样的争议\",{\"1\":{\"812\":1}}],[\"为什么会这样呢\",{\"1\":{\"291\":1}}],[\"为什么会引入泛型\",{\"0\":{\"279\":1}}],[\"为什么会耗时\",{\"0\":{\"276\":1}}],[\"为什么在重写\",{\"0\":{\"179\":1}}],[\"为什么\",{\"0\":{\"169\":1}}],[\"为什么注释中的代码会被执行\",{\"1\":{\"89\":1}}],[\"为了提高代码的可预测性\",{\"1\":{\"947\":1}}],[\"为了遵守这条严格的要求\",{\"1\":{\"905\":1}}],[\"为了更方便地进行单元测试\",{\"1\":{\"860\":1}}],[\"为了更好的使用\",{\"1\":{\"443\":1}}],[\"为了不受外界环境影响\",{\"1\":{\"860\":1}}],[\"为了保护用户隐私\",{\"1\":{\"859\":1}}],[\"为了保证单元测试稳定可靠且便于维护\",{\"1\":{\"860\":1}}],[\"为了保证任何时刻\",{\"1\":{\"772\":1}}],[\"为了保证全局唯一\",{\"1\":{\"769\":1}}],[\"为了保证类型安全\",{\"1\":{\"287\":1}}],[\"为了达到代码自解释的目标\",{\"1\":{\"845\":1}}],[\"为了让重构能小步快跑\",{\"1\":{\"818\":1}}],[\"为了支持多态\",{\"1\":{\"814\":1}}],[\"为了满足这条原则\",{\"1\":{\"810\":1}}],[\"为了满足这样一个需求的变化\",{\"1\":{\"809\":1}}],[\"为了满足里式替换原则\",{\"1\":{\"135\":1}}],[\"为了代码复用\",{\"1\":{\"809\":1}}],[\"为了实现这样的目的\",{\"1\":{\"766\":1}}],[\"为了实现深克隆\",{\"1\":{\"682\":1}}],[\"为了解决这个问题\",{\"1\":{\"766\":1}}],[\"为了解决泛型中隐含的转换问题\",{\"1\":{\"284\":1}}],[\"为了应对这个需求变化\",{\"1\":{\"764\":1}}],[\"为了交互对象之间的松耦合设计而努力\",{\"1\":{\"746\":1}}],[\"为了避免请求发送者与多个请求处理者耦合在一起\",{\"1\":{\"707\":1}}],[\"为了避免这种情况\",{\"1\":{\"183\":1}}],[\"为了节约内存\",{\"1\":{\"668\":1}}],[\"为了使对象可以共享\",{\"1\":{\"629\":1}}],[\"为了简化代码实现\",{\"1\":{\"624\":1}}],[\"为了方便\",{\"1\":{\"617\":4}}],[\"为了产生class引用\",{\"1\":{\"305\":1}}],[\"为了获得最大限度的灵活性\",{\"1\":{\"284\":1}}],[\"为了和同事更好的合作\",{\"1\":{\"262\":1}}],[\"为了验证应用了这三种策略的注解类有何区别\",{\"1\":{\"228\":1}}],[\"为了兼容\",{\"1\":{\"151\":1}}],[\"为了丰富文档写作\",{\"1\":{\"12\":1}}],[\"为指定的服务使用指定的类加载器来创建一个serviceloader\",{\"1\":{\"114\":1}}],[\"为每个具体元素类对应一个访问操作\",{\"1\":{\"838\":1}}],[\"为每个\",{\"1\":{\"10\":1}}],[\"扩展名组成\",{\"1\":{\"880\":1}}],[\"扩展说明\",{\"1\":{\"854\":1}}],[\"扩展说一下pecs\",{\"1\":{\"850\":1}}],[\"扩展可变部分\",{\"1\":{\"800\":1}}],[\"扩展困难\",{\"1\":{\"750\":1}}],[\"扩展一个类的功能会使用继承方式来实现\",{\"1\":{\"580\":1}}],[\"扩展性\",{\"0\":{\"820\":1},\"1\":{\"769\":1}}],[\"扩展性都不理想\",{\"1\":{\"658\":1}}],[\"扩展性良好\",{\"1\":{\"560\":1}}],[\"扩展性好\",{\"1\":{\"549\":1,\"641\":1,\"837\":1}}],[\"扩展性问题\",{\"1\":{\"541\":1}}],[\"扩展抽象化角色\",{\"1\":{\"538\":1}}],[\"扩展抽象化\",{\"1\":{\"538\":2}}],[\"扩展能力强\",{\"1\":{\"537\":1}}],[\"扩展方法\",{\"1\":{\"187\":1}}],[\"扩展\",{\"0\":{\"11\":1,\"12\":1},\"1\":{\"12\":1,\"861\":1}}],[\"中执行的命令\",{\"1\":{\"905\":1}}],[\"中很长的方法引用\",{\"1\":{\"905\":1}}],[\"中很重要的一个概念\",{\"1\":{\"10\":1}}],[\"中文描述\",{\"1\":{\"874\":1}}],[\"中国大陆许可协议\",{\"1\":{\"993\":1}}],[\"中国大陆个人手机号码显示\",{\"1\":{\"861\":1}}],[\"中国顶级大学\",{\"1\":{\"574\":1}}],[\"中方法\",{\"1\":{\"839\":1}}],[\"中间没有其它成员\",{\"1\":{\"897\":1}}],[\"中间件服务出错\",{\"1\":{\"874\":1}}],[\"中间件通用处理\",{\"1\":{\"868\":1}}],[\"中间件等\",{\"1\":{\"860\":1}}],[\"中间件错误是二级\",{\"1\":{\"857\":1}}],[\"中间的感叹号\",{\"1\":{\"855\":1}}],[\"中间的部分标识类的属性\",{\"1\":{\"826\":1}}],[\"中间层次的优点在于模式提供的复用方式要比框架的风险小\",{\"1\":{\"819\":1}}],[\"中间层的引入明显地简化了依赖关系\",{\"1\":{\"818\":1}}],[\"中间层\",{\"1\":{\"818\":1}}],[\"中间层等解耦代码\",{\"0\":{\"815\":1}}],[\"中间构件\",{\"1\":{\"568\":1}}],[\"中定义的\",{\"1\":{\"809\":1}}],[\"中模板文件等\",{\"1\":{\"800\":1}}],[\"中奖机会\",{\"1\":{\"778\":1}}],[\"中奖概率是\",{\"1\":{\"777\":1}}],[\"中由程序员自己负责\",{\"1\":{\"769\":1}}],[\"中内存对象的释放由\",{\"1\":{\"769\":1}}],[\"中内存泄露也时有发生\",{\"1\":{\"485\":1}}],[\"中只存在单一实例\",{\"1\":{\"762\":1}}],[\"中添加的枚举来实现单例模式\",{\"1\":{\"759\":1}}],[\"中提出\",{\"1\":{\"736\":1}}],[\"中出现的方法\",{\"1\":{\"723\":1}}],[\"中就存在属性的延迟加载和关联表的延时加载\",{\"1\":{\"705\":1}}],[\"中生成代理对象的\",{\"0\":{\"699\":1}}],[\"中也实现\",{\"1\":{\"695\":1}}],[\"中原型\",{\"1\":{\"688\":1}}],[\"中介者对象本身变得过于复杂\",{\"1\":{\"660\":1}}],[\"中介者承担了较多的责任\",{\"1\":{\"660\":1}}],[\"中介者在这个方法\",{\"1\":{\"659\":1}}],[\"中介者抽象类\",{\"1\":{\"659\":1}}],[\"中介者类\",{\"1\":{\"659\":1}}],[\"中介者就会越臃肿\",{\"1\":{\"655\":1}}],[\"中介者\",{\"1\":{\"655\":2}}],[\"中介者使各个对象不需要显式地相互引用\",{\"1\":{\"655\":1}}],[\"中介者模式减少类间依赖\",{\"1\":{\"660\":1}}],[\"中介者模式的应用场景\",{\"0\":{\"661\":1}}],[\"中介者模式的注意事项和细节\",{\"0\":{\"660\":1}}],[\"中介者模式的结构图如下所示\",{\"1\":{\"656\":1}}],[\"中介者模式的结构与实现\",{\"0\":{\"656\":1}}],[\"中介者模式解决智能家庭项目\",{\"0\":{\"659\":1}}],[\"中介者模式包含以下主要角色\",{\"1\":{\"656\":1}}],[\"中介者模式将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系\",{\"1\":{\"655\":1}}],[\"中介者模式属于行为型模式\",{\"1\":{\"655\":1}}],[\"中介者模式基本介绍\",{\"0\":{\"655\":1}}],[\"中介者模式\",{\"1\":{\"591\":1,\"655\":2,\"658\":1,\"798\":1}}],[\"中介对象来封装一系列的对象交互\",{\"1\":{\"655\":1}}],[\"中还有没有下一个元素\",{\"1\":{\"650\":1}}],[\"中山大学\",{\"1\":{\"649\":1}}],[\"中可以用\",{\"1\":{\"646\":1}}],[\"中取出返回\",{\"1\":{\"627\":1}}],[\"中取得引用\",{\"1\":{\"123\":1}}],[\"中加载\",{\"1\":{\"625\":1}}],[\"中最简单实用的模式\",{\"1\":{\"608\":1}}],[\"中都会暴露出来\",{\"1\":{\"525\":1}}],[\"中用类型安全的方式编写\",{\"1\":{\"474\":1}}],[\"中用过像\",{\"1\":{\"472\":1}}],[\"中糟糕的样板代码\",{\"1\":{\"471\":1}}],[\"中但缺失的一些特性\",{\"1\":{\"469\":1}}],[\"中排除对\",{\"1\":{\"459\":1}}],[\"中为了开发可测试软件\",{\"1\":{\"449\":1}}],[\"中是不能创建一个确切的泛型类型的数组的\",{\"1\":{\"294\":1}}],[\"中处理异常并不是一个简单的事情\",{\"1\":{\"262\":1}}],[\"中抛出一个异常\",{\"1\":{\"253\":1}}],[\"中限制一个类只能继承一个类\",{\"1\":{\"189\":1}}],[\"中你可以在接口声明静态方法和默认普通方法\",{\"1\":{\"188\":1}}],[\"中有\",{\"1\":{\"186\":1}}],[\"中有三个访问权限修饰符\",{\"1\":{\"132\":1}}],[\"中会有冲突\",{\"1\":{\"175\":1}}],[\"中怎么创建一个不可变对象\",{\"0\":{\"173\":1}}],[\"中怎样将\",{\"0\":{\"160\":1}}],[\"中应该使用什么数据类型来代表价格\",{\"0\":{\"158\":1}}],[\"中\",{\"0\":{\"164\":1,\"178\":1,\"185\":1,\"189\":1},\"1\":{\"113\":2,\"120\":1,\"125\":2,\"139\":1,\"145\":1,\"161\":1,\"187\":1,\"189\":1,\"263\":1,\"306\":1,\"449\":1,\"477\":2,\"574\":1,\"600\":1,\"627\":2,\"637\":2,\"677\":1,\"686\":1,\"725\":1,\"743\":1,\"760\":1,\"809\":2,\"824\":1,\"825\":1,\"839\":1,\"852\":2,\"877\":1}}],[\"中使用随机数字吗\",{\"0\":{\"177\":1}}],[\"中使用字符串的\",{\"1\":{\"170\":1}}],[\"中使用字符串\",{\"1\":{\"170\":1}}],[\"中使用\",{\"0\":{\"170\":1},\"1\":{\"14\":2,\"213\":1,\"214\":1}}],[\"中的很长的\",{\"1\":{\"905\":1}}],[\"中的api\",{\"1\":{\"859\":2}}],[\"中的商品\",{\"1\":{\"837\":1}}],[\"中的某些方法来完成一些职责\",{\"1\":{\"828\":1}}],[\"中的类图有以下几种关系\",{\"1\":{\"827\":1}}],[\"中的每个容器都存在多种布局供用户选择\",{\"1\":{\"792\":1}}],[\"中的容器布局管理就是一个典型的实例\",{\"1\":{\"792\":1}}],[\"中的配置对象\",{\"1\":{\"762\":1}}],[\"中的配置文件\",{\"1\":{\"95\":1}}],[\"中的继承性的思考和说明\",{\"0\":{\"731\":1}}],[\"中的后退键\",{\"1\":{\"663\":1}}],[\"中的反射语法\",{\"1\":{\"627\":1}}],[\"中的代码会不会线性膨胀\",{\"1\":{\"622\":1}}],[\"中的代码作死小技巧\",{\"1\":{\"88\":1}}],[\"中的元素\",{\"1\":{\"571\":1}}],[\"中的属性动画\",{\"1\":{\"532\":1}}],[\"中的原始异常\",{\"1\":{\"271\":1}}],[\"中的三个新特性\",{\"0\":{\"186\":1}}],[\"中的编译期常量是什么\",{\"0\":{\"183\":1}}],[\"中的构造器链\",{\"1\":{\"171\":1}}],[\"中的构造器链是什么\",{\"0\":{\"171\":1}}],[\"中的\",{\"0\":{\"169\":1},\"1\":{\"12\":1,\"169\":1,\"259\":1,\"420\":1,\"533\":1,\"602\":1,\"618\":1,\"650\":1,\"767\":1,\"808\":1,\"809\":1}}],[\"中设置一个最大节点数量\",{\"1\":{\"711\":1}}],[\"中设置页面信息\",{\"1\":{\"32\":1}}],[\"中设置\",{\"1\":{\"0\":1}}],[\"是在现有类的基础上包装了一个对象\",{\"1\":{\"996\":1}}],[\"是在调用方法的时候指明泛型的具体类型\",{\"1\":{\"283\":1}}],[\"是无中生有地生出一个完全虚拟的对象\",{\"1\":{\"996\":1}}],[\"是什么意思\",{\"1\":{\"960\":1}}],[\"是名词短语或者动词短语\",{\"1\":{\"958\":1}}],[\"是非法的\",{\"1\":{\"921\":1}}],[\"是非享元角色\",{\"1\":{\"632\":1}}],[\"是合法的\",{\"1\":{\"921\":1}}],[\"是越少越好的\",{\"1\":{\"907\":1}}],[\"是源文件中唯一允许出现的空格字符\",{\"1\":{\"883\":1}}],[\"是必须的\",{\"1\":{\"866\":1}}],[\"是sql92定义的标准统计行数的语法\",{\"1\":{\"865\":1}}],[\"是spi思想的一种体现\",{\"1\":{\"105\":1}}],[\"是程序员的基本修养\",{\"1\":{\"858\":1}}],[\"是程序运行时错误\",{\"1\":{\"146\":1}}],[\"是编号\",{\"1\":{\"857\":1}}],[\"是编程中\",{\"1\":{\"736\":1}}],[\"是可选的\",{\"1\":{\"960\":1}}],[\"是可以解决变量同步问题\",{\"1\":{\"851\":1}}],[\"是可变的\",{\"1\":{\"123\":1}}],[\"是阿里巴巴和开课吧技术团队的集体智慧结晶和经验总结\",{\"1\":{\"843\":1}}],[\"是行为类模式中最复杂的一种模式\",{\"1\":{\"837\":1}}],[\"是is\",{\"1\":{\"835\":1}}],[\"是immutable的\",{\"1\":{\"192\":1}}],[\"是父类与子类之间的关系\",{\"1\":{\"833\":1}}],[\"是组合的弱引用\",{\"1\":{\"832\":1}}],[\"是组合中的分支节点对象\",{\"1\":{\"568\":1}}],[\"是组合中的叶节点对象\",{\"1\":{\"568\":1}}],[\"是整体和部分之间的关系\",{\"1\":{\"831\":1}}],[\"是整个算法中的一个步骤\",{\"1\":{\"801\":1}}],[\"是强关联关系\",{\"1\":{\"831\":1}}],[\"是临时性的关联\",{\"1\":{\"828\":1}}],[\"是用来唯一标识jar包\",{\"1\":{\"873\":1}}],[\"是用来显示系统中的类\",{\"1\":{\"826\":1}}],[\"是用来判断两个对象是否等价\",{\"1\":{\"139\":1}}],[\"是大家比较推崇的一种标准而已\",{\"1\":{\"823\":1}}],[\"是功能提供者提供给使用者的一个\",{\"1\":{\"808\":1}}],[\"是经典的书\",{\"1\":{\"795\":1}}],[\"是变化\",{\"1\":{\"778\":1}}],[\"是线程\",{\"1\":{\"771\":1}}],[\"是线程安全的\",{\"1\":{\"124\":1}}],[\"是以局部变量方式出现在\",{\"1\":{\"742\":1}}],[\"是以怎样的方式存放\",{\"1\":{\"650\":1}}],[\"是以怎样的形式给到\",{\"1\":{\"534\":1}}],[\"是求减法\",{\"1\":{\"734\":1}}],[\"是利用\",{\"1\":{\"698\":1}}],[\"是最终要引用的对象\",{\"1\":{\"694\":1}}],[\"是最快速的消息格式之一\",{\"1\":{\"395\":1}}],[\"是代理对象所代表的真实对象\",{\"1\":{\"694\":1}}],[\"是引用类型\",{\"1\":{\"689\":1}}],[\"是对所有实现类都有价值的默认实现\",{\"1\":{\"845\":1}}],[\"是对类的封装性\",{\"1\":{\"797\":1}}],[\"是对软件设计中\",{\"1\":{\"796\":1}}],[\"是对实现抽象化的具体步骤的规范\",{\"1\":{\"732\":1}}],[\"是对开闭原则的补充\",{\"1\":{\"732\":1}}],[\"是对象\",{\"1\":{\"687\":1,\"771\":1}}],[\"是对简单工厂模式的进一步抽象化\",{\"1\":{\"612\":1}}],[\"是类型\",{\"1\":{\"732\":1}}],[\"是类\",{\"1\":{\"679\":2}}],[\"是由\",{\"1\":{\"676\":1,\"678\":2}}],[\"是常用的设计模式\",{\"1\":{\"648\":1}}],[\"是常用的日志库门面\",{\"1\":{\"104\":1}}],[\"是残疾人还是正常人等信息\",{\"1\":{\"648\":1}}],[\"是让其子类来实现\",{\"1\":{\"644\":1}}],[\"是其中的一个句子\",{\"1\":{\"641\":1}}],[\"是语言集中的元素\",{\"1\":{\"641\":1}}],[\"是享元工厂角色\",{\"1\":{\"632\":1}}],[\"是具体享元角色\",{\"1\":{\"632\":1}}],[\"是具体命令对象业务的真正实现者\",{\"1\":{\"561\":1}}],[\"是所有的具体享元类的基类\",{\"1\":{\"632\":1}}],[\"是所有异常和错误的超类\",{\"1\":{\"268\":1}}],[\"是如何设计和实现的\",{\"1\":{\"627\":1}}],[\"是如何实现的\",{\"1\":{\"564\":1}}],[\"是接口的实现类\",{\"1\":{\"625\":1}}],[\"是接口\",{\"1\":{\"625\":1}}],[\"是工厂方法模式的升级版本\",{\"1\":{\"616\":1}}],[\"是工厂模式的一种\",{\"1\":{\"608\":1}}],[\"是简单工厂模式的创建目标\",{\"1\":{\"608\":1}}],[\"是简单工厂模式的核心\",{\"1\":{\"608\":1}}],[\"是简单工厂创建的所有对象的父类\",{\"1\":{\"608\":1}}],[\"是电视机的开和关的操作\",{\"1\":{\"562\":1}}],[\"是电灯的开和关的操作\",{\"1\":{\"562\":1}}],[\"是请求的发送者\",{\"1\":{\"561\":1}}],[\"是抽象同事类的实现者\",{\"1\":{\"656\":1}}],[\"是抽象表达式的子类\",{\"1\":{\"642\":1}}],[\"是抽象享元角色\",{\"1\":{\"632\":1}}],[\"是抽象类\",{\"1\":{\"585\":1}}],[\"是抽象命令类的具体实现类\",{\"1\":{\"561\":1}}],[\"是抽象化角色的子类\",{\"1\":{\"538\":1}}],[\"是命令\",{\"1\":{\"560\":1}}],[\"是被调用者\",{\"1\":{\"560\":1}}],[\"是调用者\",{\"1\":{\"560\":1}}],[\"是服务于人类社会的\",{\"1\":{\"545\":1}}],[\"是指对软件中的最小可测试单元进行检查和验证\",{\"1\":{\"988\":1,\"989\":1}}],[\"是指捆绑了几个单元测试用例并运行起来\",{\"1\":{\"982\":1}}],[\"是指线程内只允许创建一个对象\",{\"1\":{\"770\":1}}],[\"是指给定一个语言\",{\"1\":{\"641\":1}}],[\"是指\",{\"1\":{\"537\":1,\"682\":1,\"725\":1}}],[\"是根据\",{\"1\":{\"534\":1}}],[\"是单继承机制\",{\"1\":{\"525\":1}}],[\"是解耦的\",{\"1\":{\"520\":1}}],[\"是我用过的最好用的解决内存泄露问题的工具\",{\"1\":{\"485\":1}}],[\"是我用过的最简单的时间处理库\",{\"1\":{\"470\":1}}],[\"是标准的\",{\"1\":{\"477\":1}}],[\"是传统的实现方式\",{\"1\":{\"472\":1}}],[\"是谷歌优秀的对\",{\"1\":{\"466\":1}}],[\"是很典型的选择\",{\"1\":{\"462\":1}}],[\"是主观的\",{\"1\":{\"443\":1}}],[\"是开源的\",{\"1\":{\"414\":1}}],[\"是安卓开发者好的选择\",{\"1\":{\"407\":1}}],[\"是为了性能考虑\",{\"1\":{\"312\":1}}],[\"是为了方便设计者进行类型检查\",{\"1\":{\"236\":1}}],[\"是生成具体类的方法\",{\"1\":{\"312\":1}}],[\"是个匿名内部类\",{\"1\":{\"563\":1}}],[\"是个\",{\"1\":{\"312\":1}}],[\"是个接口\",{\"1\":{\"312\":1}}],[\"是实现聚合接口\",{\"1\":{\"651\":1}}],[\"是实现\",{\"1\":{\"305\":1}}],[\"是同时存在的\",{\"1\":{\"291\":1}}],[\"是会在编译之前检查的\",{\"1\":{\"290\":1}}],[\"是应该允许任意引用类型添加的\",{\"1\":{\"290\":1}}],[\"是建立一个普通object耗时的约20倍\",{\"1\":{\"276\":1}}],[\"是发一手牌的纸牌张数\",{\"1\":{\"265\":1}}],[\"是runtimeexception以外的异常\",{\"1\":{\"248\":1}}],[\"是throwable子类的实例\",{\"1\":{\"245\":1}}],[\"是一条比较抽象\",{\"1\":{\"808\":1}}],[\"是一样的\",{\"1\":{\"753\":1}}],[\"是一步一步创建一个复杂的对象\",{\"1\":{\"549\":1}}],[\"是一种代码的编写方式\",{\"1\":{\"912\":1}}],[\"是一种继承关系\",{\"1\":{\"833\":1}}],[\"是一种特殊的类\",{\"1\":{\"825\":1}}],[\"是一种用于软件系统分析和设计的语言工具\",{\"1\":{\"822\":1}}],[\"是一种非常有效的提高代码质量的手段\",{\"1\":{\"807\":1}}],[\"是一种通过为多个复杂的子系统提供一个一致的接口\",{\"1\":{\"593\":1}}],[\"是一种对象行为型模式\",{\"1\":{\"837\":1}}],[\"是一种对象\",{\"1\":{\"549\":1}}],[\"是一种结构型设计模式\",{\"1\":{\"537\":1}}],[\"是一笔很大的开销\",{\"1\":{\"205\":1}}],[\"是一个整体\",{\"1\":{\"865\":1}}],[\"是一个有效关联并互相转义的和谐整体\",{\"1\":{\"857\":1}}],[\"是一个set集合对象\",{\"1\":{\"850\":1}}],[\"是一个list集合对象\",{\"1\":{\"850\":1}}],[\"是一个黑盒实现\",{\"1\":{\"848\":1}}],[\"是一个包含元素角色的容器\",{\"1\":{\"838\":1}}],[\"是一个小型框架\",{\"1\":{\"819\":1}}],[\"是一个非常重要的设计思想\",{\"1\":{\"818\":1}}],[\"是一个比较通用的设计思想\",{\"1\":{\"816\":1}}],[\"是一个外部类\",{\"1\":{\"814\":1}}],[\"是一个线程唯一的单例类\",{\"1\":{\"771\":1}}],[\"是一个存储了\",{\"1\":{\"768\":1}}],[\"是一个强大的高性能的代码生成包\",{\"1\":{\"702\":1}}],[\"是一个默认实现\",{\"1\":{\"644\":1}}],[\"是一个抽象类\",{\"1\":{\"582\":1}}],[\"是一个接口\",{\"1\":{\"532\":1}}],[\"是一个更好的解决方案\",{\"1\":{\"474\":1}}],[\"是一个很有意思的库\",{\"1\":{\"471\":1}}],[\"是一个全新的飞跃\",{\"1\":{\"469\":1}}],[\"是一个全文检索引擎的架构\",{\"1\":{\"426\":1}}],[\"是一个函数式编程库\",{\"1\":{\"469\":1}}],[\"是一个轻量级\",{\"1\":{\"427\":1}}],[\"是一个轻量级的\",{\"1\":{\"419\":1}}],[\"是一个轻量级的可伸缩的\",{\"1\":{\"414\":1}}],[\"是一个开放的资源框架\",{\"1\":{\"970\":1}}],[\"是一个开放源代码的全文检索引擎工具包\",{\"1\":{\"426\":1}}],[\"是一个开源\",{\"1\":{\"414\":1}}],[\"是一个无限定的类型变量\",{\"1\":{\"289\":1}}],[\"是一个顶级类\",{\"1\":{\"184\":1}}],[\"是一个嵌套静态类\",{\"1\":{\"184\":1}}],[\"是一个关键字\",{\"1\":{\"182\":1}}],[\"是一个修饰符\",{\"1\":{\"182\":1}}],[\"是一个原始类型的数据\",{\"1\":{\"168\":1}}],[\"是一个对象\",{\"1\":{\"168\":1}}],[\"是一个标示性接口\",{\"1\":{\"163\":1}}],[\"是一个指针\",{\"1\":{\"127\":1}}],[\"是进行逻辑比较\",{\"1\":{\"180\":1}}],[\"是比较两个对象的引用\",{\"1\":{\"180\":1}}],[\"是方法接收的参数类型\",{\"1\":{\"829\":1}}],[\"是方法\",{\"1\":{\"179\":1}}],[\"是的\",{\"1\":{\"161\":1,\"174\":1}}],[\"是保留字\",{\"1\":{\"151\":1}}],[\"是纯粹的面向对象语言\",{\"1\":{\"151\":1}}],[\"是因为从理论上来讲\",{\"1\":{\"764\":1}}],[\"是因为java基础类型的自动装箱拆箱操作\",{\"1\":{\"292\":1}}],[\"是因为\",{\"1\":{\"130\":1}}],[\"是虚拟机规范中是方法区的一部分\",{\"1\":{\"125\":1}}],[\"是通过对测试类和测试方法的命名来确定是否是测试\",{\"1\":{\"972\":1}}],[\"是通过\",{\"1\":{\"125\":1,\"312\":1}}],[\"是不是任何代码都要只依赖接口\",{\"1\":{\"810\":1}}],[\"是不是没有人会信\",{\"1\":{\"91\":1}}],[\"是不可以共享的外部状态\",{\"1\":{\"632\":1}}],[\"是不可变的\",{\"0\":{\"169\":1},\"1\":{\"123\":1}}],[\"是不一样的\",{\"1\":{\"125\":1}}],[\"是jdk内置的一种\",{\"1\":{\"95\":2}}],[\"是框中显示的内容\",{\"1\":{\"41\":1}}],[\"是否会下蛋\",{\"1\":{\"812\":1}}],[\"是否会叫\",{\"1\":{\"812\":1}}],[\"是否会飞\",{\"1\":{\"812\":1}}],[\"是否需要为每个类定义接口\",{\"0\":{\"810\":1}}],[\"是否需要保存request\",{\"1\":{\"242\":1}}],[\"是否能够做到在替换具体的接口实现的时候\",{\"1\":{\"809\":1}}],[\"是否抽中奖品\",{\"1\":{\"778\":1}}],[\"是否还能正常工作\",{\"1\":{\"741\":1}}],[\"是否存在注解\",{\"1\":{\"242\":1}}],[\"是否保存请求的参数\",{\"1\":{\"242\":1}}],[\"是否有合适的处理者来处理\",{\"1\":{\"275\":1}}],[\"是否有永久代\",{\"1\":{\"125\":1}}],[\"是否有浪费时间\",{\"1\":{\"36\":1}}],[\"是否相对昨天有所进步\",{\"1\":{\"36\":1}}],[\"是你不敢踏出第一步的心\",{\"1\":{\"36\":1}}],[\"是\",{\"0\":{\"163\":1},\"1\":{\"10\":1,\"129\":1,\"141\":1,\"161\":2,\"185\":1,\"246\":1,\"480\":1,\"528\":1,\"585\":3,\"618\":1,\"655\":2,\"703\":1,\"741\":2,\"808\":1,\"822\":1,\"831\":3,\"832\":1,\"833\":1,\"835\":1,\"846\":1,\"847\":1,\"996\":1}}],[\"和这个类的每个\",{\"1\":{\"959\":1}}],[\"和块标签组\",{\"1\":{\"956\":1}}],[\"和任何可以设置为\",{\"1\":{\"942\":1}}],[\"和静态分析工具可以发出警告\",{\"1\":{\"925\":1}}],[\"和其它任何语句块一样\",{\"1\":{\"923\":1}}],[\"和其他\",{\"1\":{\"472\":1}}],[\"和箭头符号相邻的那行代码永远不会换行\",{\"1\":{\"907\":1}}],[\"和逗号之后的花括号不能换行\",{\"1\":{\"901\":1}}],[\"和数据库相关的单元测试\",{\"1\":{\"860\":1}}],[\"和稳定性\",{\"1\":{\"850\":1}}],[\"和getxxx\",{\"1\":{\"848\":1}}],[\"和聚合关系对比\",{\"1\":{\"835\":1}}],[\"和聚合不同\",{\"1\":{\"216\":1}}],[\"和不稳定性\",{\"1\":{\"850\":1}}],[\"和不会飞的鸟类\",{\"1\":{\"812\":1}}],[\"和不可变的\",{\"1\":{\"945\":1}}],[\"和不可变的集合使该类不可变\",{\"1\":{\"451\":1}}],[\"和不可查的异常\",{\"0\":{\"249\":1}}],[\"和用户\",{\"1\":{\"764\":1}}],[\"和懒汉式\",{\"1\":{\"756\":1}}],[\"和学院员工的\",{\"1\":{\"742\":1}}],[\"和依赖倒转原则类似\",{\"1\":{\"739\":1}}],[\"和类\",{\"1\":{\"721\":3,\"723\":3}}],[\"和重写\",{\"1\":{\"703\":1}}],[\"和该对象的父类基因\",{\"1\":{\"699\":1}}],[\"和boss大战~~~\",{\"1\":{\"667\":1}}],[\"和boss大战前的状态\",{\"1\":{\"667\":1}}],[\"和具体实现的工厂子类\",{\"1\":{\"616\":1}}],[\"和创建产品的过程\",{\"1\":{\"554\":1}}],[\"和实现\",{\"1\":{\"544\":1}}],[\"和你写代码的技术水平\",{\"1\":{\"484\":1}}],[\"和你的代码放在一块儿提交\",{\"1\":{\"484\":1}}],[\"和你的代码放在一起\",{\"1\":{\"484\":1}}],[\"和前面所述的工具不同\",{\"1\":{\"484\":1}}],[\"和构建工具的支持也很好\",{\"1\":{\"484\":1}}],[\"和更多实用的方法\",{\"1\":{\"465\":1}}],[\"和lombok\",{\"1\":{\"447\":1}}],[\"和模拟函数\",{\"1\":{\"431\":1}}],[\"和获取所有构造器的方法很相似\",{\"1\":{\"311\":1}}],[\"和date\",{\"1\":{\"291\":1}}],[\"和finally的问题\",{\"1\":{\"275\":1}}],[\"和之前有所不同\",{\"1\":{\"275\":1}}],[\"和javac一样由jdk提供\",{\"1\":{\"275\":1}}],[\"和把\",{\"1\":{\"259\":1}}],[\"和错误\",{\"1\":{\"249\":1}}],[\"和elementtype\",{\"1\":{\"236\":1}}],[\"和枚举的声明\",{\"1\":{\"236\":1}}],[\"和关联关系不同的是\",{\"1\":{\"218\":1}}],[\"和x数据类型不同\",{\"1\":{\"181\":1}}],[\"和堆\",{\"1\":{\"125\":2}}],[\"和\",{\"0\":{\"168\":1,\"180\":1,\"182\":1},\"1\":{\"9\":1,\"32\":1,\"113\":1,\"124\":1,\"125\":2,\"132\":1,\"133\":3,\"144\":1,\"145\":2,\"146\":1,\"180\":2,\"182\":1,\"186\":1,\"210\":1,\"211\":2,\"228\":2,\"246\":1,\"449\":1,\"451\":1,\"457\":1,\"460\":1,\"461\":1,\"462\":1,\"465\":1,\"466\":1,\"469\":1,\"471\":1,\"472\":1,\"473\":1,\"474\":1,\"480\":1,\"484\":1,\"560\":1,\"564\":1,\"574\":1,\"582\":1,\"622\":2,\"625\":2,\"644\":3,\"652\":1,\"655\":1,\"679\":1,\"689\":1,\"692\":1,\"707\":1,\"741\":2,\"742\":1,\"743\":1,\"750\":1,\"768\":4,\"771\":2,\"778\":1,\"795\":1,\"809\":1,\"819\":1,\"832\":3,\"843\":1,\"852\":1,\"872\":1,\"884\":1,\"900\":1,\"905\":1,\"907\":1,\"911\":1,\"937\":1,\"947\":3,\"952\":1,\"972\":1,\"978\":3,\"982\":1,\"996\":2,\"997\":2,\"999\":1}}],[\"介绍\",{\"0\":{\"9\":1},\"1\":{\"9\":1,\"10\":1}}],[\"文法中的每条规则都对应于一个非终结符表达式\",{\"1\":{\"642\":1}}],[\"文法中的每一个终结符都有一个具体终结表达式与之相对应\",{\"1\":{\"642\":1}}],[\"文法\",{\"1\":{\"641\":1}}],[\"文档记录\",{\"1\":{\"990\":1}}],[\"文档解释\",{\"1\":{\"646\":1}}],[\"文档对对你代码的阅读着来说也很重要\",{\"1\":{\"454\":1}}],[\"文档索引引擎\",{\"1\":{\"426\":1}}],[\"文档分类\",{\"1\":{\"418\":1}}],[\"文档处理工具\",{\"0\":{\"402\":1}}],[\"文本框节点\",{\"0\":{\"42\":1}}],[\"文章标题列表\",{\"1\":{\"34\":1}}],[\"文件编码\",{\"0\":{\"881\":1}}],[\"文件名\",{\"0\":{\"880\":1}}],[\"文件句柄耗尽\",{\"1\":{\"874\":1}}],[\"文件侵犯版权\",{\"1\":{\"874\":1}}],[\"文件也要修改\",{\"1\":{\"610\":1}}],[\"文件系统中的文件与文件夹\",{\"1\":{\"567\":1}}],[\"文件中\",{\"1\":{\"484\":1}}],[\"文件中定义\",{\"1\":{\"484\":1}}],[\"文件上传或xml处理等\",{\"1\":{\"432\":1}}],[\"文件未找到异常\",{\"1\":{\"261\":1}}],[\"文件已结束异常\",{\"1\":{\"261\":1}}],[\"文件找不到\",{\"1\":{\"245\":1}}],[\"文件时\",{\"1\":{\"183\":1}}],[\"文件内容是具体的实现名字\",{\"1\":{\"110\":1}}],[\"文件内容是org\",{\"1\":{\"101\":1}}],[\"文件内容是com\",{\"1\":{\"100\":1}}],[\"文件搜索\",{\"1\":{\"96\":2}}],[\"文件搜索实现\",{\"1\":{\"96\":1}}],[\"文件夹的图片\",{\"1\":{\"33\":1}}],[\"文件放置在一起\",{\"1\":{\"33\":1}}],[\"文件\",{\"1\":{\"8\":1,\"145\":1,\"485\":1,\"770\":1}}],[\"文件生成页面\",{\"1\":{\"8\":1}}],[\"文字类控件中\",{\"1\":{\"854\":1}}],[\"文字结尾应该有深蓝色的\",{\"1\":{\"33\":1}}],[\"文字\",{\"1\":{\"7\":2}}],[\"文字段落\",{\"1\":{\"7\":24}}],[\"段落样式\",{\"1\":{\"933\":1}}],[\"段落\",{\"0\":{\"956\":1},\"1\":{\"7\":2,\"962\":1}}],[\"页脚\",{\"1\":{\"6\":1,\"34\":1}}],[\"页面搜索严禁左模糊或者全模糊\",{\"1\":{\"864\":1}}],[\"页面page\",{\"1\":{\"861\":1}}],[\"页面显示为0\",{\"1\":{\"848\":1}}],[\"页面结构\",{\"0\":{\"34\":1}}],[\"页面内容\",{\"0\":{\"33\":1}}],[\"页面配置\",{\"0\":{\"31\":1},\"1\":{\"32\":1}}],[\"页面引入配置\",{\"1\":{\"10\":1}}],[\"页面信息\",{\"0\":{\"32\":1},\"1\":{\"6\":1}}],[\"页面展示\",{\"1\":{\"5\":1}}],[\"链接\",{\"1\":{\"6\":1,\"14\":1,\"770\":1}}],[\"贡献者\",{\"1\":{\"6\":1,\"34\":1}}],[\"布局与功能禁用\",{\"0\":{\"6\":1}}],[\"展示对象\",{\"1\":{\"845\":1}}],[\"展示网站项目需求\",{\"0\":{\"633\":1}}],[\"展示\",{\"0\":{\"8\":1},\"1\":{\"5\":1}}],[\"afoo\",{\"1\":{\"951\":2}}],[\"after修饰的方法执行后执行\",{\"1\":{\"976\":1}}],[\"after修饰的方法会在子类\",{\"1\":{\"976\":1}}],[\"after注解修饰的方法会在每个测试方法执行后执行一次\",{\"1\":{\"976\":1}}],[\"afterclass注解方法修饰的方法会在子类的\",{\"1\":{\"976\":1}}],[\"afterclass注解修饰的方法执行之后才会被执行\",{\"1\":{\"976\":1}}],[\"afterclass注解修饰的方法\",{\"1\":{\"976\":1}}],[\"afterclass\",{\"1\":{\"972\":1,\"976\":2,\"997\":1}}],[\"afterthrowing\",{\"1\":{\"242\":1}}],[\"afterreturning\",{\"1\":{\"242\":1}}],[\"after等等注解来实现\",{\"1\":{\"241\":1}}],[\"after\",{\"1\":{\"78\":1,\"86\":1,\"241\":1,\"477\":1,\"489\":1,\"659\":1,\"849\":1,\"972\":1,\"976\":4,\"980\":1,\"997\":3}}],[\"a0907\",{\"1\":{\"874\":1}}],[\"a0906\",{\"1\":{\"874\":1}}],[\"a0905\",{\"1\":{\"874\":1}}],[\"a0904\",{\"1\":{\"874\":1}}],[\"a0903\",{\"1\":{\"874\":1}}],[\"a0902\",{\"1\":{\"874\":1}}],[\"a0901\",{\"1\":{\"874\":1}}],[\"a0900\",{\"1\":{\"874\":1}}],[\"a0807\",{\"1\":{\"874\":1}}],[\"a0806\",{\"1\":{\"874\":1}}],[\"a0805\",{\"1\":{\"874\":1}}],[\"a0804\",{\"1\":{\"874\":1}}],[\"a0803\",{\"1\":{\"874\":1}}],[\"a0802\",{\"1\":{\"874\":1}}],[\"a0801\",{\"1\":{\"874\":1}}],[\"a0800\",{\"1\":{\"874\":1}}],[\"a0705\",{\"1\":{\"874\":1}}],[\"a0704\",{\"1\":{\"874\":1}}],[\"a0703\",{\"1\":{\"874\":1}}],[\"a0702\",{\"1\":{\"874\":1}}],[\"a0701\",{\"1\":{\"874\":1}}],[\"a0700\",{\"1\":{\"874\":1}}],[\"a0605\",{\"1\":{\"874\":1}}],[\"a0604\",{\"1\":{\"874\":1}}],[\"a0603\",{\"1\":{\"874\":1}}],[\"a0602\",{\"1\":{\"874\":1}}],[\"a0601\",{\"1\":{\"874\":1}}],[\"a0600\",{\"1\":{\"874\":1}}],[\"a0506\",{\"1\":{\"874\":1}}],[\"a0505\",{\"1\":{\"874\":1}}],[\"a0504\",{\"1\":{\"874\":1}}],[\"a0503\",{\"1\":{\"874\":1}}],[\"a0502\",{\"1\":{\"874\":1}}],[\"a0501\",{\"1\":{\"874\":1}}],[\"a0500\",{\"1\":{\"874\":1}}],[\"a0443\",{\"1\":{\"874\":1}}],[\"a0442\",{\"1\":{\"874\":1}}],[\"a0441\",{\"1\":{\"874\":1}}],[\"a0440\",{\"1\":{\"874\":1}}],[\"a0433\",{\"1\":{\"874\":1}}],[\"a0432\",{\"1\":{\"874\":1}}],[\"a0431\",{\"1\":{\"874\":1}}],[\"a0430\",{\"1\":{\"874\":1}}],[\"a0427\",{\"1\":{\"874\":1}}],[\"a0426\",{\"1\":{\"874\":1}}],[\"a0425\",{\"1\":{\"874\":1}}],[\"a0424\",{\"1\":{\"874\":1}}],[\"a0423\",{\"1\":{\"874\":1}}],[\"a0422\",{\"1\":{\"874\":1}}],[\"a0421\",{\"1\":{\"874\":1}}],[\"a0420\",{\"1\":{\"874\":1}}],[\"a0414\",{\"1\":{\"874\":1}}],[\"a0413\",{\"1\":{\"874\":1}}],[\"a0412\",{\"1\":{\"874\":1}}],[\"a0411\",{\"1\":{\"874\":1}}],[\"a0410\",{\"1\":{\"874\":1}}],[\"a0402\",{\"1\":{\"874\":1}}],[\"a0401\",{\"1\":{\"874\":1}}],[\"a0400\",{\"1\":{\"874\":1}}],[\"a0341\",{\"1\":{\"874\":1}}],[\"a0340\",{\"1\":{\"874\":1}}],[\"a0330\",{\"1\":{\"874\":1}}],[\"a0325\",{\"1\":{\"874\":1}}],[\"a0324\",{\"1\":{\"874\":1}}],[\"a0323\",{\"1\":{\"874\":1}}],[\"a0322\",{\"1\":{\"874\":1}}],[\"a0321\",{\"1\":{\"874\":1}}],[\"a0320\",{\"1\":{\"874\":1}}],[\"a0312\",{\"1\":{\"874\":1}}],[\"a0311\",{\"1\":{\"874\":1}}],[\"a0310\",{\"1\":{\"874\":1}}],[\"a0303\",{\"1\":{\"874\":1}}],[\"a0302\",{\"1\":{\"874\":1}}],[\"a0301\",{\"1\":{\"874\":1}}],[\"a0300\",{\"1\":{\"874\":1}}],[\"a0241\",{\"1\":{\"874\":1}}],[\"a0240\",{\"1\":{\"874\":1}}],[\"a0230\",{\"1\":{\"874\":1}}],[\"a0223\",{\"1\":{\"874\":1}}],[\"a0222\",{\"1\":{\"874\":1}}],[\"a0221\",{\"1\":{\"874\":1}}],[\"a0220\",{\"1\":{\"874\":1}}],[\"a0211\",{\"1\":{\"874\":1}}],[\"a0210\",{\"1\":{\"874\":1}}],[\"a0203\",{\"1\":{\"874\":1}}],[\"a0202\",{\"1\":{\"874\":1}}],[\"a0201\",{\"1\":{\"874\":1}}],[\"a0200\",{\"1\":{\"874\":1}}],[\"a0153\",{\"1\":{\"874\":1}}],[\"a0152\",{\"1\":{\"874\":1}}],[\"a0151\",{\"1\":{\"874\":1}}],[\"a0150\",{\"1\":{\"874\":1}}],[\"a0144\",{\"1\":{\"874\":1}}],[\"a0143\",{\"1\":{\"874\":1}}],[\"a0142\",{\"1\":{\"874\":1}}],[\"a0141\",{\"1\":{\"874\":1}}],[\"a0140\",{\"1\":{\"874\":1}}],[\"a0133\",{\"1\":{\"874\":1}}],[\"a0132\",{\"1\":{\"874\":1}}],[\"a0131\",{\"1\":{\"874\":1}}],[\"a0130\",{\"1\":{\"874\":1}}],[\"a0122\",{\"1\":{\"874\":1}}],[\"a0121\",{\"1\":{\"874\":1}}],[\"a0120\",{\"1\":{\"874\":1}}],[\"a0113\",{\"1\":{\"874\":1}}],[\"a0112\",{\"1\":{\"874\":1}}],[\"a0111\",{\"1\":{\"874\":1}}],[\"a0110\",{\"1\":{\"874\":1}}],[\"a0102\",{\"1\":{\"874\":1}}],[\"a0101\",{\"1\":{\"874\":1}}],[\"a0100\",{\"1\":{\"874\":1}}],[\"a0001\",{\"1\":{\"857\":1,\"874\":1}}],[\"aqs\",{\"1\":{\"873\":1}}],[\"a索引即可\",{\"1\":{\"864\":1}}],[\"a列的几乎接近于唯一值\",{\"1\":{\"864\":1}}],[\"ajax提交必须执行csrf安全验证\",{\"1\":{\"861\":1}}],[\"ajaxresult\",{\"1\":{\"242\":5}}],[\"a表示错误来源于用户\",{\"1\":{\"857\":1}}],[\"aap\",{\"1\":{\"845\":1}}],[\"aaa\",{\"1\":{\"125\":2,\"130\":1}}],[\"aaaabbbd\",{\"1\":{\"83\":1}}],[\"aaa<span>bbb<\",{\"1\":{\"83\":1}}],[\"a的关系\",{\"1\":{\"835\":1}}],[\"await\",{\"1\":{\"980\":1}}],[\"awaitility\",{\"1\":{\"431\":1}}],[\"awesome\",{\"1\":{\"85\":2,\"383\":1}}],[\"aeron\",{\"1\":{\"414\":1}}],[\"akka\",{\"1\":{\"399\":1}}],[\"aop\",{\"1\":{\"398\":1,\"702\":3}}],[\"aop切面实现统一的操作日志管理\",{\"1\":{\"242\":1}}],[\"autumn\",{\"1\":{\"846\":1}}],[\"author为$\",{\"1\":{\"853\":2}}],[\"author\",{\"1\":{\"474\":5,\"853\":1,\"975\":1}}],[\"authoring\",{\"1\":{\"401\":1}}],[\"automatic\",{\"1\":{\"860\":1}}],[\"automaticallycloseresource\",{\"1\":{\"264\":1}}],[\"auto\",{\"1\":{\"398\":1}}],[\"autocloseable\",{\"1\":{\"259\":2,\"264\":1}}],[\"autowired\",{\"1\":{\"242\":1}}],[\"aurora是一个mesos框架\",{\"1\":{\"387\":1}}],[\"aurora\",{\"1\":{\"387\":1}}],[\"air\",{\"1\":{\"860\":1}}],[\"airvehicle\",{\"1\":{\"718\":5}}],[\"ai\",{\"1\":{\"809\":2}}],[\"aio\",{\"0\":{\"324\":1}}],[\"aid\",{\"1\":{\"145\":1}}],[\"ambiguous\",{\"1\":{\"865\":1}}],[\"amt\",{\"1\":{\"546\":1}}],[\"among\",{\"1\":{\"310\":1}}],[\"am\",{\"1\":{\"307\":2,\"659\":1}}],[\"a>\",{\"1\":{\"284\":1}}],[\"a>表示该类型参数可以是a\",{\"1\":{\"284\":1}}],[\"ag\",{\"1\":{\"649\":5}}],[\"aggregate\",{\"1\":{\"649\":4,\"745\":1}}],[\"aggregation\",{\"0\":{\"215\":1,\"831\":1},\"1\":{\"215\":1,\"831\":1}}],[\"agrona\",{\"1\":{\"406\":1}}],[\"ages\",{\"1\":{\"942\":1}}],[\"agefield\",{\"1\":{\"307\":2}}],[\"age=18\",{\"1\":{\"307\":1}}],[\"age=25\",{\"1\":{\"306\":1}}],[\"age=22\",{\"1\":{\"306\":1}}],[\"age=20\",{\"1\":{\"306\":1}}],[\"age=0\",{\"1\":{\"305\":1}}],[\"age=\",{\"1\":{\"305\":1,\"306\":1,\"685\":1,\"687\":1}}],[\"age\",{\"1\":{\"209\":6,\"305\":9,\"306\":10,\"307\":5,\"685\":9,\"687\":9}}],[\"a+b+c\",{\"1\":{\"643\":2}}],[\"a+b\",{\"1\":{\"165\":1,\"644\":3}}],[\"a进行理解\",{\"1\":{\"154\":1}}],[\"avoided\",{\"1\":{\"145\":1}}],[\"avoid\",{\"0\":{\"450\":1,\"452\":1},\"1\":{\"145\":1}}],[\"available\",{\"1\":{\"77\":1,\"104\":1,\"145\":1,\"310\":1,\"311\":1}}],[\"a2\",{\"1\":{\"144\":1,\"310\":6,\"716\":1}}],[\"actual\",{\"1\":{\"978\":5}}],[\"active\",{\"1\":{\"855\":1}}],[\"activemq\",{\"1\":{\"414\":1}}],[\"activity\",{\"1\":{\"435\":1,\"778\":31}}],[\"action\",{\"1\":{\"114\":4,\"438\":1,\"561\":2,\"563\":2,\"839\":16}}],[\"actor\",{\"1\":{\"399\":1}}],[\"acquirequeued\",{\"1\":{\"852\":1}}],[\"acquire\",{\"1\":{\"852\":1}}],[\"acquiremethodaccessor\",{\"1\":{\"312\":3}}],[\"acquireconstructoraccessor\",{\"1\":{\"310\":1}}],[\"ac2\",{\"1\":{\"133\":2}}],[\"ac1\",{\"1\":{\"133\":1}}],[\"acceptable\",{\"1\":{\"902\":3}}],[\"accept\",{\"1\":{\"838\":10,\"839\":4}}],[\"acceptorderevent\",{\"1\":{\"779\":6}}],[\"access$000\",{\"1\":{\"979\":1}}],[\"access等\",{\"1\":{\"859\":1}}],[\"accesstoken\",{\"1\":{\"809\":6}}],[\"accesskey\",{\"1\":{\"809\":2}}],[\"accessorgenerator\",{\"1\":{\"312\":1}}],[\"accessibility\",{\"1\":{\"310\":2}}],[\"accessibleobject\",{\"1\":{\"310\":1}}],[\"accessible\",{\"1\":{\"307\":1}}],[\"accessing\",{\"1\":{\"145\":2}}],[\"access\",{\"1\":{\"141\":1,\"225\":6,\"312\":1,\"809\":7,\"845\":1}}],[\"accesswithinnerclassexample\",{\"1\":{\"132\":2}}],[\"accessexample\",{\"1\":{\"132\":3}}],[\"accessed\",{\"1\":{\"85\":1}}],[\"accesscontrolcontext\",{\"1\":{\"114\":1}}],[\"accesscontroller\",{\"1\":{\"103\":2,\"114\":3,\"310\":1,\"312\":1}}],[\"accumulators\",{\"1\":{\"150\":1}}],[\"acc\",{\"1\":{\"114\":6,\"228\":4,\"310\":2,\"312\":8}}],[\"accommodate\",{\"1\":{\"71\":1}}],[\"appname\",{\"1\":{\"859\":1}}],[\"approver\",{\"1\":{\"709\":2,\"710\":16}}],[\"app\",{\"0\":{\"777\":1},\"1\":{\"562\":6}}],[\"append\",{\"1\":{\"556\":1,\"847\":8}}],[\"appendable\",{\"1\":{\"556\":3}}],[\"appdynamics\",{\"1\":{\"416\":1}}],[\"applet\",{\"1\":{\"145\":1}}],[\"applicable\",{\"1\":{\"284\":1}}],[\"applicationcontext\",{\"1\":{\"624\":3,\"625\":4,\"750\":1}}],[\"applications\",{\"1\":{\"145\":1}}],[\"application\",{\"1\":{\"145\":1,\"152\":1,\"854\":1}}],[\"applied\",{\"1\":{\"83\":1}}],[\"apply\",{\"1\":{\"80\":1,\"81\":1}}],[\"api开放接口必须使用错误码\",{\"1\":{\"858\":1}}],[\"api文档上有说最多查多少个\",{\"1\":{\"852\":1}}],[\"apis\",{\"1\":{\"145\":1}}],[\"api在新窗口打开\",{\"1\":{\"113\":2}}],[\"api\",{\"0\":{\"699\":1},\"1\":{\"113\":1,\"116\":1,\"132\":2,\"150\":1,\"187\":2,\"188\":1,\"262\":1,\"459\":1,\"673\":1,\"698\":1,\"852\":1,\"869\":2,\"874\":4}}],[\"apache2\",{\"1\":{\"872\":1}}],[\"apachebeanutils性能较差\",{\"1\":{\"855\":1}}],[\"apache\",{\"0\":{\"465\":1},\"1\":{\"104\":13,\"384\":1,\"385\":1,\"387\":2,\"394\":1,\"395\":1,\"397\":1,\"399\":2,\"400\":2,\"401\":1,\"402\":1,\"408\":1,\"412\":1,\"413\":4,\"414\":5,\"418\":1,\"420\":1,\"421\":2,\"426\":2,\"427\":1,\"429\":2,\"430\":1,\"431\":1,\"432\":1,\"433\":1,\"434\":2,\"465\":1,\"859\":2,\"974\":4}}],[\"a==b\",{\"0\":{\"180\":1},\"1\":{\"180\":1}}],[\"a=unsafe\",{\"1\":{\"93\":1}}],[\"a=10\",{\"1\":{\"644\":5}}],[\"a=1\",{\"1\":{\"89\":1,\"93\":1}}],[\"ad\",{\"1\":{\"947\":1}}],[\"adwords\",{\"1\":{\"947\":1}}],[\"admin\",{\"1\":{\"859\":1,\"863\":1}}],[\"adaptee\",{\"1\":{\"519\":1}}],[\"adapter\",{\"1\":{\"518\":1,\"519\":2,\"523\":1,\"524\":1,\"525\":2,\"527\":1,\"528\":1,\"531\":1,\"534\":6,\"535\":1,\"590\":1,\"798\":1}}],[\"adam\",{\"1\":{\"440\":1}}],[\"adt4j\",{\"1\":{\"398\":1}}],[\"advantages\",{\"1\":{\"145\":1}}],[\"adriver\",{\"1\":{\"103\":3}}],[\"adjust\",{\"1\":{\"87\":1,\"312\":1}}],[\"addwaiter\",{\"1\":{\"852\":1}}],[\"addandget\",{\"1\":{\"851\":1}}],[\"addall方法的第一行代码即object\",{\"1\":{\"850\":1}}],[\"addall\",{\"1\":{\"106\":1}}],[\"add操作\",{\"1\":{\"850\":1}}],[\"addcondiments\",{\"1\":{\"803\":5}}],[\"adddepartment\",{\"1\":{\"650\":9}}],[\"addbeandefinitions\",{\"1\":{\"625\":1,\"627\":3}}],[\"addlistener\",{\"1\":{\"532\":3}}],[\"addexpresson\",{\"1\":{\"644\":1}}],[\"addexpression\",{\"1\":{\"644\":3}}],[\"addelapsedtimefrom\",{\"1\":{\"310\":1}}],[\"addedfunction\",{\"1\":{\"580\":2}}],[\"added\",{\"1\":{\"71\":2}}],[\"addtime\",{\"1\":{\"310\":1}}],[\"addsusppressed\",{\"1\":{\"259\":1}}],[\"addsave\",{\"1\":{\"242\":1}}],[\"additivity=\",{\"1\":{\"859\":1}}],[\"additional\",{\"1\":{\"312\":1}}],[\"addison\",{\"1\":{\"153\":1}}],[\"adding\",{\"1\":{\"71\":1,\"77\":1,\"82\":1}}],[\"address=\",{\"1\":{\"687\":1}}],[\"address\",{\"1\":{\"687\":2}}],[\"addr2+4\",{\"1\":{\"93\":1}}],[\"addr2\",{\"1\":{\"93\":3}}],[\"addr\",{\"1\":{\"93\":14}}],[\"add\",{\"1\":{\"71\":1,\"85\":1,\"114\":1,\"139\":2,\"211\":2,\"234\":1,\"242\":2,\"279\":7,\"288\":5,\"289\":7,\"290\":12,\"292\":1,\"294\":2,\"312\":3,\"455\":1,\"568\":1,\"569\":1,\"571\":15,\"574\":17,\"649\":6,\"650\":3,\"656\":1,\"672\":4,\"678\":1,\"679\":1,\"742\":2,\"743\":2,\"826\":1,\"838\":4,\"839\":1,\"849\":1,\"850\":12}}],[\"atest\",{\"1\":{\"972\":1,\"981\":1}}],[\"atleast\",{\"1\":{\"477\":1}}],[\"atlassian解决方案\",{\"1\":{\"392\":1}}],[\"atomicinteger\",{\"1\":{\"851\":4}}],[\"atomiclong\",{\"1\":{\"769\":2,\"771\":2,\"772\":2}}],[\"atomic\",{\"1\":{\"310\":1}}],[\"athrow\",{\"1\":{\"275\":3}}],[\"attempts\",{\"1\":{\"104\":1}}],[\"attributes\",{\"1\":{\"104\":1,\"312\":1}}],[\"attaching\",{\"1\":{\"485\":1}}],[\"attachment\",{\"1\":{\"82\":1}}],[\"attached\",{\"1\":{\"80\":1,\"485\":1}}],[\"attach\",{\"1\":{\"59\":1,\"82\":3,\"839\":3}}],[\"at\",{\"1\":{\"77\":1,\"270\":5,\"979\":25,\"980\":16}}],[\"a1005\",{\"1\":{\"874\":1}}],[\"a1004\",{\"1\":{\"874\":1}}],[\"a1003\",{\"1\":{\"874\":1}}],[\"a1002\",{\"1\":{\"874\":1}}],[\"a1001\",{\"1\":{\"874\":1}}],[\"a1000\",{\"1\":{\"874\":1}}],[\"a1\",{\"1\":{\"74\":2,\"75\":1,\"144\":1,\"310\":6,\"716\":1}}],[\"absfactory\",{\"1\":{\"616\":1}}],[\"abs\",{\"1\":{\"538\":2,\"848\":1}}],[\"absadapter\",{\"1\":{\"532\":6}}],[\"abstractqueuedsynchronizer\",{\"1\":{\"873\":1}}],[\"abstractmap\",{\"1\":{\"850\":3}}],[\"abstractmethod2\",{\"1\":{\"801\":3}}],[\"abstractmethod1\",{\"1\":{\"801\":3}}],[\"abstracttranslator实现translatable\",{\"1\":{\"845\":1}}],[\"abstractunflyableuntweetablebird\",{\"1\":{\"812\":1}}],[\"abstractunflyabletweetablebird\",{\"1\":{\"812\":1}}],[\"abstractunflyablebird\",{\"1\":{\"812\":2}}],[\"abstractflyableuntweetablebird\",{\"1\":{\"812\":1}}],[\"abstractflyabletweetablebird\",{\"1\":{\"812\":1}}],[\"abstractflyablebird\",{\"1\":{\"812\":2}}],[\"abstractfactory\",{\"1\":{\"798\":1}}],[\"abstractbird\",{\"1\":{\"812\":5}}],[\"abstractclass\",{\"1\":{\"801\":3,\"845\":1}}],[\"abstractclassexample\",{\"1\":{\"133\":6}}],[\"abstractstate\",{\"1\":{\"779\":8}}],[\"abstractstringbuilder\",{\"1\":{\"556\":4}}],[\"abstractexpression\",{\"1\":{\"642\":6}}],[\"abstractextendclassexample\",{\"1\":{\"133\":2}}],[\"abstracthouse\",{\"1\":{\"553\":3}}],[\"abstraction\",{\"1\":{\"537\":1,\"538\":7,\"732\":1}}],[\"abstractions\",{\"1\":{\"145\":1}}],[\"abstract\",{\"0\":{\"615\":1},\"1\":{\"104\":1,\"133\":7,\"144\":4,\"194\":1,\"532\":2,\"538\":2,\"542\":1,\"553\":4,\"555\":4,\"561\":1,\"574\":2,\"584\":2,\"609\":2,\"612\":1,\"613\":4,\"616\":1,\"636\":2,\"642\":1,\"644\":2,\"656\":6,\"659\":6,\"672\":2,\"708\":2,\"710\":2,\"739\":2,\"776\":2,\"778\":4,\"779\":1,\"787\":2,\"789\":2,\"801\":4,\"803\":2,\"833\":1,\"839\":5,\"845\":1,\"934\":1}}],[\"able结尾的形容词\",{\"1\":{\"845\":1}}],[\"able\",{\"1\":{\"145\":2,\"312\":1}}],[\"about\",{\"1\":{\"104\":2,\"732\":1}}],[\"above\",{\"1\":{\"51\":1,\"77\":1,\"104\":1,\"312\":52}}],[\"ability\",{\"1\":{\"77\":1,\"104\":1}}],[\"abc\",{\"1\":{\"69\":1,\"234\":1,\"259\":1,\"288\":1}}],[\"abcde\",{\"1\":{\"77\":1}}],[\"abcd\",{\"1\":{\"68\":2,\"70\":1,\"77\":1}}],[\"ab\",{\"1\":{\"60\":1,\"61\":1,\"62\":1,\"64\":1,\"66\":1,\"82\":1}}],[\"ary\",{\"1\":{\"848\":2}}],[\"artifactid\",{\"1\":{\"873\":1}}],[\"artifactid格式\",{\"1\":{\"869\":1}}],[\"artifactid>\",{\"1\":{\"458\":1,\"974\":3}}],[\"artifactory\",{\"1\":{\"461\":2}}],[\"artifact<\",{\"1\":{\"458\":1}}],[\"articles\",{\"1\":{\"299\":1,\"1000\":1}}],[\"article\",{\"1\":{\"116\":1,\"219\":1,\"238\":1,\"243\":2,\"277\":3,\"299\":4,\"305\":1,\"314\":3,\"984\":1,\"1000\":1}}],[\"arsenal\",{\"1\":{\"442\":1}}],[\"arsg\",{\"1\":{\"282\":1}}],[\"arun\",{\"1\":{\"440\":1}}],[\"arquillian\",{\"1\":{\"431\":1}}],[\"arg3\",{\"1\":{\"703\":1}}],[\"arg0\",{\"1\":{\"703\":1}}],[\"argobjects\",{\"1\":{\"627\":4}}],[\"argclasses\",{\"1\":{\"627\":4}}],[\"argumenttypestostring\",{\"1\":{\"310\":1,\"311\":1}}],[\"arguments\",{\"1\":{\"284\":1}}],[\"arg\",{\"1\":{\"285\":2,\"310\":2,\"622\":3,\"624\":3,\"626\":1,\"627\":6,\"852\":3}}],[\"argsx\",{\"1\":{\"847\":1}}],[\"args3\",{\"1\":{\"847\":1}}],[\"args2\",{\"1\":{\"847\":1}}],[\"args1\",{\"1\":{\"847\":1}}],[\"args4j\",{\"1\":{\"432\":1}}],[\"args\",{\"1\":{\"89\":3,\"91\":1,\"92\":1,\"96\":1,\"127\":2,\"144\":3,\"201\":1,\"211\":1,\"228\":4,\"234\":1,\"276\":1,\"281\":2,\"284\":3,\"285\":1,\"288\":2,\"289\":2,\"290\":2,\"291\":1,\"298\":1,\"305\":5,\"306\":1,\"307\":1,\"308\":4,\"309\":1,\"310\":4,\"312\":10,\"524\":1,\"528\":1,\"532\":1,\"538\":1,\"542\":1,\"553\":1,\"555\":1,\"561\":1,\"562\":1,\"571\":2,\"574\":1,\"580\":1,\"584\":1,\"596\":1,\"601\":1,\"609\":1,\"610\":1,\"613\":1,\"617\":1,\"618\":1,\"624\":1,\"627\":6,\"632\":1,\"636\":1,\"637\":1,\"644\":1,\"649\":1,\"650\":1,\"656\":1,\"659\":1,\"664\":1,\"667\":1,\"672\":1,\"676\":1,\"678\":1,\"685\":1,\"687\":1,\"689\":1,\"695\":1,\"700\":3,\"703\":4,\"708\":1,\"710\":1,\"718\":3,\"723\":2,\"727\":2,\"728\":1,\"734\":2,\"738\":2,\"739\":1,\"742\":1,\"743\":1,\"752\":1,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"757\":1,\"758\":1,\"759\":1,\"776\":1,\"778\":1,\"779\":1,\"784\":1,\"789\":1,\"790\":1,\"801\":1,\"803\":1,\"838\":1,\"839\":1,\"845\":1,\"847\":4,\"852\":1,\"921\":2}}],[\"arithmeticexception>\",{\"1\":{\"979\":1}}],[\"arithmeticexception\",{\"1\":{\"198\":1,\"253\":1,\"261\":1,\"979\":2}}],[\"arithmetic\",{\"1\":{\"146\":1}}],[\"archive\",{\"1\":{\"116\":1,\"283\":1,\"299\":1}}],[\"arr\",{\"1\":{\"141\":28}}],[\"array2\",{\"1\":{\"978\":2}}],[\"array1\",{\"1\":{\"978\":2}}],[\"arraydemo\",{\"1\":{\"845\":1}}],[\"arraycontentseq\",{\"1\":{\"310\":2,\"311\":1}}],[\"arrayindexoutofbounds是indexoutofbounds的子类\",{\"1\":{\"297\":1}}],[\"arrayindexoutofboundsexception\",{\"1\":{\"261\":1}}],[\"arraytoken\",{\"1\":{\"295\":2}}],[\"arraywithtypetoken<integer>\",{\"1\":{\"295\":2}}],[\"arraywithtypetoken<t>\",{\"1\":{\"295\":1}}],[\"arraywithtypetoken\",{\"1\":{\"285\":1,\"295\":1}}],[\"arraylist是order\",{\"1\":{\"850\":1}}],[\"arraylist的sublist结果不可强转成arraylist\",{\"1\":{\"850\":1}}],[\"arraylist的原始类型变为object\",{\"1\":{\"292\":1}}],[\"arraylist举例子\",{\"1\":{\"290\":1}}],[\"arraylist\",{\"0\":{\"315\":1,\"651\":1},\"1\":{\"188\":1,\"222\":1,\"234\":2,\"279\":1,\"285\":1,\"289\":2,\"290\":8,\"294\":2,\"295\":1,\"651\":4,\"678\":2,\"850\":3}}],[\"arraylist<user>\",{\"1\":{\"850\":1}}],[\"arraylist<element>\",{\"1\":{\"838\":1}}],[\"arraylist<employee>\",{\"1\":{\"742\":1,\"743\":1}}],[\"arraylist<collegeemployee>\",{\"1\":{\"742\":1,\"743\":1}}],[\"arraylist<college>\",{\"1\":{\"650\":1}}],[\"arraylist<colleague>\",{\"1\":{\"656\":1}}],[\"arraylist<component>\",{\"1\":{\"571\":4}}],[\"arraylist<department>\",{\"1\":{\"650\":1}}],[\"arraylist<observer>\",{\"1\":{\"672\":1,\"678\":2}}],[\"arraylist<object>\",{\"1\":{\"290\":5,\"649\":1}}],[\"arraylist<organizationcomponent>\",{\"1\":{\"574\":2}}],[\"arraylist<integer>\",{\"1\":{\"288\":4,\"294\":2}}],[\"arraylist<\",{\"1\":{\"236\":2,\"285\":3,\"294\":3}}],[\"arraylist<>\",{\"1\":{\"114\":1,\"211\":1,\"455\":1,\"626\":2,\"850\":4}}],[\"arraylist<string>\",{\"1\":{\"106\":1,\"114\":1,\"279\":1,\"285\":2,\"288\":2,\"290\":16,\"294\":2}}],[\"array\",{\"1\":{\"120\":1,\"285\":2,\"294\":1,\"295\":8,\"310\":1,\"311\":2,\"850\":2,\"942\":1}}],[\"arraystoreexception\",{\"1\":{\"261\":2}}],[\"arrays\",{\"0\":{\"790\":1},\"1\":{\"106\":1,\"790\":6,\"850\":3,\"978\":4,\"981\":2}}],[\"arrows\",{\"0\":{\"70\":1},\"1\":{\"69\":1,\"70\":1}}],[\"arrow\",{\"0\":{\"60\":1,\"63\":1,\"69\":1},\"1\":{\"71\":3}}],[\"areturn意思为return\",{\"1\":{\"275\":1}}],[\"areturn\",{\"1\":{\"275\":2,\"291\":2}}],[\"are\",{\"1\":{\"44\":1,\"69\":1,\"71\":2,\"73\":1,\"77\":4,\"85\":2,\"104\":1,\"145\":2,\"151\":1,\"618\":1,\"847\":1,\"955\":1,\"978\":1}}],[\"albumen\",{\"1\":{\"978\":1}}],[\"algorithms\",{\"0\":{\"1012\":1}}],[\"algorithm\",{\"1\":{\"947\":2}}],[\"alignment\",{\"1\":{\"912\":1}}],[\"alipay\",{\"1\":{\"863\":1}}],[\"alibaba\",{\"1\":{\"845\":5,\"869\":2}}],[\"ali\",{\"1\":{\"845\":1}}],[\"aliyunadmin\",{\"1\":{\"863\":1}}],[\"aliyun\",{\"1\":{\"809\":2,\"845\":1,\"863\":1}}],[\"aliyunimagestore\",{\"1\":{\"809\":13}}],[\"alarm\",{\"1\":{\"659\":13}}],[\"alanlee\",{\"1\":{\"219\":1}}],[\"al等技术进行抽象的健壮框架\",{\"1\":{\"404\":1}}],[\"already\",{\"1\":{\"275\":1,\"310\":2}}],[\"alocale\",{\"1\":{\"618\":16}}],[\"aload\",{\"1\":{\"228\":1,\"275\":8,\"291\":7}}],[\"along\",{\"1\":{\"86\":2}}],[\"always\",{\"1\":{\"104\":1}}],[\"allof\",{\"1\":{\"978\":2}}],[\"allowlist\",{\"1\":{\"845\":1}}],[\"allows\",{\"1\":{\"145\":1}}],[\"allowed\",{\"1\":{\"86\":1,\"133\":3,\"294\":1}}],[\"allocatememory\",{\"1\":{\"93\":3}}],[\"all\",{\"1\":{\"80\":1,\"84\":1,\"120\":1,\"225\":2,\"310\":1,\"489\":1}}],[\"alert\",{\"1\":{\"77\":2}}],[\"also\",{\"1\":{\"68\":1,\"73\":1,\"74\":1,\"75\":1,\"82\":1,\"83\":1,\"86\":4,\"104\":2,\"732\":1}}],[\"alternative\",{\"1\":{\"104\":2}}],[\"alternate\",{\"1\":{\"77\":1}}],[\"alt\",{\"0\":{\"55\":1,\"57\":1}}],[\"alpha\",{\"1\":{\"0\":1}}],[\"anumber\",{\"1\":{\"978\":3}}],[\"animation\",{\"1\":{\"532\":16}}],[\"animatorpauselistener\",{\"1\":{\"532\":1}}],[\"animator\",{\"1\":{\"532\":22}}],[\"animatorlisteneradapter\",{\"1\":{\"532\":4}}],[\"animatorlistener\",{\"1\":{\"532\":6}}],[\"animal\",{\"1\":{\"210\":7,\"305\":3,\"689\":1}}],[\"analyzer\",{\"0\":{\"485\":1},\"1\":{\"485\":1}}],[\"analysis\",{\"1\":{\"225\":1}}],[\"anti\",{\"1\":{\"763\":1}}],[\"antonio\",{\"1\":{\"440\":1}}],[\"antlr\",{\"1\":{\"389\":1}}],[\"ant更推荐使用maven\",{\"1\":{\"385\":1}}],[\"ant\",{\"1\":{\"384\":1}}],[\"anonymous\",{\"1\":{\"310\":1,\"312\":2}}],[\"another\",{\"1\":{\"104\":1}}],[\"answer\",{\"1\":{\"915\":1}}],[\"answertab=votes\",{\"1\":{\"116\":1}}],[\"ansible\",{\"1\":{\"462\":1}}],[\"ans\",{\"1\":{\"302\":1}}],[\"anno\",{\"1\":{\"234\":2}}],[\"annotatedelement\",{\"1\":{\"233\":1,\"302\":1}}],[\"annotation=\",{\"1\":{\"302\":1}}],[\"annotation接口\",{\"1\":{\"237\":1}}],[\"annotationclass\",{\"1\":{\"233\":5}}],[\"annotation>\",{\"1\":{\"233\":5}}],[\"annotation\",{\"1\":{\"225\":1,\"227\":1,\"229\":3,\"230\":4,\"233\":2,\"234\":22,\"237\":1,\"238\":1,\"242\":2,\"243\":3,\"302\":1,\"877\":1}}],[\"annotations\",{\"1\":{\"150\":1,\"230\":2,\"310\":1}}],[\"ann\",{\"1\":{\"225\":1,\"942\":3}}],[\"anyof\",{\"1\":{\"978\":1}}],[\"anyway\",{\"1\":{\"104\":1,\"310\":1,\"312\":1}}],[\"any\",{\"1\":{\"71\":2,\"78\":2,\"86\":1,\"104\":3,\"209\":1,\"275\":2,\"477\":1,\"618\":1,\"732\":1}}],[\"anyfork\",{\"1\":{\"0\":1}}],[\"android\",{\"1\":{\"442\":1,\"532\":1}}],[\"and\",{\"0\":{\"63\":1,\"79\":1,\"86\":2,\"124\":1},\"1\":{\"51\":1,\"68\":1,\"75\":1,\"77\":3,\"78\":1,\"82\":1,\"85\":1,\"86\":6,\"104\":3,\"113\":1,\"116\":1,\"120\":3,\"124\":1,\"133\":1,\"144\":1,\"145\":6,\"150\":3,\"151\":1,\"302\":2,\"310\":3,\"312\":7,\"442\":1,\"446\":1,\"455\":1,\"489\":1,\"618\":1,\"732\":1,\"851\":1,\"859\":3,\"864\":3,\"865\":1,\"873\":1,\"933\":1,\"978\":1}}],[\"an\",{\"0\":{\"51\":1,\"61\":1},\"1\":{\"74\":2,\"77\":1,\"104\":9,\"120\":1,\"130\":1,\"145\":4,\"310\":1,\"311\":1,\"431\":1,\"808\":2,\"955\":1}}],[\"ascending\",{\"1\":{\"983\":1}}],[\"ascii\",{\"0\":{\"885\":1},\"1\":{\"883\":1,\"885\":2,\"892\":3,\"911\":1,\"937\":1,\"947\":1}}],[\"astaticmethod\",{\"1\":{\"951\":3}}],[\"astore\",{\"1\":{\"275\":9}}],[\"asm\",{\"1\":{\"312\":52,\"386\":1,\"702\":1,\"858\":1}}],[\"asd\",{\"1\":{\"288\":1,\"289\":1}}],[\"async\",{\"1\":{\"419\":1}}],[\"asyncfactory\",{\"1\":{\"242\":1}}],[\"asyncmanager\",{\"1\":{\"242\":1}}],[\"asymmetric\",{\"0\":{\"51\":1}}],[\"aspectj\",{\"1\":{\"242\":1,\"398\":1}}],[\"aspect\",{\"1\":{\"242\":1}}],[\"assetstatus\",{\"1\":{\"854\":1}}],[\"assertarrayequals\",{\"1\":{\"978\":4}}],[\"assertsame\",{\"1\":{\"978\":4}}],[\"assertion2test\",{\"1\":{\"978\":1}}],[\"assertions\",{\"1\":{\"978\":1}}],[\"assertiontest\",{\"1\":{\"978\":1}}],[\"assertion\",{\"1\":{\"978\":2}}],[\"assertionerror\",{\"1\":{\"950\":1}}],[\"assertissatisfied\",{\"1\":{\"477\":1}}],[\"assertthat\",{\"1\":{\"478\":1,\"978\":10}}],[\"asserttrue\",{\"1\":{\"477\":1,\"478\":2,\"978\":4}}],[\"assertfalse\",{\"1\":{\"478\":1,\"978\":4}}],[\"assertj\",{\"0\":{\"478\":1},\"1\":{\"431\":1,\"478\":1}}],[\"assertnotsame\",{\"1\":{\"978\":4}}],[\"assertnotnull\",{\"1\":{\"241\":2,\"978\":4}}],[\"assertnull\",{\"1\":{\"241\":2,\"978\":4}}],[\"assertequals\",{\"1\":{\"241\":2,\"478\":1,\"975\":2,\"978\":4,\"981\":1}}],[\"assert\",{\"1\":{\"120\":1,\"477\":1,\"975\":1,\"978\":10,\"981\":2}}],[\"assurance\",{\"0\":{\"1015\":1}}],[\"assured\",{\"1\":{\"431\":1}}],[\"assumptions\",{\"1\":{\"476\":1}}],[\"assuming\",{\"1\":{\"302\":1}}],[\"association\",{\"0\":{\"217\":1,\"830\":1},\"1\":{\"217\":1,\"830\":1}}],[\"assign\",{\"1\":{\"143\":1}}],[\"assignment\",{\"1\":{\"129\":1,\"907\":2}}],[\"assigned\",{\"1\":{\"71\":1,\"84\":1}}],[\"aslist体现的是适配器模式\",{\"1\":{\"850\":1}}],[\"aslist的返回对象是一个arrays内部类\",{\"1\":{\"850\":1}}],[\"aslist\",{\"1\":{\"106\":1,\"850\":2,\"978\":2,\"981\":1}}],[\"ask\",{\"1\":{\"71\":1}}],[\"as\",{\"1\":{\"44\":1,\"68\":3,\"69\":1,\"71\":1,\"72\":1,\"73\":1,\"75\":1,\"77\":1,\"78\":1,\"80\":2,\"81\":1,\"82\":2,\"83\":1,\"104\":7,\"145\":2,\"218\":1,\"310\":2,\"312\":1,\"439\":1,\"864\":2,\"865\":4}}],[\"a\",{\"0\":{\"46\":1,\"47\":1,\"48\":2,\"49\":2,\"50\":2,\"51\":1,\"52\":1,\"53\":1,\"60\":1,\"63\":1,\"71\":1,\"81\":1,\"154\":1,\"157\":1,\"162\":1,\"165\":3,\"180\":1,\"181\":2,\"332\":1},\"1\":{\"14\":1,\"56\":1,\"59\":2,\"60\":1,\"61\":1,\"62\":2,\"63\":2,\"64\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":7,\"69\":1,\"70\":1,\"71\":4,\"73\":5,\"76\":1,\"77\":28,\"78\":5,\"80\":1,\"81\":3,\"82\":10,\"83\":2,\"84\":1,\"85\":1,\"86\":6,\"87\":2,\"89\":1,\"93\":1,\"104\":20,\"114\":1,\"127\":3,\"130\":2,\"133\":3,\"141\":3,\"143\":3,\"144\":20,\"145\":8,\"152\":1,\"165\":4,\"180\":3,\"210\":2,\"218\":4,\"222\":2,\"225\":2,\"236\":4,\"264\":3,\"267\":1,\"270\":1,\"271\":1,\"275\":2,\"277\":1,\"279\":16,\"284\":4,\"289\":1,\"310\":5,\"312\":1,\"314\":1,\"446\":1,\"618\":4,\"632\":7,\"633\":2,\"643\":2,\"644\":5,\"716\":4,\"721\":3,\"723\":15,\"732\":3,\"734\":36,\"741\":3,\"745\":6,\"768\":2,\"771\":3,\"776\":2,\"784\":1,\"790\":5,\"812\":1,\"813\":3,\"814\":1,\"818\":1,\"831\":1,\"832\":1,\"833\":1,\"834\":1,\"835\":2,\"838\":2,\"845\":2,\"847\":1,\"848\":9,\"850\":1,\"852\":3,\"854\":2,\"860\":1,\"864\":4,\"902\":1,\"911\":1,\"917\":1,\"958\":2,\"978\":1,\"979\":4,\"993\":1,\"1000\":1}}],[\"2d\",{\"1\":{\"847\":1}}],[\"2d实现\",{\"1\":{\"408\":1}}],[\"21\",{\"1\":{\"846\":1,\"859\":1,\"872\":1,\"979\":1}}],[\"2l\",{\"1\":{\"773\":2,\"847\":1}}],[\"2个以上的类对象\",{\"1\":{\"593\":1}}],[\"2nd\",{\"1\":{\"438\":1}}],[\"266\",{\"1\":{\"980\":1}}],[\"268\",{\"1\":{\"979\":1}}],[\"263\",{\"1\":{\"854\":1}}],[\"269代码生成器\",{\"1\":{\"398\":1}}],[\"26\",{\"1\":{\"291\":2,\"849\":2,\"853\":1}}],[\"2656555\",{\"1\":{\"116\":1}}],[\"292\",{\"1\":{\"980\":1}}],[\"298\",{\"1\":{\"980\":1}}],[\"290\",{\"1\":{\"979\":1}}],[\"29\",{\"1\":{\"275\":1,\"849\":2}}],[\"2954372\",{\"1\":{\"116\":1}}],[\"255\",{\"1\":{\"863\":1}}],[\"253\",{\"1\":{\"854\":1}}],[\"25\",{\"1\":{\"275\":1,\"306\":1,\"485\":1,\"849\":1,\"872\":1}}],[\"230\",{\"1\":{\"979\":1}}],[\"23\",{\"1\":{\"275\":1,\"291\":1,\"485\":1,\"588\":1,\"798\":1,\"981\":1}}],[\"275\",{\"1\":{\"843\":1}}],[\"27\",{\"1\":{\"275\":2,\"872\":1}}],[\"220\",{\"1\":{\"524\":1,\"528\":1}}],[\"220v\",{\"1\":{\"524\":5,\"528\":5}}],[\"22\",{\"1\":{\"275\":2,\"290\":1,\"306\":1,\"773\":3,\"872\":2,\"981\":1}}],[\"222\",{\"1\":{\"130\":2,\"141\":4}}],[\"288\",{\"1\":{\"979\":1}}],[\"28\",{\"1\":{\"270\":1,\"275\":1,\"291\":1,\"850\":2,\"859\":1,\"979\":1}}],[\"28909673\",{\"1\":{\"116\":1}}],[\"240\",{\"1\":{\"870\":1}}],[\"245\",{\"1\":{\"768\":1}}],[\"24\",{\"1\":{\"161\":1,\"275\":2,\"849\":1}}],[\"2048\",{\"1\":{\"854\":2}}],[\"20cm\",{\"1\":{\"555\":1}}],[\"2022\",{\"1\":{\"872\":1}}],[\"20220226231346103\",{\"1\":{\"834\":1}}],[\"20220226231114471\",{\"1\":{\"833\":1}}],[\"20220226232506081\",{\"1\":{\"832\":1}}],[\"20220226232425687\",{\"1\":{\"832\":1}}],[\"20220226230456728\",{\"1\":{\"828\":1}}],[\"20220226225625153\",{\"1\":{\"826\":1}}],[\"20220226225439452\",{\"1\":{\"826\":1}}],[\"20220226103439980\",{\"1\":{\"745\":1}}],[\"20220226103435911\",{\"1\":{\"745\":1}}],[\"20220226103414310\",{\"1\":{\"745\":1}}],[\"20220224203440696\",{\"1\":{\"738\":1}}],[\"20220224203106674\",{\"1\":{\"734\":1}}],[\"20220224200505149\",{\"1\":{\"723\":1}}],[\"20220224195635097\",{\"1\":{\"721\":1}}],[\"20220227141801967\",{\"1\":{\"616\":1}}],[\"20220227140635359\",{\"1\":{\"613\":1}}],[\"20220227140036784\",{\"1\":{\"610\":1}}],[\"20220227134528102\",{\"1\":{\"609\":1}}],[\"20220327001543029\",{\"1\":{\"831\":1}}],[\"20220327001329079\",{\"1\":{\"830\":1}}],[\"20220327001011970\",{\"1\":{\"825\":1}}],[\"20220327001037848\",{\"1\":{\"825\":1}}],[\"20220325225354561\",{\"1\":{\"702\":1}}],[\"20220325225306403\",{\"1\":{\"699\":1}}],[\"20220326235402075\",{\"1\":{\"824\":1}}],[\"20220326223223254\",{\"1\":{\"616\":1}}],[\"20220326223625612\",{\"1\":{\"608\":1}}],[\"20220326222947461\",{\"1\":{\"612\":1}}],[\"20220326114122266\",{\"1\":{\"802\":1}}],[\"20220326113623976\",{\"1\":{\"801\":1}}],[\"20220326182515064\",{\"1\":{\"790\":1}}],[\"20220326181409122\",{\"1\":{\"789\":1}}],[\"20220326181157415\",{\"1\":{\"784\":1}}],[\"20220326180057205\",{\"1\":{\"786\":1}}],[\"20220326183929550\",{\"1\":{\"710\":1}}],[\"20220326184654465\",{\"1\":{\"708\":1}}],[\"20220326184616770\",{\"1\":{\"708\":1}}],[\"20220326162754094\",{\"1\":{\"679\":1}}],[\"20220326162333026\",{\"1\":{\"678\":1}}],[\"20220326160613310\",{\"1\":{\"675\":1}}],[\"20220326160526405\",{\"1\":{\"675\":1}}],[\"20220326161321893\",{\"1\":{\"672\":1}}],[\"20220326165601510\",{\"1\":{\"667\":1}}],[\"20220326165253607\",{\"1\":{\"664\":1}}],[\"20220326164847860\",{\"1\":{\"666\":1}}],[\"20220326163930542\",{\"1\":{\"659\":1}}],[\"20220326163154437\",{\"1\":{\"658\":1}}],[\"20220326163809453\",{\"1\":{\"656\":1}}],[\"20220326155841174\",{\"1\":{\"651\":1}}],[\"20220326155825142\",{\"1\":{\"651\":1}}],[\"20220326155107325\",{\"1\":{\"650\":1}}],[\"20220326154814205\",{\"1\":{\"649\":1}}],[\"20220326172843488\",{\"1\":{\"778\":1}}],[\"20220326172739237\",{\"1\":{\"777\":1}}],[\"20220326173758893\",{\"1\":{\"776\":1}}],[\"20220326171909429\",{\"1\":{\"644\":1}}],[\"20220326171643437\",{\"1\":{\"642\":1}}],[\"20220326170939660\",{\"1\":{\"643\":1}}],[\"20220326123658042\",{\"1\":{\"839\":1}}],[\"20220326123351242\",{\"1\":{\"838\":1}}],[\"20220326122132691\",{\"1\":{\"563\":1}}],[\"20220326122114890\",{\"1\":{\"563\":1}}],[\"20220326121345564\",{\"1\":{\"562\":1}}],[\"20220326120837468\",{\"1\":{\"561\":1}}],[\"20220301175359902\",{\"1\":{\"688\":1}}],[\"20220301174437773\",{\"1\":{\"685\":1}}],[\"20220301174940372\",{\"1\":{\"683\":1}}],[\"20220301171914376\",{\"1\":{\"617\":1}}],[\"20220301195650273\",{\"1\":{\"555\":1}}],[\"20220301194218699\",{\"1\":{\"553\":1}}],[\"20220301201855363\",{\"1\":{\"556\":1}}],[\"20220307155052736\",{\"1\":{\"533\":1}}],[\"20220307154814117\",{\"1\":{\"532\":1}}],[\"20220307153329627\",{\"1\":{\"528\":1}}],[\"20220307113851301\",{\"1\":{\"524\":1}}],[\"20220307113604066\",{\"1\":{\"521\":1}}],[\"20220307113733499\",{\"1\":{\"520\":1}}],[\"20220316220549595\",{\"1\":{\"703\":1}}],[\"20220316221211102\",{\"1\":{\"694\":1}}],[\"20220316221946018\",{\"1\":{\"551\":1}}],[\"20220316215716168\",{\"1\":{\"700\":1}}],[\"20220316213701600\",{\"1\":{\"695\":1}}],[\"20220314192143394\",{\"1\":{\"692\":1}}],[\"20220314191251956\",{\"1\":{\"637\":1}}],[\"20220314190856461\",{\"1\":{\"636\":1}}],[\"20220314190248901\",{\"1\":{\"634\":1}}],[\"20220314190636066\",{\"1\":{\"632\":1}}],[\"20220314190648003\",{\"1\":{\"632\":1}}],[\"20220314180442486\",{\"1\":{\"602\":1}}],[\"20220314180358602\",{\"1\":{\"602\":1}}],[\"20220314175754422\",{\"1\":{\"601\":1}}],[\"20220314175728964\",{\"1\":{\"601\":1}}],[\"20220314175108493\",{\"1\":{\"599\":1}}],[\"20220314175538719\",{\"1\":{\"595\":1}}],[\"20220314170106903\",{\"1\":{\"571\":1}}],[\"20220314170025485\",{\"1\":{\"570\":1}}],[\"20220314162102077\",{\"1\":{\"585\":1}}],[\"20220314162328427\",{\"1\":{\"580\":1}}],[\"20220314161323609\",{\"1\":{\"584\":1}}],[\"20220314161222580\",{\"1\":{\"584\":1}}],[\"20220314160744377\",{\"1\":{\"583\":1}}],[\"20220314160422590\",{\"1\":{\"582\":1}}],[\"20220314165737331\",{\"1\":{\"575\":1}}],[\"20220314164610345\",{\"1\":{\"574\":1}}],[\"20220314164535175\",{\"1\":{\"569\":1}}],[\"20220314163646797\",{\"1\":{\"573\":1}}],[\"20220314163409100\",{\"1\":{\"572\":1}}],[\"20220314155454968\",{\"1\":{\"547\":1}}],[\"20220314154956046\",{\"1\":{\"543\":1}}],[\"20220314154935717\",{\"1\":{\"543\":1}}],[\"20220314154311971\",{\"1\":{\"542\":1}}],[\"20220314154132216\",{\"1\":{\"538\":1}}],[\"20220314153823688\",{\"1\":{\"540\":1}}],[\"20220314153744545\",{\"1\":{\"539\":1}}],[\"20220314150231277\",{\"1\":{\"527\":1}}],[\"20220314150218744\",{\"1\":{\"523\":1}}],[\"2021\",{\"1\":{\"849\":1,\"853\":1}}],[\"2020\",{\"1\":{\"32\":1,\"849\":2,\"872\":2}}],[\"20\",{\"1\":{\"275\":1,\"281\":1,\"306\":1,\"676\":1,\"768\":2,\"859\":1,\"864\":2,\"872\":3}}],[\"2001\",{\"1\":{\"974\":1}}],[\"200\",{\"1\":{\"637\":2,\"854\":1}}],[\"2000\",{\"1\":{\"242\":2}}],[\"20009015\",{\"1\":{\"238\":1,\"243\":1}}],[\"2002\",{\"1\":{\"153\":1}}],[\"2019\",{\"1\":{\"872\":1}}],[\"2016\",{\"1\":{\"872\":1}}],[\"2011\",{\"1\":{\"849\":1}}],[\"2018\",{\"1\":{\"843\":1,\"872\":1}}],[\"2015\",{\"1\":{\"439\":1}}],[\"2013\",{\"1\":{\"116\":1,\"283\":1,\"299\":1}}],[\"2017\",{\"1\":{\"116\":1,\"153\":1,\"287\":1,\"843\":1,\"849\":1,\"872\":8}}],[\"2px\",{\"1\":{\"81\":1}}],[\"2\",{\"0\":{\"349\":1,\"583\":1,\"873\":1},\"1\":{\"0\":1,\"7\":14,\"20\":1,\"71\":1,\"77\":1,\"86\":1,\"93\":2,\"104\":1,\"119\":1,\"123\":1,\"124\":1,\"133\":1,\"134\":1,\"135\":1,\"138\":1,\"139\":2,\"141\":9,\"143\":2,\"144\":1,\"173\":1,\"181\":1,\"241\":2,\"275\":3,\"284\":1,\"285\":1,\"289\":7,\"291\":2,\"305\":1,\"306\":2,\"309\":1,\"312\":1,\"412\":1,\"421\":1,\"424\":1,\"571\":2,\"583\":1,\"584\":3,\"613\":1,\"637\":1,\"643\":1,\"659\":1,\"678\":1,\"687\":1,\"689\":3,\"700\":1,\"703\":1,\"708\":1,\"716\":2,\"718\":2,\"723\":3,\"727\":1,\"728\":1,\"738\":4,\"739\":1,\"742\":1,\"752\":1,\"753\":1,\"769\":1,\"778\":1,\"779\":1,\"790\":3,\"794\":1,\"801\":1,\"832\":1,\"839\":1,\"843\":1,\"845\":3,\"846\":4,\"847\":4,\"848\":4,\"849\":6,\"850\":9,\"851\":1,\"852\":8,\"853\":2,\"854\":3,\"857\":2,\"858\":3,\"863\":2,\"864\":2,\"865\":2,\"866\":1,\"868\":2,\"869\":3,\"870\":1,\"871\":1,\"872\":11,\"873\":1,\"903\":1,\"920\":4,\"924\":1,\"975\":1,\"976\":1,\"978\":3,\"981\":4}}],[\"^\",{\"1\":{\"312\":3}}],[\"^1\",{\"1\":{\"0\":1}}],[\"^0\",{\"1\":{\"0\":1}}],[\"t3的方式命名\",{\"1\":{\"865\":1}}],[\"t3\",{\"1\":{\"865\":1}}],[\"tmall\",{\"1\":{\"869\":1}}],[\"tm\",{\"1\":{\"801\":2}}],[\"tmpconstructor\",{\"1\":{\"310\":4}}],[\"tmp\",{\"1\":{\"264\":3,\"312\":7}}],[\"tcp\",{\"1\":{\"870\":1}}],[\"tcp连接超时\",{\"1\":{\"853\":1}}],[\"tcpudpdeal\",{\"1\":{\"845\":2}}],[\"tcl\",{\"1\":{\"614\":1}}],[\"tccl\",{\"1\":{\"104\":4}}],[\"tv\",{\"1\":{\"659\":14,\"728\":14}}],[\"tvoffcommand\",{\"1\":{\"562\":6}}],[\"tvoncommand\",{\"1\":{\"562\":6}}],[\"tvreceiver\",{\"1\":{\"562\":13}}],[\"tuples\",{\"0\":{\"468\":1},\"1\":{\"468\":1}}],[\"tutorial\",{\"1\":{\"294\":1,\"299\":1}}],[\"t1\",{\"1\":{\"310\":3,\"732\":3,\"864\":3,\"865\":6}}],[\"t0\",{\"1\":{\"310\":2}}],[\"t2\",{\"1\":{\"309\":2,\"732\":2,\"864\":2,\"865\":6,\"946\":1}}],[\"tps\",{\"1\":{\"306\":1}}],[\"tps=cs3\",{\"1\":{\"306\":1}}],[\"tp\",{\"1\":{\"306\":1}}],[\"t在运行时才能被确定下来\",{\"1\":{\"295\":1}}],[\"t是type的简称\",{\"1\":{\"281\":1}}],[\"txt\",{\"1\":{\"264\":3}}],[\"t>描述和说明\",{\"1\":{\"872\":1}}],[\"t>不能使用get方法\",{\"1\":{\"850\":1}}],[\"t>来接收返回的数据\",{\"1\":{\"850\":1}}],[\"t>\",{\"1\":{\"236\":1,\"284\":2,\"790\":1,\"850\":2}}],[\"type头来确定\",{\"1\":{\"854\":1}}],[\"type=\",{\"1\":{\"622\":2,\"624\":2}}],[\"typed\",{\"1\":{\"411\":1}}],[\"type就是一个接口而已\",{\"1\":{\"308\":1}}],[\"typevariable\",{\"1\":{\"298\":1}}],[\"type体系中类型的包括\",{\"1\":{\"298\":1}}],[\"type是java中所有类型的公共高级接口\",{\"1\":{\"298\":1}}],[\"typeparameterandtypeuseannotation<\",{\"1\":{\"236\":1}}],[\"type\",{\"1\":{\"104\":1,\"130\":1,\"145\":1,\"147\":1,\"150\":2,\"224\":1,\"225\":1,\"227\":4,\"229\":1,\"230\":1,\"236\":9,\"275\":3,\"278\":1,\"284\":1,\"285\":2,\"287\":2,\"294\":1,\"295\":2,\"298\":9,\"301\":1,\"302\":1,\"306\":4,\"308\":5,\"312\":4,\"618\":1,\"626\":1,\"636\":10,\"710\":5,\"738\":13,\"739\":5,\"848\":1,\"854\":1,\"864\":1,\"927\":1}}],[\"typesafely\",{\"1\":{\"474\":1}}],[\"typesafe统一查询\",{\"1\":{\"394\":1}}],[\"types\",{\"0\":{\"69\":1},\"1\":{\"59\":1,\"69\":1,\"130\":1,\"145\":1,\"225\":1,\"227\":1,\"312\":2}}],[\"t\",{\"1\":{\"103\":1,\"104\":5,\"114\":1,\"129\":1,\"130\":1,\"147\":9,\"209\":1,\"225\":1,\"233\":4,\"234\":1,\"236\":4,\"268\":2,\"275\":2,\"279\":2,\"281\":9,\"282\":5,\"284\":12,\"285\":7,\"289\":7,\"291\":3,\"293\":6,\"295\":5,\"296\":5,\"297\":9,\"298\":3,\"305\":6,\"306\":2,\"310\":7,\"312\":7,\"451\":1,\"478\":2,\"649\":1,\"790\":1,\"809\":1,\"812\":1,\"850\":1,\"871\":1,\"884\":1,\"907\":1,\"946\":2}}],[\"tes\",{\"1\":{\"863\":1}}],[\"testb\",{\"1\":{\"983\":1}}],[\"testblockforever\",{\"1\":{\"980\":1}}],[\"testc\",{\"1\":{\"983\":1}}],[\"testcase2\",{\"1\":{\"976\":1}}],[\"testcase1\",{\"1\":{\"976\":1,\"980\":2}}],[\"testcase来实现\",{\"1\":{\"241\":1}}],[\"testcase\",{\"1\":{\"96\":1,\"241\":1,\"819\":1}}],[\"testa\",{\"1\":{\"983\":1}}],[\"testasserttrue\",{\"1\":{\"978\":1}}],[\"testassertthathamcrestcorematchers\",{\"1\":{\"978\":1}}],[\"testassertthathasitems\",{\"1\":{\"978\":1}}],[\"testassertthateveryitemcontainsstring\",{\"1\":{\"978\":1}}],[\"testassertthatbothcontainsstring\",{\"1\":{\"978\":1}}],[\"testassertsame\",{\"1\":{\"978\":1}}],[\"testassertnull\",{\"1\":{\"978\":1}}],[\"testassertnotsame\",{\"1\":{\"978\":1}}],[\"testassertnotnull\",{\"1\":{\"978\":1}}],[\"testassertfalse\",{\"1\":{\"978\":1}}],[\"testassertequals\",{\"1\":{\"978\":1}}],[\"testassertarrayequals\",{\"1\":{\"978\":1}}],[\"testprimenumberchecker\",{\"1\":{\"981\":1}}],[\"testtimedoutexception\",{\"1\":{\"980\":1}}],[\"testtimes\",{\"1\":{\"276\":7}}],[\"test注解一起使用\",{\"1\":{\"980\":1}}],[\"test注解在方法上标记方法为测试方法\",{\"1\":{\"975\":1}}],[\"test注解的一些函数\",{\"1\":{\"972\":1,\"981\":1}}],[\"test就行了\",{\"1\":{\"972\":1}}],[\"testsuit\",{\"1\":{\"999\":1}}],[\"testsuite\",{\"1\":{\"819\":1,\"982\":3}}],[\"testsleepfortoolong\",{\"1\":{\"980\":1}}],[\"testsay\",{\"1\":{\"241\":2}}],[\"testmethodorder\",{\"1\":{\"983\":1}}],[\"testmethod\",{\"1\":{\"478\":2}}],[\"testmethodannotation\",{\"1\":{\"234\":7}}],[\"testing\",{\"0\":{\"475\":1},\"1\":{\"988\":1,\"989\":1}}],[\"testinheritedannotation被\",{\"1\":{\"230\":1}}],[\"testinheritedannotation\",{\"1\":{\"230\":4}}],[\"testng\",{\"1\":{\"431\":1,\"476\":1}}],[\"testnpe\",{\"1\":{\"275\":8}}],[\"tested\",{\"1\":{\"980\":1}}],[\"tester\",{\"1\":{\"309\":1}}],[\"testexceptionhandling\",{\"1\":{\"270\":5}}],[\"test$inner\",{\"1\":{\"305\":1}}],[\"testobj\",{\"1\":{\"241\":2}}],[\"testworld\",{\"1\":{\"241\":2}}],[\"testhello\",{\"1\":{\"241\":2}}],[\"testdoc\",{\"1\":{\"229\":1}}],[\"testdocannotation\",{\"1\":{\"229\":2}}],[\"testdocannotation注解信息\",{\"1\":{\"229\":1}}],[\"test2<t>\",{\"1\":{\"296\":2}}],[\"test2\",{\"1\":{\"93\":1,\"236\":1}}],[\"test\",{\"0\":{\"996\":1,\"997\":1,\"998\":1},\"1\":{\"93\":2,\"145\":3,\"201\":1,\"222\":2,\"230\":2,\"234\":2,\"236\":1,\"241\":5,\"276\":4,\"284\":1,\"288\":2,\"289\":7,\"290\":1,\"291\":6,\"293\":1,\"305\":16,\"309\":3,\"477\":2,\"622\":1,\"624\":1,\"819\":1,\"848\":2,\"859\":2,\"860\":3,\"940\":2,\"972\":2,\"975\":3,\"976\":5,\"977\":4,\"978\":20,\"979\":10,\"980\":8,\"981\":4,\"982\":5,\"983\":4,\"994\":1,\"996\":10,\"997\":2,\"998\":2}}],[\"terminated\",{\"1\":{\"845\":2}}],[\"terminalexpression\",{\"1\":{\"642\":1}}],[\"terminal\",{\"1\":{\"642\":1}}],[\"tercher\",{\"1\":{\"830\":1}}],[\"team\",{\"1\":{\"978\":2,\"984\":1}}],[\"teamcity\",{\"1\":{\"392\":1}}],[\"teas\",{\"1\":{\"830\":1,\"831\":4}}],[\"teaching\",{\"1\":{\"831\":1}}],[\"teacher\",{\"1\":{\"831\":3}}],[\"teacherdaoproxy\",{\"1\":{\"695\":7}}],[\"teacherdao\",{\"1\":{\"695\":6,\"700\":2,\"703\":5}}],[\"teach\",{\"1\":{\"695\":5,\"700\":3,\"703\":2}}],[\"teardown\",{\"1\":{\"241\":3,\"997\":2}}],[\"temperatrue\",{\"1\":{\"676\":3,\"678\":4}}],[\"temperature\",{\"1\":{\"676\":7,\"678\":13}}],[\"templatemethodpattern\",{\"1\":{\"801\":1}}],[\"templatemethod\",{\"1\":{\"801\":2}}],[\"template\",{\"1\":{\"591\":1,\"798\":1,\"800\":2,\"814\":1}}],[\"temporaryres\",{\"1\":{\"310\":2}}],[\"tempfunctiontest\",{\"1\":{\"309\":3}}],[\"temp\",{\"1\":{\"284\":2}}],[\"tech\",{\"1\":{\"243\":1,\"277\":1,\"299\":1,\"314\":1,\"975\":1,\"976\":1,\"977\":1,\"978\":2,\"979\":2,\"980\":3,\"981\":2,\"982\":3,\"983\":1}}],[\"textonetwohard\",{\"1\":{\"86\":1}}],[\"text|\",{\"1\":{\"86\":1}}],[\"text|b\",{\"1\":{\"62\":1}}],[\"texttext2abc\",{\"1\":{\"68\":1}}],[\"text2\",{\"1\":{\"68\":1,\"78\":1}}],[\"textab\",{\"1\":{\"62\":1,\"63\":2,\"65\":1,\"67\":1}}],[\"text\",{\"0\":{\"62\":1,\"63\":1,\"65\":1,\"67\":1},\"1\":{\"47\":2,\"48\":2,\"50\":2,\"51\":2,\"52\":2,\"53\":2,\"54\":2,\"55\":2,\"58\":2,\"59\":1,\"62\":2,\"63\":1,\"65\":1,\"67\":1,\"68\":1,\"72\":3,\"77\":1,\"78\":3,\"86\":2,\"955\":1,\"978\":2}}],[\"tex\",{\"0\":{\"26\":1}}],[\"tweetability\",{\"1\":{\"813\":6}}],[\"tweetable\",{\"1\":{\"813\":6}}],[\"tweet\",{\"1\":{\"813\":6}}],[\"twitter官方账号\",{\"1\":{\"440\":2}}],[\"twitter\",{\"0\":{\"440\":1},\"1\":{\"85\":1}}],[\"two\",{\"1\":{\"71\":2,\"74\":1,\"75\":4,\"86\":2,\"92\":3,\"708\":2,\"847\":2,\"978\":1}}],[\"task\",{\"1\":{\"851\":2,\"863\":1}}],[\"tapromotion\",{\"1\":{\"845\":1}}],[\"tapromotion反例\",{\"1\":{\"845\":1}}],[\"tapestry\",{\"1\":{\"434\":1}}],[\"takipi\",{\"1\":{\"416\":1,\"442\":1}}],[\"taking\",{\"1\":{\"312\":1}}],[\"take\",{\"1\":{\"68\":1,\"312\":1}}],[\"taobao\",{\"1\":{\"845\":1,\"846\":3,\"859\":1,\"869\":2}}],[\"tao\",{\"1\":{\"291\":6}}],[\"target>\",{\"1\":{\"974\":1}}],[\"targetmethodref\",{\"1\":{\"312\":1}}],[\"targetclass\",{\"1\":{\"312\":3}}],[\"target注解用来说明那些被它所注解的注解类可修饰的对象范围\",{\"1\":{\"227\":1}}],[\"target注解的作用是\",{\"1\":{\"227\":1}}],[\"target用于标明注解使用的范围\",{\"1\":{\"221\":1}}],[\"target\",{\"0\":{\"227\":1},\"1\":{\"77\":1,\"221\":1,\"223\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"229\":2,\"230\":1,\"234\":2,\"236\":2,\"242\":1,\"275\":3,\"312\":5,\"519\":1,\"695\":5,\"700\":10,\"703\":10,\"927\":1}}],[\"tabs\",{\"1\":{\"847\":1}}],[\"tab\",{\"1\":{\"77\":4,\"116\":1,\"847\":1}}],[\"table在功能上与不带where子句的delete语句相同\",{\"1\":{\"865\":1}}],[\"table比delete速度快\",{\"1\":{\"865\":1}}],[\"table\",{\"1\":{\"71\":1,\"275\":4,\"865\":6,\"866\":1}}],[\"trove\",{\"1\":{\"406\":1}}],[\"troublesome\",{\"1\":{\"72\":1}}],[\"transient\",{\"1\":{\"934\":1}}],[\"transfermoney\",{\"1\":{\"941\":1}}],[\"transfer\",{\"1\":{\"868\":1,\"873\":1}}],[\"transform\",{\"1\":{\"466\":1}}],[\"transactional事务不要滥用\",{\"1\":{\"866\":1}}],[\"trace\",{\"1\":{\"857\":1}}],[\"trade\",{\"1\":{\"859\":1,\"863\":1}}],[\"tradeid\",{\"1\":{\"846\":3}}],[\"traditional\",{\"1\":{\"618\":1}}],[\"trampoline等特性\",{\"1\":{\"403\":1}}],[\"travis\",{\"1\":{\"392\":1,\"460\":1}}],[\"trapezoid\",{\"0\":{\"56\":1,\"57\":1}}],[\"tree命令\",{\"1\":{\"869\":1}}],[\"tree的最左前缀匹配特性\",{\"1\":{\"864\":1}}],[\"treemap\",{\"0\":{\"322\":1},\"1\":{\"850\":1}}],[\"treeset是order\",{\"1\":{\"850\":1}}],[\"treeset\",{\"0\":{\"322\":1}}],[\"treated\",{\"1\":{\"78\":1}}],[\"truncate\",{\"1\":{\"865\":2}}],[\"truth\",{\"1\":{\"431\":1}}],[\"truck\",{\"1\":{\"213\":2}}],[\"truefield\",{\"1\":{\"91\":5}}],[\"truetest\",{\"1\":{\"91\":1}}],[\"true\",{\"0\":{\"167\":1},\"1\":{\"0\":1,\"13\":1,\"77\":3,\"91\":8,\"93\":1,\"103\":1,\"114\":3,\"120\":3,\"125\":2,\"138\":7,\"139\":1,\"180\":1,\"181\":4,\"242\":1,\"288\":1,\"306\":1,\"307\":2,\"308\":2,\"310\":4,\"311\":3,\"624\":1,\"637\":2,\"649\":1,\"650\":2,\"752\":1,\"753\":1,\"754\":1,\"755\":1,\"756\":1,\"757\":1,\"758\":1,\"778\":1,\"803\":1,\"848\":2,\"978\":2,\"981\":4}}],[\"trial\",{\"1\":{\"978\":2}}],[\"triangle\",{\"1\":{\"738\":3,\"739\":3}}],[\"trisha\",{\"1\":{\"440\":1}}],[\"trim\",{\"1\":{\"104\":3,\"114\":1,\"312\":1}}],[\"triggered\",{\"1\":{\"77\":2}}],[\"tryacquire\",{\"1\":{\"852\":1}}],[\"trylock\",{\"1\":{\"851\":1}}],[\"try<user>\",{\"1\":{\"469\":1}}],[\"trycatchreturn\",{\"1\":{\"275\":6}}],[\"try语句块监控代码\",{\"1\":{\"260\":1}}],[\"try语句块中的语句逐一被执行\",{\"1\":{\"257\":1}}],[\"trywithresourcetest\",{\"1\":{\"259\":1}}],[\"try块中的return语句执行成功后\",{\"1\":{\"273\":1,\"858\":1}}],[\"try块中引起异常\",{\"1\":{\"258\":1}}],[\"try块没有引发异常\",{\"1\":{\"258\":1}}],[\"trying\",{\"1\":{\"104\":5}}],[\"try\",{\"0\":{\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"264\":1},\"1\":{\"91\":1,\"103\":3,\"104\":9,\"114\":4,\"120\":1,\"141\":3,\"146\":1,\"150\":1,\"182\":2,\"186\":1,\"196\":2,\"234\":2,\"241\":1,\"242\":1,\"251\":1,\"253\":1,\"255\":4,\"256\":3,\"257\":3,\"258\":2,\"259\":3,\"260\":2,\"263\":1,\"264\":13,\"267\":2,\"268\":1,\"269\":2,\"270\":2,\"271\":1,\"273\":1,\"275\":6,\"276\":1,\"297\":5,\"309\":1,\"310\":4,\"312\":1,\"448\":1,\"451\":2,\"469\":3,\"618\":1,\"625\":2,\"627\":1,\"687\":1,\"689\":2,\"779\":1,\"851\":4,\"858\":2,\"901\":1,\"902\":2,\"950\":2}}],[\"tb\",{\"1\":{\"43\":1,\"44\":1,\"68\":2,\"74\":2,\"75\":1,\"76\":1}}],[\"tdd\",{\"1\":{\"991\":1}}],[\"td\",{\"1\":{\"43\":1,\"44\":1,\"54\":1,\"55\":1,\"56\":1,\"57\":1,\"58\":1,\"71\":2,\"85\":1}}],[\"toarray\",{\"1\":{\"850\":2,\"872\":1}}],[\"toajax\",{\"1\":{\"242\":3}}],[\"toyduck\",{\"1\":{\"788\":4,\"789\":6}}],[\"tobytearray\",{\"1\":{\"689\":1}}],[\"today\",{\"1\":{\"676\":3,\"678\":3}}],[\"todo\",{\"1\":{\"104\":1,\"625\":1,\"626\":2,\"853\":1}}],[\"tojson\",{\"1\":{\"467\":1}}],[\"tojsonstring\",{\"1\":{\"242\":2}}],[\"tolist\",{\"1\":{\"455\":1}}],[\"touppercase\",{\"1\":{\"455\":2,\"469\":1}}],[\"tomap\",{\"1\":{\"850\":3,\"872\":1}}],[\"tom\",{\"1\":{\"636\":1,\"684\":3,\"685\":1,\"687\":1,\"700\":1}}],[\"tomee\",{\"1\":{\"429\":1}}],[\"tomcat默认限制为2mb\",{\"1\":{\"854\":1}}],[\"tomcat加java\",{\"1\":{\"429\":1}}],[\"tomcat\",{\"1\":{\"429\":1}}],[\"token\",{\"1\":{\"427\":2,\"809\":7,\"908\":1,\"912\":1}}],[\"togenericstring\",{\"1\":{\"306\":2,\"307\":1,\"308\":1}}],[\"tostring的简单类\",{\"1\":{\"873\":1}}],[\"tostring时\",{\"1\":{\"848\":1}}],[\"tostringmethod\",{\"1\":{\"234\":2}}],[\"tostringexample\",{\"1\":{\"140\":6}}],[\"tostring\",{\"0\":{\"140\":1},\"1\":{\"114\":1,\"127\":1,\"137\":1,\"140\":1,\"190\":1,\"230\":1,\"234\":5,\"254\":1,\"284\":4,\"305\":2,\"306\":4,\"307\":1,\"308\":2,\"312\":3,\"649\":2,\"685\":1,\"687\":1,\"790\":2,\"848\":1,\"911\":2,\"915\":1}}],[\"toolkit\",{\"1\":{\"434\":1}}],[\"tool\",{\"1\":{\"401\":1,\"407\":1,\"869\":1}}],[\"tools\",{\"0\":{\"479\":1},\"1\":{\"145\":1,\"152\":1}}],[\"tooltip\",{\"1\":{\"77\":10}}],[\"too\",{\"1\":{\"68\":2,\"870\":1,\"912\":1}}],[\"to\",{\"0\":{\"73\":1},\"1\":{\"43\":2,\"44\":5,\"59\":2,\"68\":3,\"70\":1,\"71\":8,\"72\":2,\"73\":2,\"75\":2,\"76\":1,\"77\":9,\"78\":2,\"80\":6,\"81\":2,\"82\":7,\"83\":1,\"84\":1,\"85\":1,\"86\":1,\"87\":4,\"104\":22,\"120\":1,\"133\":1,\"143\":1,\"145\":11,\"152\":1,\"165\":1,\"225\":37,\"264\":3,\"275\":3,\"310\":8,\"311\":1,\"312\":11,\"451\":1,\"485\":2,\"618\":2,\"659\":2,\"716\":1,\"808\":1,\"826\":1,\"850\":1,\"997\":2}}],[\"topb1f1i1b2f2i2ab\",{\"1\":{\"76\":1}}],[\"top\",{\"1\":{\"43\":1,\"44\":4,\"76\":2,\"77\":1,\"116\":1}}],[\"tochararray\",{\"1\":{\"644\":2}}],[\"toc\",{\"1\":{\"34\":1}}],[\"th\",{\"1\":{\"618\":4}}],[\"thoughts\",{\"1\":{\"442\":1}}],[\"thoughtwork开源解决方案\",{\"1\":{\"392\":1}}],[\"thymeleaf\",{\"1\":{\"430\":1}}],[\"thumbnailator是一个高质量java缩略图开发库\",{\"1\":{\"408\":1}}],[\"thumbnailator\",{\"1\":{\"408\":1}}],[\"through\",{\"0\":{\"924\":1},\"1\":{\"924\":3}}],[\"throw等中断逻辑的右大括号后需要加一个空行\",{\"1\":{\"852\":1}}],[\"throwifcondition\",{\"1\":{\"452\":1}}],[\"throwing\",{\"1\":{\"242\":1}}],[\"throwexception\",{\"1\":{\"310\":1}}],[\"thrown\",{\"1\":{\"310\":1}}],[\"throw\",{\"0\":{\"253\":1},\"1\":{\"104\":1,\"114\":5,\"196\":2,\"241\":1,\"251\":1,\"253\":2,\"257\":1,\"260\":1,\"270\":2,\"271\":1,\"276\":1,\"297\":1,\"310\":6,\"311\":1,\"312\":2,\"451\":1,\"574\":2,\"625\":1,\"627\":3,\"768\":2,\"779\":8,\"812\":1,\"850\":1}}],[\"throws抛出异常的规则\",{\"1\":{\"252\":1}}],[\"throws\",{\"0\":{\"252\":1},\"1\":{\"104\":2,\"114\":5,\"137\":5,\"141\":4,\"196\":2,\"234\":2,\"241\":3,\"242\":3,\"251\":1,\"252\":3,\"253\":1,\"257\":1,\"259\":1,\"260\":1,\"266\":3,\"270\":1,\"271\":1,\"288\":1,\"291\":1,\"293\":1,\"297\":1,\"305\":3,\"306\":1,\"307\":1,\"308\":4,\"310\":9,\"311\":1,\"312\":4,\"644\":3,\"689\":3,\"700\":1,\"703\":2,\"957\":1,\"980\":3}}],[\"throwable>\",{\"1\":{\"297\":3}}],[\"throwable\",{\"0\":{\"246\":1,\"268\":1},\"1\":{\"103\":1,\"114\":1,\"137\":1,\"146\":1,\"234\":1,\"246\":3,\"254\":1,\"268\":4,\"271\":1,\"275\":1,\"297\":1,\"312\":2,\"700\":1,\"703\":2}}],[\"threshold\",{\"1\":{\"852\":1}}],[\"threadfactory\",{\"1\":{\"851\":1}}],[\"threadlocal无法解决共享对象的更新问题\",{\"1\":{\"851\":1}}],[\"threadlocal对象使用static修饰\",{\"1\":{\"851\":1}}],[\"threadlocalrandom\",{\"1\":{\"851\":1}}],[\"threadlocal<dateformat>\",{\"1\":{\"851\":2}}],[\"threadlocal\",{\"1\":{\"771\":2}}],[\"threadlocal详解\",{\"0\":{\"516\":1}}],[\"threadpoolexecutor详解\",{\"0\":{\"498\":1}}],[\"thread则会终止\",{\"1\":{\"275\":1}}],[\"thread\",{\"0\":{\"1011\":1},\"1\":{\"104\":1,\"114\":1,\"270\":1,\"312\":2,\"469\":1,\"771\":1,\"845\":2,\"851\":7,\"980\":5}}],[\"three都要增加几个空格\",{\"1\":{\"847\":1}}],[\"threeten\",{\"1\":{\"396\":1}}],[\"threeonec2c1twob2b1a2a1\",{\"1\":{\"74\":1,\"75\":1}}],[\"three\",{\"1\":{\"74\":1,\"75\":2,\"847\":1,\"978\":2}}],[\"that\",{\"0\":{\"72\":1},\"1\":{\"71\":1,\"80\":1,\"82\":1,\"83\":1,\"85\":1,\"104\":8,\"138\":4,\"145\":2,\"225\":2,\"270\":1,\"271\":1,\"310\":3,\"312\":3,\"732\":1,\"950\":1}}],[\"than\",{\"1\":{\"71\":3,\"82\":1,\"145\":1,\"716\":1}}],[\"thing\",{\"1\":{\"312\":1}}],[\"thinkwon\",{\"1\":{\"277\":1}}],[\"thinking\",{\"1\":{\"155\":4,\"301\":1,\"438\":1}}],[\"think\",{\"1\":{\"104\":1,\"155\":1}}],[\"third\",{\"1\":{\"104\":1,\"458\":1,\"983\":1}}],[\"thicker\",{\"1\":{\"81\":1}}],[\"thick\",{\"0\":{\"66\":1,\"67\":1},\"1\":{\"71\":3}}],[\"thisclass\",{\"1\":{\"312\":2}}],[\"thisclassloader\",{\"1\":{\"104\":2}}],[\"this和super不能出现在同一个构造器中\",{\"1\":{\"200\":1}}],[\"this在同一类中调用其他构造均需要放在第一行\",{\"1\":{\"200\":1}}],[\"this\",{\"0\":{\"200\":1},\"1\":{\"43\":3,\"47\":2,\"48\":2,\"50\":2,\"51\":2,\"52\":2,\"53\":2,\"54\":2,\"55\":2,\"58\":2,\"62\":3,\"68\":2,\"72\":2,\"76\":1,\"77\":9,\"78\":1,\"82\":1,\"86\":1,\"87\":1,\"104\":9,\"114\":2,\"127\":3,\"132\":1,\"134\":3,\"138\":4,\"140\":1,\"144\":4,\"145\":1,\"147\":1,\"200\":1,\"264\":1,\"268\":1,\"269\":3,\"276\":1,\"281\":5,\"282\":3,\"284\":6,\"289\":2,\"291\":4,\"298\":1,\"302\":2,\"305\":4,\"306\":5,\"310\":20,\"311\":1,\"312\":15,\"445\":3,\"446\":5,\"450\":3,\"528\":1,\"538\":1,\"542\":2,\"555\":5,\"561\":2,\"571\":2,\"574\":4,\"580\":1,\"584\":3,\"601\":6,\"622\":3,\"625\":3,\"627\":1,\"632\":3,\"636\":3,\"644\":6,\"649\":2,\"650\":7,\"656\":4,\"659\":15,\"664\":4,\"667\":11,\"676\":7,\"678\":12,\"685\":6,\"687\":6,\"689\":3,\"695\":1,\"700\":1,\"703\":3,\"708\":1,\"710\":9,\"728\":4,\"734\":1,\"742\":3,\"743\":3,\"768\":6,\"772\":1,\"773\":2,\"776\":3,\"778\":10,\"779\":11,\"784\":1,\"789\":2,\"814\":2,\"826\":1,\"831\":1,\"832\":2,\"838\":3,\"839\":3,\"846\":1,\"848\":3,\"850\":1,\"851\":1,\"902\":3,\"912\":2,\"933\":3,\"958\":1,\"981\":2}}],[\"theaterlight\",{\"1\":{\"601\":14}}],[\"theories\",{\"1\":{\"476\":1}}],[\"theserverside\",{\"1\":{\"442\":1}}],[\"these\",{\"1\":{\"310\":1,\"311\":1,\"489\":1,\"942\":1}}],[\"theunsafe\",{\"1\":{\"93\":1}}],[\"their\",{\"1\":{\"78\":1,\"104\":1,\"145\":2}}],[\"therefore\",{\"1\":{\"145\":1}}],[\"there\",{\"1\":{\"69\":1,\"70\":1,\"86\":1,\"716\":1}}],[\"then\",{\"1\":{\"68\":1,\"104\":1,\"145\":1,\"310\":1,\"469\":2}}],[\"the\",{\"0\":{\"50\":1,\"446\":1,\"483\":1},\"1\":{\"43\":4,\"47\":4,\"48\":4,\"50\":4,\"51\":5,\"52\":4,\"53\":4,\"54\":4,\"55\":4,\"58\":4,\"62\":4,\"68\":8,\"70\":1,\"71\":20,\"72\":5,\"73\":1,\"74\":1,\"75\":2,\"76\":4,\"77\":17,\"78\":4,\"80\":11,\"82\":6,\"83\":2,\"85\":3,\"86\":10,\"87\":7,\"104\":45,\"120\":2,\"122\":1,\"134\":1,\"145\":5,\"151\":1,\"152\":2,\"264\":3,\"270\":1,\"271\":1,\"284\":3,\"302\":3,\"310\":21,\"311\":1,\"312\":11,\"442\":2,\"469\":1,\"474\":1,\"488\":1,\"618\":3,\"958\":3,\"960\":2,\"997\":2}}],[\"tinyint\",{\"1\":{\"863\":2}}],[\"timsort\",{\"1\":{\"790\":1}}],[\"tim\",{\"1\":{\"440\":1}}],[\"timed\",{\"1\":{\"980\":1}}],[\"timeunit\",{\"1\":{\"980\":6}}],[\"time字段值为当前时间\",{\"1\":{\"866\":1}}],[\"time的类型均为datetime类型\",{\"1\":{\"863\":1}}],[\"timer运行多个timetask时\",{\"1\":{\"851\":1}}],[\"time反例\",{\"1\":{\"845\":1}}],[\"timezoneconvert\",{\"1\":{\"859\":1}}],[\"timezone\",{\"1\":{\"618\":3}}],[\"timestamp时\",{\"1\":{\"849\":1}}],[\"timestamp\",{\"1\":{\"849\":1}}],[\"times\",{\"1\":{\"452\":1}}],[\"time4j\",{\"1\":{\"396\":1}}],[\"time是实际使用的时间日期库标准\",{\"1\":{\"396\":1}}],[\"timeouttest\",{\"1\":{\"980\":3}}],[\"timeout=1000\",{\"1\":{\"980\":1}}],[\"timeout=30\",{\"1\":{\"870\":1}}],[\"timeout参数和\",{\"1\":{\"980\":1}}],[\"timeout\",{\"1\":{\"137\":2,\"980\":7}}],[\"time\",{\"0\":{\"470\":1},\"1\":{\"82\":1,\"104\":1,\"150\":1,\"187\":1,\"294\":2,\"301\":1,\"396\":1,\"470\":1,\"659\":2,\"845\":1,\"849\":2,\"863\":3,\"873\":1}}],[\"tigase\",{\"1\":{\"414\":1}}],[\"tidb\",{\"1\":{\"400\":1}}],[\"ti\",{\"1\":{\"310\":1}}],[\"tips\",{\"1\":{\"275\":1}}],[\"tip\",{\"1\":{\"14\":1,\"77\":1,\"857\":1}}],[\"title=tostringmethod\",{\"1\":{\"234\":1}}],[\"title=test\",{\"1\":{\"234\":1}}],[\"title=old\",{\"1\":{\"234\":1}}],[\"title\",{\"1\":{\"0\":1,\"74\":1,\"213\":1,\"214\":1,\"215\":1,\"216\":1,\"217\":1,\"218\":1,\"234\":5,\"242\":5,\"474\":1}}],[\"dd正例\",{\"1\":{\"859\":1}}],[\"dd的格式\",{\"1\":{\"853\":1}}],[\"dd进行日期格式化\",{\"1\":{\"849\":1}}],[\"dd\",{\"1\":{\"849\":1,\"851\":1,\"854\":1}}],[\"dto\",{\"1\":{\"845\":2,\"848\":1,\"868\":1,\"871\":2,\"873\":2}}],[\"dp\",{\"0\":{\"740\":1}}],[\"d+e=23\",{\"1\":{\"643\":1}}],[\"d+e\",{\"1\":{\"643\":1}}],[\"dvdplayer\",{\"1\":{\"601\":12}}],[\"dvd\",{\"1\":{\"597\":3,\"601\":6}}],[\"dstv\",{\"1\":{\"524\":2}}],[\"dst\",{\"1\":{\"524\":1,\"525\":1,\"527\":2,\"528\":5,\"529\":1}}],[\"dsl\",{\"1\":{\"431\":1}}],[\"db\",{\"1\":{\"469\":1,\"767\":1,\"818\":1}}],[\"dfa\",{\"1\":{\"432\":1}}],[\"dcevm\",{\"1\":{\"398\":1,\"482\":1}}],[\"dummy\",{\"1\":{\"996\":4}}],[\"dumping\",{\"1\":{\"485\":1}}],[\"dump\",{\"1\":{\"485\":2}}],[\"dubbo\",{\"1\":{\"859\":1,\"869\":2}}],[\"duck\",{\"1\":{\"787\":4,\"788\":4,\"789\":5}}],[\"during\",{\"1\":{\"275\":1}}],[\"due\",{\"1\":{\"77\":1}}],[\"dysfunctional\",{\"1\":{\"145\":1}}],[\"dynamicreports\",{\"1\":{\"421\":1}}],[\"dynamically\",{\"1\":{\"104\":1,\"145\":1}}],[\"dynamic\",{\"1\":{\"0\":1,\"150\":1}}],[\"drink\",{\"1\":{\"582\":3,\"583\":1,\"584\":10,\"585\":1}}],[\"driver文件\",{\"1\":{\"103\":1,\"110\":1}}],[\"driverslist\",{\"1\":{\"103\":3}}],[\"driversiterator\",{\"1\":{\"103\":6,\"111\":3}}],[\"drivers\",{\"1\":{\"103\":10}}],[\"driver的实现\",{\"1\":{\"101\":1}}],[\"driver的文件\",{\"1\":{\"100\":1}}],[\"driver\",{\"1\":{\"98\":2,\"99\":1,\"100\":1,\"101\":1,\"102\":1,\"103\":3,\"109\":1,\"111\":1,\"145\":1,\"543\":4}}],[\"drivermanager是java中的实现\",{\"1\":{\"103\":1}}],[\"drivermanager\",{\"0\":{\"98\":1},\"1\":{\"102\":1,\"103\":4}}],[\"driver接口\",{\"1\":{\"95\":1}}],[\"dropwizard\",{\"1\":{\"424\":1,\"457\":1}}],[\"druid\",{\"1\":{\"400\":1}}],[\"dremel论文中发布的基于组装算法的列式\",{\"1\":{\"395\":1}}],[\"drawtriangle\",{\"1\":{\"738\":1}}],[\"drawrectangle\",{\"1\":{\"738\":4}}],[\"drawshape\",{\"1\":{\"738\":7,\"739\":5}}],[\"drawcircle\",{\"1\":{\"308\":7,\"738\":4}}],[\"draw\",{\"1\":{\"308\":10,\"739\":9}}],[\"drawbacks\",{\"1\":{\"145\":1}}],[\"d\",{\"1\":{\"68\":4,\"70\":1,\"71\":4,\"77\":3,\"86\":1,\"305\":1,\"312\":2,\"580\":2,\"643\":2,\"650\":2,\"721\":2,\"723\":19,\"797\":1,\"854\":1,\"860\":1,\"864\":2}}],[\"dictionary\",{\"1\":{\"850\":1}}],[\"diff\",{\"1\":{\"848\":2}}],[\"differences\",{\"1\":{\"151\":1}}],[\"difference\",{\"1\":{\"113\":1,\"116\":1,\"150\":1}}],[\"different\",{\"1\":{\"59\":1,\"81\":1,\"82\":1}}],[\"dip\",{\"0\":{\"724\":1}}],[\"di\",{\"0\":{\"621\":1,\"622\":1,\"623\":1},\"1\":{\"620\":4,\"621\":6,\"622\":8,\"623\":1,\"624\":2,\"627\":1}}],[\"dim\",{\"1\":{\"601\":3}}],[\"diamonds\",{\"1\":{\"915\":1}}],[\"diamond方式\",{\"1\":{\"850\":1}}],[\"diamond\",{\"1\":{\"150\":1}}],[\"diagram在新窗口打开\",{\"1\":{\"219\":1}}],[\"diagram\",{\"1\":{\"68\":1,\"78\":1,\"826\":1}}],[\"director\",{\"1\":{\"550\":1,\"551\":1}}],[\"directory\",{\"1\":{\"104\":1}}],[\"directly\",{\"1\":{\"309\":1,\"474\":1}}],[\"directional\",{\"0\":{\"70\":1}}],[\"direction\",{\"0\":{\"76\":1},\"1\":{\"43\":1,\"76\":5}}],[\"div>\",{\"1\":{\"77\":1}}],[\"discussion\",{\"1\":{\"885\":1}}],[\"discontinued\",{\"1\":{\"439\":1,\"488\":1}}],[\"discount\",{\"1\":{\"284\":2}}],[\"discouraged\",{\"1\":{\"225\":1}}],[\"discoverable\",{\"1\":{\"145\":1}}],[\"discovery\",{\"1\":{\"104\":2}}],[\"distinct\",{\"1\":{\"864\":1,\"865\":2}}],[\"distributedlock\",{\"1\":{\"772\":2}}],[\"dispenseprize\",{\"1\":{\"778\":6}}],[\"dispenseoutstate\",{\"1\":{\"778\":4}}],[\"dispensestate\",{\"1\":{\"778\":4}}],[\"dispensoutstate\",{\"1\":{\"778\":1}}],[\"display\",{\"1\":{\"667\":4,\"676\":2,\"678\":4,\"787\":3,\"788\":1,\"789\":4,\"839\":4}}],[\"displaying\",{\"1\":{\"77\":1}}],[\"disruptor\",{\"1\":{\"406\":1}}],[\"disable\",{\"1\":{\"310\":1}}],[\"disabled\",{\"1\":{\"77\":1}}],[\"do语句中必须使用大括号\",{\"1\":{\"852\":1}}],[\"doothers\",{\"1\":{\"851\":3}}],[\"do等保留字与左右括号之间都必须加空格\",{\"1\":{\"847\":1}}],[\"doinstatemnt\",{\"1\":{\"563\":1}}],[\"doinstatement\",{\"1\":{\"563\":1}}],[\"dom等模块\",{\"1\":{\"408\":1}}],[\"domain\",{\"1\":{\"312\":1}}],[\"doesnotcontain\",{\"1\":{\"478\":1}}],[\"doesn\",{\"1\":{\"312\":1}}],[\"dowork\",{\"1\":{\"297\":3}}],[\"download\",{\"1\":{\"809\":3}}],[\"downloadfromaliyun\",{\"1\":{\"809\":3}}],[\"down\",{\"1\":{\"44\":1,\"601\":3}}],[\"doprint\",{\"1\":{\"284\":1}}],[\"doprivileged\",{\"1\":{\"103\":2,\"114\":2,\"310\":1,\"312\":1}}],[\"dosomething\",{\"1\":{\"266\":1,\"267\":1,\"851\":3,\"902\":1}}],[\"doafterthrowing\",{\"1\":{\"242\":1}}],[\"doafterreturning\",{\"1\":{\"242\":1}}],[\"docker\",{\"0\":{\"1016\":1},\"1\":{\"1001\":1}}],[\"documentation\",{\"1\":{\"877\":1}}],[\"documents4j\",{\"1\":{\"402\":1}}],[\"documented注解的作用是\",{\"1\":{\"229\":1}}],[\"documented用于标明是否生成javadoc文档\",{\"1\":{\"221\":1}}],[\"documented\",{\"0\":{\"229\":1},\"1\":{\"221\":1,\"224\":1,\"226\":1,\"229\":2,\"242\":1}}],[\"doc\",{\"0\":{\"995\":1},\"1\":{\"402\":1,\"995\":1}}],[\"docx\",{\"1\":{\"402\":1}}],[\"docs\",{\"1\":{\"294\":1,\"299\":1}}],[\"docsify\",{\"1\":{\"77\":1}}],[\"dog\",{\"1\":{\"127\":31,\"305\":16}}],[\"donothingelse\",{\"1\":{\"902\":1}}],[\"donothing\",{\"1\":{\"902\":1}}],[\"donotignoreexceptions\",{\"1\":{\"269\":1}}],[\"donotcatchthrowable\",{\"1\":{\"268\":1}}],[\"donotcloseresourceintry\",{\"1\":{\"264\":1}}],[\"don\",{\"1\":{\"104\":2,\"129\":1,\"225\":1,\"234\":1,\"268\":1,\"871\":1}}],[\"done\",{\"1\":{\"82\":1,\"87\":1}}],[\"do\",{\"1\":{\"103\":1,\"104\":1,\"264\":2,\"268\":2,\"269\":2,\"270\":1,\"271\":1,\"310\":1,\"845\":1,\"868\":1,\"873\":1,\"900\":1,\"933\":1}}],[\"dothing\",{\"1\":{\"477\":1}}],[\"dots\",{\"1\":{\"71\":1}}],[\"dotted\",{\"0\":{\"64\":1,\"65\":1},\"1\":{\"71\":3}}],[\"double>\",{\"1\":{\"850\":2}}],[\"double>>\",{\"1\":{\"850\":2}}],[\"double和关键字void同样表现为\",{\"1\":{\"302\":1}}],[\"doublevalue\",{\"1\":{\"279\":4,\"312\":1}}],[\"double\",{\"0\":{\"58\":1,\"128\":1,\"166\":1,\"996\":1},\"1\":{\"73\":2,\"77\":1,\"78\":1,\"119\":1,\"128\":1,\"158\":1,\"166\":2,\"253\":1,\"279\":4,\"312\":1,\"757\":1,\"846\":1,\"847\":1,\"848\":3,\"851\":1,\"996\":2}}],[\"dazhepromotion\",{\"1\":{\"845\":1}}],[\"dayarray\",{\"1\":{\"849\":1}}],[\"daysofthisyear\",{\"1\":{\"849\":1}}],[\"day\",{\"1\":{\"618\":2}}],[\"dao层\",{\"1\":{\"868\":1}}],[\"dao层方法命名规约\",{\"1\":{\"845\":1}}],[\"daoexception\",{\"1\":{\"858\":1,\"868\":1}}],[\"daosupport\",{\"1\":{\"833\":2}}],[\"dao\",{\"1\":{\"474\":1,\"716\":1}}],[\"dagger\",{\"1\":{\"449\":1}}],[\"dagger2\",{\"1\":{\"397\":1}}],[\"datetimeformatter代替simpledateformat\",{\"1\":{\"851\":1}}],[\"dateformat\",{\"1\":{\"851\":1}}],[\"datestyle\",{\"1\":{\"851\":1}}],[\"date>\",{\"1\":{\"291\":1}}],[\"dateinter\",{\"1\":{\"291\":8}}],[\"date\",{\"1\":{\"150\":1,\"187\":1,\"289\":1,\"291\":17,\"848\":1,\"849\":5,\"853\":1}}],[\"dataloader\",{\"1\":{\"930\":1}}],[\"data2=\",{\"1\":{\"790\":1}}],[\"data2\",{\"1\":{\"790\":3}}],[\"datachange\",{\"1\":{\"675\":1,\"676\":3,\"677\":1,\"678\":3}}],[\"datainputstream\",{\"1\":{\"585\":1}}],[\"dataholder\",{\"1\":{\"445\":4,\"446\":1}}],[\"datamelt\",{\"1\":{\"425\":1}}],[\"data\",{\"1\":{\"130\":1,\"298\":5,\"310\":1,\"423\":1,\"440\":1,\"445\":9,\"446\":8,\"450\":7,\"732\":1,\"790\":3,\"848\":2,\"868\":2,\"873\":2}}],[\"databasesearch\",{\"1\":{\"96\":1}}],[\"database\",{\"1\":{\"49\":2}}],[\"dasharray\",{\"1\":{\"81\":1}}],[\"dashes\",{\"1\":{\"71\":3}}],[\"danger\",{\"1\":{\"14\":1}}],[\"deductsfromsource\",{\"1\":{\"941\":1}}],[\"deductmoney\",{\"1\":{\"778\":7}}],[\"debug\",{\"1\":{\"859\":4}}],[\"debugger\",{\"1\":{\"485\":1}}],[\"debuggers\",{\"1\":{\"145\":2}}],[\"debuctmoney\",{\"1\":{\"778\":2}}],[\"demeter1\",{\"1\":{\"742\":1,\"743\":1}}],[\"demeter\",{\"1\":{\"741\":1}}],[\"demofunction\",{\"1\":{\"769\":3,\"814\":2}}],[\"demo1\",{\"1\":{\"284\":1}}],[\"demo\",{\"1\":{\"77\":1,\"624\":1,\"847\":1}}],[\"devoxx4kids成员\",{\"1\":{\"440\":1}}],[\"devoxx\",{\"1\":{\"440\":1}}],[\"develop\",{\"0\":{\"1013\":1}}],[\"developing\",{\"1\":{\"152\":1}}],[\"developer\",{\"1\":{\"145\":1}}],[\"development\",{\"1\":{\"145\":2,\"403\":1}}],[\"derived\",{\"1\":{\"431\":1}}],[\"deeply\",{\"1\":{\"942\":1}}],[\"deeplearning4j\",{\"1\":{\"413\":1}}],[\"deepspace\",{\"1\":{\"939\":2}}],[\"deep\",{\"1\":{\"689\":3,\"939\":1}}],[\"deepprototype\",{\"1\":{\"689\":17}}],[\"deepclone\",{\"1\":{\"689\":2}}],[\"deepcloneabletarget=\",{\"1\":{\"689\":4}}],[\"deepcloneabletarget\",{\"1\":{\"689\":14}}],[\"deepcloneexample\",{\"1\":{\"141\":8}}],[\"deepdive\",{\"1\":{\"413\":1}}],[\"delayed等\",{\"1\":{\"863\":1}}],[\"deltaspike\",{\"1\":{\"397\":1}}],[\"delegation\",{\"1\":{\"813\":1}}],[\"delegatingmethodaccessorimpl\",{\"1\":{\"312\":8,\"979\":2,\"980\":2}}],[\"delegatingconstructoraccessorimpl\",{\"1\":{\"310\":1}}],[\"delegate\",{\"1\":{\"310\":1,\"312\":7,\"591\":1}}],[\"deleted\",{\"1\":{\"863\":1,\"872\":1}}],[\"deletedeptbyid\",{\"1\":{\"242\":1}}],[\"delete做前缀\",{\"1\":{\"845\":1}}],[\"delete\",{\"1\":{\"242\":1,\"419\":1,\"679\":1,\"833\":1,\"834\":2,\"854\":1}}],[\"des\",{\"1\":{\"574\":14,\"582\":1,\"584\":6}}],[\"design\",{\"0\":{\"1014\":1},\"1\":{\"415\":1,\"795\":2,\"796\":1,\"860\":1}}],[\"desired\",{\"1\":{\"104\":1}}],[\"destidx++\",{\"1\":{\"311\":1}}],[\"destidx\",{\"1\":{\"311\":1}}],[\"destroy\",{\"1\":{\"145\":1,\"622\":3}}],[\"desc=\",{\"1\":{\"307\":1}}],[\"descfield\",{\"1\":{\"307\":2}}],[\"desc\",{\"1\":{\"307\":6,\"650\":13}}],[\"descriptor\",{\"1\":{\"312\":3,\"870\":1}}],[\"description=override\",{\"1\":{\"234\":1}}],[\"description=suppress\",{\"1\":{\"234\":1}}],[\"description=deprecated\",{\"1\":{\"234\":1}}],[\"description\",{\"1\":{\"234\":4,\"266\":2}}],[\"describes\",{\"1\":{\"270\":1,\"271\":1}}],[\"described\",{\"1\":{\"87\":1}}],[\"describe\",{\"1\":{\"68\":2,\"312\":1}}],[\"depth\",{\"1\":{\"310\":1}}],[\"deptid\",{\"1\":{\"242\":6}}],[\"deptservice\",{\"1\":{\"242\":8}}],[\"deptcontroller\",{\"1\":{\"242\":1}}],[\"dept\",{\"1\":{\"242\":20}}],[\"deprecation\",{\"1\":{\"225\":2,\"234\":1}}],[\"deprecated注解\",{\"1\":{\"848\":1}}],[\"deprecated注解的代码则编译器将发出警告\",{\"1\":{\"222\":1}}],[\"deprecated\",{\"0\":{\"224\":1},\"1\":{\"222\":2,\"224\":1,\"225\":1,\"234\":3,\"928\":1,\"929\":1,\"949\":1,\"957\":1}}],[\"deprecated和\",{\"1\":{\"221\":1,\"222\":1}}],[\"dep\",{\"1\":{\"225\":1,\"477\":5}}],[\"departmentlist\",{\"1\":{\"650\":10}}],[\"departments\",{\"1\":{\"650\":11,\"850\":2}}],[\"department\",{\"1\":{\"574\":8,\"650\":20,\"828\":4}}],[\"departmentb\",{\"1\":{\"216\":2}}],[\"departmentapprover\",{\"1\":{\"710\":8}}],[\"departmenta\",{\"1\":{\"216\":2}}],[\"deploying\",{\"0\":{\"456\":1}}],[\"deploy\",{\"1\":{\"104\":1}}],[\"deployed\",{\"1\":{\"104\":1}}],[\"dependecyinversion\",{\"1\":{\"727\":2}}],[\"dependence\",{\"0\":{\"828\":1},\"1\":{\"725\":1}}],[\"dependencypass\",{\"1\":{\"728\":1}}],[\"dependencymanagement\",{\"1\":{\"459\":1}}],[\"dependency>\",{\"1\":{\"458\":1,\"974\":1}}],[\"dependency\",{\"0\":{\"218\":1,\"449\":1,\"459\":1},\"1\":{\"218\":1,\"620\":1,\"828\":1}}],[\"dependencies>\",{\"1\":{\"458\":1,\"974\":1}}],[\"dependencies\",{\"1\":{\"68\":1}}],[\"depend5\",{\"1\":{\"723\":3}}],[\"depend4\",{\"1\":{\"723\":3}}],[\"depend3\",{\"1\":{\"723\":3}}],[\"depend2\",{\"1\":{\"723\":3}}],[\"depend1\",{\"1\":{\"723\":6}}],[\"depends\",{\"1\":{\"459\":2}}],[\"depending\",{\"1\":{\"71\":1}}],[\"detach\",{\"1\":{\"839\":1}}],[\"details\",{\"1\":{\"14\":1,\"116\":1,\"155\":1,\"219\":1,\"238\":1,\"243\":2,\"277\":3,\"299\":4,\"305\":1,\"310\":1,\"314\":3,\"984\":1,\"1000\":1}}],[\"detected\",{\"1\":{\"485\":1}}],[\"determine\",{\"1\":{\"104\":3}}],[\"decode\",{\"1\":{\"848\":1}}],[\"decoratorpattern\",{\"1\":{\"580\":1}}],[\"decorator\",{\"1\":{\"579\":1,\"580\":4,\"584\":5,\"585\":1,\"590\":1,\"798\":1,\"814\":1}}],[\"decaf\",{\"1\":{\"581\":1,\"582\":1,\"584\":3,\"585\":1}}],[\"decision\",{\"1\":{\"86\":1}}],[\"deciding\",{\"1\":{\"80\":1}}],[\"declaringclass\",{\"1\":{\"312\":8}}],[\"declaration\",{\"1\":{\"86\":4}}],[\"declarations\",{\"0\":{\"86\":1},\"1\":{\"86\":2}}],[\"declaredpublicmethods\",{\"1\":{\"310\":1,\"311\":2}}],[\"declaredpublicfields\",{\"1\":{\"310\":1}}],[\"declaredmethods\",{\"1\":{\"310\":1,\"311\":2}}],[\"declaredfields\",{\"1\":{\"310\":1}}],[\"declaredconstructors\",{\"1\":{\"310\":3}}],[\"declared\",{\"1\":{\"310\":1,\"311\":1}}],[\"declare\",{\"1\":{\"68\":2}}],[\"declares\",{\"1\":{\"43\":3}}],[\"dec\",{\"1\":{\"73\":2}}],[\"def\",{\"1\":{\"667\":16}}],[\"defineclass方法实现中\",{\"1\":{\"312\":1}}],[\"defineclass\",{\"1\":{\"312\":2}}],[\"define\",{\"1\":{\"82\":1,\"104\":3}}],[\"defined\",{\"1\":{\"77\":1,\"80\":2,\"104\":1,\"145\":2,\"627\":2}}],[\"defining\",{\"1\":{\"82\":1,\"87\":1,\"310\":1}}],[\"definitions\",{\"1\":{\"84\":1}}],[\"definition\",{\"1\":{\"71\":1,\"74\":1,\"77\":1,\"82\":1,\"83\":2}}],[\"defaultbaz\",{\"1\":{\"450\":1}}],[\"default\",{\"0\":{\"84\":1,\"451\":1,\"925\":1},\"1\":{\"71\":1,\"77\":1,\"80\":1,\"84\":2,\"104\":5,\"133\":1,\"150\":1,\"229\":2,\"234\":2,\"242\":4,\"302\":1,\"308\":1,\"531\":1,\"618\":1,\"644\":1,\"852\":2,\"922\":1,\"924\":1,\"925\":2,\"934\":1}}],[\"denaro\",{\"1\":{\"0\":1}}],[\"0<\",{\"1\":{\"974\":1}}],[\"0x20\",{\"1\":{\"883\":1}}],[\"0x00001000\",{\"1\":{\"302\":1}}],[\"0x00004000\",{\"1\":{\"302\":1}}],[\"0x00002000\",{\"1\":{\"302\":1}}],[\"08\",{\"1\":{\"872\":1}}],[\"06\",{\"1\":{\"872\":1}}],[\"05\",{\"1\":{\"872\":2}}],[\"03\",{\"1\":{\"872\":3}}],[\"07\",{\"1\":{\"872\":1}}],[\"0开始\",{\"1\":{\"869\":1}}],[\"0000\",{\"1\":{\"874\":1}}],[\"00000\",{\"1\":{\"857\":1}}],[\"00000001\",{\"1\":{\"93\":4}}],[\"0001\",{\"1\":{\"857\":1}}],[\"00\",{\"1\":{\"848\":1}}],[\"0f\",{\"1\":{\"584\":7,\"710\":1,\"848\":2}}],[\"02\",{\"1\":{\"439\":1,\"872\":5}}],[\"0和websocket启发的http客户端连接器\",{\"1\":{\"424\":1}}],[\"012\",{\"1\":{\"884\":1}}],[\"01\",{\"1\":{\"287\":1}}],[\"01111111111111111111111111111110\",{\"1\":{\"90\":1}}],[\"0d196ad23915\",{\"1\":{\"116\":1}}],[\"09\",{\"1\":{\"116\":1,\"283\":1,\"299\":1,\"872\":2}}],[\"04\",{\"1\":{\"116\":1,\"283\":1,\"299\":1,\"872\":1}}],[\"0之后不需要用class\",{\"1\":{\"98\":1}}],[\"0之前\",{\"1\":{\"98\":1}}],[\"0\",{\"0\":{\"167\":2,\"349\":1},\"1\":{\"0\":4,\"77\":1,\"86\":1,\"93\":1,\"100\":1,\"101\":2,\"103\":4,\"114\":7,\"120\":1,\"133\":3,\"141\":5,\"146\":1,\"209\":1,\"228\":11,\"242\":3,\"253\":2,\"273\":1,\"275\":16,\"276\":3,\"284\":1,\"288\":1,\"290\":3,\"291\":10,\"294\":2,\"298\":1,\"306\":4,\"310\":6,\"311\":5,\"312\":3,\"420\":1,\"427\":1,\"459\":1,\"477\":2,\"528\":1,\"532\":2,\"562\":7,\"584\":1,\"618\":1,\"622\":2,\"624\":2,\"627\":1,\"644\":2,\"649\":1,\"650\":2,\"659\":3,\"678\":1,\"709\":1,\"710\":3,\"742\":2,\"743\":2,\"769\":1,\"771\":1,\"772\":1,\"778\":4,\"790\":5,\"830\":4,\"845\":1,\"847\":3,\"848\":17,\"849\":3,\"850\":7,\"851\":1,\"852\":1,\"855\":1,\"858\":1,\"863\":6,\"865\":4,\"869\":9,\"872\":12,\"920\":4,\"974\":9,\"979\":2,\"981\":1,\"993\":1}}],[\"1中\",{\"1\":{\"854\":1}}],[\"1e\",{\"1\":{\"848\":1}}],[\"1+8\",{\"1\":{\"734\":1}}],[\"1+8=\",{\"1\":{\"734\":1}}],[\"1l\",{\"1\":{\"689\":1,\"773\":2}}],[\"1渲染器\",{\"1\":{\"421\":1}}],[\"137\",{\"1\":{\"979\":1}}],[\"139\",{\"1\":{\"773\":1,\"861\":1}}],[\"138\",{\"1\":{\"773\":1}}],[\"134\",{\"1\":{\"773\":3}}],[\"13\",{\"0\":{\"342\":1},\"1\":{\"790\":1,\"872\":1}}],[\"1994\",{\"1\":{\"808\":1}}],[\"1990\",{\"1\":{\"796\":1}}],[\"192\",{\"1\":{\"773\":3}}],[\"1988\",{\"1\":{\"736\":1}}],[\"1987\",{\"1\":{\"732\":1}}],[\"1948\",{\"1\":{\"474\":1}}],[\"19\",{\"1\":{\"275\":4,\"790\":1,\"850\":1,\"863\":1,\"872\":1,\"979\":1,\"981\":1}}],[\"19th\",{\"1\":{\"17\":1}}],[\"140\",{\"1\":{\"773\":1}}],[\"14\",{\"0\":{\"343\":1},\"1\":{\"228\":1,\"275\":5,\"790\":1,\"872\":1,\"979\":1,\"980\":1}}],[\"15978\",{\"1\":{\"845\":1}}],[\"150\",{\"1\":{\"676\":1,\"846\":1,\"863\":1}}],[\"15\",{\"0\":{\"344\":1},\"1\":{\"228\":1,\"275\":3,\"308\":1,\"859\":1}}],[\"15分钟的闹钟\",{\"1\":{\"36\":1}}],[\"18\",{\"1\":{\"209\":1,\"307\":1,\"790\":1}}],[\"1190000006731125\",{\"1\":{\"993\":1,\"1000\":1}}],[\"112\",{\"1\":{\"872\":1}}],[\"11+3\",{\"1\":{\"734\":1}}],[\"11+3=\",{\"1\":{\"734\":1}}],[\"11+3+9=\",{\"1\":{\"734\":2}}],[\"11\",{\"0\":{\"339\":1,\"340\":1,\"360\":1},\"1\":{\"228\":2,\"275\":5,\"290\":1,\"643\":1,\"734\":13,\"790\":1,\"798\":2,\"820\":1,\"849\":1,\"853\":1,\"859\":1,\"864\":2,\"872\":2}}],[\"11个方法\",{\"1\":{\"190\":1}}],[\"111\",{\"1\":{\"130\":3}}],[\"11111111111111111111111111111101\",{\"1\":{\"90\":1}}],[\"1f\",{\"1\":{\"128\":2,\"848\":1}}],[\"12<\",{\"1\":{\"974\":1}}],[\"120\",{\"1\":{\"847\":4}}],[\"12\",{\"0\":{\"341\":1},\"1\":{\"790\":1,\"849\":3,\"850\":2,\"865\":1,\"872\":1,\"979\":1,\"980\":1}}],[\"1219\",{\"1\":{\"861\":1}}],[\"121\",{\"1\":{\"289\":1}}],[\"127\",{\"1\":{\"120\":6,\"161\":1,\"165\":2,\"622\":1,\"624\":1,\"637\":6,\"848\":1}}],[\"128\",{\"1\":{\"120\":4,\"161\":1,\"637\":2,\"848\":1}}],[\"128~127\",{\"1\":{\"120\":1}}],[\"12345\",{\"1\":{\"857\":1}}],[\"12306\",{\"1\":{\"692\":1}}],[\"123\",{\"1\":{\"120\":10,\"133\":1,\"140\":1,\"144\":2,\"288\":1,\"290\":2,\"768\":1}}],[\"175\",{\"1\":{\"846\":1}}],[\"17\",{\"0\":{\"340\":1,\"346\":1},\"1\":{\"116\":2,\"139\":1,\"270\":1,\"275\":1,\"979\":1,\"980\":1}}],[\"160\",{\"1\":{\"676\":1}}],[\"16\",{\"0\":{\"345\":1},\"1\":{\"86\":1,\"119\":2,\"275\":3,\"291\":1,\"465\":1,\"850\":4,\"854\":1,\"866\":1,\"872\":1}}],[\"10339039\",{\"1\":{\"984\":1}}],[\"1052\",{\"1\":{\"865\":1}}],[\"1024\",{\"1\":{\"850\":1,\"870\":1,\"872\":1}}],[\"10f\",{\"1\":{\"678\":2}}],[\"10cm\",{\"1\":{\"555\":1}}],[\"10125073\",{\"1\":{\"309\":1}}],[\"101681073\",{\"1\":{\"277\":1}}],[\"1000\",{\"1\":{\"849\":2,\"852\":1,\"980\":2}}],[\"100000\",{\"1\":{\"864\":1}}],[\"100000000000000000000000000000001\",{\"1\":{\"93\":1}}],[\"10000\",{\"1\":{\"276\":1,\"709\":3,\"710\":2}}],[\"100f\",{\"1\":{\"678\":2}}],[\"100\",{\"0\":{\"905\":1},\"1\":{\"295\":1,\"308\":2,\"532\":2,\"555\":1,\"667\":2,\"814\":1,\"848\":3,\"857\":1,\"888\":1,\"891\":1,\"905\":1,\"980\":2}}],[\"100d\",{\"1\":{\"279\":1}}],[\"106038023\",{\"1\":{\"238\":1,\"243\":1}}],[\"10\",{\"0\":{\"338\":1},\"1\":{\"73\":1,\"141\":3,\"230\":1,\"275\":1,\"285\":6,\"294\":8,\"295\":1,\"643\":1,\"684\":1,\"742\":2,\"743\":2,\"768\":4,\"777\":1,\"778\":2,\"845\":1,\"850\":3,\"852\":1,\"855\":1,\"863\":1,\"864\":1,\"980\":2}}],[\"1\",{\"0\":{\"167\":1,\"186\":1,\"187\":1,\"582\":1,\"872\":1},\"1\":{\"0\":1,\"7\":12,\"14\":1,\"18\":1,\"20\":1,\"32\":2,\"71\":1,\"93\":4,\"104\":2,\"114\":3,\"119\":1,\"120\":3,\"123\":1,\"124\":1,\"128\":8,\"129\":6,\"133\":1,\"134\":1,\"135\":1,\"138\":3,\"139\":6,\"141\":1,\"143\":3,\"144\":1,\"150\":2,\"173\":1,\"181\":1,\"186\":1,\"203\":2,\"217\":4,\"222\":1,\"226\":2,\"227\":2,\"228\":2,\"241\":2,\"275\":7,\"278\":1,\"284\":1,\"285\":1,\"287\":1,\"288\":1,\"289\":8,\"290\":4,\"291\":7,\"292\":1,\"294\":5,\"305\":1,\"306\":3,\"308\":1,\"309\":1,\"310\":1,\"312\":2,\"562\":4,\"571\":2,\"583\":1,\"584\":3,\"613\":1,\"618\":1,\"622\":1,\"624\":1,\"637\":1,\"643\":1,\"649\":2,\"650\":5,\"659\":3,\"672\":1,\"678\":1,\"684\":1,\"685\":1,\"687\":1,\"689\":3,\"700\":1,\"703\":1,\"708\":1,\"710\":2,\"716\":2,\"718\":1,\"723\":5,\"728\":1,\"734\":8,\"738\":4,\"739\":1,\"742\":1,\"743\":1,\"752\":1,\"753\":1,\"769\":1,\"778\":4,\"779\":1,\"790\":9,\"794\":1,\"801\":1,\"830\":2,\"832\":1,\"839\":1,\"845\":4,\"846\":2,\"847\":7,\"848\":11,\"849\":8,\"850\":11,\"851\":3,\"852\":9,\"853\":2,\"854\":4,\"855\":1,\"857\":2,\"858\":3,\"863\":5,\"864\":4,\"865\":2,\"866\":1,\"868\":1,\"869\":6,\"870\":1,\"872\":27,\"920\":4,\"924\":2,\"935\":1,\"974\":1,\"975\":2,\"976\":1,\"978\":3,\"979\":2,\"980\":1,\"981\":1}}],[\"你将遵循\",{\"1\":{\"981\":1}}],[\"你将会有几十个外部依赖了\",{\"1\":{\"458\":1}}],[\"你将会丢失堆栈跟踪和原始异常的消息\",{\"1\":{\"271\":1}}],[\"你见过建筑设计图纸吗\",{\"1\":{\"823\":1}}],[\"你设计了一款优秀的电子商务网站\",{\"1\":{\"820\":1}}],[\"你创建了一个使用方形按钮的\",{\"1\":{\"820\":1}}],[\"你在\",{\"1\":{\"820\":1}}],[\"你接手维护该项目怎么办\",{\"1\":{\"796\":1}}],[\"你完全可以简单地理解为就是代码本身\",{\"1\":{\"770\":1}}],[\"你中有我\",{\"1\":{\"658\":1,\"797\":1}}],[\"你刚刚参加工作想租房\",{\"1\":{\"655\":1}}],[\"你可能又会说\",{\"1\":{\"812\":1}}],[\"你可能会有这样的疑问\",{\"1\":{\"810\":1}}],[\"你可能会说\",{\"1\":{\"622\":1,\"766\":1,\"769\":1,\"812\":1}}],[\"你可以测试代码是否它抛出了想要得到的异常\",{\"1\":{\"979\":1}}],[\"你可以先自己思考一下\",{\"1\":{\"812\":1}}],[\"你可以简单理解为存储目录\",{\"1\":{\"809\":1}}],[\"你可以自行补充完整\",{\"1\":{\"626\":1}}],[\"你可以自由在这里书写你的\",{\"1\":{\"33\":1}}],[\"你可以看到你的代码的健康状况信息\",{\"1\":{\"484\":1}}],[\"你可以把针对你的代码的检查规则控制在\",{\"1\":{\"484\":1}}],[\"你可以把它检入你的版本控制工具\",{\"1\":{\"484\":1}}],[\"你可以把相同的代码转换成这个样子\",{\"1\":{\"478\":1}}],[\"你可以获取到变量的变化历史\",{\"1\":{\"481\":1}}],[\"你可以用像\",{\"1\":{\"472\":1}}],[\"你可以用新出的优秀的\",{\"1\":{\"450\":1}}],[\"你可以选择一个版本\",{\"1\":{\"459\":1}}],[\"你可以像这样来写代码\",{\"1\":{\"455\":1}}],[\"你可以像这样在类中用\",{\"1\":{\"450\":1}}],[\"你可以很容易地动态构建集合\",{\"1\":{\"451\":1}}],[\"你可以很容易去修改它\",{\"1\":{\"451\":1}}],[\"你可以建一个静态内部类来构建你的对象\",{\"1\":{\"446\":1}}],[\"你可以确保你清理了所有打开的资源\",{\"1\":{\"264\":1}}],[\"你可以使用它们验证你的代码从而检查代码是否有问题\",{\"1\":{\"484\":1}}],[\"你可以使用它轻松生成文档或博客站点\",{\"1\":{\"8\":1}}],[\"你可以使用\",{\"1\":{\"466\":1}}],[\"你可以使用这个语法\",{\"1\":{\"264\":1}}],[\"你可以使用可随机访问的\",{\"1\":{\"188\":1}}],[\"你可以通过在某处构建子类来与框架建立联系\",{\"1\":{\"819\":1}}],[\"你可以通过安装\",{\"1\":{\"481\":1}}],[\"你可以通过主题选项和页面\",{\"1\":{\"34\":1}}],[\"你可以通过设置页面的\",{\"1\":{\"6\":1}}],[\"你可以将图片和\",{\"1\":{\"33\":1}}],[\"你可以在下面的代码片断中看到这样一个\",{\"1\":{\"267\":1}}],[\"你可以在\",{\"1\":{\"32\":1,\"268\":1}}],[\"你可以在这里放置你的主体内容\",{\"1\":{\"0\":1}}],[\"你可以标记\",{\"1\":{\"19\":1}}],[\"你可以设置在主题选项中设置\",{\"1\":{\"13\":1}}],[\"你把你代码提交到这个服务器来进行分析\",{\"1\":{\"484\":1}}],[\"你甚至可以使用自定义注解来实现静态分析\",{\"1\":{\"483\":1}}],[\"你就给我滚多远\",{\"1\":{\"852\":1}}],[\"你就会发现\",{\"1\":{\"810\":1}}],[\"你就会发现神奇地打印了false\",{\"1\":{\"91\":1}}],[\"你就懂了面向对象分析和设计\",{\"1\":{\"797\":1}}],[\"你就可以从服务器看到实时变化\",{\"1\":{\"482\":1}}],[\"你还想咋地\",{\"1\":{\"478\":1}}],[\"你曾经用\",{\"1\":{\"478\":1}}],[\"你对\",{\"1\":{\"472\":1}}],[\"你写的类要和路由文件中的路由信息关联起来\",{\"1\":{\"472\":1}}],[\"你仅仅只需要实现\",{\"1\":{\"466\":1}}],[\"你会从这些自动化方式中尝到很多的甜头\",{\"1\":{\"462\":1}}],[\"你会发现有些库的版本是冲突的\",{\"1\":{\"459\":1}}],[\"你会爱上自己的改变\",{\"1\":{\"36\":1}}],[\"你所有的\",{\"1\":{\"458\":1}}],[\"你的仓库也跑起来了\",{\"1\":{\"462\":1}}],[\"你的代码已经编译完了\",{\"1\":{\"462\":1}}],[\"你的项目到底要引入哪一个版本呢\",{\"1\":{\"459\":1}}],[\"你的根\",{\"1\":{\"458\":1}}],[\"你的内在再丰富\",{\"1\":{\"36\":1}}],[\"你以可重用代码的名义全放这了\",{\"1\":{\"452\":1}}],[\"你不得不迁移到手动配置更多的部署方案上来\",{\"1\":{\"457\":1}}],[\"你不得不使用依赖注入\",{\"1\":{\"449\":1}}],[\"你不能在没有强制类型转换的前提下将一个\",{\"1\":{\"166\":1}}],[\"你如果又用list2往里面add\",{\"1\":{\"290\":1}}],[\"你却使用异常处理\",{\"1\":{\"272\":1}}],[\"你应该把它放到\",{\"1\":{\"477\":1}}],[\"你应该把清理工作的代码放到\",{\"1\":{\"264\":1}}],[\"你应该有自己的\",{\"1\":{\"461\":1}}],[\"你应该从maven\",{\"1\":{\"458\":1}}],[\"你应该返回一个\",{\"1\":{\"450\":1}}],[\"你应该使用\",{\"1\":{\"445\":1}}],[\"你应该创建和编写\",{\"1\":{\"8\":1}}],[\"你并没有关闭资源\",{\"1\":{\"264\":1}}],[\"你自己也可能会抛出一个异常\",{\"1\":{\"264\":1}}],[\"你也可以看到权限管理也是通过类似的注解\",{\"1\":{\"242\":1}}],[\"你只需要谨慎一点\",{\"1\":{\"174\":1}}],[\"你肯定会说不可能\",{\"1\":{\"92\":1}}],[\"你这么写的话客户如果懂点代码\",{\"1\":{\"89\":1}}],[\"你一定会越来越好\",{\"1\":{\"36\":1}}],[\"你需要明确程序所有的执行流程及对应的执行结果等等\",{\"1\":{\"990\":1}}],[\"你需要这一个库足矣\",{\"1\":{\"470\":1}}],[\"你需要一个仓库\",{\"1\":{\"461\":1}}],[\"你需要一个地方存储你生成的\",{\"1\":{\"461\":1}}],[\"你需要某种形式的持续集成服务器来帮你不断构建你的快照版本和基于\",{\"1\":{\"460\":1}}],[\"你需要阅读\",{\"1\":{\"10\":1}}],[\"你需要在页面\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
